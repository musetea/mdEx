/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./codemirror/lib/codemirror.js":
/*!**************************************!*\
  !*** ./codemirror/lib/codemirror.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n// This is CodeMirror (http://codemirror.net), a code editor\r\n// implemented in JavaScript on top of the browser's DOM.\r\n//\r\n// You can find some technical background for some of the code below\r\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\r\n\r\n(function(mod) {\r\n  if (true) // CommonJS\r\n    module.exports = mod();\r\n  else {}\r\n})(function() {\r\n  \"use strict\";\r\n\r\n  // BROWSER SNIFFING\r\n\r\n  // Kludges for bugs and behavior differences that can't be feature\r\n  // detected are enabled based on userAgent etc sniffing.\r\n\r\n  var gecko = /gecko\\/\\d/i.test(navigator.userAgent);\r\n  var ie_upto10 = /MSIE \\d/.test(navigator.userAgent);\r\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent);\r\n  var ie = ie_upto10 || ie_11up;\r\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);\r\n  var webkit = /WebKit\\//.test(navigator.userAgent);\r\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(navigator.userAgent);\r\n  var chrome = /Chrome\\//.test(navigator.userAgent);\r\n  var presto = /Opera\\//.test(navigator.userAgent);\r\n  var safari = /Apple Computer/.test(navigator.vendor);\r\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(navigator.userAgent);\r\n  var phantom = /PhantomJS/.test(navigator.userAgent);\r\n\r\n  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent);\r\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\r\n  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);\r\n  var mac = ios || /Mac/.test(navigator.platform);\r\n  var windows = /win/i.test(navigator.platform);\r\n\r\n  var presto_version = presto && navigator.userAgent.match(/Version\\/(\\d*\\.\\d*)/);\r\n  if (presto_version) presto_version = Number(presto_version[1]);\r\n  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\r\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\r\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\r\n  var captureRightClick = gecko || (ie && ie_version >= 9);\r\n\r\n  // Optimize some code when these features are not used.\r\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\r\n\r\n  // EDITOR CONSTRUCTOR\r\n\r\n  // A CodeMirror instance represents an editor. This is the object\r\n  // that user code is usually dealing with.\r\n\r\n  function CodeMirror(place, options) {\r\n    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\r\n\r\n    this.options = options = options ? copyObj(options) : {};\r\n    // Determine effective options based on given values and defaults.\r\n    copyObj(defaults, options, false);\r\n    setGuttersForLineNumbers(options);\r\n\r\n    var doc = options.value;\r\n    if (typeof doc == \"string\") doc = new Doc(doc, options.mode);\r\n    this.doc = doc;\r\n\r\n    var input = new CodeMirror.inputStyles[options.inputStyle](this);\r\n    var display = this.display = new Display(place, doc, input);\r\n    display.wrapper.CodeMirror = this;\r\n    updateGutters(this);\r\n    themeChanged(this);\r\n    if (options.lineWrapping)\r\n      this.display.wrapper.className += \" CodeMirror-wrap\";\r\n    if (options.autofocus && !mobile) display.input.focus();\r\n    initScrollbars(this);\r\n\r\n    this.state = {\r\n      keyMaps: [],  // stores maps added by addKeyMap\r\n      overlays: [], // highlighting overlays, as added by addOverlay\r\n      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\r\n      overwrite: false,\r\n      delayingBlurEvent: false,\r\n      focused: false,\r\n      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\r\n      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\r\n      draggingText: false,\r\n      highlight: new Delayed(), // stores highlight worker timeout\r\n      keySeq: null,  // Unfinished key sequence\r\n      specialChars: null\r\n    };\r\n\r\n    var cm = this;\r\n\r\n    // Override magic textarea content restore that IE sometimes does\r\n    // on our hidden textarea on reload\r\n    if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);\r\n\r\n    registerEventHandlers(this);\r\n    ensureGlobalHandlers();\r\n\r\n    startOperation(this);\r\n    this.curOp.forceUpdate = true;\r\n    attachDoc(this, doc);\r\n\r\n    if ((options.autofocus && !mobile) || cm.hasFocus())\r\n      setTimeout(bind(onFocus, this), 20);\r\n    else\r\n      onBlur(this);\r\n\r\n    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))\r\n      optionHandlers[opt](this, options[opt], Init);\r\n    maybeUpdateLineNumberWidth(this);\r\n    if (options.finishInit) options.finishInit(this);\r\n    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);\r\n    endOperation(this);\r\n    // Suppress optimizelegibility in Webkit, since it breaks text\r\n    // measuring on line wrapping boundaries.\r\n    if (webkit && options.lineWrapping &&\r\n        getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\r\n      display.lineDiv.style.textRendering = \"auto\";\r\n  }\r\n\r\n  // DISPLAY CONSTRUCTOR\r\n\r\n  // The display handles the DOM integration, both for input reading\r\n  // and content drawing. It holds references to DOM nodes and\r\n  // display-related state.\r\n\r\n  function Display(place, doc, input) {\r\n    var d = this;\r\n    this.input = input;\r\n\r\n    // Covers bottom-right square when both scrollbars are present.\r\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\r\n    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\r\n    // Covers bottom of gutter when coverGutterNextToScrollbar is on\r\n    // and h scrollbar is present.\r\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\r\n    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\r\n    // Will contain the actual code, positioned to cover the viewport.\r\n    d.lineDiv = elt(\"div\", null, \"CodeMirror-code\");\r\n    // Elements are added to these to represent selection and cursors.\r\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\r\n    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\r\n    // A visibility: hidden element used to find the size of things.\r\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\r\n    // When lines outside of the viewport are measured, they are drawn in this.\r\n    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\r\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\r\n    d.lineSpace = elt(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\r\n                      null, \"position: relative; outline: none\");\r\n    // Moved around its parent to cover visible view.\r\n    d.mover = elt(\"div\", [elt(\"div\", [d.lineSpace], \"CodeMirror-lines\")], null, \"position: relative\");\r\n    // Set to the height of the document, allowing scrolling.\r\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\r\n    d.sizerWidth = null;\r\n    // Behavior of elts with overflow: auto and padding is\r\n    // inconsistent across browsers. This is used to ensure the\r\n    // scrollable area is big enough.\r\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\r\n    // Will contain the gutters, if any.\r\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\r\n    d.lineGutter = null;\r\n    // Actual scrollable element.\r\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\r\n    d.scroller.setAttribute(\"tabIndex\", \"-1\");\r\n    // The element in which the editor lives.\r\n    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\r\n\r\n    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\r\n    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\r\n    if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;\r\n\r\n    if (place) {\r\n      if (place.appendChild) place.appendChild(d.wrapper);\r\n      else place(d.wrapper);\r\n    }\r\n\r\n    // Current rendered range (may be bigger than the view window).\r\n    d.viewFrom = d.viewTo = doc.first;\r\n    d.reportedViewFrom = d.reportedViewTo = doc.first;\r\n    // Information about the rendered lines.\r\n    d.view = [];\r\n    d.renderedView = null;\r\n    // Holds info about a single rendered line when it was rendered\r\n    // for measurement, while not in view.\r\n    d.externalMeasured = null;\r\n    // Empty space (in pixels) above the view\r\n    d.viewOffset = 0;\r\n    d.lastWrapHeight = d.lastWrapWidth = 0;\r\n    d.updateLineNumbers = null;\r\n\r\n    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\r\n    d.scrollbarsClipped = false;\r\n\r\n    // Used to only resize the line number gutter when necessary (when\r\n    // the amount of lines crosses a boundary that makes its width change)\r\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\r\n    // Set to true when a non-horizontal-scrolling line widget is\r\n    // added. As an optimization, line widget aligning is skipped when\r\n    // this is false.\r\n    d.alignWidgets = false;\r\n\r\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\r\n\r\n    // Tracks the maximum line length so that the horizontal scrollbar\r\n    // can be kept static when scrolling.\r\n    d.maxLine = null;\r\n    d.maxLineLength = 0;\r\n    d.maxLineChanged = false;\r\n\r\n    // Used for measuring wheel scrolling granularity\r\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\r\n\r\n    // True when shift is held down.\r\n    d.shift = false;\r\n\r\n    // Used to track whether anything happened since the context menu\r\n    // was opened.\r\n    d.selForContextMenu = null;\r\n\r\n    d.activeTouch = null;\r\n\r\n    input.init(d);\r\n  }\r\n\r\n  // STATE UPDATES\r\n\r\n  // Used to get the editor into a consistent state again when options change.\r\n\r\n  function loadMode(cm) {\r\n    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\r\n    resetModeState(cm);\r\n  }\r\n\r\n  function resetModeState(cm) {\r\n    cm.doc.iter(function(line) {\r\n      if (line.stateAfter) line.stateAfter = null;\r\n      if (line.styles) line.styles = null;\r\n    });\r\n    cm.doc.frontier = cm.doc.first;\r\n    startWorker(cm, 100);\r\n    cm.state.modeGen++;\r\n    if (cm.curOp) regChange(cm);\r\n  }\r\n\r\n  function wrappingChanged(cm) {\r\n    if (cm.options.lineWrapping) {\r\n      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\r\n      cm.display.sizer.style.minWidth = \"\";\r\n      cm.display.sizerWidth = null;\r\n    } else {\r\n      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\r\n      findMaxLine(cm);\r\n    }\r\n    estimateLineHeights(cm);\r\n    regChange(cm);\r\n    clearCaches(cm);\r\n    setTimeout(function(){updateScrollbars(cm);}, 100);\r\n  }\r\n\r\n  // Returns a function that estimates the height of a line, to use as\r\n  // first approximation until the line becomes visible (and is thus\r\n  // properly measurable).\r\n  function estimateHeight(cm) {\r\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\r\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\r\n    return function(line) {\r\n      if (lineIsHidden(cm.doc, line)) return 0;\r\n\r\n      var widgetsHeight = 0;\r\n      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {\r\n        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;\r\n      }\r\n\r\n      if (wrapping)\r\n        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\r\n      else\r\n        return widgetsHeight + th;\r\n    };\r\n  }\r\n\r\n  function estimateLineHeights(cm) {\r\n    var doc = cm.doc, est = estimateHeight(cm);\r\n    doc.iter(function(line) {\r\n      var estHeight = est(line);\r\n      if (estHeight != line.height) updateLineHeight(line, estHeight);\r\n    });\r\n  }\r\n\r\n  function themeChanged(cm) {\r\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\r\n      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\r\n    clearCaches(cm);\r\n  }\r\n\r\n  function guttersChanged(cm) {\r\n    updateGutters(cm);\r\n    regChange(cm);\r\n    setTimeout(function(){alignHorizontally(cm);}, 20);\r\n  }\r\n\r\n  // Rebuild the gutter elements, ensure the margin to the left of the\r\n  // code matches their width.\r\n  function updateGutters(cm) {\r\n    var gutters = cm.display.gutters, specs = cm.options.gutters;\r\n    removeChildren(gutters);\r\n    for (var i = 0; i < specs.length; ++i) {\r\n      var gutterClass = specs[i];\r\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\r\n      if (gutterClass == \"CodeMirror-linenumbers\") {\r\n        cm.display.lineGutter = gElt;\r\n        gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\r\n      }\r\n    }\r\n    gutters.style.display = i ? \"\" : \"none\";\r\n    updateGutterSpace(cm);\r\n  }\r\n\r\n  function updateGutterSpace(cm) {\r\n    var width = cm.display.gutters.offsetWidth;\r\n    cm.display.sizer.style.marginLeft = width + \"px\";\r\n  }\r\n\r\n  // Compute the character length of a line, taking into account\r\n  // collapsed ranges (see markText) that might hide parts, and join\r\n  // other lines onto it.\r\n  function lineLength(line) {\r\n    if (line.height == 0) return 0;\r\n    var len = line.text.length, merged, cur = line;\r\n    while (merged = collapsedSpanAtStart(cur)) {\r\n      var found = merged.find(0, true);\r\n      cur = found.from.line;\r\n      len += found.from.ch - found.to.ch;\r\n    }\r\n    cur = line;\r\n    while (merged = collapsedSpanAtEnd(cur)) {\r\n      var found = merged.find(0, true);\r\n      len -= cur.text.length - found.from.ch;\r\n      cur = found.to.line;\r\n      len += cur.text.length - found.to.ch;\r\n    }\r\n    return len;\r\n  }\r\n\r\n  // Find the longest line in the document.\r\n  function findMaxLine(cm) {\r\n    var d = cm.display, doc = cm.doc;\r\n    d.maxLine = getLine(doc, doc.first);\r\n    d.maxLineLength = lineLength(d.maxLine);\r\n    d.maxLineChanged = true;\r\n    doc.iter(function(line) {\r\n      var len = lineLength(line);\r\n      if (len > d.maxLineLength) {\r\n        d.maxLineLength = len;\r\n        d.maxLine = line;\r\n      }\r\n    });\r\n  }\r\n\r\n  // Make sure the gutters options contains the element\r\n  // \"CodeMirror-linenumbers\" when the lineNumbers option is true.\r\n  function setGuttersForLineNumbers(options) {\r\n    var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\r\n    if (found == -1 && options.lineNumbers) {\r\n      options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\r\n    } else if (found > -1 && !options.lineNumbers) {\r\n      options.gutters = options.gutters.slice(0);\r\n      options.gutters.splice(found, 1);\r\n    }\r\n  }\r\n\r\n  // SCROLLBARS\r\n\r\n  // Prepare DOM reads needed to update the scrollbars. Done in one\r\n  // shot to minimize update/measure roundtrips.\r\n  function measureForScrollbars(cm) {\r\n    var d = cm.display, gutterW = d.gutters.offsetWidth;\r\n    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\r\n    return {\r\n      clientHeight: d.scroller.clientHeight,\r\n      viewHeight: d.wrapper.clientHeight,\r\n      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\r\n      viewWidth: d.wrapper.clientWidth,\r\n      barLeft: cm.options.fixedGutter ? gutterW : 0,\r\n      docHeight: docH,\r\n      scrollHeight: docH + scrollGap(cm) + d.barHeight,\r\n      nativeBarWidth: d.nativeBarWidth,\r\n      gutterWidth: gutterW\r\n    };\r\n  }\r\n\r\n  function NativeScrollbars(place, scroll, cm) {\r\n    this.cm = cm;\r\n    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\r\n    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\r\n    place(vert); place(horiz);\r\n\r\n    on(vert, \"scroll\", function() {\r\n      if (vert.clientHeight) scroll(vert.scrollTop, \"vertical\");\r\n    });\r\n    on(horiz, \"scroll\", function() {\r\n      if (horiz.clientWidth) scroll(horiz.scrollLeft, \"horizontal\");\r\n    });\r\n\r\n    this.checkedOverlay = false;\r\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\r\n    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\";\r\n  }\r\n\r\n  NativeScrollbars.prototype = copyObj({\r\n    update: function(measure) {\r\n      var needsH = measure.scrollWidth > measure.clientWidth + 1;\r\n      var needsV = measure.scrollHeight > measure.clientHeight + 1;\r\n      var sWidth = measure.nativeBarWidth;\r\n\r\n      if (needsV) {\r\n        this.vert.style.display = \"block\";\r\n        this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\r\n        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\r\n        // A bug in IE8 can cause this value to be negative, so guard it.\r\n        this.vert.firstChild.style.height =\r\n          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\r\n      } else {\r\n        this.vert.style.display = \"\";\r\n        this.vert.firstChild.style.height = \"0\";\r\n      }\r\n\r\n      if (needsH) {\r\n        this.horiz.style.display = \"block\";\r\n        this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\r\n        this.horiz.style.left = measure.barLeft + \"px\";\r\n        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\r\n        this.horiz.firstChild.style.width =\r\n          (measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\r\n      } else {\r\n        this.horiz.style.display = \"\";\r\n        this.horiz.firstChild.style.width = \"0\";\r\n      }\r\n\r\n      if (!this.checkedOverlay && measure.clientHeight > 0) {\r\n        if (sWidth == 0) this.overlayHack();\r\n        this.checkedOverlay = true;\r\n      }\r\n\r\n      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};\r\n    },\r\n    setScrollLeft: function(pos) {\r\n      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;\r\n    },\r\n    setScrollTop: function(pos) {\r\n      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;\r\n    },\r\n    overlayHack: function() {\r\n      var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\r\n      this.horiz.style.minHeight = this.vert.style.minWidth = w;\r\n      var self = this;\r\n      var barMouseDown = function(e) {\r\n        if (e_target(e) != self.vert && e_target(e) != self.horiz)\r\n          operation(self.cm, onMouseDown)(e);\r\n      };\r\n      on(this.vert, \"mousedown\", barMouseDown);\r\n      on(this.horiz, \"mousedown\", barMouseDown);\r\n    },\r\n    clear: function() {\r\n      var parent = this.horiz.parentNode;\r\n      parent.removeChild(this.horiz);\r\n      parent.removeChild(this.vert);\r\n    }\r\n  }, NativeScrollbars.prototype);\r\n\r\n  function NullScrollbars() {}\r\n\r\n  NullScrollbars.prototype = copyObj({\r\n    update: function() { return {bottom: 0, right: 0}; },\r\n    setScrollLeft: function() {},\r\n    setScrollTop: function() {},\r\n    clear: function() {}\r\n  }, NullScrollbars.prototype);\r\n\r\n  CodeMirror.scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\r\n\r\n  function initScrollbars(cm) {\r\n    if (cm.display.scrollbars) {\r\n      cm.display.scrollbars.clear();\r\n      if (cm.display.scrollbars.addClass)\r\n        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);\r\n    }\r\n\r\n    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {\r\n      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\r\n      // Prevent clicks in the scrollbars from killing focus\r\n      on(node, \"mousedown\", function() {\r\n        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);\r\n      });\r\n      node.setAttribute(\"cm-not-content\", \"true\");\r\n    }, function(pos, axis) {\r\n      if (axis == \"horizontal\") setScrollLeft(cm, pos);\r\n      else setScrollTop(cm, pos);\r\n    }, cm);\r\n    if (cm.display.scrollbars.addClass)\r\n      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);\r\n  }\r\n\r\n  function updateScrollbars(cm, measure) {\r\n    if (!measure) measure = measureForScrollbars(cm);\r\n    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\r\n    updateScrollbarsInner(cm, measure);\r\n    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\r\n      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\r\n        updateHeightsInViewport(cm);\r\n      updateScrollbarsInner(cm, measureForScrollbars(cm));\r\n      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\r\n    }\r\n  }\r\n\r\n  // Re-synchronize the fake scrollbars with the actual size of the\r\n  // content.\r\n  function updateScrollbarsInner(cm, measure) {\r\n    var d = cm.display;\r\n    var sizes = d.scrollbars.update(measure);\r\n\r\n    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\r\n    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\r\n\r\n    if (sizes.right && sizes.bottom) {\r\n      d.scrollbarFiller.style.display = \"block\";\r\n      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\r\n      d.scrollbarFiller.style.width = sizes.right + \"px\";\r\n    } else d.scrollbarFiller.style.display = \"\";\r\n    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\r\n      d.gutterFiller.style.display = \"block\";\r\n      d.gutterFiller.style.height = sizes.bottom + \"px\";\r\n      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\r\n    } else d.gutterFiller.style.display = \"\";\r\n  }\r\n\r\n  // Compute the lines that are visible in a given viewport (defaults\r\n  // the the current scroll position). viewport may contain top,\r\n  // height, and ensure (see op.scrollToPos) properties.\r\n  function visibleLines(display, doc, viewport) {\r\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\r\n    top = Math.floor(top - paddingTop(display));\r\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\r\n\r\n    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\r\n    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\r\n    // forces those lines into the viewport (if possible).\r\n    if (viewport && viewport.ensure) {\r\n      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\r\n      if (ensureFrom < from) {\r\n        from = ensureFrom;\r\n        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\r\n      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\r\n        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\r\n        to = ensureTo;\r\n      }\r\n    }\r\n    return {from: from, to: Math.max(to, from + 1)};\r\n  }\r\n\r\n  // LINE NUMBERS\r\n\r\n  // Re-align line numbers and gutter marks to compensate for\r\n  // horizontal scrolling.\r\n  function alignHorizontally(cm) {\r\n    var display = cm.display, view = display.view;\r\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\r\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\r\n    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\r\n    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {\r\n      if (cm.options.fixedGutter && view[i].gutter)\r\n        view[i].gutter.style.left = left;\r\n      var align = view[i].alignable;\r\n      if (align) for (var j = 0; j < align.length; j++)\r\n        align[j].style.left = left;\r\n    }\r\n    if (cm.options.fixedGutter)\r\n      display.gutters.style.left = (comp + gutterW) + \"px\";\r\n  }\r\n\r\n  // Used to ensure that the line number gutter is still the right\r\n  // size for the current document size. Returns true when an update\r\n  // is needed.\r\n  function maybeUpdateLineNumberWidth(cm) {\r\n    if (!cm.options.lineNumbers) return false;\r\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\r\n    if (last.length != display.lineNumChars) {\r\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\r\n                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\r\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\r\n      display.lineGutter.style.width = \"\";\r\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\r\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\r\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\r\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\r\n      updateGutterSpace(cm);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function lineNumberFor(options, i) {\r\n    return String(options.lineNumberFormatter(i + options.firstLineNumber));\r\n  }\r\n\r\n  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\r\n  // but using getBoundingClientRect to get a sub-pixel-accurate\r\n  // result.\r\n  function compensateForHScroll(display) {\r\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\r\n  }\r\n\r\n  // DISPLAY DRAWING\r\n\r\n  function DisplayUpdate(cm, viewport, force) {\r\n    var display = cm.display;\r\n\r\n    this.viewport = viewport;\r\n    // Store some values that we'll need later (but don't want to force a relayout for)\r\n    this.visible = visibleLines(display, cm.doc, viewport);\r\n    this.editorIsHidden = !display.wrapper.offsetWidth;\r\n    this.wrapperHeight = display.wrapper.clientHeight;\r\n    this.wrapperWidth = display.wrapper.clientWidth;\r\n    this.oldDisplayWidth = displayWidth(cm);\r\n    this.force = force;\r\n    this.dims = getDimensions(cm);\r\n    this.events = [];\r\n  }\r\n\r\n  DisplayUpdate.prototype.signal = function(emitter, type) {\r\n    if (hasHandler(emitter, type))\r\n      this.events.push(arguments);\r\n  };\r\n  DisplayUpdate.prototype.finish = function() {\r\n    for (var i = 0; i < this.events.length; i++)\r\n      signal.apply(null, this.events[i]);\r\n  };\r\n\r\n  function maybeClipScrollbars(cm) {\r\n    var display = cm.display;\r\n    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\r\n      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\r\n      display.heightForcer.style.height = scrollGap(cm) + \"px\";\r\n      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\r\n      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\r\n      display.scrollbarsClipped = true;\r\n    }\r\n  }\r\n\r\n  // Does the actual updating of the line display. Bails out\r\n  // (returning false) when there is nothing to be done and forced is\r\n  // false.\r\n  function updateDisplayIfNeeded(cm, update) {\r\n    var display = cm.display, doc = cm.doc;\r\n\r\n    if (update.editorIsHidden) {\r\n      resetView(cm);\r\n      return false;\r\n    }\r\n\r\n    // Bail out if the visible area is already rendered and nothing changed.\r\n    if (!update.force &&\r\n        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\r\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\r\n        display.renderedView == display.view && countDirtyView(cm) == 0)\r\n      return false;\r\n\r\n    if (maybeUpdateLineNumberWidth(cm)) {\r\n      resetView(cm);\r\n      update.dims = getDimensions(cm);\r\n    }\r\n\r\n    // Compute a suitable new viewport (from & to)\r\n    var end = doc.first + doc.size;\r\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\r\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\r\n    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);\r\n    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);\r\n    if (sawCollapsedSpans) {\r\n      from = visualLineNo(cm.doc, from);\r\n      to = visualLineEndNo(cm.doc, to);\r\n    }\r\n\r\n    var different = from != display.viewFrom || to != display.viewTo ||\r\n      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\r\n    adjustView(cm, from, to);\r\n\r\n    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\r\n    // Position the mover div to align with the current scroll position\r\n    cm.display.mover.style.top = display.viewOffset + \"px\";\r\n\r\n    var toUpdate = countDirtyView(cm);\r\n    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\r\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\r\n      return false;\r\n\r\n    // For big changes, we hide the enclosing element during the\r\n    // update, since that speeds up the operations on most browsers.\r\n    var focused = activeElt();\r\n    if (toUpdate > 4) display.lineDiv.style.display = \"none\";\r\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\r\n    if (toUpdate > 4) display.lineDiv.style.display = \"\";\r\n    display.renderedView = display.view;\r\n    // There might have been a widget with a focused element that got\r\n    // hidden or updated, if so re-focus it.\r\n    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();\r\n\r\n    // Prevent selection and cursors from interfering with the scroll\r\n    // width and height.\r\n    removeChildren(display.cursorDiv);\r\n    removeChildren(display.selectionDiv);\r\n    display.gutters.style.height = 0;\r\n\r\n    if (different) {\r\n      display.lastWrapHeight = update.wrapperHeight;\r\n      display.lastWrapWidth = update.wrapperWidth;\r\n      startWorker(cm, 400);\r\n    }\r\n\r\n    display.updateLineNumbers = null;\r\n\r\n    return true;\r\n  }\r\n\r\n  function postUpdateDisplay(cm, update) {\r\n    var force = update.force, viewport = update.viewport;\r\n    for (var first = true;; first = false) {\r\n      if (first && cm.options.lineWrapping && update.oldDisplayWidth != displayWidth(cm)) {\r\n        force = true;\r\n      } else {\r\n        force = false;\r\n        // Clip forced viewport to actual scrollable area.\r\n        if (viewport && viewport.top != null)\r\n          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};\r\n        // Updated line heights might result in the drawn area not\r\n        // actually covering the viewport. Keep looping until it does.\r\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\r\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\r\n          break;\r\n      }\r\n      if (!updateDisplayIfNeeded(cm, update)) break;\r\n      updateHeightsInViewport(cm);\r\n      var barMeasure = measureForScrollbars(cm);\r\n      updateSelection(cm);\r\n      setDocumentHeight(cm, barMeasure);\r\n      updateScrollbars(cm, barMeasure);\r\n    }\r\n\r\n    update.signal(cm, \"update\", cm);\r\n    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\r\n      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\r\n      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\r\n    }\r\n  }\r\n\r\n  function updateDisplaySimple(cm, viewport) {\r\n    var update = new DisplayUpdate(cm, viewport);\r\n    if (updateDisplayIfNeeded(cm, update)) {\r\n      updateHeightsInViewport(cm);\r\n      postUpdateDisplay(cm, update);\r\n      var barMeasure = measureForScrollbars(cm);\r\n      updateSelection(cm);\r\n      setDocumentHeight(cm, barMeasure);\r\n      updateScrollbars(cm, barMeasure);\r\n      update.finish();\r\n    }\r\n  }\r\n\r\n  function setDocumentHeight(cm, measure) {\r\n    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\r\n    var total = measure.docHeight + cm.display.barHeight;\r\n    cm.display.heightForcer.style.top = total + \"px\";\r\n    cm.display.gutters.style.height = Math.max(total + scrollGap(cm), measure.clientHeight) + \"px\";\r\n  }\r\n\r\n  // Read the actual heights of the rendered lines, and update their\r\n  // stored heights to match.\r\n  function updateHeightsInViewport(cm) {\r\n    var display = cm.display;\r\n    var prevBottom = display.lineDiv.offsetTop;\r\n    for (var i = 0; i < display.view.length; i++) {\r\n      var cur = display.view[i], height;\r\n      if (cur.hidden) continue;\r\n      if (ie && ie_version < 8) {\r\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\r\n        height = bot - prevBottom;\r\n        prevBottom = bot;\r\n      } else {\r\n        var box = cur.node.getBoundingClientRect();\r\n        height = box.bottom - box.top;\r\n      }\r\n      var diff = cur.line.height - height;\r\n      if (height < 2) height = textHeight(display);\r\n      if (diff > .001 || diff < -.001) {\r\n        updateLineHeight(cur.line, height);\r\n        updateWidgetHeight(cur.line);\r\n        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)\r\n          updateWidgetHeight(cur.rest[j]);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Read and store the height of line widgets associated with the\r\n  // given line.\r\n  function updateWidgetHeight(line) {\r\n    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)\r\n      line.widgets[i].height = line.widgets[i].node.offsetHeight;\r\n  }\r\n\r\n  // Do a bulk-read of the DOM positions and sizes needed to draw the\r\n  // view, so that we don't interleave reading and writing to the DOM.\r\n  function getDimensions(cm) {\r\n    var d = cm.display, left = {}, width = {};\r\n    var gutterLeft = d.gutters.clientLeft;\r\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\r\n      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\r\n      width[cm.options.gutters[i]] = n.clientWidth;\r\n    }\r\n    return {fixedPos: compensateForHScroll(d),\r\n            gutterTotalWidth: d.gutters.offsetWidth,\r\n            gutterLeft: left,\r\n            gutterWidth: width,\r\n            wrapperWidth: d.wrapper.clientWidth};\r\n  }\r\n\r\n  // Sync the actual display DOM structure with display.view, removing\r\n  // nodes for lines that are no longer in view, and creating the ones\r\n  // that are not there yet, and updating the ones that are out of\r\n  // date.\r\n  function patchDisplay(cm, updateNumbersFrom, dims) {\r\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\r\n    var container = display.lineDiv, cur = container.firstChild;\r\n\r\n    function rm(node) {\r\n      var next = node.nextSibling;\r\n      // Works around a throw-scroll bug in OS X Webkit\r\n      if (webkit && mac && cm.display.currentWheelTarget == node)\r\n        node.style.display = \"none\";\r\n      else\r\n        node.parentNode.removeChild(node);\r\n      return next;\r\n    }\r\n\r\n    var view = display.view, lineN = display.viewFrom;\r\n    // Loop over the elements in the view, syncing cur (the DOM nodes\r\n    // in display.lineDiv) with the view as we go.\r\n    for (var i = 0; i < view.length; i++) {\r\n      var lineView = view[i];\r\n      if (lineView.hidden) {\r\n      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\r\n        var node = buildLineElement(cm, lineView, lineN, dims);\r\n        container.insertBefore(node, cur);\r\n      } else { // Already drawn\r\n        while (cur != lineView.node) cur = rm(cur);\r\n        var updateNumber = lineNumbers && updateNumbersFrom != null &&\r\n          updateNumbersFrom <= lineN && lineView.lineNumber;\r\n        if (lineView.changes) {\r\n          if (indexOf(lineView.changes, \"gutter\") > -1) updateNumber = false;\r\n          updateLineForChanges(cm, lineView, lineN, dims);\r\n        }\r\n        if (updateNumber) {\r\n          removeChildren(lineView.lineNumber);\r\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\r\n        }\r\n        cur = lineView.node.nextSibling;\r\n      }\r\n      lineN += lineView.size;\r\n    }\r\n    while (cur) cur = rm(cur);\r\n  }\r\n\r\n  // When an aspect of a line changes, a string is added to\r\n  // lineView.changes. This updates the relevant part of the line's\r\n  // DOM structure.\r\n  function updateLineForChanges(cm, lineView, lineN, dims) {\r\n    for (var j = 0; j < lineView.changes.length; j++) {\r\n      var type = lineView.changes[j];\r\n      if (type == \"text\") updateLineText(cm, lineView);\r\n      else if (type == \"gutter\") updateLineGutter(cm, lineView, lineN, dims);\r\n      else if (type == \"class\") updateLineClasses(lineView);\r\n      else if (type == \"widget\") updateLineWidgets(cm, lineView, dims);\r\n    }\r\n    lineView.changes = null;\r\n  }\r\n\r\n  // Lines with gutter elements, widgets or a background class need to\r\n  // be wrapped, and have the extra elements added to the wrapper div\r\n  function ensureLineWrapped(lineView) {\r\n    if (lineView.node == lineView.text) {\r\n      lineView.node = elt(\"div\", null, null, \"position: relative\");\r\n      if (lineView.text.parentNode)\r\n        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\r\n      lineView.node.appendChild(lineView.text);\r\n      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;\r\n    }\r\n    return lineView.node;\r\n  }\r\n\r\n  function updateLineBackground(lineView) {\r\n    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\r\n    if (cls) cls += \" CodeMirror-linebackground\";\r\n    if (lineView.background) {\r\n      if (cls) lineView.background.className = cls;\r\n      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\r\n    } else if (cls) {\r\n      var wrap = ensureLineWrapped(lineView);\r\n      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\r\n    }\r\n  }\r\n\r\n  // Wrapper around buildLineContent which will reuse the structure\r\n  // in display.externalMeasured when possible.\r\n  function getLineContent(cm, lineView) {\r\n    var ext = cm.display.externalMeasured;\r\n    if (ext && ext.line == lineView.line) {\r\n      cm.display.externalMeasured = null;\r\n      lineView.measure = ext.measure;\r\n      return ext.built;\r\n    }\r\n    return buildLineContent(cm, lineView);\r\n  }\r\n\r\n  // Redraw the line's text. Interacts with the background and text\r\n  // classes because the mode may output tokens that influence these\r\n  // classes.\r\n  function updateLineText(cm, lineView) {\r\n    var cls = lineView.text.className;\r\n    var built = getLineContent(cm, lineView);\r\n    if (lineView.text == lineView.node) lineView.node = built.pre;\r\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\r\n    lineView.text = built.pre;\r\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\r\n      lineView.bgClass = built.bgClass;\r\n      lineView.textClass = built.textClass;\r\n      updateLineClasses(lineView);\r\n    } else if (cls) {\r\n      lineView.text.className = cls;\r\n    }\r\n  }\r\n\r\n  function updateLineClasses(lineView) {\r\n    updateLineBackground(lineView);\r\n    if (lineView.line.wrapClass)\r\n      ensureLineWrapped(lineView).className = lineView.line.wrapClass;\r\n    else if (lineView.node != lineView.text)\r\n      lineView.node.className = \"\";\r\n    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\r\n    lineView.text.className = textClass || \"\";\r\n  }\r\n\r\n  function updateLineGutter(cm, lineView, lineN, dims) {\r\n    if (lineView.gutter) {\r\n      lineView.node.removeChild(lineView.gutter);\r\n      lineView.gutter = null;\r\n    }\r\n    var markers = lineView.line.gutterMarkers;\r\n    if (cm.options.lineNumbers || markers) {\r\n      var wrap = ensureLineWrapped(lineView);\r\n      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", \"left: \" +\r\n                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +\r\n                                             \"px; width: \" + dims.gutterTotalWidth + \"px\");\r\n      cm.display.input.setUneditable(gutterWrap);\r\n      wrap.insertBefore(gutterWrap, lineView.text);\r\n      if (lineView.line.gutterClass)\r\n        gutterWrap.className += \" \" + lineView.line.gutterClass;\r\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\r\n        lineView.lineNumber = gutterWrap.appendChild(\r\n          elt(\"div\", lineNumberFor(cm.options, lineN),\r\n              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\r\n              \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \"\r\n              + cm.display.lineNumInnerWidth + \"px\"));\r\n      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {\r\n        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\r\n        if (found)\r\n          gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\", \"left: \" +\r\n                                     dims.gutterLeft[id] + \"px; width: \" + dims.gutterWidth[id] + \"px\"));\r\n      }\r\n    }\r\n  }\r\n\r\n  function updateLineWidgets(cm, lineView, dims) {\r\n    if (lineView.alignable) lineView.alignable = null;\r\n    for (var node = lineView.node.firstChild, next; node; node = next) {\r\n      var next = node.nextSibling;\r\n      if (node.className == \"CodeMirror-linewidget\")\r\n        lineView.node.removeChild(node);\r\n    }\r\n    insertLineWidgets(cm, lineView, dims);\r\n  }\r\n\r\n  // Build a line's DOM representation from scratch\r\n  function buildLineElement(cm, lineView, lineN, dims) {\r\n    var built = getLineContent(cm, lineView);\r\n    lineView.text = lineView.node = built.pre;\r\n    if (built.bgClass) lineView.bgClass = built.bgClass;\r\n    if (built.textClass) lineView.textClass = built.textClass;\r\n\r\n    updateLineClasses(lineView);\r\n    updateLineGutter(cm, lineView, lineN, dims);\r\n    insertLineWidgets(cm, lineView, dims);\r\n    return lineView.node;\r\n  }\r\n\r\n  // A lineView may contain multiple logical lines (when merged by\r\n  // collapsed spans). The widgets for all of them need to be drawn.\r\n  function insertLineWidgets(cm, lineView, dims) {\r\n    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\r\n    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\r\n      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);\r\n  }\r\n\r\n  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\r\n    if (!line.widgets) return;\r\n    var wrap = ensureLineWrapped(lineView);\r\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\r\n      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\r\n      if (!widget.handleMouseEvents) node.setAttribute(\"cm-ignore-events\", \"true\");\r\n      positionLineWidget(widget, node, lineView, dims);\r\n      cm.display.input.setUneditable(node);\r\n      if (allowAbove && widget.above)\r\n        wrap.insertBefore(node, lineView.gutter || lineView.text);\r\n      else\r\n        wrap.appendChild(node);\r\n      signalLater(widget, \"redraw\");\r\n    }\r\n  }\r\n\r\n  function positionLineWidget(widget, node, lineView, dims) {\r\n    if (widget.noHScroll) {\r\n      (lineView.alignable || (lineView.alignable = [])).push(node);\r\n      var width = dims.wrapperWidth;\r\n      node.style.left = dims.fixedPos + \"px\";\r\n      if (!widget.coverGutter) {\r\n        width -= dims.gutterTotalWidth;\r\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\r\n      }\r\n      node.style.width = width + \"px\";\r\n    }\r\n    if (widget.coverGutter) {\r\n      node.style.zIndex = 5;\r\n      node.style.position = \"relative\";\r\n      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\r\n    }\r\n  }\r\n\r\n  // POSITION OBJECT\r\n\r\n  // A Pos instance represents a position within the text.\r\n  var Pos = CodeMirror.Pos = function(line, ch) {\r\n    if (!(this instanceof Pos)) return new Pos(line, ch);\r\n    this.line = line; this.ch = ch;\r\n  };\r\n\r\n  // Compare two positions, return 0 if they are the same, a negative\r\n  // number when a is less, and a positive number otherwise.\r\n  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };\r\n\r\n  function copyPos(x) {return Pos(x.line, x.ch);}\r\n  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }\r\n  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }\r\n\r\n  // INPUT HANDLING\r\n\r\n  function ensureFocus(cm) {\r\n    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\r\n  }\r\n\r\n  function isReadOnly(cm) {\r\n    return cm.options.readOnly || cm.doc.cantEdit;\r\n  }\r\n\r\n  // This will be set to an array of strings when copying, so that,\r\n  // when pasting, we know what kind of selections the copied text\r\n  // was made out of.\r\n  var lastCopied = null;\r\n\r\n  function applyTextInput(cm, inserted, deleted, sel) {\r\n    var doc = cm.doc;\r\n    cm.display.shift = false;\r\n    if (!sel) sel = doc.sel;\r\n\r\n    var textLines = splitLines(inserted), multiPaste = null;\r\n    // When pasing N lines into N selections, insert one line per selection\r\n    if (cm.state.pasteIncoming && sel.ranges.length > 1) {\r\n      if (lastCopied && lastCopied.join(\"\\n\") == inserted)\r\n        multiPaste = sel.ranges.length % lastCopied.length == 0 && map(lastCopied, splitLines);\r\n      else if (textLines.length == sel.ranges.length)\r\n        multiPaste = map(textLines, function(l) { return [l]; });\r\n    }\r\n\r\n    // Normal behavior is to insert the new text into every selection\r\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\r\n      var range = sel.ranges[i];\r\n      var from = range.from(), to = range.to();\r\n      if (range.empty()) {\r\n        if (deleted && deleted > 0) // Handle deletion\r\n          from = Pos(from.line, from.ch - deleted);\r\n        else if (cm.state.overwrite && !cm.state.pasteIncoming) // Handle overwrite\r\n          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));\r\n      }\r\n      var updateInput = cm.curOp.updateInput;\r\n      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,\r\n                         origin: cm.state.pasteIncoming ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\"};\r\n      makeChange(cm.doc, changeEvent);\r\n      signalLater(cm, \"inputRead\", cm, changeEvent);\r\n      // When an 'electric' character is inserted, immediately trigger a reindent\r\n      if (inserted && !cm.state.pasteIncoming && cm.options.electricChars &&\r\n          cm.options.smartIndent && range.head.ch < 100 &&\r\n          (!i || sel.ranges[i - 1].head.line != range.head.line)) {\r\n        var mode = cm.getModeAt(range.head);\r\n        var end = changeEnd(changeEvent);\r\n        if (mode.electricChars) {\r\n          for (var j = 0; j < mode.electricChars.length; j++)\r\n            if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\r\n              indentLine(cm, end.line, \"smart\");\r\n              break;\r\n            }\r\n        } else if (mode.electricInput) {\r\n          if (mode.electricInput.test(getLine(doc, end.line).text.slice(0, end.ch)))\r\n            indentLine(cm, end.line, \"smart\");\r\n        }\r\n      }\r\n    }\r\n    ensureCursorVisible(cm);\r\n    cm.curOp.updateInput = updateInput;\r\n    cm.curOp.typing = true;\r\n    cm.state.pasteIncoming = cm.state.cutIncoming = false;\r\n  }\r\n\r\n  function copyableRanges(cm) {\r\n    var text = [], ranges = [];\r\n    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\r\n      var line = cm.doc.sel.ranges[i].head.line;\r\n      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\r\n      ranges.push(lineRange);\r\n      text.push(cm.getRange(lineRange.anchor, lineRange.head));\r\n    }\r\n    return {text: text, ranges: ranges};\r\n  }\r\n\r\n  function disableBrowserMagic(field) {\r\n    field.setAttribute(\"autocorrect\", \"off\");\r\n    field.setAttribute(\"autocapitalize\", \"off\");\r\n    field.setAttribute(\"spellcheck\", \"false\");\r\n  }\r\n\r\n  // TEXTAREA INPUT STYLE\r\n\r\n  function TextareaInput(cm) {\r\n    this.cm = cm;\r\n    // See input.poll and input.reset\r\n    this.prevInput = \"\";\r\n\r\n    // Flag that indicates whether we expect input to appear real soon\r\n    // now (after some event like 'keypress' or 'input') and are\r\n    // polling intensively.\r\n    this.pollingFast = false;\r\n    // Self-resetting timeout for the poller\r\n    this.polling = new Delayed();\r\n    // Tracks when input.reset has punted to just putting a short\r\n    // string into the textarea instead of the full selection.\r\n    this.inaccurateSelection = false;\r\n    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\r\n    this.hasSelection = false;\r\n  };\r\n\r\n  function hiddenTextarea() {\r\n    var te = elt(\"textarea\", null, null, \"position: absolute; padding: 0; width: 1px; height: 1em; outline: none\");\r\n    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\r\n    // The textarea is kept positioned near the cursor to prevent the\r\n    // fact that it'll be scrolled into view on input from scrolling\r\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\r\n    // very slow. So make the area wide instead.\r\n    if (webkit) te.style.width = \"1000px\";\r\n    else te.setAttribute(\"wrap\", \"off\");\r\n    // If border: 0; -- iOS fails to open keyboard (issue #1287)\r\n    if (ios) te.style.border = \"1px solid black\";\r\n    disableBrowserMagic(te);\r\n    return div;\r\n  }\r\n\r\n  TextareaInput.prototype = copyObj({\r\n    init: function(display) {\r\n      var input = this, cm = this.cm;\r\n\r\n      // Wraps and hides input textarea\r\n      var div = this.wrapper = hiddenTextarea();\r\n      // The semihidden textarea that is focused when the editor is\r\n      // focused, and receives input.\r\n      var te = this.textarea = div.firstChild;\r\n      display.wrapper.insertBefore(div, display.wrapper.firstChild);\r\n\r\n      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\r\n      if (ios) te.style.width = \"0px\";\r\n\r\n      on(te, \"input\", function() {\r\n        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;\r\n        input.poll();\r\n      });\r\n\r\n      on(te, \"paste\", function() {\r\n        // Workaround for webkit bug https://bugs.webkit.org/show_bug.cgi?id=90206\r\n        // Add a char to the end of textarea before paste occur so that\r\n        // selection doesn't span to the end of textarea.\r\n        if (webkit && !cm.state.fakedLastChar && !(new Date - cm.state.lastMiddleDown < 200)) {\r\n          var start = te.selectionStart, end = te.selectionEnd;\r\n          te.value += \"$\";\r\n          // The selection end needs to be set before the start, otherwise there\r\n          // can be an intermediate non-empty selection between the two, which\r\n          // can override the middle-click paste buffer on linux and cause the\r\n          // wrong thing to get pasted.\r\n          te.selectionEnd = end;\r\n          te.selectionStart = start;\r\n          cm.state.fakedLastChar = true;\r\n        }\r\n        cm.state.pasteIncoming = true;\r\n        input.fastPoll();\r\n      });\r\n\r\n      function prepareCopyCut(e) {\r\n        if (cm.somethingSelected()) {\r\n          lastCopied = cm.getSelections();\r\n          if (input.inaccurateSelection) {\r\n            input.prevInput = \"\";\r\n            input.inaccurateSelection = false;\r\n            te.value = lastCopied.join(\"\\n\");\r\n            selectInput(te);\r\n          }\r\n        } else {\r\n          var ranges = copyableRanges(cm);\r\n          lastCopied = ranges.text;\r\n          if (e.type == \"cut\") {\r\n            cm.setSelections(ranges.ranges, null, sel_dontScroll);\r\n          } else {\r\n            input.prevInput = \"\";\r\n            te.value = ranges.text.join(\"\\n\");\r\n            selectInput(te);\r\n          }\r\n        }\r\n        if (e.type == \"cut\") cm.state.cutIncoming = true;\r\n      }\r\n      on(te, \"cut\", prepareCopyCut);\r\n      on(te, \"copy\", prepareCopyCut);\r\n\r\n      on(display.scroller, \"paste\", function(e) {\r\n        if (eventInWidget(display, e)) return;\r\n        cm.state.pasteIncoming = true;\r\n        input.focus();\r\n      });\r\n\r\n      // Prevent normal selection in the editor (we handle our own)\r\n      on(display.lineSpace, \"selectstart\", function(e) {\r\n        if (!eventInWidget(display, e)) e_preventDefault(e);\r\n      });\r\n    },\r\n\r\n    prepareSelection: function() {\r\n      // Redraw the selection and/or cursor\r\n      var cm = this.cm, display = cm.display, doc = cm.doc;\r\n      var result = prepareSelection(cm);\r\n\r\n      // Move the hidden textarea near the cursor to prevent scrolling artifacts\r\n      if (cm.options.moveInputWithCursor) {\r\n        var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\r\n        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\r\n        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\r\n                                            headPos.top + lineOff.top - wrapOff.top));\r\n        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\r\n                                             headPos.left + lineOff.left - wrapOff.left));\r\n      }\r\n\r\n      return result;\r\n    },\r\n\r\n    showSelection: function(drawn) {\r\n      var cm = this.cm, display = cm.display;\r\n      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\r\n      removeChildrenAndAdd(display.selectionDiv, drawn.selection);\r\n      if (drawn.teTop != null) {\r\n        this.wrapper.style.top = drawn.teTop + \"px\";\r\n        this.wrapper.style.left = drawn.teLeft + \"px\";\r\n      }\r\n    },\r\n\r\n    // Reset the input to correspond to the selection (or to be empty,\r\n    // when not typing and nothing is selected)\r\n    reset: function(typing) {\r\n      if (this.contextMenuPending) return;\r\n      var minimal, selected, cm = this.cm, doc = cm.doc;\r\n      if (cm.somethingSelected()) {\r\n        this.prevInput = \"\";\r\n        var range = doc.sel.primary();\r\n        minimal = hasCopyEvent &&\r\n          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);\r\n        var content = minimal ? \"-\" : selected || cm.getSelection();\r\n        this.textarea.value = content;\r\n        if (cm.state.focused) selectInput(this.textarea);\r\n        if (ie && ie_version >= 9) this.hasSelection = content;\r\n      } else if (!typing) {\r\n        this.prevInput = this.textarea.value = \"\";\r\n        if (ie && ie_version >= 9) this.hasSelection = null;\r\n      }\r\n      this.inaccurateSelection = minimal;\r\n    },\r\n\r\n    getField: function() { return this.textarea; },\r\n\r\n    supportsTouch: function() { return false; },\r\n\r\n    focus: function() {\r\n      if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\r\n        try { this.textarea.focus(); }\r\n        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\r\n      }\r\n    },\r\n\r\n    blur: function() { this.textarea.blur(); },\r\n\r\n    resetPosition: function() {\r\n      this.wrapper.style.top = this.wrapper.style.left = 0;\r\n    },\r\n\r\n    receivedFocus: function() { this.slowPoll(); },\r\n\r\n    // Poll for input changes, using the normal rate of polling. This\r\n    // runs as long as the editor is focused.\r\n    slowPoll: function() {\r\n      var input = this;\r\n      if (input.pollingFast) return;\r\n      input.polling.set(this.cm.options.pollInterval, function() {\r\n        input.poll();\r\n        if (input.cm.state.focused) input.slowPoll();\r\n      });\r\n    },\r\n\r\n    // When an event has just come in that is likely to add or change\r\n    // something in the input textarea, we poll faster, to ensure that\r\n    // the change appears on the screen quickly.\r\n    fastPoll: function() {\r\n      var missed = false, input = this;\r\n      input.pollingFast = true;\r\n      function p() {\r\n        var changed = input.poll();\r\n        if (!changed && !missed) {missed = true; input.polling.set(60, p);}\r\n        else {input.pollingFast = false; input.slowPoll();}\r\n      }\r\n      input.polling.set(20, p);\r\n    },\r\n\r\n    // Read input from the textarea, and update the document to match.\r\n    // When something is selected, it is present in the textarea, and\r\n    // selected (unless it is huge, in which case a placeholder is\r\n    // used). When nothing is selected, the cursor sits after previously\r\n    // seen text (can be empty), which is stored in prevInput (we must\r\n    // not reset the textarea when typing, because that breaks IME).\r\n    poll: function() {\r\n      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\r\n      // Since this is called a *lot*, try to bail out as cheaply as\r\n      // possible when it is clear that nothing happened. hasSelection\r\n      // will be the case when there is a lot of text in the textarea,\r\n      // in which case reading its value would be expensive.\r\n      if (!cm.state.focused || (hasSelection(input) && !prevInput) ||\r\n          isReadOnly(cm) || cm.options.disableInput || cm.state.keySeq)\r\n        return false;\r\n      // See paste handler for more on the fakedLastChar kludge\r\n      if (cm.state.pasteIncoming && cm.state.fakedLastChar) {\r\n        input.value = input.value.substring(0, input.value.length - 1);\r\n        cm.state.fakedLastChar = false;\r\n      }\r\n      var text = input.value;\r\n      // If nothing changed, bail.\r\n      if (text == prevInput && !cm.somethingSelected()) return false;\r\n      // Work around nonsensical selection resetting in IE9/10, and\r\n      // inexplicable appearance of private area unicode characters on\r\n      // some key combos in Mac (#2689).\r\n      if (ie && ie_version >= 9 && this.hasSelection === text ||\r\n          mac && /[\\uf700-\\uf7ff]/.test(text)) {\r\n        cm.display.input.reset();\r\n        return false;\r\n      }\r\n\r\n      if (cm.doc.sel == cm.display.selForContextMenu) {\r\n        var first = text.charCodeAt(0);\r\n        if (first == 0x200b && !prevInput) prevInput = \"\\u200b\";\r\n        if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\"); }\r\n      }\r\n      // Find the part of the input that is actually new\r\n      var same = 0, l = Math.min(prevInput.length, text.length);\r\n      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;\r\n\r\n      var self = this;\r\n      runInOp(cm, function() {\r\n        applyTextInput(cm, text.slice(same), prevInput.length - same);\r\n\r\n        // Don't leave long text in the textarea, since it makes further polling slow\r\n        if (text.length > 1000 || text.indexOf(\"\\n\") > -1) input.value = self.prevInput = \"\";\r\n        else self.prevInput = text;\r\n      });\r\n      return true;\r\n    },\r\n\r\n    ensurePolled: function() {\r\n      if (this.pollingFast && this.poll()) this.pollingFast = false;\r\n    },\r\n\r\n    onKeyPress: function() {\r\n      if (ie && ie_version >= 9) this.hasSelection = null;\r\n      this.fastPoll();\r\n    },\r\n\r\n    onContextMenu: function(e) {\r\n      var input = this, cm = input.cm, display = cm.display, te = input.textarea;\r\n      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\r\n      if (!pos || presto) return; // Opera is difficult.\r\n\r\n      // Reset the current text selection only if the click is done outside of the selection\r\n      // and 'resetSelectionOnContextMenu' option is true.\r\n      var reset = cm.options.resetSelectionOnContextMenu;\r\n      if (reset && cm.doc.sel.contains(pos) == -1)\r\n        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\r\n\r\n      var oldCSS = te.style.cssText;\r\n      input.wrapper.style.position = \"absolute\";\r\n      te.style.cssText = \"position: fixed; width: 30px; height: 30px; top: \" + (e.clientY - 5) +\r\n        \"px; left: \" + (e.clientX - 5) + \"px; z-index: 1000; background: \" +\r\n        (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") +\r\n        \"; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\r\n      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)\r\n      display.input.focus();\r\n      if (webkit) window.scrollTo(null, oldScrollY);\r\n      display.input.reset();\r\n      // Adds \"Select all\" to context menu in FF\r\n      if (!cm.somethingSelected()) te.value = input.prevInput = \" \";\r\n      input.contextMenuPending = true;\r\n      display.selForContextMenu = cm.doc.sel;\r\n      clearTimeout(display.detectingSelectAll);\r\n\r\n      // Select-all will be greyed out if there's nothing to select, so\r\n      // this adds a zero-width space so that we can later check whether\r\n      // it got selected.\r\n      function prepareSelectAllHack() {\r\n        if (te.selectionStart != null) {\r\n          var selected = cm.somethingSelected();\r\n          te.value = \"\\u21da\"; // Used to catch context-menu undo\r\n          var extval = te.value = \"\\u200b\" + (selected ? te.value : \"\");\r\n          input.prevInput = selected ? \"\" : \"\\u200b\";\r\n          te.selectionStart = 1; te.selectionEnd = extval.length;\r\n          // Re-set this, in case some other handler touched the\r\n          // selection in the meantime.\r\n          display.selForContextMenu = cm.doc.sel;\r\n        }\r\n      }\r\n      function rehide() {\r\n        input.contextMenuPending = false;\r\n        input.wrapper.style.position = \"relative\";\r\n        te.style.cssText = oldCSS;\r\n        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);\r\n\r\n        // Try to detect the user choosing select-all\r\n        if (te.selectionStart != null) {\r\n          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();\r\n          var i = 0, poll = function() {\r\n            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && input.prevInput == \"\\u200b\")\r\n              operation(cm, commands.selectAll)(cm);\r\n            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);\r\n            else display.input.reset();\r\n          };\r\n          display.detectingSelectAll = setTimeout(poll, 200);\r\n        }\r\n      }\r\n\r\n      if (ie && ie_version >= 9) prepareSelectAllHack();\r\n      if (captureRightClick) {\r\n        e_stop(e);\r\n        var mouseup = function() {\r\n          off(window, \"mouseup\", mouseup);\r\n          setTimeout(rehide, 20);\r\n        };\r\n        on(window, \"mouseup\", mouseup);\r\n      } else {\r\n        setTimeout(rehide, 50);\r\n      }\r\n    },\r\n\r\n    setUneditable: nothing,\r\n\r\n    needsContentAttribute: false\r\n  }, TextareaInput.prototype);\r\n\r\n  // CONTENTEDITABLE INPUT STYLE\r\n\r\n  function ContentEditableInput(cm) {\r\n    this.cm = cm;\r\n    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\r\n    this.polling = new Delayed();\r\n    this.gracePeriod = false;\r\n  }\r\n\r\n  ContentEditableInput.prototype = copyObj({\r\n    init: function(display) {\r\n      var input = this, cm = input.cm;\r\n      var div = input.div = display.lineDiv;\r\n      div.contentEditable = \"true\";\r\n      disableBrowserMagic(div);\r\n\r\n      on(div, \"paste\", function(e) {\r\n        var pasted = e.clipboardData && e.clipboardData.getData(\"text/plain\");\r\n        if (pasted) {\r\n          e.preventDefault();\r\n          cm.replaceSelection(pasted, null, \"paste\");\r\n        }\r\n      });\r\n\r\n      on(div, \"compositionstart\", function(e) {\r\n        var data = e.data;\r\n        input.composing = {sel: cm.doc.sel, data: data, startData: data};\r\n        if (!data) return;\r\n        var prim = cm.doc.sel.primary();\r\n        var line = cm.getLine(prim.head.line);\r\n        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));\r\n        if (found > -1 && found <= prim.head.ch)\r\n          input.composing.sel = simpleSelection(Pos(prim.head.line, found),\r\n                                                Pos(prim.head.line, found + data.length));\r\n      });\r\n      on(div, \"compositionupdate\", function(e) {\r\n        input.composing.data = e.data;\r\n      });\r\n      on(div, \"compositionend\", function(e) {\r\n        var ours = input.composing;\r\n        if (!ours) return;\r\n        if (e.data != ours.startData && !/\\u200b/.test(e.data))\r\n          ours.data = e.data;\r\n        // Need a small delay to prevent other code (input event,\r\n        // selection polling) from doing damage when fired right after\r\n        // compositionend.\r\n        setTimeout(function() {\r\n          if (!ours.handled)\r\n            input.applyComposition(ours);\r\n          if (input.composing == ours)\r\n            input.composing = null;\r\n        }, 50);\r\n      });\r\n\r\n      on(div, \"touchstart\", function() {\r\n        input.forceCompositionEnd();\r\n      });\r\n\r\n      on(div, \"input\", function() {\r\n        if (input.composing) return;\r\n        if (!input.pollContent())\r\n          runInOp(input.cm, function() {regChange(cm);});\r\n      });\r\n\r\n      function onCopyCut(e) {\r\n        if (cm.somethingSelected()) {\r\n          lastCopied = cm.getSelections();\r\n          if (e.type == \"cut\") cm.replaceSelection(\"\", null, \"cut\");\r\n        } else {\r\n          var ranges = copyableRanges(cm);\r\n          lastCopied = ranges.text;\r\n          if (e.type == \"cut\") {\r\n            cm.operation(function() {\r\n              cm.setSelections(ranges.ranges, 0, sel_dontScroll);\r\n              cm.replaceSelection(\"\", null, \"cut\");\r\n            });\r\n          }\r\n        }\r\n        // iOS exposes the clipboard API, but seems to discard content inserted into it\r\n        if (e.clipboardData && !ios) {\r\n          e.preventDefault();\r\n          e.clipboardData.clearData();\r\n          e.clipboardData.setData(\"text/plain\", lastCopied.join(\"\\n\"));\r\n        } else {\r\n          // Old-fashioned briefly-focus-a-textarea hack\r\n          var kludge = hiddenTextarea(), te = kludge.firstChild;\r\n          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\r\n          te.value = lastCopied.join(\"\\n\");\r\n          var hadFocus = document.activeElement;\r\n          selectInput(te);\r\n          setTimeout(function() {\r\n            cm.display.lineSpace.removeChild(kludge);\r\n            hadFocus.focus();\r\n          }, 50);\r\n        }\r\n      }\r\n      on(div, \"copy\", onCopyCut);\r\n      on(div, \"cut\", onCopyCut);\r\n    },\r\n\r\n    prepareSelection: function() {\r\n      var result = prepareSelection(this.cm, false);\r\n      result.focus = this.cm.state.focused;\r\n      return result;\r\n    },\r\n\r\n    showSelection: function(info) {\r\n      if (!info || !this.cm.display.view.length) return;\r\n      if (info.focus) this.showPrimarySelection();\r\n      this.showMultipleSelections(info);\r\n    },\r\n\r\n    showPrimarySelection: function() {\r\n      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();\r\n      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);\r\n      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);\r\n      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\r\n          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&\r\n          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)\r\n        return;\r\n\r\n      var start = posToDOM(this.cm, prim.from());\r\n      var end = posToDOM(this.cm, prim.to());\r\n      if (!start && !end) return;\r\n\r\n      var view = this.cm.display.view;\r\n      var old = sel.rangeCount && sel.getRangeAt(0);\r\n      if (!start) {\r\n        start = {node: view[0].measure.map[2], offset: 0};\r\n      } else if (!end) { // FIXME dangerously hacky\r\n        var measure = view[view.length - 1].measure;\r\n        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\r\n        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};\r\n      }\r\n\r\n      try { var rng = range(start.node, start.offset, end.offset, end.node); }\r\n      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\r\n      if (rng) {\r\n        sel.removeAllRanges();\r\n        sel.addRange(rng);\r\n        if (old && sel.anchorNode == null) sel.addRange(old);\r\n        else if (gecko) this.startGracePeriod();\r\n      }\r\n      this.rememberSelection();\r\n    },\r\n\r\n    startGracePeriod: function() {\r\n      var input = this;\r\n      clearTimeout(this.gracePeriod);\r\n      this.gracePeriod = setTimeout(function() {\r\n        input.gracePeriod = false;\r\n        if (input.selectionChanged())\r\n          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });\r\n      }, 20);\r\n    },\r\n\r\n    showMultipleSelections: function(info) {\r\n      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\r\n      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\r\n    },\r\n\r\n    rememberSelection: function() {\r\n      var sel = window.getSelection();\r\n      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\r\n      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\r\n    },\r\n\r\n    selectionInEditor: function() {\r\n      var sel = window.getSelection();\r\n      if (!sel.rangeCount) return false;\r\n      var node = sel.getRangeAt(0).commonAncestorContainer;\r\n      return contains(this.div, node);\r\n    },\r\n\r\n    focus: function() {\r\n      if (this.cm.options.readOnly != \"nocursor\") this.div.focus();\r\n    },\r\n    blur: function() { this.div.blur(); },\r\n    getField: function() { return this.div; },\r\n\r\n    supportsTouch: function() { return true; },\r\n\r\n    receivedFocus: function() {\r\n      var input = this;\r\n      if (this.selectionInEditor())\r\n        this.pollSelection();\r\n      else\r\n        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });\r\n\r\n      function poll() {\r\n        if (input.cm.state.focused) {\r\n          input.pollSelection();\r\n          input.polling.set(input.cm.options.pollInterval, poll);\r\n        }\r\n      }\r\n      this.polling.set(this.cm.options.pollInterval, poll);\r\n    },\r\n\r\n    selectionChanged: function() {\r\n      var sel = window.getSelection();\r\n      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\r\n        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\r\n    },\r\n\r\n    pollSelection: function() {\r\n      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {\r\n        var sel = window.getSelection(), cm = this.cm;\r\n        this.rememberSelection();\r\n        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\r\n        var head = domToPos(cm, sel.focusNode, sel.focusOffset);\r\n        if (anchor && head) runInOp(cm, function() {\r\n          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\r\n          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;\r\n        });\r\n      }\r\n    },\r\n\r\n    pollContent: function() {\r\n      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\r\n      var from = sel.from(), to = sel.to();\r\n      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;\r\n\r\n      var fromIndex;\r\n      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\r\n        var fromLine = lineNo(display.view[0].line);\r\n        var fromNode = display.view[0].node;\r\n      } else {\r\n        var fromLine = lineNo(display.view[fromIndex].line);\r\n        var fromNode = display.view[fromIndex - 1].node.nextSibling;\r\n      }\r\n      var toIndex = findViewIndex(cm, to.line);\r\n      if (toIndex == display.view.length - 1) {\r\n        var toLine = display.viewTo - 1;\r\n        var toNode = display.view[toIndex].node;\r\n      } else {\r\n        var toLine = lineNo(display.view[toIndex + 1].line) - 1;\r\n        var toNode = display.view[toIndex + 1].node.previousSibling;\r\n      }\r\n\r\n      var newText = splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\r\n      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\r\n      while (newText.length > 1 && oldText.length > 1) {\r\n        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\r\n        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\r\n        else break;\r\n      }\r\n\r\n      var cutFront = 0, cutEnd = 0;\r\n      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\r\n      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\r\n        ++cutFront;\r\n      var newBot = lst(newText), oldBot = lst(oldText);\r\n      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\r\n                               oldBot.length - (oldText.length == 1 ? cutFront : 0));\r\n      while (cutEnd < maxCutEnd &&\r\n             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\r\n        ++cutEnd;\r\n\r\n      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);\r\n      newText[0] = newText[0].slice(cutFront);\r\n\r\n      var chFrom = Pos(fromLine, cutFront);\r\n      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\r\n      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\r\n        replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\r\n        return true;\r\n      }\r\n    },\r\n\r\n    ensurePolled: function() {\r\n      this.forceCompositionEnd();\r\n    },\r\n    reset: function() {\r\n      this.forceCompositionEnd();\r\n    },\r\n    forceCompositionEnd: function() {\r\n      if (!this.composing || this.composing.handled) return;\r\n      this.applyComposition(this.composing);\r\n      this.composing.handled = true;\r\n      this.div.blur();\r\n      this.div.focus();\r\n    },\r\n    applyComposition: function(composing) {\r\n      if (composing.data && composing.data != composing.startData)\r\n        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);\r\n    },\r\n\r\n    setUneditable: function(node) {\r\n      node.setAttribute(\"contenteditable\", \"false\");\r\n    },\r\n\r\n    onKeyPress: function(e) {\r\n      e.preventDefault();\r\n      operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\r\n    },\r\n\r\n    onContextMenu: nothing,\r\n    resetPosition: nothing,\r\n\r\n    needsContentAttribute: true\r\n  }, ContentEditableInput.prototype);\r\n\r\n  function posToDOM(cm, pos) {\r\n    var view = findViewForLine(cm, pos.line);\r\n    if (!view || view.hidden) return null;\r\n    var line = getLine(cm.doc, pos.line);\r\n    var info = mapFromLineView(view, line, pos.line);\r\n\r\n    var order = getOrder(line), side = \"left\";\r\n    if (order) {\r\n      var partPos = getBidiPartAt(order, pos.ch);\r\n      side = partPos % 2 ? \"right\" : \"left\";\r\n    }\r\n    var result = nodeAndOffsetInLineMap(info.map, pos.ch, \"left\");\r\n    result.offset = result.collapse == \"right\" ? result.end : result.start;\r\n    return result;\r\n  }\r\n\r\n  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }\r\n\r\n  function domToPos(cm, node, offset) {\r\n    var lineNode;\r\n    if (node == cm.display.lineDiv) {\r\n      lineNode = cm.display.lineDiv.childNodes[offset];\r\n      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);\r\n      node = null; offset = 0;\r\n    } else {\r\n      for (lineNode = node;; lineNode = lineNode.parentNode) {\r\n        if (!lineNode || lineNode == cm.display.lineDiv) return null;\r\n        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;\r\n      }\r\n    }\r\n    for (var i = 0; i < cm.display.view.length; i++) {\r\n      var lineView = cm.display.view[i];\r\n      if (lineView.node == lineNode)\r\n        return locateNodeInLineView(lineView, node, offset);\r\n    }\r\n  }\r\n\r\n  function locateNodeInLineView(lineView, node, offset) {\r\n    var wrapper = lineView.text.firstChild, bad = false;\r\n    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);\r\n    if (node == wrapper) {\r\n      bad = true;\r\n      node = wrapper.childNodes[offset];\r\n      offset = 0;\r\n      if (!node) {\r\n        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\r\n        return badPos(Pos(lineNo(line), line.text.length), bad);\r\n      }\r\n    }\r\n\r\n    var textNode = node.nodeType == 3 ? node : null, topNode = node;\r\n    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\r\n      textNode = node.firstChild;\r\n      if (offset) offset = textNode.nodeValue.length;\r\n    }\r\n    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;\r\n    var measure = lineView.measure, maps = measure.maps;\r\n\r\n    function find(textNode, topNode, offset) {\r\n      for (var i = -1; i < (maps ? maps.length : 0); i++) {\r\n        var map = i < 0 ? measure.map : maps[i];\r\n        for (var j = 0; j < map.length; j += 3) {\r\n          var curNode = map[j + 2];\r\n          if (curNode == textNode || curNode == topNode) {\r\n            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\r\n            var ch = map[j] + offset;\r\n            if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];\r\n            return Pos(line, ch);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    var found = find(textNode, topNode, offset);\r\n    if (found) return badPos(found, bad);\r\n\r\n    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\r\n    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\r\n      found = find(after, after.firstChild, 0);\r\n      if (found)\r\n        return badPos(Pos(found.line, found.ch - dist), bad);\r\n      else\r\n        dist += after.textContent.length;\r\n    }\r\n    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {\r\n      found = find(before, before.firstChild, -1);\r\n      if (found)\r\n        return badPos(Pos(found.line, found.ch + dist), bad);\r\n      else\r\n        dist += after.textContent.length;\r\n    }\r\n  }\r\n\r\n  function domTextBetween(cm, from, to, fromLine, toLine) {\r\n    var text = \"\", closing = false;\r\n    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }\r\n    function walk(node) {\r\n      if (node.nodeType == 1) {\r\n        var cmText = node.getAttribute(\"cm-text\");\r\n        if (cmText != null) {\r\n          if (cmText == \"\") cmText = node.textContent.replace(/\\u200b/g, \"\");\r\n          text += cmText;\r\n          return;\r\n        }\r\n        var markerID = node.getAttribute(\"cm-marker\"), range;\r\n        if (markerID) {\r\n          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\r\n          if (found.length && (range = found[0].find()))\r\n            text += getBetween(cm.doc, range.from, range.to).join(\"\\n\");\r\n          return;\r\n        }\r\n        if (node.getAttribute(\"contenteditable\") == \"false\") return;\r\n        for (var i = 0; i < node.childNodes.length; i++)\r\n          walk(node.childNodes[i]);\r\n        if (/^(pre|div|p)$/i.test(node.nodeName))\r\n          closing = true;\r\n      } else if (node.nodeType == 3) {\r\n        var val = node.nodeValue;\r\n        if (!val) return;\r\n        if (closing) {\r\n          text += \"\\n\";\r\n          closing = false;\r\n        }\r\n        text += val;\r\n      }\r\n    }\r\n    for (;;) {\r\n      walk(from);\r\n      if (from == to) break;\r\n      from = from.nextSibling;\r\n    }\r\n    return text;\r\n  }\r\n\r\n  CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\r\n\r\n  // SELECTION / CURSOR\r\n\r\n  // Selection objects are immutable. A new one is created every time\r\n  // the selection changes. A selection is one or more non-overlapping\r\n  // (and non-touching) ranges, sorted, and an integer that indicates\r\n  // which one is the primary selection (the one that's scrolled into\r\n  // view, that getCursor returns, etc).\r\n  function Selection(ranges, primIndex) {\r\n    this.ranges = ranges;\r\n    this.primIndex = primIndex;\r\n  }\r\n\r\n  Selection.prototype = {\r\n    primary: function() { return this.ranges[this.primIndex]; },\r\n    equals: function(other) {\r\n      if (other == this) return true;\r\n      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;\r\n      for (var i = 0; i < this.ranges.length; i++) {\r\n        var here = this.ranges[i], there = other.ranges[i];\r\n        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;\r\n      }\r\n      return true;\r\n    },\r\n    deepCopy: function() {\r\n      for (var out = [], i = 0; i < this.ranges.length; i++)\r\n        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));\r\n      return new Selection(out, this.primIndex);\r\n    },\r\n    somethingSelected: function() {\r\n      for (var i = 0; i < this.ranges.length; i++)\r\n        if (!this.ranges[i].empty()) return true;\r\n      return false;\r\n    },\r\n    contains: function(pos, end) {\r\n      if (!end) end = pos;\r\n      for (var i = 0; i < this.ranges.length; i++) {\r\n        var range = this.ranges[i];\r\n        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\r\n          return i;\r\n      }\r\n      return -1;\r\n    }\r\n  };\r\n\r\n  function Range(anchor, head) {\r\n    this.anchor = anchor; this.head = head;\r\n  }\r\n\r\n  Range.prototype = {\r\n    from: function() { return minPos(this.anchor, this.head); },\r\n    to: function() { return maxPos(this.anchor, this.head); },\r\n    empty: function() {\r\n      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\r\n    }\r\n  };\r\n\r\n  // Take an unsorted, potentially overlapping set of ranges, and\r\n  // build a selection out of it. 'Consumes' ranges array (modifying\r\n  // it).\r\n  function normalizeSelection(ranges, primIndex) {\r\n    var prim = ranges[primIndex];\r\n    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });\r\n    primIndex = indexOf(ranges, prim);\r\n    for (var i = 1; i < ranges.length; i++) {\r\n      var cur = ranges[i], prev = ranges[i - 1];\r\n      if (cmp(prev.to(), cur.from()) >= 0) {\r\n        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\r\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\r\n        if (i <= primIndex) --primIndex;\r\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\r\n      }\r\n    }\r\n    return new Selection(ranges, primIndex);\r\n  }\r\n\r\n  function simpleSelection(anchor, head) {\r\n    return new Selection([new Range(anchor, head || anchor)], 0);\r\n  }\r\n\r\n  // Most of the external API clips given positions to make sure they\r\n  // actually exist within the document.\r\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}\r\n  function clipPos(doc, pos) {\r\n    if (pos.line < doc.first) return Pos(doc.first, 0);\r\n    var last = doc.first + doc.size - 1;\r\n    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\r\n    return clipToLen(pos, getLine(doc, pos.line).text.length);\r\n  }\r\n  function clipToLen(pos, linelen) {\r\n    var ch = pos.ch;\r\n    if (ch == null || ch > linelen) return Pos(pos.line, linelen);\r\n    else if (ch < 0) return Pos(pos.line, 0);\r\n    else return pos;\r\n  }\r\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}\r\n  function clipPosArray(doc, array) {\r\n    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);\r\n    return out;\r\n  }\r\n\r\n  // SELECTION UPDATES\r\n\r\n  // The 'scroll' parameter given to many of these indicated whether\r\n  // the new cursor position should be scrolled into view after\r\n  // modifying the selection.\r\n\r\n  // If shift is held or the extend flag is set, extends a range to\r\n  // include a given position (and optionally a second position).\r\n  // Otherwise, simply returns the range between the given positions.\r\n  // Used for cursor motion and such.\r\n  function extendRange(doc, range, head, other) {\r\n    if (doc.cm && doc.cm.display.shift || doc.extend) {\r\n      var anchor = range.anchor;\r\n      if (other) {\r\n        var posBefore = cmp(head, anchor) < 0;\r\n        if (posBefore != (cmp(other, anchor) < 0)) {\r\n          anchor = head;\r\n          head = other;\r\n        } else if (posBefore != (cmp(head, other) < 0)) {\r\n          head = other;\r\n        }\r\n      }\r\n      return new Range(anchor, head);\r\n    } else {\r\n      return new Range(other || head, head);\r\n    }\r\n  }\r\n\r\n  // Extend the primary selection range, discard the rest.\r\n  function extendSelection(doc, head, other, options) {\r\n    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);\r\n  }\r\n\r\n  // Extend all selections (pos is an array of selections with length\r\n  // equal the number of selections)\r\n  function extendSelections(doc, heads, options) {\r\n    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)\r\n      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);\r\n    var newSel = normalizeSelection(out, doc.sel.primIndex);\r\n    setSelection(doc, newSel, options);\r\n  }\r\n\r\n  // Updates a single range in the selection.\r\n  function replaceOneSelection(doc, i, range, options) {\r\n    var ranges = doc.sel.ranges.slice(0);\r\n    ranges[i] = range;\r\n    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\r\n  }\r\n\r\n  // Reset the selection to a single range.\r\n  function setSimpleSelection(doc, anchor, head, options) {\r\n    setSelection(doc, simpleSelection(anchor, head), options);\r\n  }\r\n\r\n  // Give beforeSelectionChange handlers a change to influence a\r\n  // selection update.\r\n  function filterSelectionChange(doc, sel) {\r\n    var obj = {\r\n      ranges: sel.ranges,\r\n      update: function(ranges) {\r\n        this.ranges = [];\r\n        for (var i = 0; i < ranges.length; i++)\r\n          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\r\n                                     clipPos(doc, ranges[i].head));\r\n      }\r\n    };\r\n    signal(doc, \"beforeSelectionChange\", doc, obj);\r\n    if (doc.cm) signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj);\r\n    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);\r\n    else return sel;\r\n  }\r\n\r\n  function setSelectionReplaceHistory(doc, sel, options) {\r\n    var done = doc.history.done, last = lst(done);\r\n    if (last && last.ranges) {\r\n      done[done.length - 1] = sel;\r\n      setSelectionNoUndo(doc, sel, options);\r\n    } else {\r\n      setSelection(doc, sel, options);\r\n    }\r\n  }\r\n\r\n  // Set a new selection.\r\n  function setSelection(doc, sel, options) {\r\n    setSelectionNoUndo(doc, sel, options);\r\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\r\n  }\r\n\r\n  function setSelectionNoUndo(doc, sel, options) {\r\n    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\r\n      sel = filterSelectionChange(doc, sel);\r\n\r\n    var bias = options && options.bias ||\r\n      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\r\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\r\n\r\n    if (!(options && options.scroll === false) && doc.cm)\r\n      ensureCursorVisible(doc.cm);\r\n  }\r\n\r\n  function setSelectionInner(doc, sel) {\r\n    if (sel.equals(doc.sel)) return;\r\n\r\n    doc.sel = sel;\r\n\r\n    if (doc.cm) {\r\n      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\r\n      signalCursorActivity(doc.cm);\r\n    }\r\n    signalLater(doc, \"cursorActivity\", doc);\r\n  }\r\n\r\n  // Verify that the selection does not partially select any atomic\r\n  // marked ranges.\r\n  function reCheckSelection(doc) {\r\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);\r\n  }\r\n\r\n  // Return a selection that does not partially select any atomic\r\n  // ranges.\r\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\r\n    var out;\r\n    for (var i = 0; i < sel.ranges.length; i++) {\r\n      var range = sel.ranges[i];\r\n      var newAnchor = skipAtomic(doc, range.anchor, bias, mayClear);\r\n      var newHead = skipAtomic(doc, range.head, bias, mayClear);\r\n      if (out || newAnchor != range.anchor || newHead != range.head) {\r\n        if (!out) out = sel.ranges.slice(0, i);\r\n        out[i] = new Range(newAnchor, newHead);\r\n      }\r\n    }\r\n    return out ? normalizeSelection(out, sel.primIndex) : sel;\r\n  }\r\n\r\n  // Ensure a given position is not inside an atomic range.\r\n  function skipAtomic(doc, pos, bias, mayClear) {\r\n    var flipped = false, curPos = pos;\r\n    var dir = bias || 1;\r\n    doc.cantEdit = false;\r\n    search: for (;;) {\r\n      var line = getLine(doc, curPos.line);\r\n      if (line.markedSpans) {\r\n        for (var i = 0; i < line.markedSpans.length; ++i) {\r\n          var sp = line.markedSpans[i], m = sp.marker;\r\n          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&\r\n              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {\r\n            if (mayClear) {\r\n              signal(m, \"beforeCursorEnter\");\r\n              if (m.explicitlyCleared) {\r\n                if (!line.markedSpans) break;\r\n                else {--i; continue;}\r\n              }\r\n            }\r\n            if (!m.atomic) continue;\r\n            var newPos = m.find(dir < 0 ? -1 : 1);\r\n            if (cmp(newPos, curPos) == 0) {\r\n              newPos.ch += dir;\r\n              if (newPos.ch < 0) {\r\n                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));\r\n                else newPos = null;\r\n              } else if (newPos.ch > line.text.length) {\r\n                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);\r\n                else newPos = null;\r\n              }\r\n              if (!newPos) {\r\n                if (flipped) {\r\n                  // Driven in a corner -- no valid cursor position found at all\r\n                  // -- try again *with* clearing, if we didn't already\r\n                  if (!mayClear) return skipAtomic(doc, pos, bias, true);\r\n                  // Otherwise, turn off editing until further notice, and return the start of the doc\r\n                  doc.cantEdit = true;\r\n                  return Pos(doc.first, 0);\r\n                }\r\n                flipped = true; newPos = pos; dir = -dir;\r\n              }\r\n            }\r\n            curPos = newPos;\r\n            continue search;\r\n          }\r\n        }\r\n      }\r\n      return curPos;\r\n    }\r\n  }\r\n\r\n  // SELECTION DRAWING\r\n\r\n  function updateSelection(cm) {\r\n    cm.display.input.showSelection(cm.display.input.prepareSelection());\r\n  }\r\n\r\n  function prepareSelection(cm, primary) {\r\n    var doc = cm.doc, result = {};\r\n    var curFragment = result.cursors = document.createDocumentFragment();\r\n    var selFragment = result.selection = document.createDocumentFragment();\r\n\r\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\r\n      if (primary === false && i == doc.sel.primIndex) continue;\r\n      var range = doc.sel.ranges[i];\r\n      var collapsed = range.empty();\r\n      if (collapsed || cm.options.showCursorWhenSelecting)\r\n        drawSelectionCursor(cm, range, curFragment);\r\n      if (!collapsed)\r\n        drawSelectionRange(cm, range, selFragment);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  // Draws a cursor for the given range\r\n  function drawSelectionCursor(cm, range, output) {\r\n    var pos = cursorCoords(cm, range.head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\r\n\r\n    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\r\n    cursor.style.left = pos.left + \"px\";\r\n    cursor.style.top = pos.top + \"px\";\r\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\r\n\r\n    if (pos.other) {\r\n      // Secondary cursor, shown when on a 'jump' in bi-directional text\r\n      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\r\n      otherCursor.style.display = \"\";\r\n      otherCursor.style.left = pos.other.left + \"px\";\r\n      otherCursor.style.top = pos.other.top + \"px\";\r\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\r\n    }\r\n  }\r\n\r\n  // Draws the given range as a highlighted selection\r\n  function drawSelectionRange(cm, range, output) {\r\n    var display = cm.display, doc = cm.doc;\r\n    var fragment = document.createDocumentFragment();\r\n    var padding = paddingH(cm.display), leftSide = padding.left;\r\n    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\r\n\r\n    function add(left, top, width, bottom) {\r\n      if (top < 0) top = 0;\r\n      top = Math.round(top);\r\n      bottom = Math.round(bottom);\r\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left +\r\n                               \"px; top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) +\r\n                               \"px; height: \" + (bottom - top) + \"px\"));\r\n    }\r\n\r\n    function drawForLine(line, fromArg, toArg) {\r\n      var lineObj = getLine(doc, line);\r\n      var lineLen = lineObj.text.length;\r\n      var start, end;\r\n      function coords(ch, bias) {\r\n        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias);\r\n      }\r\n\r\n      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\r\n        var leftPos = coords(from, \"left\"), rightPos, left, right;\r\n        if (from == to) {\r\n          rightPos = leftPos;\r\n          left = right = leftPos.left;\r\n        } else {\r\n          rightPos = coords(to - 1, \"right\");\r\n          if (dir == \"rtl\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\r\n          left = leftPos.left;\r\n          right = rightPos.right;\r\n        }\r\n        if (fromArg == null && from == 0) left = leftSide;\r\n        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\r\n          add(left, leftPos.top, null, leftPos.bottom);\r\n          left = leftSide;\r\n          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\r\n        }\r\n        if (toArg == null && to == lineLen) right = rightSide;\r\n        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\r\n          start = leftPos;\r\n        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\r\n          end = rightPos;\r\n        if (left < leftSide + 1) left = leftSide;\r\n        add(left, rightPos.top, right - left, rightPos.bottom);\r\n      });\r\n      return {start: start, end: end};\r\n    }\r\n\r\n    var sFrom = range.from(), sTo = range.to();\r\n    if (sFrom.line == sTo.line) {\r\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\r\n    } else {\r\n      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\r\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\r\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\r\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\r\n      if (singleVLine) {\r\n        if (leftEnd.top < rightStart.top - 2) {\r\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\r\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\r\n        } else {\r\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\r\n        }\r\n      }\r\n      if (leftEnd.bottom < rightStart.top)\r\n        add(leftSide, leftEnd.bottom, null, rightStart.top);\r\n    }\r\n\r\n    output.appendChild(fragment);\r\n  }\r\n\r\n  // Cursor-blinking\r\n  function restartBlink(cm) {\r\n    if (!cm.state.focused) return;\r\n    var display = cm.display;\r\n    clearInterval(display.blinker);\r\n    var on = true;\r\n    display.cursorDiv.style.visibility = \"\";\r\n    if (cm.options.cursorBlinkRate > 0)\r\n      display.blinker = setInterval(function() {\r\n        display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\r\n      }, cm.options.cursorBlinkRate);\r\n    else if (cm.options.cursorBlinkRate < 0)\r\n      display.cursorDiv.style.visibility = \"hidden\";\r\n  }\r\n\r\n  // HIGHLIGHT WORKER\r\n\r\n  function startWorker(cm, time) {\r\n    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\r\n      cm.state.highlight.set(time, bind(highlightWorker, cm));\r\n  }\r\n\r\n  function highlightWorker(cm) {\r\n    var doc = cm.doc;\r\n    if (doc.frontier < doc.first) doc.frontier = doc.first;\r\n    if (doc.frontier >= cm.display.viewTo) return;\r\n    var end = +new Date + cm.options.workTime;\r\n    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\r\n    var changedLines = [];\r\n\r\n    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {\r\n      if (doc.frontier >= cm.display.viewFrom) { // Visible\r\n        var oldStyles = line.styles;\r\n        var highlighted = highlightLine(cm, line, state, true);\r\n        line.styles = highlighted.styles;\r\n        var oldCls = line.styleClasses, newCls = highlighted.classes;\r\n        if (newCls) line.styleClasses = newCls;\r\n        else if (oldCls) line.styleClasses = null;\r\n        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\r\n          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\r\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];\r\n        if (ischange) changedLines.push(doc.frontier);\r\n        line.stateAfter = copyState(doc.mode, state);\r\n      } else {\r\n        processLine(cm, line.text, state);\r\n        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\r\n      }\r\n      ++doc.frontier;\r\n      if (+new Date > end) {\r\n        startWorker(cm, cm.options.workDelay);\r\n        return true;\r\n      }\r\n    });\r\n    if (changedLines.length) runInOp(cm, function() {\r\n      for (var i = 0; i < changedLines.length; i++)\r\n        regLineChange(cm, changedLines[i], \"text\");\r\n    });\r\n  }\r\n\r\n  // Finds the line to start with when starting a parse. Tries to\r\n  // find a line with a stateAfter, so that it can start with a\r\n  // valid state. If that fails, it returns the line with the\r\n  // smallest indentation, which tends to need the least context to\r\n  // parse correctly.\r\n  function findStartLine(cm, n, precise) {\r\n    var minindent, minline, doc = cm.doc;\r\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\r\n    for (var search = n; search > lim; --search) {\r\n      if (search <= doc.first) return doc.first;\r\n      var line = getLine(doc, search - 1);\r\n      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\r\n      var indented = countColumn(line.text, null, cm.options.tabSize);\r\n      if (minline == null || minindent > indented) {\r\n        minline = search - 1;\r\n        minindent = indented;\r\n      }\r\n    }\r\n    return minline;\r\n  }\r\n\r\n  function getStateBefore(cm, n, precise) {\r\n    var doc = cm.doc, display = cm.display;\r\n    if (!doc.mode.startState) return true;\r\n    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\r\n    if (!state) state = startState(doc.mode);\r\n    else state = copyState(doc.mode, state);\r\n    doc.iter(pos, n, function(line) {\r\n      processLine(cm, line.text, state);\r\n      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;\r\n      line.stateAfter = save ? copyState(doc.mode, state) : null;\r\n      ++pos;\r\n    });\r\n    if (precise) doc.frontier = pos;\r\n    return state;\r\n  }\r\n\r\n  // POSITION MEASUREMENT\r\n\r\n  function paddingTop(display) {return display.lineSpace.offsetTop;}\r\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}\r\n  function paddingH(display) {\r\n    if (display.cachedPaddingH) return display.cachedPaddingH;\r\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\r\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\r\n    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\r\n    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;\r\n    return data;\r\n  }\r\n\r\n  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }\r\n  function displayWidth(cm) {\r\n    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;\r\n  }\r\n  function displayHeight(cm) {\r\n    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;\r\n  }\r\n\r\n  // Ensure the lineView.wrapping.heights array is populated. This is\r\n  // an array of bottom offsets for the lines that make up a drawn\r\n  // line. When lineWrapping is on, there might be more than one\r\n  // height.\r\n  function ensureLineHeights(cm, lineView, rect) {\r\n    var wrapping = cm.options.lineWrapping;\r\n    var curWidth = wrapping && displayWidth(cm);\r\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\r\n      var heights = lineView.measure.heights = [];\r\n      if (wrapping) {\r\n        lineView.measure.width = curWidth;\r\n        var rects = lineView.text.firstChild.getClientRects();\r\n        for (var i = 0; i < rects.length - 1; i++) {\r\n          var cur = rects[i], next = rects[i + 1];\r\n          if (Math.abs(cur.bottom - next.bottom) > 2)\r\n            heights.push((cur.bottom + next.top) / 2 - rect.top);\r\n        }\r\n      }\r\n      heights.push(rect.bottom - rect.top);\r\n    }\r\n  }\r\n\r\n  // Find a line map (mapping character offsets to text nodes) and a\r\n  // measurement cache for the given line number. (A line view might\r\n  // contain multiple lines when collapsed ranges are present.)\r\n  function mapFromLineView(lineView, line, lineN) {\r\n    if (lineView.line == line)\r\n      return {map: lineView.measure.map, cache: lineView.measure.cache};\r\n    for (var i = 0; i < lineView.rest.length; i++)\r\n      if (lineView.rest[i] == line)\r\n        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};\r\n    for (var i = 0; i < lineView.rest.length; i++)\r\n      if (lineNo(lineView.rest[i]) > lineN)\r\n        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};\r\n  }\r\n\r\n  // Render a line into the hidden node display.externalMeasured. Used\r\n  // when measurement is needed for a line that's not in the viewport.\r\n  function updateExternalMeasurement(cm, line) {\r\n    line = visualLine(line);\r\n    var lineN = lineNo(line);\r\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\r\n    view.lineN = lineN;\r\n    var built = view.built = buildLineContent(cm, view);\r\n    view.text = built.pre;\r\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\r\n    return view;\r\n  }\r\n\r\n  // Get a {top, bottom, left, right} box (in line-local coordinates)\r\n  // for a given character.\r\n  function measureChar(cm, line, ch, bias) {\r\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\r\n  }\r\n\r\n  // Find a line view that corresponds to the given line number.\r\n  function findViewForLine(cm, lineN) {\r\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\r\n      return cm.display.view[findViewIndex(cm, lineN)];\r\n    var ext = cm.display.externalMeasured;\r\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\r\n      return ext;\r\n  }\r\n\r\n  // Measurement can be split in two steps, the set-up work that\r\n  // applies to the whole line, and the measurement of the actual\r\n  // character. Functions like coordsChar, that need to do a lot of\r\n  // measurements in a row, can thus ensure that the set-up work is\r\n  // only done once.\r\n  function prepareMeasureForLine(cm, line) {\r\n    var lineN = lineNo(line);\r\n    var view = findViewForLine(cm, lineN);\r\n    if (view && !view.text)\r\n      view = null;\r\n    else if (view && view.changes)\r\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\r\n    if (!view)\r\n      view = updateExternalMeasurement(cm, line);\r\n\r\n    var info = mapFromLineView(view, line, lineN);\r\n    return {\r\n      line: line, view: view, rect: null,\r\n      map: info.map, cache: info.cache, before: info.before,\r\n      hasHeights: false\r\n    };\r\n  }\r\n\r\n  // Given a prepared measurement object, measures the position of an\r\n  // actual character (or fetches it from the cache).\r\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\r\n    if (prepared.before) ch = -1;\r\n    var key = ch + (bias || \"\"), found;\r\n    if (prepared.cache.hasOwnProperty(key)) {\r\n      found = prepared.cache[key];\r\n    } else {\r\n      if (!prepared.rect)\r\n        prepared.rect = prepared.view.text.getBoundingClientRect();\r\n      if (!prepared.hasHeights) {\r\n        ensureLineHeights(cm, prepared.view, prepared.rect);\r\n        prepared.hasHeights = true;\r\n      }\r\n      found = measureCharInner(cm, prepared, ch, bias);\r\n      if (!found.bogus) prepared.cache[key] = found;\r\n    }\r\n    return {left: found.left, right: found.right,\r\n            top: varHeight ? found.rtop : found.top,\r\n            bottom: varHeight ? found.rbottom : found.bottom};\r\n  }\r\n\r\n  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\r\n\r\n  function nodeAndOffsetInLineMap(map, ch, bias) {\r\n    var node, start, end, collapse;\r\n    // First, search the line map for the text node corresponding to,\r\n    // or closest to, the target character.\r\n    for (var i = 0; i < map.length; i += 3) {\r\n      var mStart = map[i], mEnd = map[i + 1];\r\n      if (ch < mStart) {\r\n        start = 0; end = 1;\r\n        collapse = \"left\";\r\n      } else if (ch < mEnd) {\r\n        start = ch - mStart;\r\n        end = start + 1;\r\n      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\r\n        end = mEnd - mStart;\r\n        start = end - 1;\r\n        if (ch >= mEnd) collapse = \"right\";\r\n      }\r\n      if (start != null) {\r\n        node = map[i + 2];\r\n        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\r\n          collapse = bias;\r\n        if (bias == \"left\" && start == 0)\r\n          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\r\n            node = map[(i -= 3) + 2];\r\n            collapse = \"left\";\r\n          }\r\n        if (bias == \"right\" && start == mEnd - mStart)\r\n          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\r\n            node = map[(i += 3) + 2];\r\n            collapse = \"right\";\r\n          }\r\n        break;\r\n      }\r\n    }\r\n    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};\r\n  }\r\n\r\n  function measureCharInner(cm, prepared, ch, bias) {\r\n    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\r\n    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\r\n\r\n    var rect;\r\n    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\r\n      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned\r\n        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;\r\n        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;\r\n        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {\r\n          rect = node.parentNode.getBoundingClientRect();\r\n        } else if (ie && cm.options.lineWrapping) {\r\n          var rects = range(node, start, end).getClientRects();\r\n          if (rects.length)\r\n            rect = rects[bias == \"right\" ? rects.length - 1 : 0];\r\n          else\r\n            rect = nullRect;\r\n        } else {\r\n          rect = range(node, start, end).getBoundingClientRect() || nullRect;\r\n        }\r\n        if (rect.left || rect.right || start == 0) break;\r\n        end = start;\r\n        start = start - 1;\r\n        collapse = \"right\";\r\n      }\r\n      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);\r\n    } else { // If it is a widget, simply get the box for the whole widget.\r\n      if (start > 0) collapse = bias = \"right\";\r\n      var rects;\r\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\r\n        rect = rects[bias == \"right\" ? rects.length - 1 : 0];\r\n      else\r\n        rect = node.getBoundingClientRect();\r\n    }\r\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\r\n      var rSpan = node.parentNode.getClientRects()[0];\r\n      if (rSpan)\r\n        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};\r\n      else\r\n        rect = nullRect;\r\n    }\r\n\r\n    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\r\n    var mid = (rtop + rbot) / 2;\r\n    var heights = prepared.view.measure.heights;\r\n    for (var i = 0; i < heights.length - 1; i++)\r\n      if (mid < heights[i]) break;\r\n    var top = i ? heights[i - 1] : 0, bot = heights[i];\r\n    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\r\n                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\r\n                  top: top, bottom: bot};\r\n    if (!rect.left && !rect.right) result.bogus = true;\r\n    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\r\n\r\n    return result;\r\n  }\r\n\r\n  // Work around problem with bounding client rects on ranges being\r\n  // returned incorrectly when zoomed on IE10 and below.\r\n  function maybeUpdateRectForZooming(measure, rect) {\r\n    if (!window.screen || screen.logicalXDPI == null ||\r\n        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\r\n      return rect;\r\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\r\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\r\n    return {left: rect.left * scaleX, right: rect.right * scaleX,\r\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY};\r\n  }\r\n\r\n  function clearLineMeasurementCacheFor(lineView) {\r\n    if (lineView.measure) {\r\n      lineView.measure.cache = {};\r\n      lineView.measure.heights = null;\r\n      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\r\n        lineView.measure.caches[i] = {};\r\n    }\r\n  }\r\n\r\n  function clearLineMeasurementCache(cm) {\r\n    cm.display.externalMeasure = null;\r\n    removeChildren(cm.display.lineMeasure);\r\n    for (var i = 0; i < cm.display.view.length; i++)\r\n      clearLineMeasurementCacheFor(cm.display.view[i]);\r\n  }\r\n\r\n  function clearCaches(cm) {\r\n    clearLineMeasurementCache(cm);\r\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\r\n    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\r\n    cm.display.lineNumChars = null;\r\n  }\r\n\r\n  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }\r\n  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }\r\n\r\n  // Converts a {top, bottom, left, right} box from line-local\r\n  // coordinates into another coordinate system. Context may be one of\r\n  // \"line\", \"div\" (display.lineDiv), \"local\"/null (editor), \"window\",\r\n  // or \"page\".\r\n  function intoCoordSystem(cm, lineObj, rect, context) {\r\n    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\r\n      var size = widgetHeight(lineObj.widgets[i]);\r\n      rect.top += size; rect.bottom += size;\r\n    }\r\n    if (context == \"line\") return rect;\r\n    if (!context) context = \"local\";\r\n    var yOff = heightAtLine(lineObj);\r\n    if (context == \"local\") yOff += paddingTop(cm.display);\r\n    else yOff -= cm.display.viewOffset;\r\n    if (context == \"page\" || context == \"window\") {\r\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\r\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\r\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\r\n      rect.left += xOff; rect.right += xOff;\r\n    }\r\n    rect.top += yOff; rect.bottom += yOff;\r\n    return rect;\r\n  }\r\n\r\n  // Coverts a box from \"div\" coords to another coordinate system.\r\n  // Context may be \"window\", \"page\", \"div\", or \"local\"/null.\r\n  function fromCoordSystem(cm, coords, context) {\r\n    if (context == \"div\") return coords;\r\n    var left = coords.left, top = coords.top;\r\n    // First move into \"page\" coordinate system\r\n    if (context == \"page\") {\r\n      left -= pageScrollX();\r\n      top -= pageScrollY();\r\n    } else if (context == \"local\" || !context) {\r\n      var localBox = cm.display.sizer.getBoundingClientRect();\r\n      left += localBox.left;\r\n      top += localBox.top;\r\n    }\r\n\r\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\r\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};\r\n  }\r\n\r\n  function charCoords(cm, pos, context, lineObj, bias) {\r\n    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\r\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\r\n  }\r\n\r\n  // Returns a box for a given cursor position, which may have an\r\n  // 'other' property containing the position of the secondary cursor\r\n  // on a bidi boundary.\r\n  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\r\n    lineObj = lineObj || getLine(cm.doc, pos.line);\r\n    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);\r\n    function get(ch, right) {\r\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\r\n      if (right) m.left = m.right; else m.right = m.left;\r\n      return intoCoordSystem(cm, lineObj, m, context);\r\n    }\r\n    function getBidi(ch, partPos) {\r\n      var part = order[partPos], right = part.level % 2;\r\n      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\r\n        part = order[--partPos];\r\n        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\r\n        right = true;\r\n      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\r\n        part = order[++partPos];\r\n        ch = bidiLeft(part) - part.level % 2;\r\n        right = false;\r\n      }\r\n      if (right && ch == part.to && ch > part.from) return get(ch - 1);\r\n      return get(ch, right);\r\n    }\r\n    var order = getOrder(lineObj), ch = pos.ch;\r\n    if (!order) return get(ch);\r\n    var partPos = getBidiPartAt(order, ch);\r\n    var val = getBidi(ch, partPos);\r\n    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\r\n    return val;\r\n  }\r\n\r\n  // Used to cheaply estimate the coordinates for a position. Used for\r\n  // intermediate scroll updates.\r\n  function estimateCoords(cm, pos) {\r\n    var left = 0, pos = clipPos(cm.doc, pos);\r\n    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;\r\n    var lineObj = getLine(cm.doc, pos.line);\r\n    var top = heightAtLine(lineObj) + paddingTop(cm.display);\r\n    return {left: left, right: left, top: top, bottom: top + lineObj.height};\r\n  }\r\n\r\n  // Positions returned by coordsChar contain some extra information.\r\n  // xRel is the relative x position of the input coordinates compared\r\n  // to the found position (so xRel > 0 means the coordinates are to\r\n  // the right of the character position, for example). When outside\r\n  // is true, that means the coordinates lie outside the line's\r\n  // vertical range.\r\n  function PosWithInfo(line, ch, outside, xRel) {\r\n    var pos = Pos(line, ch);\r\n    pos.xRel = xRel;\r\n    if (outside) pos.outside = true;\r\n    return pos;\r\n  }\r\n\r\n  // Compute the character position closest to the given coordinates.\r\n  // Input must be lineSpace-local (\"div\" coordinate system).\r\n  function coordsChar(cm, x, y) {\r\n    var doc = cm.doc;\r\n    y += cm.display.viewOffset;\r\n    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\r\n    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\r\n    if (lineN > last)\r\n      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\r\n    if (x < 0) x = 0;\r\n\r\n    var lineObj = getLine(doc, lineN);\r\n    for (;;) {\r\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\r\n      var merged = collapsedSpanAtEnd(lineObj);\r\n      var mergedPos = merged && merged.find(0, true);\r\n      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\r\n        lineN = lineNo(lineObj = mergedPos.to.line);\r\n      else\r\n        return found;\r\n    }\r\n  }\r\n\r\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\r\n    var innerOff = y - heightAtLine(lineObj);\r\n    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;\r\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\r\n\r\n    function getX(ch) {\r\n      var sp = cursorCoords(cm, Pos(lineNo, ch), \"line\", lineObj, preparedMeasure);\r\n      wrongLine = true;\r\n      if (innerOff > sp.bottom) return sp.left - adjust;\r\n      else if (innerOff < sp.top) return sp.left + adjust;\r\n      else wrongLine = false;\r\n      return sp.left;\r\n    }\r\n\r\n    var bidi = getOrder(lineObj), dist = lineObj.text.length;\r\n    var from = lineLeft(lineObj), to = lineRight(lineObj);\r\n    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\r\n\r\n    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);\r\n    // Do a binary search between these bounds.\r\n    for (;;) {\r\n      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\r\n        var ch = x < fromX || x - fromX <= toX - x ? from : to;\r\n        var xDiff = x - (ch == from ? fromX : toX);\r\n        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;\r\n        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,\r\n                              xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);\r\n        return pos;\r\n      }\r\n      var step = Math.ceil(dist / 2), middle = from + step;\r\n      if (bidi) {\r\n        middle = from;\r\n        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\r\n      }\r\n      var middleX = getX(middle);\r\n      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}\r\n      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}\r\n    }\r\n  }\r\n\r\n  var measureText;\r\n  // Compute the default text height.\r\n  function textHeight(display) {\r\n    if (display.cachedTextHeight != null) return display.cachedTextHeight;\r\n    if (measureText == null) {\r\n      measureText = elt(\"pre\");\r\n      // Measure a bunch of lines, for browsers that compute\r\n      // fractional heights.\r\n      for (var i = 0; i < 49; ++i) {\r\n        measureText.appendChild(document.createTextNode(\"x\"));\r\n        measureText.appendChild(elt(\"br\"));\r\n      }\r\n      measureText.appendChild(document.createTextNode(\"x\"));\r\n    }\r\n    removeChildrenAndAdd(display.measure, measureText);\r\n    var height = measureText.offsetHeight / 50;\r\n    if (height > 3) display.cachedTextHeight = height;\r\n    removeChildren(display.measure);\r\n    return height || 1;\r\n  }\r\n\r\n  // Compute the default character width.\r\n  function charWidth(display) {\r\n    if (display.cachedCharWidth != null) return display.cachedCharWidth;\r\n    var anchor = elt(\"span\", \"xxxxxxxxxx\");\r\n    var pre = elt(\"pre\", [anchor]);\r\n    removeChildrenAndAdd(display.measure, pre);\r\n    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\r\n    if (width > 2) display.cachedCharWidth = width;\r\n    return width || 10;\r\n  }\r\n\r\n  // OPERATIONS\r\n\r\n  // Operations are used to wrap a series of changes to the editor\r\n  // state in such a way that each change won't have to update the\r\n  // cursor and display (which would be awkward, slow, and\r\n  // error-prone). Instead, display updates are batched and then all\r\n  // combined and executed at once.\r\n\r\n  var operationGroup = null;\r\n\r\n  var nextOpId = 0;\r\n  // Start a new operation.\r\n  function startOperation(cm) {\r\n    cm.curOp = {\r\n      cm: cm,\r\n      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\r\n      startHeight: cm.doc.height, // Used to detect need to update scrollbar\r\n      forceUpdate: false,      // Used to force a redraw\r\n      updateInput: null,       // Whether to reset the input textarea\r\n      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\r\n      changeObjs: null,        // Accumulated changes, for firing change events\r\n      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\r\n      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\r\n      selectionChanged: false, // Whether the selection needs to be redrawn\r\n      updateMaxLine: false,    // Set when the widest line needs to be determined anew\r\n      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\r\n      scrollToPos: null,       // Used to scroll to a specific position\r\n      id: ++nextOpId           // Unique ID\r\n    };\r\n    if (operationGroup) {\r\n      operationGroup.ops.push(cm.curOp);\r\n    } else {\r\n      cm.curOp.ownsGroup = operationGroup = {\r\n        ops: [cm.curOp],\r\n        delayedCallbacks: []\r\n      };\r\n    }\r\n  }\r\n\r\n  function fireCallbacksForOps(group) {\r\n    // Calls delayed callbacks and cursorActivity handlers until no\r\n    // new ones appear\r\n    var callbacks = group.delayedCallbacks, i = 0;\r\n    do {\r\n      for (; i < callbacks.length; i++)\r\n        callbacks[i]();\r\n      for (var j = 0; j < group.ops.length; j++) {\r\n        var op = group.ops[j];\r\n        if (op.cursorActivityHandlers)\r\n          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\r\n            op.cursorActivityHandlers[op.cursorActivityCalled++](op.cm);\r\n      }\r\n    } while (i < callbacks.length);\r\n  }\r\n\r\n  // Finish an operation, updating the display and signalling delayed events\r\n  function endOperation(cm) {\r\n    var op = cm.curOp, group = op.ownsGroup;\r\n    if (!group) return;\r\n\r\n    try { fireCallbacksForOps(group); }\r\n    finally {\r\n      operationGroup = null;\r\n      for (var i = 0; i < group.ops.length; i++)\r\n        group.ops[i].cm.curOp = null;\r\n      endOperations(group);\r\n    }\r\n  }\r\n\r\n  // The DOM updates done when an operation finishes are batched so\r\n  // that the minimum number of relayouts are required.\r\n  function endOperations(group) {\r\n    var ops = group.ops;\r\n    for (var i = 0; i < ops.length; i++) // Read DOM\r\n      endOperation_R1(ops[i]);\r\n    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\r\n      endOperation_W1(ops[i]);\r\n    for (var i = 0; i < ops.length; i++) // Read DOM\r\n      endOperation_R2(ops[i]);\r\n    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\r\n      endOperation_W2(ops[i]);\r\n    for (var i = 0; i < ops.length; i++) // Read DOM\r\n      endOperation_finish(ops[i]);\r\n  }\r\n\r\n  function endOperation_R1(op) {\r\n    var cm = op.cm, display = cm.display;\r\n    maybeClipScrollbars(cm);\r\n    if (op.updateMaxLine) findMaxLine(cm);\r\n\r\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\r\n      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\r\n                         op.scrollToPos.to.line >= display.viewTo) ||\r\n      display.maxLineChanged && cm.options.lineWrapping;\r\n    op.update = op.mustUpdate &&\r\n      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\r\n  }\r\n\r\n  function endOperation_W1(op) {\r\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\r\n  }\r\n\r\n  function endOperation_R2(op) {\r\n    var cm = op.cm, display = cm.display;\r\n    if (op.updatedDisplay) updateHeightsInViewport(cm);\r\n\r\n    op.barMeasure = measureForScrollbars(cm);\r\n\r\n    // If the max line changed since it was last measured, measure it,\r\n    // and ensure the document's width matches it.\r\n    // updateDisplay_W2 will use these properties to do the actual resizing\r\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\r\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\r\n      cm.display.sizerWidth = op.adjustWidthTo;\r\n      op.barMeasure.scrollWidth =\r\n        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\r\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\r\n    }\r\n\r\n    if (op.updatedDisplay || op.selectionChanged)\r\n      op.preparedSelection = display.input.prepareSelection();\r\n  }\r\n\r\n  function endOperation_W2(op) {\r\n    var cm = op.cm;\r\n\r\n    if (op.adjustWidthTo != null) {\r\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\r\n      if (op.maxScrollLeft < cm.doc.scrollLeft)\r\n        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\r\n      cm.display.maxLineChanged = false;\r\n    }\r\n\r\n    if (op.preparedSelection)\r\n      cm.display.input.showSelection(op.preparedSelection);\r\n    if (op.updatedDisplay)\r\n      setDocumentHeight(cm, op.barMeasure);\r\n    if (op.updatedDisplay || op.startHeight != cm.doc.height)\r\n      updateScrollbars(cm, op.barMeasure);\r\n\r\n    if (op.selectionChanged) restartBlink(cm);\r\n\r\n    if (cm.state.focused && op.updateInput)\r\n      cm.display.input.reset(op.typing);\r\n  }\r\n\r\n  function endOperation_finish(op) {\r\n    var cm = op.cm, display = cm.display, doc = cm.doc;\r\n\r\n    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);\r\n\r\n    // Abort mouse wheel delta measurement, when scrolling explicitly\r\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\r\n      display.wheelStartX = display.wheelStartY = null;\r\n\r\n    // Propagate the scroll position to the actual DOM scroller\r\n    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {\r\n      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));\r\n      display.scrollbars.setScrollTop(doc.scrollTop);\r\n      display.scroller.scrollTop = doc.scrollTop;\r\n    }\r\n    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {\r\n      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - displayWidth(cm), op.scrollLeft));\r\n      display.scrollbars.setScrollLeft(doc.scrollLeft);\r\n      display.scroller.scrollLeft = doc.scrollLeft;\r\n      alignHorizontally(cm);\r\n    }\r\n    // If we need to scroll a specific position into view, do so.\r\n    if (op.scrollToPos) {\r\n      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\r\n                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\r\n      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);\r\n    }\r\n\r\n    // Fire events for markers that are hidden/unidden by editing or\r\n    // undoing\r\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\r\n    if (hidden) for (var i = 0; i < hidden.length; ++i)\r\n      if (!hidden[i].lines.length) signal(hidden[i], \"hide\");\r\n    if (unhidden) for (var i = 0; i < unhidden.length; ++i)\r\n      if (unhidden[i].lines.length) signal(unhidden[i], \"unhide\");\r\n\r\n    if (display.wrapper.offsetHeight)\r\n      doc.scrollTop = cm.display.scroller.scrollTop;\r\n\r\n    // Fire change events, and delayed event handlers\r\n    if (op.changeObjs)\r\n      signal(cm, \"changes\", cm, op.changeObjs);\r\n    if (op.update)\r\n      op.update.finish();\r\n  }\r\n\r\n  // Run the given function in an operation\r\n  function runInOp(cm, f) {\r\n    if (cm.curOp) return f();\r\n    startOperation(cm);\r\n    try { return f(); }\r\n    finally { endOperation(cm); }\r\n  }\r\n  // Wraps a function in an operation. Returns the wrapped function.\r\n  function operation(cm, f) {\r\n    return function() {\r\n      if (cm.curOp) return f.apply(cm, arguments);\r\n      startOperation(cm);\r\n      try { return f.apply(cm, arguments); }\r\n      finally { endOperation(cm); }\r\n    };\r\n  }\r\n  // Used to add methods to editor and doc instances, wrapping them in\r\n  // operations.\r\n  function methodOp(f) {\r\n    return function() {\r\n      if (this.curOp) return f.apply(this, arguments);\r\n      startOperation(this);\r\n      try { return f.apply(this, arguments); }\r\n      finally { endOperation(this); }\r\n    };\r\n  }\r\n  function docMethodOp(f) {\r\n    return function() {\r\n      var cm = this.cm;\r\n      if (!cm || cm.curOp) return f.apply(this, arguments);\r\n      startOperation(cm);\r\n      try { return f.apply(this, arguments); }\r\n      finally { endOperation(cm); }\r\n    };\r\n  }\r\n\r\n  // VIEW TRACKING\r\n\r\n  // These objects are used to represent the visible (currently drawn)\r\n  // part of the document. A LineView may correspond to multiple\r\n  // logical lines, if those are connected by collapsed ranges.\r\n  function LineView(doc, line, lineN) {\r\n    // The starting line\r\n    this.line = line;\r\n    // Continuing lines, if any\r\n    this.rest = visualLineContinued(line);\r\n    // Number of logical lines in this visual line\r\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\r\n    this.node = this.text = null;\r\n    this.hidden = lineIsHidden(doc, line);\r\n  }\r\n\r\n  // Create a range of LineView objects for the given lines.\r\n  function buildViewArray(cm, from, to) {\r\n    var array = [], nextPos;\r\n    for (var pos = from; pos < to; pos = nextPos) {\r\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\r\n      nextPos = pos + view.size;\r\n      array.push(view);\r\n    }\r\n    return array;\r\n  }\r\n\r\n  // Updates the display.view data structure for a given change to the\r\n  // document. From and to are in pre-change coordinates. Lendiff is\r\n  // the amount of lines added or subtracted by the change. This is\r\n  // used for changes that span multiple lines, or change the way\r\n  // lines are divided into visual lines. regLineChange (below)\r\n  // registers single-line changes.\r\n  function regChange(cm, from, to, lendiff) {\r\n    if (from == null) from = cm.doc.first;\r\n    if (to == null) to = cm.doc.first + cm.doc.size;\r\n    if (!lendiff) lendiff = 0;\r\n\r\n    var display = cm.display;\r\n    if (lendiff && to < display.viewTo &&\r\n        (display.updateLineNumbers == null || display.updateLineNumbers > from))\r\n      display.updateLineNumbers = from;\r\n\r\n    cm.curOp.viewChanged = true;\r\n\r\n    if (from >= display.viewTo) { // Change after\r\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\r\n        resetView(cm);\r\n    } else if (to <= display.viewFrom) { // Change before\r\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\r\n        resetView(cm);\r\n      } else {\r\n        display.viewFrom += lendiff;\r\n        display.viewTo += lendiff;\r\n      }\r\n    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\r\n      resetView(cm);\r\n    } else if (from <= display.viewFrom) { // Top overlap\r\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\r\n      if (cut) {\r\n        display.view = display.view.slice(cut.index);\r\n        display.viewFrom = cut.lineN;\r\n        display.viewTo += lendiff;\r\n      } else {\r\n        resetView(cm);\r\n      }\r\n    } else if (to >= display.viewTo) { // Bottom overlap\r\n      var cut = viewCuttingPoint(cm, from, from, -1);\r\n      if (cut) {\r\n        display.view = display.view.slice(0, cut.index);\r\n        display.viewTo = cut.lineN;\r\n      } else {\r\n        resetView(cm);\r\n      }\r\n    } else { // Gap in the middle\r\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\r\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\r\n      if (cutTop && cutBot) {\r\n        display.view = display.view.slice(0, cutTop.index)\r\n          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\r\n          .concat(display.view.slice(cutBot.index));\r\n        display.viewTo += lendiff;\r\n      } else {\r\n        resetView(cm);\r\n      }\r\n    }\r\n\r\n    var ext = display.externalMeasured;\r\n    if (ext) {\r\n      if (to < ext.lineN)\r\n        ext.lineN += lendiff;\r\n      else if (from < ext.lineN + ext.size)\r\n        display.externalMeasured = null;\r\n    }\r\n  }\r\n\r\n  // Register a change to a single line. Type must be one of \"text\",\r\n  // \"gutter\", \"class\", \"widget\"\r\n  function regLineChange(cm, line, type) {\r\n    cm.curOp.viewChanged = true;\r\n    var display = cm.display, ext = cm.display.externalMeasured;\r\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\r\n      display.externalMeasured = null;\r\n\r\n    if (line < display.viewFrom || line >= display.viewTo) return;\r\n    var lineView = display.view[findViewIndex(cm, line)];\r\n    if (lineView.node == null) return;\r\n    var arr = lineView.changes || (lineView.changes = []);\r\n    if (indexOf(arr, type) == -1) arr.push(type);\r\n  }\r\n\r\n  // Clear the view.\r\n  function resetView(cm) {\r\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\r\n    cm.display.view = [];\r\n    cm.display.viewOffset = 0;\r\n  }\r\n\r\n  // Find the view element corresponding to a given line. Return null\r\n  // when the line isn't visible.\r\n  function findViewIndex(cm, n) {\r\n    if (n >= cm.display.viewTo) return null;\r\n    n -= cm.display.viewFrom;\r\n    if (n < 0) return null;\r\n    var view = cm.display.view;\r\n    for (var i = 0; i < view.length; i++) {\r\n      n -= view[i].size;\r\n      if (n < 0) return i;\r\n    }\r\n  }\r\n\r\n  function viewCuttingPoint(cm, oldN, newN, dir) {\r\n    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\r\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\r\n      return {index: index, lineN: newN};\r\n    for (var i = 0, n = cm.display.viewFrom; i < index; i++)\r\n      n += view[i].size;\r\n    if (n != oldN) {\r\n      if (dir > 0) {\r\n        if (index == view.length - 1) return null;\r\n        diff = (n + view[index].size) - oldN;\r\n        index++;\r\n      } else {\r\n        diff = n - oldN;\r\n      }\r\n      oldN += diff; newN += diff;\r\n    }\r\n    while (visualLineNo(cm.doc, newN) != newN) {\r\n      if (index == (dir < 0 ? 0 : view.length - 1)) return null;\r\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\r\n      index += dir;\r\n    }\r\n    return {index: index, lineN: newN};\r\n  }\r\n\r\n  // Force the view to cover a given range, adding empty view element\r\n  // or clipping off existing ones as needed.\r\n  function adjustView(cm, from, to) {\r\n    var display = cm.display, view = display.view;\r\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\r\n      display.view = buildViewArray(cm, from, to);\r\n      display.viewFrom = from;\r\n    } else {\r\n      if (display.viewFrom > from)\r\n        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\r\n      else if (display.viewFrom < from)\r\n        display.view = display.view.slice(findViewIndex(cm, from));\r\n      display.viewFrom = from;\r\n      if (display.viewTo < to)\r\n        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\r\n      else if (display.viewTo > to)\r\n        display.view = display.view.slice(0, findViewIndex(cm, to));\r\n    }\r\n    display.viewTo = to;\r\n  }\r\n\r\n  // Count the number of lines in the view whose DOM representation is\r\n  // out of date (or nonexistent).\r\n  function countDirtyView(cm) {\r\n    var view = cm.display.view, dirty = 0;\r\n    for (var i = 0; i < view.length; i++) {\r\n      var lineView = view[i];\r\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;\r\n    }\r\n    return dirty;\r\n  }\r\n\r\n  // EVENT HANDLERS\r\n\r\n  // Attach the necessary event handlers when initializing the editor\r\n  function registerEventHandlers(cm) {\r\n    var d = cm.display;\r\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\r\n    // Older IE's will not fire a second mousedown for a double click\r\n    if (ie && ie_version < 11)\r\n      on(d.scroller, \"dblclick\", operation(cm, function(e) {\r\n        if (signalDOMEvent(cm, e)) return;\r\n        var pos = posFromMouse(cm, e);\r\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;\r\n        e_preventDefault(e);\r\n        var word = cm.findWordAt(pos);\r\n        extendSelection(cm.doc, word.anchor, word.head);\r\n      }));\r\n    else\r\n      on(d.scroller, \"dblclick\", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });\r\n    // Some browsers fire contextmenu *after* opening the menu, at\r\n    // which point we can't mess with it anymore. Context menu is\r\n    // handled in onMouseDown for these browsers.\r\n    if (!captureRightClick) on(d.scroller, \"contextmenu\", function(e) {onContextMenu(cm, e);});\r\n\r\n    // Used to suppress mouse event handling when a touch happens\r\n    var touchFinished, prevTouch = {end: 0};\r\n    function finishTouch() {\r\n      if (d.activeTouch) {\r\n        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);\r\n        prevTouch = d.activeTouch;\r\n        prevTouch.end = +new Date;\r\n      }\r\n    };\r\n    function isMouseLikeTouchEvent(e) {\r\n      if (e.touches.length != 1) return false;\r\n      var touch = e.touches[0];\r\n      return touch.radiusX <= 1 && touch.radiusY <= 1;\r\n    }\r\n    function farAway(touch, other) {\r\n      if (other.left == null) return true;\r\n      var dx = other.left - touch.left, dy = other.top - touch.top;\r\n      return dx * dx + dy * dy > 20 * 20;\r\n    }\r\n    on(d.scroller, \"touchstart\", function(e) {\r\n      if (!isMouseLikeTouchEvent(e)) {\r\n        clearTimeout(touchFinished);\r\n        var now = +new Date;\r\n        d.activeTouch = {start: now, moved: false,\r\n                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\r\n        if (e.touches.length == 1) {\r\n          d.activeTouch.left = e.touches[0].pageX;\r\n          d.activeTouch.top = e.touches[0].pageY;\r\n        }\r\n      }\r\n    });\r\n    on(d.scroller, \"touchmove\", function() {\r\n      if (d.activeTouch) d.activeTouch.moved = true;\r\n    });\r\n    on(d.scroller, \"touchend\", function(e) {\r\n      var touch = d.activeTouch;\r\n      if (touch && !eventInWidget(d, e) && touch.left != null &&\r\n          !touch.moved && new Date - touch.start < 300) {\r\n        var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\r\n        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\r\n          range = new Range(pos, pos);\r\n        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\r\n          range = cm.findWordAt(pos);\r\n        else // Triple tap\r\n          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));\r\n        cm.setSelection(range.anchor, range.head);\r\n        cm.focus();\r\n        e_preventDefault(e);\r\n      }\r\n      finishTouch();\r\n    });\r\n    on(d.scroller, \"touchcancel\", finishTouch);\r\n\r\n    // Sync scrolling between fake scrollbars and real scrollable\r\n    // area, ensure viewport is updated when scrolling.\r\n    on(d.scroller, \"scroll\", function() {\r\n      if (d.scroller.clientHeight) {\r\n        setScrollTop(cm, d.scroller.scrollTop);\r\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\r\n        signal(cm, \"scroll\", cm);\r\n      }\r\n    });\r\n\r\n    // Listen to wheel events in order to try and update the viewport on time.\r\n    on(d.scroller, \"mousewheel\", function(e){onScrollWheel(cm, e);});\r\n    on(d.scroller, \"DOMMouseScroll\", function(e){onScrollWheel(cm, e);});\r\n\r\n    // Prevent wrapper from ever scrolling\r\n    on(d.wrapper, \"scroll\", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\r\n\r\n    function drag_(e) {\r\n      if (!signalDOMEvent(cm, e)) e_stop(e);\r\n    }\r\n    if (cm.options.dragDrop) {\r\n      on(d.scroller, \"dragstart\", function(e){onDragStart(cm, e);});\r\n      on(d.scroller, \"dragenter\", drag_);\r\n      on(d.scroller, \"dragover\", drag_);\r\n      on(d.scroller, \"drop\", operation(cm, onDrop));\r\n    }\r\n\r\n    var inp = d.input.getField();\r\n    on(inp, \"keyup\", function(e) { onKeyUp.call(cm, e); });\r\n    on(inp, \"keydown\", operation(cm, onKeyDown));\r\n    on(inp, \"keypress\", operation(cm, onKeyPress));\r\n    on(inp, \"focus\", bind(onFocus, cm));\r\n    on(inp, \"blur\", bind(onBlur, cm));\r\n  }\r\n\r\n  // Called when the window resizes\r\n  function onResize(cm) {\r\n    var d = cm.display;\r\n    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\r\n      return;\r\n    // Might be a text scaling operation, clear size caches.\r\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\r\n    d.scrollbarsClipped = false;\r\n    cm.setSize();\r\n  }\r\n\r\n  // MOUSE EVENTS\r\n\r\n  // Return true when the given mouse event happened in a widget\r\n  function eventInWidget(display, e) {\r\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\r\n      if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\r\n          (n.parentNode == display.sizer && n != display.mover))\r\n        return true;\r\n    }\r\n  }\r\n\r\n  // Given a mouse event, find the corresponding position. If liberal\r\n  // is false, it checks whether a gutter or scrollbar was clicked,\r\n  // and returns null if it was. forRect is used by rectangular\r\n  // selections, and tries to estimate a character position even for\r\n  // coordinates beyond the right of the text.\r\n  function posFromMouse(cm, e, liberal, forRect) {\r\n    var display = cm.display;\r\n    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") return null;\r\n\r\n    var x, y, space = display.lineSpace.getBoundingClientRect();\r\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\r\n    try { x = e.clientX - space.left; y = e.clientY - space.top; }\r\n    catch (e) { return null; }\r\n    var coords = coordsChar(cm, x, y), line;\r\n    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\r\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\r\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\r\n    }\r\n    return coords;\r\n  }\r\n\r\n  // A mouse down can be a single click, double click, triple click,\r\n  // start of selection drag, start of text drag, new cursor\r\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\r\n  // middle-click-paste. Or it might be a click on something we should\r\n  // not interfere with, such as a scrollbar or widget.\r\n  function onMouseDown(e) {\r\n    var cm = this, display = cm.display;\r\n    if (display.activeTouch && display.input.supportsTouch() || signalDOMEvent(cm, e)) return;\r\n    display.shift = e.shiftKey;\r\n\r\n    if (eventInWidget(display, e)) {\r\n      if (!webkit) {\r\n        // Briefly turn off draggability, to allow widgets to do\r\n        // normal dragging things.\r\n        display.scroller.draggable = false;\r\n        setTimeout(function(){display.scroller.draggable = true;}, 100);\r\n      }\r\n      return;\r\n    }\r\n    if (clickInGutter(cm, e)) return;\r\n    var start = posFromMouse(cm, e);\r\n    window.focus();\r\n\r\n    switch (e_button(e)) {\r\n    case 1:\r\n      if (start)\r\n        leftButtonDown(cm, e, start);\r\n      else if (e_target(e) == display.scroller)\r\n        e_preventDefault(e);\r\n      break;\r\n    case 2:\r\n      if (webkit) cm.state.lastMiddleDown = +new Date;\r\n      if (start) extendSelection(cm.doc, start);\r\n      setTimeout(function() {display.input.focus();}, 20);\r\n      e_preventDefault(e);\r\n      break;\r\n    case 3:\r\n      if (captureRightClick) onContextMenu(cm, e);\r\n      else delayBlurEvent(cm);\r\n      break;\r\n    }\r\n  }\r\n\r\n  var lastClick, lastDoubleClick;\r\n  function leftButtonDown(cm, e, start) {\r\n    if (ie) setTimeout(bind(ensureFocus, cm), 0);\r\n    else ensureFocus(cm);\r\n\r\n    var now = +new Date, type;\r\n    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\r\n      type = \"triple\";\r\n    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\r\n      type = \"double\";\r\n      lastDoubleClick = {time: now, pos: start};\r\n    } else {\r\n      type = \"single\";\r\n      lastClick = {time: now, pos: start};\r\n    }\r\n\r\n    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;\r\n    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) &&\r\n        type == \"single\" && (contained = sel.contains(start)) > -1 &&\r\n        !sel.ranges[contained].empty())\r\n      leftButtonStartDrag(cm, e, start, modifier);\r\n    else\r\n      leftButtonSelect(cm, e, start, type, modifier);\r\n  }\r\n\r\n  // Start a text drag. When it ends, see if any dragging actually\r\n  // happen, and treat as a click if it didn't.\r\n  function leftButtonStartDrag(cm, e, start, modifier) {\r\n    var display = cm.display;\r\n    var dragEnd = operation(cm, function(e2) {\r\n      if (webkit) display.scroller.draggable = false;\r\n      cm.state.draggingText = false;\r\n      off(document, \"mouseup\", dragEnd);\r\n      off(display.scroller, \"drop\", dragEnd);\r\n      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\r\n        e_preventDefault(e2);\r\n        if (!modifier)\r\n          extendSelection(cm.doc, start);\r\n        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\r\n        if (webkit || ie && ie_version == 9)\r\n          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);\r\n        else\r\n          display.input.focus();\r\n      }\r\n    });\r\n    // Let the drag handler handle this.\r\n    if (webkit) display.scroller.draggable = true;\r\n    cm.state.draggingText = dragEnd;\r\n    // IE's approach to draggable\r\n    if (display.scroller.dragDrop) display.scroller.dragDrop();\r\n    on(document, \"mouseup\", dragEnd);\r\n    on(display.scroller, \"drop\", dragEnd);\r\n  }\r\n\r\n  // Normal selection, as opposed to text dragging.\r\n  function leftButtonSelect(cm, e, start, type, addNew) {\r\n    var display = cm.display, doc = cm.doc;\r\n    e_preventDefault(e);\r\n\r\n    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\r\n    if (addNew && !e.shiftKey) {\r\n      ourIndex = doc.sel.contains(start);\r\n      if (ourIndex > -1)\r\n        ourRange = ranges[ourIndex];\r\n      else\r\n        ourRange = new Range(start, start);\r\n    } else {\r\n      ourRange = doc.sel.primary();\r\n      ourIndex = doc.sel.primIndex;\r\n    }\r\n\r\n    if (e.altKey) {\r\n      type = \"rect\";\r\n      if (!addNew) ourRange = new Range(start, start);\r\n      start = posFromMouse(cm, e, true, true);\r\n      ourIndex = -1;\r\n    } else if (type == \"double\") {\r\n      var word = cm.findWordAt(start);\r\n      if (cm.display.shift || doc.extend)\r\n        ourRange = extendRange(doc, ourRange, word.anchor, word.head);\r\n      else\r\n        ourRange = word;\r\n    } else if (type == \"triple\") {\r\n      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));\r\n      if (cm.display.shift || doc.extend)\r\n        ourRange = extendRange(doc, ourRange, line.anchor, line.head);\r\n      else\r\n        ourRange = line;\r\n    } else {\r\n      ourRange = extendRange(doc, ourRange, start);\r\n    }\r\n\r\n    if (!addNew) {\r\n      ourIndex = 0;\r\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\r\n      startSel = doc.sel;\r\n    } else if (ourIndex == -1) {\r\n      ourIndex = ranges.length;\r\n      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\r\n                   {scroll: false, origin: \"*mouse\"});\r\n    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == \"single\" && !e.shiftKey) {\r\n      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0));\r\n      startSel = doc.sel;\r\n    } else {\r\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\r\n    }\r\n\r\n    var lastPos = start;\r\n    function extendTo(pos) {\r\n      if (cmp(lastPos, pos) == 0) return;\r\n      lastPos = pos;\r\n\r\n      if (type == \"rect\") {\r\n        var ranges = [], tabSize = cm.options.tabSize;\r\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\r\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\r\n        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\r\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\r\n             line <= end; line++) {\r\n          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\r\n          if (left == right)\r\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));\r\n          else if (text.length > leftPos)\r\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));\r\n        }\r\n        if (!ranges.length) ranges.push(new Range(start, start));\r\n        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\r\n                     {origin: \"*mouse\", scroll: false});\r\n        cm.scrollIntoView(pos);\r\n      } else {\r\n        var oldRange = ourRange;\r\n        var anchor = oldRange.anchor, head = pos;\r\n        if (type != \"single\") {\r\n          if (type == \"double\")\r\n            var range = cm.findWordAt(pos);\r\n          else\r\n            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));\r\n          if (cmp(range.anchor, anchor) > 0) {\r\n            head = range.head;\r\n            anchor = minPos(oldRange.from(), range.anchor);\r\n          } else {\r\n            head = range.anchor;\r\n            anchor = maxPos(oldRange.to(), range.head);\r\n          }\r\n        }\r\n        var ranges = startSel.ranges.slice(0);\r\n        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);\r\n        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);\r\n      }\r\n    }\r\n\r\n    var editorSize = display.wrapper.getBoundingClientRect();\r\n    // Used to ensure timeout re-tries don't fire when another extend\r\n    // happened in the meantime (clearTimeout isn't reliable -- at\r\n    // least on Chrome, the timeouts still happen even when cleared,\r\n    // if the clear happens after their scheduled firing time).\r\n    var counter = 0;\r\n\r\n    function extend(e) {\r\n      var curCount = ++counter;\r\n      var cur = posFromMouse(cm, e, true, type == \"rect\");\r\n      if (!cur) return;\r\n      if (cmp(cur, lastPos) != 0) {\r\n        ensureFocus(cm);\r\n        extendTo(cur);\r\n        var visible = visibleLines(display, doc);\r\n        if (cur.line >= visible.to || cur.line < visible.from)\r\n          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\r\n      } else {\r\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\r\n        if (outside) setTimeout(operation(cm, function() {\r\n          if (counter != curCount) return;\r\n          display.scroller.scrollTop += outside;\r\n          extend(e);\r\n        }), 50);\r\n      }\r\n    }\r\n\r\n    function done(e) {\r\n      counter = Infinity;\r\n      e_preventDefault(e);\r\n      display.input.focus();\r\n      off(document, \"mousemove\", move);\r\n      off(document, \"mouseup\", up);\r\n      doc.history.lastSelOrigin = null;\r\n    }\r\n\r\n    var move = operation(cm, function(e) {\r\n      if (!e_button(e)) done(e);\r\n      else extend(e);\r\n    });\r\n    var up = operation(cm, done);\r\n    on(document, \"mousemove\", move);\r\n    on(document, \"mouseup\", up);\r\n  }\r\n\r\n  // Determines whether an event happened in the gutter, and fires the\r\n  // handlers for the corresponding event.\r\n  function gutterEvent(cm, e, type, prevent, signalfn) {\r\n    try { var mX = e.clientX, mY = e.clientY; }\r\n    catch(e) { return false; }\r\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;\r\n    if (prevent) e_preventDefault(e);\r\n\r\n    var display = cm.display;\r\n    var lineBox = display.lineDiv.getBoundingClientRect();\r\n\r\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);\r\n    mY -= lineBox.top - display.viewOffset;\r\n\r\n    for (var i = 0; i < cm.options.gutters.length; ++i) {\r\n      var g = display.gutters.childNodes[i];\r\n      if (g && g.getBoundingClientRect().right >= mX) {\r\n        var line = lineAtHeight(cm.doc, mY);\r\n        var gutter = cm.options.gutters[i];\r\n        signalfn(cm, type, cm, line, gutter, e);\r\n        return e_defaultPrevented(e);\r\n      }\r\n    }\r\n  }\r\n\r\n  function clickInGutter(cm, e) {\r\n    return gutterEvent(cm, e, \"gutterClick\", true, signalLater);\r\n  }\r\n\r\n  // Kludge to work around strange IE behavior where it'll sometimes\r\n  // re-fire a series of drag-related events right after the drop (#1551)\r\n  var lastDrop = 0;\r\n\r\n  function onDrop(e) {\r\n    var cm = this;\r\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\r\n      return;\r\n    e_preventDefault(e);\r\n    if (ie) lastDrop = +new Date;\r\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\r\n    if (!pos || isReadOnly(cm)) return;\r\n    // Might be a file drop, in which case we simply extract the text\r\n    // and insert it.\r\n    if (files && files.length && window.FileReader && window.File) {\r\n      var n = files.length, text = Array(n), read = 0;\r\n      var loadFile = function(file, i) {\r\n        var reader = new FileReader;\r\n        reader.onload = operation(cm, function() {\r\n          text[i] = reader.result;\r\n          if (++read == n) {\r\n            pos = clipPos(cm.doc, pos);\r\n            var change = {from: pos, to: pos, text: splitLines(text.join(\"\\n\")), origin: \"paste\"};\r\n            makeChange(cm.doc, change);\r\n            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\r\n          }\r\n        });\r\n        reader.readAsText(file);\r\n      };\r\n      for (var i = 0; i < n; ++i) loadFile(files[i], i);\r\n    } else { // Normal drop\r\n      // Don't do a replace if the drop happened inside of the selected text.\r\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\r\n        cm.state.draggingText(e);\r\n        // Ensure the editor is re-focused\r\n        setTimeout(function() {cm.display.input.focus();}, 20);\r\n        return;\r\n      }\r\n      try {\r\n        var text = e.dataTransfer.getData(\"Text\");\r\n        if (text) {\r\n          if (cm.state.draggingText && !(mac ? e.metaKey : e.ctrlKey))\r\n            var selected = cm.listSelections();\r\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\r\n          if (selected) for (var i = 0; i < selected.length; ++i)\r\n            replaceRange(cm.doc, \"\", selected[i].anchor, selected[i].head, \"drag\");\r\n          cm.replaceSelection(text, \"around\", \"paste\");\r\n          cm.display.input.focus();\r\n        }\r\n      }\r\n      catch(e){}\r\n    }\r\n  }\r\n\r\n  function onDragStart(cm, e) {\r\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }\r\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;\r\n\r\n    e.dataTransfer.setData(\"Text\", cm.getSelection());\r\n\r\n    // Use dummy image instead of default browsers image.\r\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\r\n    if (e.dataTransfer.setDragImage && !safari) {\r\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\r\n      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\r\n      if (presto) {\r\n        img.width = img.height = 1;\r\n        cm.display.wrapper.appendChild(img);\r\n        // Force a relayout, or Opera won't use our image for some obscure reason\r\n        img._top = img.offsetTop;\r\n      }\r\n      e.dataTransfer.setDragImage(img, 0, 0);\r\n      if (presto) img.parentNode.removeChild(img);\r\n    }\r\n  }\r\n\r\n  // SCROLL EVENTS\r\n\r\n  // Sync the scrollable area and scrollbars, ensure the viewport\r\n  // covers the visible area.\r\n  function setScrollTop(cm, val) {\r\n    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\r\n    cm.doc.scrollTop = val;\r\n    if (!gecko) updateDisplaySimple(cm, {top: val});\r\n    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\r\n    cm.display.scrollbars.setScrollTop(val);\r\n    if (gecko) updateDisplaySimple(cm);\r\n    startWorker(cm, 100);\r\n  }\r\n  // Sync scroller and scrollbar, ensure the gutter elements are\r\n  // aligned.\r\n  function setScrollLeft(cm, val, isScroller) {\r\n    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\r\n    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\r\n    cm.doc.scrollLeft = val;\r\n    alignHorizontally(cm);\r\n    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\r\n    cm.display.scrollbars.setScrollLeft(val);\r\n  }\r\n\r\n  // Since the delta values reported on mouse wheel events are\r\n  // unstandardized between browsers and even browser versions, and\r\n  // generally horribly unpredictable, this code starts by measuring\r\n  // the scroll effect that the first few mouse wheel events have,\r\n  // and, from that, detects the way it can convert deltas to pixel\r\n  // offsets afterwards.\r\n  //\r\n  // The reason we want to know the amount a wheel event will scroll\r\n  // is that it gives us a chance to update the display before the\r\n  // actual scrolling happens, reducing flickering.\r\n\r\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\r\n  // Fill in a browser-detected starting value on browsers where we\r\n  // know one. These don't have to be accurate -- the result of them\r\n  // being wrong would just be a slight flicker on the first wheel\r\n  // scroll (if it is large enough).\r\n  if (ie) wheelPixelsPerUnit = -.53;\r\n  else if (gecko) wheelPixelsPerUnit = 15;\r\n  else if (chrome) wheelPixelsPerUnit = -.7;\r\n  else if (safari) wheelPixelsPerUnit = -1/3;\r\n\r\n  var wheelEventDelta = function(e) {\r\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\r\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\r\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\r\n    else if (dy == null) dy = e.wheelDelta;\r\n    return {x: dx, y: dy};\r\n  };\r\n  CodeMirror.wheelEventPixels = function(e) {\r\n    var delta = wheelEventDelta(e);\r\n    delta.x *= wheelPixelsPerUnit;\r\n    delta.y *= wheelPixelsPerUnit;\r\n    return delta;\r\n  };\r\n\r\n  function onScrollWheel(cm, e) {\r\n    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\r\n\r\n    var display = cm.display, scroll = display.scroller;\r\n    // Quit if there's nothing to scroll here\r\n    if (!(dx && scroll.scrollWidth > scroll.clientWidth ||\r\n          dy && scroll.scrollHeight > scroll.clientHeight)) return;\r\n\r\n    // Webkit browsers on OS X abort momentum scrolls when the target\r\n    // of the scroll event is removed from the scrollable element.\r\n    // This hack (see related code in patchDisplay) makes sure the\r\n    // element is kept around.\r\n    if (dy && mac && webkit) {\r\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\r\n        for (var i = 0; i < view.length; i++) {\r\n          if (view[i].node == cur) {\r\n            cm.display.currentWheelTarget = cur;\r\n            break outer;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // On some browsers, horizontal scrolling will cause redraws to\r\n    // happen before the gutter has been realigned, causing it to\r\n    // wriggle around in a most unseemly way. When we have an\r\n    // estimated pixels/delta value, we just handle horizontal\r\n    // scrolling entirely here. It'll be slightly off from native, but\r\n    // better than glitching out.\r\n    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\r\n      if (dy)\r\n        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\r\n      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\r\n      e_preventDefault(e);\r\n      display.wheelStartX = null; // Abort measurement, if in progress\r\n      return;\r\n    }\r\n\r\n    // 'Project' the visible viewport to cover the area that is being\r\n    // scrolled into view (if we know enough to estimate it).\r\n    if (dy && wheelPixelsPerUnit != null) {\r\n      var pixels = dy * wheelPixelsPerUnit;\r\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\r\n      if (pixels < 0) top = Math.max(0, top + pixels - 50);\r\n      else bot = Math.min(cm.doc.height, bot + pixels + 50);\r\n      updateDisplaySimple(cm, {top: top, bottom: bot});\r\n    }\r\n\r\n    if (wheelSamples < 20) {\r\n      if (display.wheelStartX == null) {\r\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\r\n        display.wheelDX = dx; display.wheelDY = dy;\r\n        setTimeout(function() {\r\n          if (display.wheelStartX == null) return;\r\n          var movedX = scroll.scrollLeft - display.wheelStartX;\r\n          var movedY = scroll.scrollTop - display.wheelStartY;\r\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\r\n            (movedX && display.wheelDX && movedX / display.wheelDX);\r\n          display.wheelStartX = display.wheelStartY = null;\r\n          if (!sample) return;\r\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\r\n          ++wheelSamples;\r\n        }, 200);\r\n      } else {\r\n        display.wheelDX += dx; display.wheelDY += dy;\r\n      }\r\n    }\r\n  }\r\n\r\n  // KEY EVENTS\r\n\r\n  // Run a handler that was bound to a key.\r\n  function doHandleBinding(cm, bound, dropShift) {\r\n    if (typeof bound == \"string\") {\r\n      bound = commands[bound];\r\n      if (!bound) return false;\r\n    }\r\n    // Ensure previous input has been read, so that the handler sees a\r\n    // consistent view of the document\r\n    cm.display.input.ensurePolled();\r\n    var prevShift = cm.display.shift, done = false;\r\n    try {\r\n      if (isReadOnly(cm)) cm.state.suppressEdits = true;\r\n      if (dropShift) cm.display.shift = false;\r\n      done = bound(cm) != Pass;\r\n    } finally {\r\n      cm.display.shift = prevShift;\r\n      cm.state.suppressEdits = false;\r\n    }\r\n    return done;\r\n  }\r\n\r\n  function lookupKeyForEditor(cm, name, handle) {\r\n    for (var i = 0; i < cm.state.keyMaps.length; i++) {\r\n      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\r\n      if (result) return result;\r\n    }\r\n    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\r\n      || lookupKey(name, cm.options.keyMap, handle, cm);\r\n  }\r\n\r\n  var stopSeq = new Delayed;\r\n  function dispatchKey(cm, name, e, handle) {\r\n    var seq = cm.state.keySeq;\r\n    if (seq) {\r\n      if (isModifierKey(name)) return \"handled\";\r\n      stopSeq.set(50, function() {\r\n        if (cm.state.keySeq == seq) {\r\n          cm.state.keySeq = null;\r\n          cm.display.input.reset();\r\n        }\r\n      });\r\n      name = seq + \" \" + name;\r\n    }\r\n    var result = lookupKeyForEditor(cm, name, handle);\r\n\r\n    if (result == \"multi\")\r\n      cm.state.keySeq = name;\r\n    if (result == \"handled\")\r\n      signalLater(cm, \"keyHandled\", cm, name, e);\r\n\r\n    if (result == \"handled\" || result == \"multi\") {\r\n      e_preventDefault(e);\r\n      restartBlink(cm);\r\n    }\r\n\r\n    if (seq && !result && /\\'$/.test(name)) {\r\n      e_preventDefault(e);\r\n      return true;\r\n    }\r\n    return !!result;\r\n  }\r\n\r\n  // Handle a key from the keydown event.\r\n  function handleKeyBinding(cm, e) {\r\n    var name = keyName(e, true);\r\n    if (!name) return false;\r\n\r\n    if (e.shiftKey && !cm.state.keySeq) {\r\n      // First try to resolve full name (including 'Shift-'). Failing\r\n      // that, see if there is a cursor-motion command (starting with\r\n      // 'go') bound to the keyname without 'Shift-'.\r\n      return dispatchKey(cm, \"Shift-\" + name, e, function(b) {return doHandleBinding(cm, b, true);})\r\n          || dispatchKey(cm, name, e, function(b) {\r\n               if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\r\n                 return doHandleBinding(cm, b);\r\n             });\r\n    } else {\r\n      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });\r\n    }\r\n  }\r\n\r\n  // Handle a key from the keypress event\r\n  function handleCharBinding(cm, e, ch) {\r\n    return dispatchKey(cm, \"'\" + ch + \"'\", e,\r\n                       function(b) { return doHandleBinding(cm, b, true); });\r\n  }\r\n\r\n  var lastStoppedKey = null;\r\n  function onKeyDown(e) {\r\n    var cm = this;\r\n    ensureFocus(cm);\r\n    if (signalDOMEvent(cm, e)) return;\r\n    // IE does strange things with escape.\r\n    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;\r\n    var code = e.keyCode;\r\n    cm.display.shift = code == 16 || e.shiftKey;\r\n    var handled = handleKeyBinding(cm, e);\r\n    if (presto) {\r\n      lastStoppedKey = handled ? code : null;\r\n      // Opera has no cut event... we try to at least catch the key combo\r\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\r\n        cm.replaceSelection(\"\", null, \"cut\");\r\n    }\r\n\r\n    // Turn mouse into crosshair when Alt is held on Mac.\r\n    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\r\n      showCrossHair(cm);\r\n  }\r\n\r\n  function showCrossHair(cm) {\r\n    var lineDiv = cm.display.lineDiv;\r\n    addClass(lineDiv, \"CodeMirror-crosshair\");\r\n\r\n    function up(e) {\r\n      if (e.keyCode == 18 || !e.altKey) {\r\n        rmClass(lineDiv, \"CodeMirror-crosshair\");\r\n        off(document, \"keyup\", up);\r\n        off(document, \"mouseover\", up);\r\n      }\r\n    }\r\n    on(document, \"keyup\", up);\r\n    on(document, \"mouseover\", up);\r\n  }\r\n\r\n  function onKeyUp(e) {\r\n    if (e.keyCode == 16) this.doc.sel.shift = false;\r\n    signalDOMEvent(this, e);\r\n  }\r\n\r\n  function onKeyPress(e) {\r\n    var cm = this;\r\n    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;\r\n    var keyCode = e.keyCode, charCode = e.charCode;\r\n    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\r\n    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;\r\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\r\n    if (handleCharBinding(cm, e, ch)) return;\r\n    cm.display.input.onKeyPress(e);\r\n  }\r\n\r\n  // FOCUS/BLUR EVENTS\r\n\r\n  function delayBlurEvent(cm) {\r\n    cm.state.delayingBlurEvent = true;\r\n    setTimeout(function() {\r\n      if (cm.state.delayingBlurEvent) {\r\n        cm.state.delayingBlurEvent = false;\r\n        onBlur(cm);\r\n      }\r\n    }, 100);\r\n  }\r\n\r\n  function onFocus(cm) {\r\n    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;\r\n\r\n    if (cm.options.readOnly == \"nocursor\") return;\r\n    if (!cm.state.focused) {\r\n      signal(cm, \"focus\", cm);\r\n      cm.state.focused = true;\r\n      addClass(cm.display.wrapper, \"CodeMirror-focused\");\r\n      // This test prevents this from firing when a context\r\n      // menu is closed (since the input reset would kill the\r\n      // select-all detection hack)\r\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\r\n        cm.display.input.reset();\r\n        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730\r\n      }\r\n      cm.display.input.receivedFocus();\r\n    }\r\n    restartBlink(cm);\r\n  }\r\n  function onBlur(cm) {\r\n    if (cm.state.delayingBlurEvent) return;\r\n\r\n    if (cm.state.focused) {\r\n      signal(cm, \"blur\", cm);\r\n      cm.state.focused = false;\r\n      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\r\n    }\r\n    clearInterval(cm.display.blinker);\r\n    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);\r\n  }\r\n\r\n  // CONTEXT MENU HANDLING\r\n\r\n  // To make the context menu work, we need to briefly unhide the\r\n  // textarea (making it as unobtrusive as possible) to let the\r\n  // right-click take effect on it.\r\n  function onContextMenu(cm, e) {\r\n    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;\r\n    cm.display.input.onContextMenu(e);\r\n  }\r\n\r\n  function contextMenuInGutter(cm, e) {\r\n    if (!hasHandler(cm, \"gutterContextMenu\")) return false;\r\n    return gutterEvent(cm, e, \"gutterContextMenu\", false, signal);\r\n  }\r\n\r\n  // UPDATING\r\n\r\n  // Compute the position of the end of a change (its 'to' property\r\n  // refers to the pre-change end).\r\n  var changeEnd = CodeMirror.changeEnd = function(change) {\r\n    if (!change.text) return change.to;\r\n    return Pos(change.from.line + change.text.length - 1,\r\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\r\n  };\r\n\r\n  // Adjust a position to refer to the post-change position of the\r\n  // same text, or the end of the change if the change covers it.\r\n  function adjustForChange(pos, change) {\r\n    if (cmp(pos, change.from) < 0) return pos;\r\n    if (cmp(pos, change.to) <= 0) return changeEnd(change);\r\n\r\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\r\n    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;\r\n    return Pos(line, ch);\r\n  }\r\n\r\n  function computeSelAfterChange(doc, change) {\r\n    var out = [];\r\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\r\n      var range = doc.sel.ranges[i];\r\n      out.push(new Range(adjustForChange(range.anchor, change),\r\n                         adjustForChange(range.head, change)));\r\n    }\r\n    return normalizeSelection(out, doc.sel.primIndex);\r\n  }\r\n\r\n  function offsetPos(pos, old, nw) {\r\n    if (pos.line == old.line)\r\n      return Pos(nw.line, pos.ch - old.ch + nw.ch);\r\n    else\r\n      return Pos(nw.line + (pos.line - old.line), pos.ch);\r\n  }\r\n\r\n  // Used by replaceSelections to allow moving the selection to the\r\n  // start or around the replaced test. Hint may be \"start\" or \"around\".\r\n  function computeReplacedSel(doc, changes, hint) {\r\n    var out = [];\r\n    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\r\n    for (var i = 0; i < changes.length; i++) {\r\n      var change = changes[i];\r\n      var from = offsetPos(change.from, oldPrev, newPrev);\r\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\r\n      oldPrev = change.to;\r\n      newPrev = to;\r\n      if (hint == \"around\") {\r\n        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\r\n        out[i] = new Range(inv ? to : from, inv ? from : to);\r\n      } else {\r\n        out[i] = new Range(from, from);\r\n      }\r\n    }\r\n    return new Selection(out, doc.sel.primIndex);\r\n  }\r\n\r\n  // Allow \"beforeChange\" event handlers to influence a change\r\n  function filterChange(doc, change, update) {\r\n    var obj = {\r\n      canceled: false,\r\n      from: change.from,\r\n      to: change.to,\r\n      text: change.text,\r\n      origin: change.origin,\r\n      cancel: function() { this.canceled = true; }\r\n    };\r\n    if (update) obj.update = function(from, to, text, origin) {\r\n      if (from) this.from = clipPos(doc, from);\r\n      if (to) this.to = clipPos(doc, to);\r\n      if (text) this.text = text;\r\n      if (origin !== undefined) this.origin = origin;\r\n    };\r\n    signal(doc, \"beforeChange\", doc, obj);\r\n    if (doc.cm) signal(doc.cm, \"beforeChange\", doc.cm, obj);\r\n\r\n    if (obj.canceled) return null;\r\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};\r\n  }\r\n\r\n  // Apply a change to a document, and add it to the document's\r\n  // history, and propagating it to all linked documents.\r\n  function makeChange(doc, change, ignoreReadOnly) {\r\n    if (doc.cm) {\r\n      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\r\n      if (doc.cm.state.suppressEdits) return;\r\n    }\r\n\r\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\r\n      change = filterChange(doc, change, true);\r\n      if (!change) return;\r\n    }\r\n\r\n    // Possibly split or suppress the update based on the presence\r\n    // of read-only spans in its range.\r\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\r\n    if (split) {\r\n      for (var i = split.length - 1; i >= 0; --i)\r\n        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text});\r\n    } else {\r\n      makeChangeInner(doc, change);\r\n    }\r\n  }\r\n\r\n  function makeChangeInner(doc, change) {\r\n    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) return;\r\n    var selAfter = computeSelAfterChange(doc, change);\r\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\r\n\r\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\r\n    var rebased = [];\r\n\r\n    linkedDocs(doc, function(doc, sharedHist) {\r\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\r\n        rebaseHist(doc.history, change);\r\n        rebased.push(doc.history);\r\n      }\r\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\r\n    });\r\n  }\r\n\r\n  // Revert a change stored in a document's history.\r\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\r\n    if (doc.cm && doc.cm.state.suppressEdits) return;\r\n\r\n    var hist = doc.history, event, selAfter = doc.sel;\r\n    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\r\n\r\n    // Verify that there is a useable event (so that ctrl-z won't\r\n    // needlessly clear selection events)\r\n    for (var i = 0; i < source.length; i++) {\r\n      event = source[i];\r\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\r\n        break;\r\n    }\r\n    if (i == source.length) return;\r\n    hist.lastOrigin = hist.lastSelOrigin = null;\r\n\r\n    for (;;) {\r\n      event = source.pop();\r\n      if (event.ranges) {\r\n        pushSelectionToHistory(event, dest);\r\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\r\n          setSelection(doc, event, {clearRedo: false});\r\n          return;\r\n        }\r\n        selAfter = event;\r\n      }\r\n      else break;\r\n    }\r\n\r\n    // Build up a reverse change object to add to the opposite history\r\n    // stack (redo when undoing, and vice versa).\r\n    var antiChanges = [];\r\n    pushSelectionToHistory(selAfter, dest);\r\n    dest.push({changes: antiChanges, generation: hist.generation});\r\n    hist.generation = event.generation || ++hist.maxGeneration;\r\n\r\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\r\n\r\n    for (var i = event.changes.length - 1; i >= 0; --i) {\r\n      var change = event.changes[i];\r\n      change.origin = type;\r\n      if (filter && !filterChange(doc, change, false)) {\r\n        source.length = 0;\r\n        return;\r\n      }\r\n\r\n      antiChanges.push(historyChangeFromChange(doc, change));\r\n\r\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\r\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\r\n      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});\r\n      var rebased = [];\r\n\r\n      // Propagate to the linked documents\r\n      linkedDocs(doc, function(doc, sharedHist) {\r\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\r\n          rebaseHist(doc.history, change);\r\n          rebased.push(doc.history);\r\n        }\r\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\r\n      });\r\n    }\r\n  }\r\n\r\n  // Sub-views need their line numbers shifted when text is added\r\n  // above or below them in the parent document.\r\n  function shiftDoc(doc, distance) {\r\n    if (distance == 0) return;\r\n    doc.first += distance;\r\n    doc.sel = new Selection(map(doc.sel.ranges, function(range) {\r\n      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),\r\n                       Pos(range.head.line + distance, range.head.ch));\r\n    }), doc.sel.primIndex);\r\n    if (doc.cm) {\r\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\r\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\r\n        regLineChange(doc.cm, l, \"gutter\");\r\n    }\r\n  }\r\n\r\n  // More lower-level change function, handling only a single document\r\n  // (not linked ones).\r\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\r\n    if (doc.cm && !doc.cm.curOp)\r\n      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\r\n\r\n    if (change.to.line < doc.first) {\r\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\r\n      return;\r\n    }\r\n    if (change.from.line > doc.lastLine()) return;\r\n\r\n    // Clip the change to the size of this doc\r\n    if (change.from.line < doc.first) {\r\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\r\n      shiftDoc(doc, shift);\r\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\r\n                text: [lst(change.text)], origin: change.origin};\r\n    }\r\n    var last = doc.lastLine();\r\n    if (change.to.line > last) {\r\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\r\n                text: [change.text[0]], origin: change.origin};\r\n    }\r\n\r\n    change.removed = getBetween(doc, change.from, change.to);\r\n\r\n    if (!selAfter) selAfter = computeSelAfterChange(doc, change);\r\n    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);\r\n    else updateDoc(doc, change, spans);\r\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\r\n  }\r\n\r\n  // Handle the interaction of a change to a document with the editor\r\n  // that this document is part of.\r\n  function makeChangeSingleDocInEditor(cm, change, spans) {\r\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\r\n\r\n    var recomputeMaxLength = false, checkWidthStart = from.line;\r\n    if (!cm.options.lineWrapping) {\r\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\r\n      doc.iter(checkWidthStart, to.line + 1, function(line) {\r\n        if (line == display.maxLine) {\r\n          recomputeMaxLength = true;\r\n          return true;\r\n        }\r\n      });\r\n    }\r\n\r\n    if (doc.sel.contains(change.from, change.to) > -1)\r\n      signalCursorActivity(cm);\r\n\r\n    updateDoc(doc, change, spans, estimateHeight(cm));\r\n\r\n    if (!cm.options.lineWrapping) {\r\n      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\r\n        var len = lineLength(line);\r\n        if (len > display.maxLineLength) {\r\n          display.maxLine = line;\r\n          display.maxLineLength = len;\r\n          display.maxLineChanged = true;\r\n          recomputeMaxLength = false;\r\n        }\r\n      });\r\n      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\r\n    }\r\n\r\n    // Adjust frontier, schedule worker\r\n    doc.frontier = Math.min(doc.frontier, from.line);\r\n    startWorker(cm, 400);\r\n\r\n    var lendiff = change.text.length - (to.line - from.line) - 1;\r\n    // Remember that these lines changed, for updating the display\r\n    if (change.full)\r\n      regChange(cm);\r\n    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\r\n      regLineChange(cm, from.line, \"text\");\r\n    else\r\n      regChange(cm, from.line, to.line + 1, lendiff);\r\n\r\n    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\r\n    if (changeHandler || changesHandler) {\r\n      var obj = {\r\n        from: from, to: to,\r\n        text: change.text,\r\n        removed: change.removed,\r\n        origin: change.origin\r\n      };\r\n      if (changeHandler) signalLater(cm, \"change\", cm, obj);\r\n      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\r\n    }\r\n    cm.display.selForContextMenu = null;\r\n  }\r\n\r\n  function replaceRange(doc, code, from, to, origin) {\r\n    if (!to) to = from;\r\n    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }\r\n    if (typeof code == \"string\") code = splitLines(code);\r\n    makeChange(doc, {from: from, to: to, text: code, origin: origin});\r\n  }\r\n\r\n  // SCROLLING THINGS INTO VIEW\r\n\r\n  // If an editor sits on the top or bottom of the window, partially\r\n  // scrolled out of view, this ensures that the cursor is visible.\r\n  function maybeScrollWindow(cm, coords) {\r\n    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) return;\r\n\r\n    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\r\n    if (coords.top + box.top < 0) doScroll = true;\r\n    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\r\n    if (doScroll != null && !phantom) {\r\n      var scrollNode = elt(\"div\", \"\\u200b\", null, \"position: absolute; top: \" +\r\n                           (coords.top - display.viewOffset - paddingTop(cm.display)) + \"px; height: \" +\r\n                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + \"px; left: \" +\r\n                           coords.left + \"px; width: 2px;\");\r\n      cm.display.lineSpace.appendChild(scrollNode);\r\n      scrollNode.scrollIntoView(doScroll);\r\n      cm.display.lineSpace.removeChild(scrollNode);\r\n    }\r\n  }\r\n\r\n  // Scroll a given position into view (immediately), verifying that\r\n  // it actually became visible (as line heights are accurately\r\n  // measured, the position of something may 'drift' during drawing).\r\n  function scrollPosIntoView(cm, pos, end, margin) {\r\n    if (margin == null) margin = 0;\r\n    for (var limit = 0; limit < 5; limit++) {\r\n      var changed = false, coords = cursorCoords(cm, pos);\r\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\r\n      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\r\n                                         Math.min(coords.top, endCoords.top) - margin,\r\n                                         Math.max(coords.left, endCoords.left),\r\n                                         Math.max(coords.bottom, endCoords.bottom) + margin);\r\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\r\n      if (scrollPos.scrollTop != null) {\r\n        setScrollTop(cm, scrollPos.scrollTop);\r\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\r\n      }\r\n      if (scrollPos.scrollLeft != null) {\r\n        setScrollLeft(cm, scrollPos.scrollLeft);\r\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\r\n      }\r\n      if (!changed) break;\r\n    }\r\n    return coords;\r\n  }\r\n\r\n  // Scroll a given set of coordinates into view (immediately).\r\n  function scrollIntoView(cm, x1, y1, x2, y2) {\r\n    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\r\n    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\r\n    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\r\n  }\r\n\r\n  // Calculate a new scroll position needed to scroll the given\r\n  // rectangle into view. Returns an object with scrollTop and\r\n  // scrollLeft properties. When these are undefined, the\r\n  // vertical/horizontal position does not need to be adjusted.\r\n  function calculateScrollPos(cm, x1, y1, x2, y2) {\r\n    var display = cm.display, snapMargin = textHeight(cm.display);\r\n    if (y1 < 0) y1 = 0;\r\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\r\n    var screen = displayHeight(cm), result = {};\r\n    if (y2 - y1 > screen) y2 = y1 + screen;\r\n    var docBottom = cm.doc.height + paddingVert(display);\r\n    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;\r\n    if (y1 < screentop) {\r\n      result.scrollTop = atTop ? 0 : y1;\r\n    } else if (y2 > screentop + screen) {\r\n      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\r\n      if (newTop != screentop) result.scrollTop = newTop;\r\n    }\r\n\r\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\r\n    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\r\n    var tooWide = x2 - x1 > screenw;\r\n    if (tooWide) x2 = x1 + screenw;\r\n    if (x1 < 10)\r\n      result.scrollLeft = 0;\r\n    else if (x1 < screenleft)\r\n      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));\r\n    else if (x2 > screenw + screenleft - 3)\r\n      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;\r\n    return result;\r\n  }\r\n\r\n  // Store a relative adjustment to the scroll position in the current\r\n  // operation (to be applied when the operation finishes).\r\n  function addToScrollPos(cm, left, top) {\r\n    if (left != null || top != null) resolveScrollToPos(cm);\r\n    if (left != null)\r\n      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;\r\n    if (top != null)\r\n      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\r\n  }\r\n\r\n  // Make sure that at the end of the operation the current cursor is\r\n  // shown.\r\n  function ensureCursorVisible(cm) {\r\n    resolveScrollToPos(cm);\r\n    var cur = cm.getCursor(), from = cur, to = cur;\r\n    if (!cm.options.lineWrapping) {\r\n      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;\r\n      to = Pos(cur.line, cur.ch + 1);\r\n    }\r\n    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};\r\n  }\r\n\r\n  // When an operation has its scrollToPos property set, and another\r\n  // scroll action is applied before the end of the operation, this\r\n  // 'simulates' scrolling that position into view in a cheap way, so\r\n  // that the effect of intermediate scroll commands is not ignored.\r\n  function resolveScrollToPos(cm) {\r\n    var range = cm.curOp.scrollToPos;\r\n    if (range) {\r\n      cm.curOp.scrollToPos = null;\r\n      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\r\n      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),\r\n                                    Math.min(from.top, to.top) - range.margin,\r\n                                    Math.max(from.right, to.right),\r\n                                    Math.max(from.bottom, to.bottom) + range.margin);\r\n      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);\r\n    }\r\n  }\r\n\r\n  // API UTILITIES\r\n\r\n  // Indent the given line. The how parameter can be \"smart\",\r\n  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\r\n  // (typically set to true for forced single-line indents), empty\r\n  // lines are not indented, and places where the mode returns Pass\r\n  // are left alone.\r\n  function indentLine(cm, n, how, aggressive) {\r\n    var doc = cm.doc, state;\r\n    if (how == null) how = \"add\";\r\n    if (how == \"smart\") {\r\n      // Fall back to \"prev\" when the mode doesn't have an indentation\r\n      // method.\r\n      if (!doc.mode.indent) how = \"prev\";\r\n      else state = getStateBefore(cm, n);\r\n    }\r\n\r\n    var tabSize = cm.options.tabSize;\r\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\r\n    if (line.stateAfter) line.stateAfter = null;\r\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\r\n    if (!aggressive && !/\\S/.test(line.text)) {\r\n      indentation = 0;\r\n      how = \"not\";\r\n    } else if (how == \"smart\") {\r\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\r\n      if (indentation == Pass || indentation > 150) {\r\n        if (!aggressive) return;\r\n        how = \"prev\";\r\n      }\r\n    }\r\n    if (how == \"prev\") {\r\n      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\r\n      else indentation = 0;\r\n    } else if (how == \"add\") {\r\n      indentation = curSpace + cm.options.indentUnit;\r\n    } else if (how == \"subtract\") {\r\n      indentation = curSpace - cm.options.indentUnit;\r\n    } else if (typeof how == \"number\") {\r\n      indentation = curSpace + how;\r\n    }\r\n    indentation = Math.max(0, indentation);\r\n\r\n    var indentString = \"\", pos = 0;\r\n    if (cm.options.indentWithTabs)\r\n      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";}\r\n    if (pos < indentation) indentString += spaceStr(indentation - pos);\r\n\r\n    if (indentString != curSpaceString) {\r\n      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\r\n    } else {\r\n      // Ensure that, if the cursor was in the whitespace at the start\r\n      // of the line, it is moved to the end of that space.\r\n      for (var i = 0; i < doc.sel.ranges.length; i++) {\r\n        var range = doc.sel.ranges[i];\r\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\r\n          var pos = Pos(n, curSpaceString.length);\r\n          replaceOneSelection(doc, i, new Range(pos, pos));\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    line.stateAfter = null;\r\n  }\r\n\r\n  // Utility for applying a change to a line by handle or number,\r\n  // returning the number and optionally registering the line as\r\n  // changed.\r\n  function changeLine(doc, handle, changeType, op) {\r\n    var no = handle, line = handle;\r\n    if (typeof handle == \"number\") line = getLine(doc, clipLine(doc, handle));\r\n    else no = lineNo(handle);\r\n    if (no == null) return null;\r\n    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);\r\n    return line;\r\n  }\r\n\r\n  // Helper for deleting text near the selection(s), used to implement\r\n  // backspace, delete, and similar functionality.\r\n  function deleteNearSelection(cm, compute) {\r\n    var ranges = cm.doc.sel.ranges, kill = [];\r\n    // Build up a set of ranges to kill first, merging overlapping\r\n    // ranges.\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      var toKill = compute(ranges[i]);\r\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\r\n        var replaced = kill.pop();\r\n        if (cmp(replaced.from, toKill.from) < 0) {\r\n          toKill.from = replaced.from;\r\n          break;\r\n        }\r\n      }\r\n      kill.push(toKill);\r\n    }\r\n    // Next, remove those actual ranges.\r\n    runInOp(cm, function() {\r\n      for (var i = kill.length - 1; i >= 0; i--)\r\n        replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\");\r\n      ensureCursorVisible(cm);\r\n    });\r\n  }\r\n\r\n  // Used for horizontal relative motion. Dir is -1 or 1 (left or\r\n  // right), unit can be \"char\", \"column\" (like char, but doesn't\r\n  // cross line boundaries), \"word\" (across next word), or \"group\" (to\r\n  // the start of next group of word or non-word-non-whitespace\r\n  // chars). The visually param controls whether, in right-to-left\r\n  // text, direction 1 means to move towards the next index in the\r\n  // string, or towards the character to the right of the current\r\n  // position. The resulting position will have a hitSide=true\r\n  // property if it reached the end of the document.\r\n  function findPosH(doc, pos, dir, unit, visually) {\r\n    var line = pos.line, ch = pos.ch, origDir = dir;\r\n    var lineObj = getLine(doc, line);\r\n    var possible = true;\r\n    function findNextLine() {\r\n      var l = line + dir;\r\n      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);\r\n      line = l;\r\n      return lineObj = getLine(doc, l);\r\n    }\r\n    function moveOnce(boundToLine) {\r\n      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\r\n      if (next == null) {\r\n        if (!boundToLine && findNextLine()) {\r\n          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\r\n          else ch = dir < 0 ? lineObj.text.length : 0;\r\n        } else return (possible = false);\r\n      } else ch = next;\r\n      return true;\r\n    }\r\n\r\n    if (unit == \"char\") moveOnce();\r\n    else if (unit == \"column\") moveOnce(true);\r\n    else if (unit == \"word\" || unit == \"group\") {\r\n      var sawType = null, group = unit == \"group\";\r\n      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\r\n      for (var first = true;; first = false) {\r\n        if (dir < 0 && !moveOnce(!first)) break;\r\n        var cur = lineObj.text.charAt(ch) || \"\\n\";\r\n        var type = isWordChar(cur, helper) ? \"w\"\r\n          : group && cur == \"\\n\" ? \"n\"\r\n          : !group || /\\s/.test(cur) ? null\r\n          : \"p\";\r\n        if (group && !first && !type) type = \"s\";\r\n        if (sawType && sawType != type) {\r\n          if (dir < 0) {dir = 1; moveOnce();}\r\n          break;\r\n        }\r\n\r\n        if (type) sawType = type;\r\n        if (dir > 0 && !moveOnce(!first)) break;\r\n      }\r\n    }\r\n    var result = skipAtomic(doc, Pos(line, ch), origDir, true);\r\n    if (!possible) result.hitSide = true;\r\n    return result;\r\n  }\r\n\r\n  // For relative vertical movement. Dir may be -1 or 1. Unit can be\r\n  // \"page\" or \"line\". The resulting position will have a hitSide=true\r\n  // property if it reached the end of the document.\r\n  function findPosV(cm, pos, dir, unit) {\r\n    var doc = cm.doc, x = pos.left, y;\r\n    if (unit == \"page\") {\r\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\r\n      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));\r\n    } else if (unit == \"line\") {\r\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\r\n    }\r\n    for (;;) {\r\n      var target = coordsChar(cm, x, y);\r\n      if (!target.outside) break;\r\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }\r\n      y += dir * 5;\r\n    }\r\n    return target;\r\n  }\r\n\r\n  // EDITOR METHODS\r\n\r\n  // The publicly visible API. Note that methodOp(f) means\r\n  // 'wrap f in an operation, performed on its `this` parameter'.\r\n\r\n  // This is not the complete set of editor methods. Most of the\r\n  // methods defined on the Doc type are also injected into\r\n  // CodeMirror.prototype, for backwards compatibility and\r\n  // convenience.\r\n\r\n  CodeMirror.prototype = {\r\n    constructor: CodeMirror,\r\n    focus: function(){window.focus(); this.display.input.focus();},\r\n\r\n    setOption: function(option, value) {\r\n      var options = this.options, old = options[option];\r\n      if (options[option] == value && option != \"mode\") return;\r\n      options[option] = value;\r\n      if (optionHandlers.hasOwnProperty(option))\r\n        operation(this, optionHandlers[option])(this, value, old);\r\n    },\r\n\r\n    getOption: function(option) {return this.options[option];},\r\n    getDoc: function() {return this.doc;},\r\n\r\n    addKeyMap: function(map, bottom) {\r\n      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map));\r\n    },\r\n    removeKeyMap: function(map) {\r\n      var maps = this.state.keyMaps;\r\n      for (var i = 0; i < maps.length; ++i)\r\n        if (maps[i] == map || maps[i].name == map) {\r\n          maps.splice(i, 1);\r\n          return true;\r\n        }\r\n    },\r\n\r\n    addOverlay: methodOp(function(spec, options) {\r\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\r\n      if (mode.startState) throw new Error(\"Overlays may not be stateful.\");\r\n      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});\r\n      this.state.modeGen++;\r\n      regChange(this);\r\n    }),\r\n    removeOverlay: methodOp(function(spec) {\r\n      var overlays = this.state.overlays;\r\n      for (var i = 0; i < overlays.length; ++i) {\r\n        var cur = overlays[i].modeSpec;\r\n        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\r\n          overlays.splice(i, 1);\r\n          this.state.modeGen++;\r\n          regChange(this);\r\n          return;\r\n        }\r\n      }\r\n    }),\r\n\r\n    indentLine: methodOp(function(n, dir, aggressive) {\r\n      if (typeof dir != \"string\" && typeof dir != \"number\") {\r\n        if (dir == null) dir = this.options.smartIndent ? \"smart\" : \"prev\";\r\n        else dir = dir ? \"add\" : \"subtract\";\r\n      }\r\n      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\r\n    }),\r\n    indentSelection: methodOp(function(how) {\r\n      var ranges = this.doc.sel.ranges, end = -1;\r\n      for (var i = 0; i < ranges.length; i++) {\r\n        var range = ranges[i];\r\n        if (!range.empty()) {\r\n          var from = range.from(), to = range.to();\r\n          var start = Math.max(end, from.line);\r\n          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\r\n          for (var j = start; j < end; ++j)\r\n            indentLine(this, j, how);\r\n          var newRanges = this.doc.sel.ranges;\r\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\r\n            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);\r\n        } else if (range.head.line > end) {\r\n          indentLine(this, range.head.line, how, true);\r\n          end = range.head.line;\r\n          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);\r\n        }\r\n      }\r\n    }),\r\n\r\n    // Fetch the parser token for a given character. Useful for hacks\r\n    // that want to inspect the mode state (say, for completion).\r\n    getTokenAt: function(pos, precise) {\r\n      return takeToken(this, pos, precise);\r\n    },\r\n\r\n    getLineTokens: function(line, precise) {\r\n      return takeToken(this, Pos(line), precise, true);\r\n    },\r\n\r\n    getTokenTypeAt: function(pos) {\r\n      pos = clipPos(this.doc, pos);\r\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\r\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\r\n      var type;\r\n      if (ch == 0) type = styles[2];\r\n      else for (;;) {\r\n        var mid = (before + after) >> 1;\r\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;\r\n        else if (styles[mid * 2 + 1] < ch) before = mid + 1;\r\n        else { type = styles[mid * 2 + 2]; break; }\r\n      }\r\n      var cut = type ? type.indexOf(\"cm-overlay \") : -1;\r\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\r\n    },\r\n\r\n    getModeAt: function(pos) {\r\n      var mode = this.doc.mode;\r\n      if (!mode.innerMode) return mode;\r\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\r\n    },\r\n\r\n    getHelper: function(pos, type) {\r\n      return this.getHelpers(pos, type)[0];\r\n    },\r\n\r\n    getHelpers: function(pos, type) {\r\n      var found = [];\r\n      if (!helpers.hasOwnProperty(type)) return found;\r\n      var help = helpers[type], mode = this.getModeAt(pos);\r\n      if (typeof mode[type] == \"string\") {\r\n        if (help[mode[type]]) found.push(help[mode[type]]);\r\n      } else if (mode[type]) {\r\n        for (var i = 0; i < mode[type].length; i++) {\r\n          var val = help[mode[type][i]];\r\n          if (val) found.push(val);\r\n        }\r\n      } else if (mode.helperType && help[mode.helperType]) {\r\n        found.push(help[mode.helperType]);\r\n      } else if (help[mode.name]) {\r\n        found.push(help[mode.name]);\r\n      }\r\n      for (var i = 0; i < help._global.length; i++) {\r\n        var cur = help._global[i];\r\n        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\r\n          found.push(cur.val);\r\n      }\r\n      return found;\r\n    },\r\n\r\n    getStateAfter: function(line, precise) {\r\n      var doc = this.doc;\r\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\r\n      return getStateBefore(this, line + 1, precise);\r\n    },\r\n\r\n    cursorCoords: function(start, mode) {\r\n      var pos, range = this.doc.sel.primary();\r\n      if (start == null) pos = range.head;\r\n      else if (typeof start == \"object\") pos = clipPos(this.doc, start);\r\n      else pos = start ? range.from() : range.to();\r\n      return cursorCoords(this, pos, mode || \"page\");\r\n    },\r\n\r\n    charCoords: function(pos, mode) {\r\n      return charCoords(this, clipPos(this.doc, pos), mode || \"page\");\r\n    },\r\n\r\n    coordsChar: function(coords, mode) {\r\n      coords = fromCoordSystem(this, coords, mode || \"page\");\r\n      return coordsChar(this, coords.left, coords.top);\r\n    },\r\n\r\n    lineAtHeight: function(height, mode) {\r\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\r\n      return lineAtHeight(this.doc, height + this.display.viewOffset);\r\n    },\r\n    heightAtLine: function(line, mode) {\r\n      var end = false, last = this.doc.first + this.doc.size - 1;\r\n      if (line < this.doc.first) line = this.doc.first;\r\n      else if (line > last) { line = last; end = true; }\r\n      var lineObj = getLine(this.doc, line);\r\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\").top +\r\n        (end ? this.doc.height - heightAtLine(lineObj) : 0);\r\n    },\r\n\r\n    defaultTextHeight: function() { return textHeight(this.display); },\r\n    defaultCharWidth: function() { return charWidth(this.display); },\r\n\r\n    setGutterMarker: methodOp(function(line, gutterID, value) {\r\n      return changeLine(this.doc, line, \"gutter\", function(line) {\r\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\r\n        markers[gutterID] = value;\r\n        if (!value && isEmpty(markers)) line.gutterMarkers = null;\r\n        return true;\r\n      });\r\n    }),\r\n\r\n    clearGutter: methodOp(function(gutterID) {\r\n      var cm = this, doc = cm.doc, i = doc.first;\r\n      doc.iter(function(line) {\r\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\r\n          line.gutterMarkers[gutterID] = null;\r\n          regLineChange(cm, i, \"gutter\");\r\n          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\r\n        }\r\n        ++i;\r\n      });\r\n    }),\r\n\r\n    lineInfo: function(line) {\r\n      if (typeof line == \"number\") {\r\n        if (!isLine(this.doc, line)) return null;\r\n        var n = line;\r\n        line = getLine(this.doc, line);\r\n        if (!line) return null;\r\n      } else {\r\n        var n = lineNo(line);\r\n        if (n == null) return null;\r\n      }\r\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\r\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\r\n              widgets: line.widgets};\r\n    },\r\n\r\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},\r\n\r\n    addWidget: function(pos, node, scroll, vert, horiz) {\r\n      var display = this.display;\r\n      pos = cursorCoords(this, clipPos(this.doc, pos));\r\n      var top = pos.bottom, left = pos.left;\r\n      node.style.position = \"absolute\";\r\n      node.setAttribute(\"cm-ignore-events\", \"true\");\r\n      this.display.input.setUneditable(node);\r\n      display.sizer.appendChild(node);\r\n      if (vert == \"over\") {\r\n        top = pos.top;\r\n      } else if (vert == \"above\" || vert == \"near\") {\r\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\r\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\r\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\r\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\r\n          top = pos.top - node.offsetHeight;\r\n        else if (pos.bottom + node.offsetHeight <= vspace)\r\n          top = pos.bottom;\r\n        if (left + node.offsetWidth > hspace)\r\n          left = hspace - node.offsetWidth;\r\n      }\r\n      node.style.top = top + \"px\";\r\n      node.style.left = node.style.right = \"\";\r\n      if (horiz == \"right\") {\r\n        left = display.sizer.clientWidth - node.offsetWidth;\r\n        node.style.right = \"0px\";\r\n      } else {\r\n        if (horiz == \"left\") left = 0;\r\n        else if (horiz == \"middle\") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\r\n        node.style.left = left + \"px\";\r\n      }\r\n      if (scroll)\r\n        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\r\n    },\r\n\r\n    triggerOnKeyDown: methodOp(onKeyDown),\r\n    triggerOnKeyPress: methodOp(onKeyPress),\r\n    triggerOnKeyUp: onKeyUp,\r\n\r\n    execCommand: function(cmd) {\r\n      if (commands.hasOwnProperty(cmd))\r\n        return commands[cmd](this);\r\n    },\r\n\r\n    findPosH: function(from, amount, unit, visually) {\r\n      var dir = 1;\r\n      if (amount < 0) { dir = -1; amount = -amount; }\r\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\r\n        cur = findPosH(this.doc, cur, dir, unit, visually);\r\n        if (cur.hitSide) break;\r\n      }\r\n      return cur;\r\n    },\r\n\r\n    moveH: methodOp(function(dir, unit) {\r\n      var cm = this;\r\n      cm.extendSelectionsBy(function(range) {\r\n        if (cm.display.shift || cm.doc.extend || range.empty())\r\n          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);\r\n        else\r\n          return dir < 0 ? range.from() : range.to();\r\n      }, sel_move);\r\n    }),\r\n\r\n    deleteH: methodOp(function(dir, unit) {\r\n      var sel = this.doc.sel, doc = this.doc;\r\n      if (sel.somethingSelected())\r\n        doc.replaceSelection(\"\", null, \"+delete\");\r\n      else\r\n        deleteNearSelection(this, function(range) {\r\n          var other = findPosH(doc, range.head, dir, unit, false);\r\n          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};\r\n        });\r\n    }),\r\n\r\n    findPosV: function(from, amount, unit, goalColumn) {\r\n      var dir = 1, x = goalColumn;\r\n      if (amount < 0) { dir = -1; amount = -amount; }\r\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\r\n        var coords = cursorCoords(this, cur, \"div\");\r\n        if (x == null) x = coords.left;\r\n        else coords.left = x;\r\n        cur = findPosV(this, coords, dir, unit);\r\n        if (cur.hitSide) break;\r\n      }\r\n      return cur;\r\n    },\r\n\r\n    moveV: methodOp(function(dir, unit) {\r\n      var cm = this, doc = this.doc, goals = [];\r\n      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();\r\n      doc.extendSelectionsBy(function(range) {\r\n        if (collapse)\r\n          return dir < 0 ? range.from() : range.to();\r\n        var headPos = cursorCoords(cm, range.head, \"div\");\r\n        if (range.goalColumn != null) headPos.left = range.goalColumn;\r\n        goals.push(headPos.left);\r\n        var pos = findPosV(cm, headPos, dir, unit);\r\n        if (unit == \"page\" && range == doc.sel.primary())\r\n          addToScrollPos(cm, null, charCoords(cm, pos, \"div\").top - headPos.top);\r\n        return pos;\r\n      }, sel_move);\r\n      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)\r\n        doc.sel.ranges[i].goalColumn = goals[i];\r\n    }),\r\n\r\n    // Find the word at the given position (as returned by coordsChar).\r\n    findWordAt: function(pos) {\r\n      var doc = this.doc, line = getLine(doc, pos.line).text;\r\n      var start = pos.ch, end = pos.ch;\r\n      if (line) {\r\n        var helper = this.getHelper(pos, \"wordChars\");\r\n        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;\r\n        var startChar = line.charAt(start);\r\n        var check = isWordChar(startChar, helper)\r\n          ? function(ch) { return isWordChar(ch, helper); }\r\n          : /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);}\r\n          : function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\r\n        while (start > 0 && check(line.charAt(start - 1))) --start;\r\n        while (end < line.length && check(line.charAt(end))) ++end;\r\n      }\r\n      return new Range(Pos(pos.line, start), Pos(pos.line, end));\r\n    },\r\n\r\n    toggleOverwrite: function(value) {\r\n      if (value != null && value == this.state.overwrite) return;\r\n      if (this.state.overwrite = !this.state.overwrite)\r\n        addClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\r\n      else\r\n        rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\r\n\r\n      signal(this, \"overwriteToggle\", this, this.state.overwrite);\r\n    },\r\n    hasFocus: function() { return this.display.input.getField() == activeElt(); },\r\n\r\n    scrollTo: methodOp(function(x, y) {\r\n      if (x != null || y != null) resolveScrollToPos(this);\r\n      if (x != null) this.curOp.scrollLeft = x;\r\n      if (y != null) this.curOp.scrollTop = y;\r\n    }),\r\n    getScrollInfo: function() {\r\n      var scroller = this.display.scroller;\r\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\r\n              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\r\n              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\r\n              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};\r\n    },\r\n\r\n    scrollIntoView: methodOp(function(range, margin) {\r\n      if (range == null) {\r\n        range = {from: this.doc.sel.primary().head, to: null};\r\n        if (margin == null) margin = this.options.cursorScrollMargin;\r\n      } else if (typeof range == \"number\") {\r\n        range = {from: Pos(range, 0), to: null};\r\n      } else if (range.from == null) {\r\n        range = {from: range, to: null};\r\n      }\r\n      if (!range.to) range.to = range.from;\r\n      range.margin = margin || 0;\r\n\r\n      if (range.from.line != null) {\r\n        resolveScrollToPos(this);\r\n        this.curOp.scrollToPos = range;\r\n      } else {\r\n        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),\r\n                                      Math.min(range.from.top, range.to.top) - range.margin,\r\n                                      Math.max(range.from.right, range.to.right),\r\n                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);\r\n        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);\r\n      }\r\n    }),\r\n\r\n    setSize: methodOp(function(width, height) {\r\n      var cm = this;\r\n      function interpret(val) {\r\n        return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\r\n      }\r\n      if (width != null) cm.display.wrapper.style.width = interpret(width);\r\n      if (height != null) cm.display.wrapper.style.height = interpret(height);\r\n      if (cm.options.lineWrapping) clearLineMeasurementCache(this);\r\n      var lineNo = cm.display.viewFrom;\r\n      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {\r\n        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)\r\n          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, \"widget\"); break; }\r\n        ++lineNo;\r\n      });\r\n      cm.curOp.forceUpdate = true;\r\n      signal(cm, \"refresh\", this);\r\n    }),\r\n\r\n    operation: function(f){return runInOp(this, f);},\r\n\r\n    refresh: methodOp(function() {\r\n      var oldHeight = this.display.cachedTextHeight;\r\n      regChange(this);\r\n      this.curOp.forceUpdate = true;\r\n      clearCaches(this);\r\n      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);\r\n      updateGutterSpace(this);\r\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\r\n        estimateLineHeights(this);\r\n      signal(this, \"refresh\", this);\r\n    }),\r\n\r\n    swapDoc: methodOp(function(doc) {\r\n      var old = this.doc;\r\n      old.cm = null;\r\n      attachDoc(this, doc);\r\n      clearCaches(this);\r\n      this.display.input.reset();\r\n      this.scrollTo(doc.scrollLeft, doc.scrollTop);\r\n      this.curOp.forceScroll = true;\r\n      signalLater(this, \"swapDoc\", this, old);\r\n      return old;\r\n    }),\r\n\r\n    getInputField: function(){return this.display.input.getField();},\r\n    getWrapperElement: function(){return this.display.wrapper;},\r\n    getScrollerElement: function(){return this.display.scroller;},\r\n    getGutterElement: function(){return this.display.gutters;}\r\n  };\r\n  eventMixin(CodeMirror);\r\n\r\n  // OPTION DEFAULTS\r\n\r\n  // The default configuration options.\r\n  var defaults = CodeMirror.defaults = {};\r\n  // Functions to run when options are changed.\r\n  var optionHandlers = CodeMirror.optionHandlers = {};\r\n\r\n  function option(name, deflt, handle, notOnInit) {\r\n    CodeMirror.defaults[name] = deflt;\r\n    if (handle) optionHandlers[name] =\r\n      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\r\n  }\r\n\r\n  // Passed to option handlers when there is no old value.\r\n  var Init = CodeMirror.Init = {toString: function(){return \"CodeMirror.Init\";}};\r\n\r\n  // These two are, on init, called from the constructor because they\r\n  // have to be initialized before the editor can start at all.\r\n  option(\"value\", \"\", function(cm, val) {\r\n    cm.setValue(val);\r\n  }, true);\r\n  option(\"mode\", null, function(cm, val) {\r\n    cm.doc.modeOption = val;\r\n    loadMode(cm);\r\n  }, true);\r\n\r\n  option(\"indentUnit\", 2, loadMode, true);\r\n  option(\"indentWithTabs\", false);\r\n  option(\"smartIndent\", true);\r\n  option(\"tabSize\", 4, function(cm) {\r\n    resetModeState(cm);\r\n    clearCaches(cm);\r\n    regChange(cm);\r\n  }, true);\r\n  option(\"specialChars\", /[\\t\\u0000-\\u0019\\u00ad\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function(cm, val, old) {\r\n    cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\r\n    if (old != CodeMirror.Init) cm.refresh();\r\n  });\r\n  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);\r\n  option(\"electricChars\", true);\r\n  option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function() {\r\n    throw new Error(\"inputStyle can not (yet) be changed in a running editor\"); // FIXME\r\n  }, true);\r\n  option(\"rtlMoveVisually\", !windows);\r\n  option(\"wholeLineUpdateBefore\", true);\r\n\r\n  option(\"theme\", \"default\", function(cm) {\r\n    themeChanged(cm);\r\n    guttersChanged(cm);\r\n  }, true);\r\n  option(\"keyMap\", \"default\", function(cm, val, old) {\r\n    var next = getKeyMap(val);\r\n    var prev = old != CodeMirror.Init && getKeyMap(old);\r\n    if (prev && prev.detach) prev.detach(cm, next);\r\n    if (next.attach) next.attach(cm, prev || null);\r\n  });\r\n  option(\"extraKeys\", null);\r\n\r\n  option(\"lineWrapping\", false, wrappingChanged, true);\r\n  option(\"gutters\", [], function(cm) {\r\n    setGuttersForLineNumbers(cm.options);\r\n    guttersChanged(cm);\r\n  }, true);\r\n  option(\"fixedGutter\", true, function(cm, val) {\r\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\r\n    cm.refresh();\r\n  }, true);\r\n  option(\"coverGutterNextToScrollbar\", false, function(cm) {updateScrollbars(cm);}, true);\r\n  option(\"scrollbarStyle\", \"native\", function(cm) {\r\n    initScrollbars(cm);\r\n    updateScrollbars(cm);\r\n    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\r\n    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\r\n  }, true);\r\n  option(\"lineNumbers\", false, function(cm) {\r\n    setGuttersForLineNumbers(cm.options);\r\n    guttersChanged(cm);\r\n  }, true);\r\n  option(\"firstLineNumber\", 1, guttersChanged, true);\r\n  option(\"lineNumberFormatter\", function(integer) {return integer;}, guttersChanged, true);\r\n  option(\"showCursorWhenSelecting\", false, updateSelection, true);\r\n\r\n  option(\"resetSelectionOnContextMenu\", true);\r\n\r\n  option(\"readOnly\", false, function(cm, val) {\r\n    if (val == \"nocursor\") {\r\n      onBlur(cm);\r\n      cm.display.input.blur();\r\n      cm.display.disabled = true;\r\n    } else {\r\n      cm.display.disabled = false;\r\n      if (!val) cm.display.input.reset();\r\n    }\r\n  });\r\n  option(\"disableInput\", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);\r\n  option(\"dragDrop\", true);\r\n\r\n  option(\"cursorBlinkRate\", 530);\r\n  option(\"cursorScrollMargin\", 0);\r\n  option(\"cursorHeight\", 1, updateSelection, true);\r\n  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\r\n  option(\"workTime\", 100);\r\n  option(\"workDelay\", 100);\r\n  option(\"flattenSpans\", true, resetModeState, true);\r\n  option(\"addModeClass\", false, resetModeState, true);\r\n  option(\"pollInterval\", 100);\r\n  option(\"undoDepth\", 200, function(cm, val){cm.doc.history.undoDepth = val;});\r\n  option(\"historyEventDelay\", 1250);\r\n  option(\"viewportMargin\", 10, function(cm){cm.refresh();}, true);\r\n  option(\"maxHighlightLength\", 10000, resetModeState, true);\r\n  option(\"moveInputWithCursor\", true, function(cm, val) {\r\n    if (!val) cm.display.input.resetPosition();\r\n  });\r\n\r\n  option(\"tabindex\", null, function(cm, val) {\r\n    cm.display.input.getField().tabIndex = val || \"\";\r\n  });\r\n  option(\"autofocus\", null);\r\n\r\n  // MODE DEFINITION AND QUERYING\r\n\r\n  // Known modes, by name and by MIME\r\n  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\r\n\r\n  // Extra arguments are stored as the mode's dependencies, which is\r\n  // used by (legacy) mechanisms like loadmode.js to automatically\r\n  // load a mode. (Preferred mechanism is the require/define calls.)\r\n  CodeMirror.defineMode = function(name, mode) {\r\n    if (!CodeMirror.defaults.mode && name != \"null\") CodeMirror.defaults.mode = name;\r\n    if (arguments.length > 2)\r\n      mode.dependencies = Array.prototype.slice.call(arguments, 2);\r\n    modes[name] = mode;\r\n  };\r\n\r\n  CodeMirror.defineMIME = function(mime, spec) {\r\n    mimeModes[mime] = spec;\r\n  };\r\n\r\n  // Given a MIME type, a {name, ...options} config object, or a name\r\n  // string, return a mode config object.\r\n  CodeMirror.resolveMode = function(spec) {\r\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\r\n      spec = mimeModes[spec];\r\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\r\n      var found = mimeModes[spec.name];\r\n      if (typeof found == \"string\") found = {name: found};\r\n      spec = createObj(found, spec);\r\n      spec.name = found.name;\r\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\r\n      return CodeMirror.resolveMode(\"application/xml\");\r\n    }\r\n    if (typeof spec == \"string\") return {name: spec};\r\n    else return spec || {name: \"null\"};\r\n  };\r\n\r\n  // Given a mode spec (anything that resolveMode accepts), find and\r\n  // initialize an actual mode object.\r\n  CodeMirror.getMode = function(options, spec) {\r\n    var spec = CodeMirror.resolveMode(spec);\r\n    var mfactory = modes[spec.name];\r\n    if (!mfactory) return CodeMirror.getMode(options, \"text/plain\");\r\n    var modeObj = mfactory(options, spec);\r\n    if (modeExtensions.hasOwnProperty(spec.name)) {\r\n      var exts = modeExtensions[spec.name];\r\n      for (var prop in exts) {\r\n        if (!exts.hasOwnProperty(prop)) continue;\r\n        if (modeObj.hasOwnProperty(prop)) modeObj[\"_\" + prop] = modeObj[prop];\r\n        modeObj[prop] = exts[prop];\r\n      }\r\n    }\r\n    modeObj.name = spec.name;\r\n    if (spec.helperType) modeObj.helperType = spec.helperType;\r\n    if (spec.modeProps) for (var prop in spec.modeProps)\r\n      modeObj[prop] = spec.modeProps[prop];\r\n\r\n    return modeObj;\r\n  };\r\n\r\n  // Minimal default mode.\r\n  CodeMirror.defineMode(\"null\", function() {\r\n    return {token: function(stream) {stream.skipToEnd();}};\r\n  });\r\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\r\n\r\n  // This can be used to attach properties to mode objects from\r\n  // outside the actual mode definition.\r\n  var modeExtensions = CodeMirror.modeExtensions = {};\r\n  CodeMirror.extendMode = function(mode, properties) {\r\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\r\n    copyObj(properties, exts);\r\n  };\r\n\r\n  // EXTENSIONS\r\n\r\n  CodeMirror.defineExtension = function(name, func) {\r\n    CodeMirror.prototype[name] = func;\r\n  };\r\n  CodeMirror.defineDocExtension = function(name, func) {\r\n    Doc.prototype[name] = func;\r\n  };\r\n  CodeMirror.defineOption = option;\r\n\r\n  var initHooks = [];\r\n  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\r\n\r\n  var helpers = CodeMirror.helpers = {};\r\n  CodeMirror.registerHelper = function(type, name, value) {\r\n    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};\r\n    helpers[type][name] = value;\r\n  };\r\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\r\n    CodeMirror.registerHelper(type, name, value);\r\n    helpers[type]._global.push({pred: predicate, val: value});\r\n  };\r\n\r\n  // MODE STATE HANDLING\r\n\r\n  // Utility functions for working with state. Exported because nested\r\n  // modes need to do this for their inner modes.\r\n\r\n  var copyState = CodeMirror.copyState = function(mode, state) {\r\n    if (state === true) return state;\r\n    if (mode.copyState) return mode.copyState(state);\r\n    var nstate = {};\r\n    for (var n in state) {\r\n      var val = state[n];\r\n      if (val instanceof Array) val = val.concat([]);\r\n      nstate[n] = val;\r\n    }\r\n    return nstate;\r\n  };\r\n\r\n  var startState = CodeMirror.startState = function(mode, a1, a2) {\r\n    return mode.startState ? mode.startState(a1, a2) : true;\r\n  };\r\n\r\n  // Given a mode and a state (for that mode), find the inner mode and\r\n  // state at the position that the state refers to.\r\n  CodeMirror.innerMode = function(mode, state) {\r\n    while (mode.innerMode) {\r\n      var info = mode.innerMode(state);\r\n      if (!info || info.mode == mode) break;\r\n      state = info.state;\r\n      mode = info.mode;\r\n    }\r\n    return info || {mode: mode, state: state};\r\n  };\r\n\r\n  // STANDARD COMMANDS\r\n\r\n  // Commands are parameter-less actions that can be performed on an\r\n  // editor, mostly used for keybindings.\r\n  var commands = CodeMirror.commands = {\r\n    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},\r\n    singleSelection: function(cm) {\r\n      cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll);\r\n    },\r\n    killLine: function(cm) {\r\n      deleteNearSelection(cm, function(range) {\r\n        if (range.empty()) {\r\n          var len = getLine(cm.doc, range.head.line).text.length;\r\n          if (range.head.ch == len && range.head.line < cm.lastLine())\r\n            return {from: range.head, to: Pos(range.head.line + 1, 0)};\r\n          else\r\n            return {from: range.head, to: Pos(range.head.line, len)};\r\n        } else {\r\n          return {from: range.from(), to: range.to()};\r\n        }\r\n      });\r\n    },\r\n    deleteLine: function(cm) {\r\n      deleteNearSelection(cm, function(range) {\r\n        return {from: Pos(range.from().line, 0),\r\n                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};\r\n      });\r\n    },\r\n    delLineLeft: function(cm) {\r\n      deleteNearSelection(cm, function(range) {\r\n        return {from: Pos(range.from().line, 0), to: range.from()};\r\n      });\r\n    },\r\n    delWrappedLineLeft: function(cm) {\r\n      deleteNearSelection(cm, function(range) {\r\n        var top = cm.charCoords(range.head, \"div\").top + 5;\r\n        var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\r\n        return {from: leftPos, to: range.from()};\r\n      });\r\n    },\r\n    delWrappedLineRight: function(cm) {\r\n      deleteNearSelection(cm, function(range) {\r\n        var top = cm.charCoords(range.head, \"div\").top + 5;\r\n        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\r\n        return {from: range.from(), to: rightPos };\r\n      });\r\n    },\r\n    undo: function(cm) {cm.undo();},\r\n    redo: function(cm) {cm.redo();},\r\n    undoSelection: function(cm) {cm.undoSelection();},\r\n    redoSelection: function(cm) {cm.redoSelection();},\r\n    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},\r\n    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},\r\n    goLineStart: function(cm) {\r\n      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },\r\n                            {origin: \"+move\", bias: 1});\r\n    },\r\n    goLineStartSmart: function(cm) {\r\n      cm.extendSelectionsBy(function(range) {\r\n        return lineStartSmart(cm, range.head);\r\n      }, {origin: \"+move\", bias: 1});\r\n    },\r\n    goLineEnd: function(cm) {\r\n      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },\r\n                            {origin: \"+move\", bias: -1});\r\n    },\r\n    goLineRight: function(cm) {\r\n      cm.extendSelectionsBy(function(range) {\r\n        var top = cm.charCoords(range.head, \"div\").top + 5;\r\n        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\r\n      }, sel_move);\r\n    },\r\n    goLineLeft: function(cm) {\r\n      cm.extendSelectionsBy(function(range) {\r\n        var top = cm.charCoords(range.head, \"div\").top + 5;\r\n        return cm.coordsChar({left: 0, top: top}, \"div\");\r\n      }, sel_move);\r\n    },\r\n    goLineLeftSmart: function(cm) {\r\n      cm.extendSelectionsBy(function(range) {\r\n        var top = cm.charCoords(range.head, \"div\").top + 5;\r\n        var pos = cm.coordsChar({left: 0, top: top}, \"div\");\r\n        if (pos.ch < cm.getLine(pos.line).search(/\\S/)) return lineStartSmart(cm, range.head);\r\n        return pos;\r\n      }, sel_move);\r\n    },\r\n    goLineUp: function(cm) {cm.moveV(-1, \"line\");},\r\n    goLineDown: function(cm) {cm.moveV(1, \"line\");},\r\n    goPageUp: function(cm) {cm.moveV(-1, \"page\");},\r\n    goPageDown: function(cm) {cm.moveV(1, \"page\");},\r\n    goCharLeft: function(cm) {cm.moveH(-1, \"char\");},\r\n    goCharRight: function(cm) {cm.moveH(1, \"char\");},\r\n    goColumnLeft: function(cm) {cm.moveH(-1, \"column\");},\r\n    goColumnRight: function(cm) {cm.moveH(1, \"column\");},\r\n    goWordLeft: function(cm) {cm.moveH(-1, \"word\");},\r\n    goGroupRight: function(cm) {cm.moveH(1, \"group\");},\r\n    goGroupLeft: function(cm) {cm.moveH(-1, \"group\");},\r\n    goWordRight: function(cm) {cm.moveH(1, \"word\");},\r\n    delCharBefore: function(cm) {cm.deleteH(-1, \"char\");},\r\n    delCharAfter: function(cm) {cm.deleteH(1, \"char\");},\r\n    delWordBefore: function(cm) {cm.deleteH(-1, \"word\");},\r\n    delWordAfter: function(cm) {cm.deleteH(1, \"word\");},\r\n    delGroupBefore: function(cm) {cm.deleteH(-1, \"group\");},\r\n    delGroupAfter: function(cm) {cm.deleteH(1, \"group\");},\r\n    indentAuto: function(cm) {cm.indentSelection(\"smart\");},\r\n    indentMore: function(cm) {cm.indentSelection(\"add\");},\r\n    indentLess: function(cm) {cm.indentSelection(\"subtract\");},\r\n    insertTab: function(cm) {cm.replaceSelection(\"\\t\");},\r\n    insertSoftTab: function(cm) {\r\n      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\r\n      for (var i = 0; i < ranges.length; i++) {\r\n        var pos = ranges[i].from();\r\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\r\n        spaces.push(new Array(tabSize - col % tabSize + 1).join(\" \"));\r\n      }\r\n      cm.replaceSelections(spaces);\r\n    },\r\n    defaultTab: function(cm) {\r\n      if (cm.somethingSelected()) cm.indentSelection(\"add\");\r\n      else cm.execCommand(\"insertTab\");\r\n    },\r\n    transposeChars: function(cm) {\r\n      runInOp(cm, function() {\r\n        var ranges = cm.listSelections(), newSel = [];\r\n        for (var i = 0; i < ranges.length; i++) {\r\n          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\r\n          if (line) {\r\n            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);\r\n            if (cur.ch > 0) {\r\n              cur = new Pos(cur.line, cur.ch + 1);\r\n              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\r\n                              Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\r\n            } else if (cur.line > cm.doc.first) {\r\n              var prev = getLine(cm.doc, cur.line - 1).text;\r\n              if (prev)\r\n                cm.replaceRange(line.charAt(0) + \"\\n\" + prev.charAt(prev.length - 1),\r\n                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), \"+transpose\");\r\n            }\r\n          }\r\n          newSel.push(new Range(cur, cur));\r\n        }\r\n        cm.setSelections(newSel);\r\n      });\r\n    },\r\n    newlineAndIndent: function(cm) {\r\n      runInOp(cm, function() {\r\n        var len = cm.listSelections().length;\r\n        for (var i = 0; i < len; i++) {\r\n          var range = cm.listSelections()[i];\r\n          cm.replaceRange(\"\\n\", range.anchor, range.head, \"+input\");\r\n          cm.indentLine(range.from().line + 1, null, true);\r\n          ensureCursorVisible(cm);\r\n        }\r\n      });\r\n    },\r\n    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\r\n  };\r\n\r\n\r\n  // STANDARD KEYMAPS\r\n\r\n  var keyMap = CodeMirror.keyMap = {};\r\n\r\n  keyMap.basic = {\r\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\r\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\r\n    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\r\n    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\r\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\r\n    \"Esc\": \"singleSelection\"\r\n  };\r\n  // Note that the save and find-related commands aren't defined by\r\n  // default. User code or addons can define them. Unknown commands\r\n  // are simply ignored.\r\n  keyMap.pcDefault = {\r\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\r\n    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\r\n    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\r\n    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\r\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\r\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\r\n    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\r\n    fallthrough: \"basic\"\r\n  };\r\n  // Very basic readline/emacs-style bindings, which are standard on Mac.\r\n  keyMap.emacsy = {\r\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\r\n    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\r\n    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\r\n    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\"\r\n  };\r\n  keyMap.macDefault = {\r\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\r\n    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\r\n    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\r\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\r\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\r\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\r\n    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\r\n    fallthrough: [\"basic\", \"emacsy\"]\r\n  };\r\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\r\n\r\n  // KEYMAP DISPATCH\r\n\r\n  function normalizeKeyName(name) {\r\n    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];\r\n    var alt, ctrl, shift, cmd;\r\n    for (var i = 0; i < parts.length - 1; i++) {\r\n      var mod = parts[i];\r\n      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;\r\n      else if (/^a(lt)?$/i.test(mod)) alt = true;\r\n      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;\r\n      else if (/^s(hift)$/i.test(mod)) shift = true;\r\n      else throw new Error(\"Unrecognized modifier name: \" + mod);\r\n    }\r\n    if (alt) name = \"Alt-\" + name;\r\n    if (ctrl) name = \"Ctrl-\" + name;\r\n    if (cmd) name = \"Cmd-\" + name;\r\n    if (shift) name = \"Shift-\" + name;\r\n    return name;\r\n  }\r\n\r\n  // This is a kludge to keep keymaps mostly working as raw objects\r\n  // (backwards compatibility) while at the same time support features\r\n  // like normalization and multi-stroke key bindings. It compiles a\r\n  // new normalized keymap, and then updates the old object to reflect\r\n  // this.\r\n  CodeMirror.normalizeKeyMap = function(keymap) {\r\n    var copy = {};\r\n    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {\r\n      var value = keymap[keyname];\r\n      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;\r\n      if (value == \"...\") { delete keymap[keyname]; continue; }\r\n\r\n      var keys = map(keyname.split(\" \"), normalizeKeyName);\r\n      for (var i = 0; i < keys.length; i++) {\r\n        var val, name;\r\n        if (i == keys.length - 1) {\r\n          name = keyname;\r\n          val = value;\r\n        } else {\r\n          name = keys.slice(0, i + 1).join(\" \");\r\n          val = \"...\";\r\n        }\r\n        var prev = copy[name];\r\n        if (!prev) copy[name] = val;\r\n        else if (prev != val) throw new Error(\"Inconsistent bindings for \" + name);\r\n      }\r\n      delete keymap[keyname];\r\n    }\r\n    for (var prop in copy) keymap[prop] = copy[prop];\r\n    return keymap;\r\n  };\r\n\r\n  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {\r\n    map = getKeyMap(map);\r\n    var found = map.call ? map.call(key, context) : map[key];\r\n    if (found === false) return \"nothing\";\r\n    if (found === \"...\") return \"multi\";\r\n    if (found != null && handle(found)) return \"handled\";\r\n\r\n    if (map.fallthrough) {\r\n      if (Object.prototype.toString.call(map.fallthrough) != \"[object Array]\")\r\n        return lookupKey(key, map.fallthrough, handle, context);\r\n      for (var i = 0; i < map.fallthrough.length; i++) {\r\n        var result = lookupKey(key, map.fallthrough[i], handle, context);\r\n        if (result) return result;\r\n      }\r\n    }\r\n  };\r\n\r\n  // Modifier key presses don't count as 'real' key presses for the\r\n  // purpose of keymap fallthrough.\r\n  var isModifierKey = CodeMirror.isModifierKey = function(value) {\r\n    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\r\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\r\n  };\r\n\r\n  // Look up the name of a key as indicated by an event object.\r\n  var keyName = CodeMirror.keyName = function(event, noShift) {\r\n    if (presto && event.keyCode == 34 && event[\"char\"]) return false;\r\n    var base = keyNames[event.keyCode], name = base;\r\n    if (name == null || event.altGraphKey) return false;\r\n    if (event.altKey && base != \"Alt\") name = \"Alt-\" + name;\r\n    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") name = \"Ctrl-\" + name;\r\n    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") name = \"Cmd-\" + name;\r\n    if (!noShift && event.shiftKey && base != \"Shift\") name = \"Shift-\" + name;\r\n    return name;\r\n  };\r\n\r\n  function getKeyMap(val) {\r\n    return typeof val == \"string\" ? keyMap[val] : val;\r\n  }\r\n\r\n  // FROMTEXTAREA\r\n\r\n  CodeMirror.fromTextArea = function(textarea, options) {\r\n    options = options ? copyObj(options) : {};\r\n    options.value = textarea.value;\r\n    if (!options.tabindex && textarea.tabIndex)\r\n      options.tabindex = textarea.tabIndex;\r\n    if (!options.placeholder && textarea.placeholder)\r\n      options.placeholder = textarea.placeholder;\r\n    // Set autofocus to true if this textarea is focused, or if it has\r\n    // autofocus and no other element is focused.\r\n    if (options.autofocus == null) {\r\n      var hasFocus = activeElt();\r\n      options.autofocus = hasFocus == textarea ||\r\n        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\r\n    }\r\n\r\n    function save() {textarea.value = cm.getValue();}\r\n    if (textarea.form) {\r\n      on(textarea.form, \"submit\", save);\r\n      // Deplorable hack to make the submit method do the right thing.\r\n      if (!options.leaveSubmitMethodAlone) {\r\n        var form = textarea.form, realSubmit = form.submit;\r\n        try {\r\n          var wrappedSubmit = form.submit = function() {\r\n            save();\r\n            form.submit = realSubmit;\r\n            form.submit();\r\n            form.submit = wrappedSubmit;\r\n          };\r\n        } catch(e) {}\r\n      }\r\n    }\r\n\r\n    options.finishInit = function(cm) {\r\n      cm.save = save;\r\n      cm.getTextArea = function() { return textarea; };\r\n      cm.toTextArea = function() {\r\n        cm.toTextArea = isNaN; // Prevent this from being ran twice\r\n        save();\r\n        textarea.parentNode.removeChild(cm.getWrapperElement());\r\n        textarea.style.display = \"\";\r\n        if (textarea.form) {\r\n          off(textarea.form, \"submit\", save);\r\n          if (typeof textarea.form.submit == \"function\")\r\n            textarea.form.submit = realSubmit;\r\n        }\r\n      };\r\n    };\r\n\r\n    textarea.style.display = \"none\";\r\n    var cm = CodeMirror(function(node) {\r\n      textarea.parentNode.insertBefore(node, textarea.nextSibling);\r\n    }, options);\r\n    return cm;\r\n  };\r\n\r\n  // STRING STREAM\r\n\r\n  // Fed to the mode parsers, provides helper functions to make\r\n  // parsers more succinct.\r\n\r\n  var StringStream = CodeMirror.StringStream = function(string, tabSize) {\r\n    this.pos = this.start = 0;\r\n    this.string = string;\r\n    this.tabSize = tabSize || 8;\r\n    this.lastColumnPos = this.lastColumnValue = 0;\r\n    this.lineStart = 0;\r\n  };\r\n\r\n  StringStream.prototype = {\r\n    eol: function() {return this.pos >= this.string.length;},\r\n    sol: function() {return this.pos == this.lineStart;},\r\n    peek: function() {return this.string.charAt(this.pos) || undefined;},\r\n    next: function() {\r\n      if (this.pos < this.string.length)\r\n        return this.string.charAt(this.pos++);\r\n    },\r\n    eat: function(match) {\r\n      var ch = this.string.charAt(this.pos);\r\n      if (typeof match == \"string\") var ok = ch == match;\r\n      else var ok = ch && (match.test ? match.test(ch) : match(ch));\r\n      if (ok) {++this.pos; return ch;}\r\n    },\r\n    eatWhile: function(match) {\r\n      var start = this.pos;\r\n      while (this.eat(match)){}\r\n      return this.pos > start;\r\n    },\r\n    eatSpace: function() {\r\n      var start = this.pos;\r\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\r\n      return this.pos > start;\r\n    },\r\n    skipToEnd: function() {this.pos = this.string.length;},\r\n    skipTo: function(ch) {\r\n      var found = this.string.indexOf(ch, this.pos);\r\n      if (found > -1) {this.pos = found; return true;}\r\n    },\r\n    backUp: function(n) {this.pos -= n;},\r\n    column: function() {\r\n      if (this.lastColumnPos < this.start) {\r\n        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\r\n        this.lastColumnPos = this.start;\r\n      }\r\n      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\r\n    },\r\n    indentation: function() {\r\n      return countColumn(this.string, null, this.tabSize) -\r\n        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\r\n    },\r\n    match: function(pattern, consume, caseInsensitive) {\r\n      if (typeof pattern == \"string\") {\r\n        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\r\n        var substr = this.string.substr(this.pos, pattern.length);\r\n        if (cased(substr) == cased(pattern)) {\r\n          if (consume !== false) this.pos += pattern.length;\r\n          return true;\r\n        }\r\n      } else {\r\n        var match = this.string.slice(this.pos).match(pattern);\r\n        if (match && match.index > 0) return null;\r\n        if (match && consume !== false) this.pos += match[0].length;\r\n        return match;\r\n      }\r\n    },\r\n    current: function(){return this.string.slice(this.start, this.pos);},\r\n    hideFirstChars: function(n, inner) {\r\n      this.lineStart += n;\r\n      try { return inner(); }\r\n      finally { this.lineStart -= n; }\r\n    }\r\n  };\r\n\r\n  // TEXTMARKERS\r\n\r\n  // Created with markText and setBookmark methods. A TextMarker is a\r\n  // handle that can be used to clear or find a marked position in the\r\n  // document. Line objects hold arrays (markedSpans) containing\r\n  // {from, to, marker} object pointing to such marker objects, and\r\n  // indicating that such a marker is present on that line. Multiple\r\n  // lines may point to the same marker when it spans across lines.\r\n  // The spans will have null for their from/to properties when the\r\n  // marker continues beyond the start/end of the line. Markers have\r\n  // links back to the lines they currently touch.\r\n\r\n  var nextMarkerId = 0;\r\n\r\n  var TextMarker = CodeMirror.TextMarker = function(doc, type) {\r\n    this.lines = [];\r\n    this.type = type;\r\n    this.doc = doc;\r\n    this.id = ++nextMarkerId;\r\n  };\r\n  eventMixin(TextMarker);\r\n\r\n  // Clear the marker.\r\n  TextMarker.prototype.clear = function() {\r\n    if (this.explicitlyCleared) return;\r\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\r\n    if (withOp) startOperation(cm);\r\n    if (hasHandler(this, \"clear\")) {\r\n      var found = this.find();\r\n      if (found) signalLater(this, \"clear\", found.from, found.to);\r\n    }\r\n    var min = null, max = null;\r\n    for (var i = 0; i < this.lines.length; ++i) {\r\n      var line = this.lines[i];\r\n      var span = getMarkedSpanFor(line.markedSpans, this);\r\n      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), \"text\");\r\n      else if (cm) {\r\n        if (span.to != null) max = lineNo(line);\r\n        if (span.from != null) min = lineNo(line);\r\n      }\r\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\r\n      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\r\n        updateLineHeight(line, textHeight(cm.display));\r\n    }\r\n    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\r\n      var visual = visualLine(this.lines[i]), len = lineLength(visual);\r\n      if (len > cm.display.maxLineLength) {\r\n        cm.display.maxLine = visual;\r\n        cm.display.maxLineLength = len;\r\n        cm.display.maxLineChanged = true;\r\n      }\r\n    }\r\n\r\n    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);\r\n    this.lines.length = 0;\r\n    this.explicitlyCleared = true;\r\n    if (this.atomic && this.doc.cantEdit) {\r\n      this.doc.cantEdit = false;\r\n      if (cm) reCheckSelection(cm.doc);\r\n    }\r\n    if (cm) signalLater(cm, \"markerCleared\", cm, this);\r\n    if (withOp) endOperation(cm);\r\n    if (this.parent) this.parent.clear();\r\n  };\r\n\r\n  // Find the position of the marker in the document. Returns a {from,\r\n  // to} object by default. Side can be passed to get a specific side\r\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\r\n  // Pos objects returned contain a line object, rather than a line\r\n  // number (used to prevent looking up the same line twice).\r\n  TextMarker.prototype.find = function(side, lineObj) {\r\n    if (side == null && this.type == \"bookmark\") side = 1;\r\n    var from, to;\r\n    for (var i = 0; i < this.lines.length; ++i) {\r\n      var line = this.lines[i];\r\n      var span = getMarkedSpanFor(line.markedSpans, this);\r\n      if (span.from != null) {\r\n        from = Pos(lineObj ? line : lineNo(line), span.from);\r\n        if (side == -1) return from;\r\n      }\r\n      if (span.to != null) {\r\n        to = Pos(lineObj ? line : lineNo(line), span.to);\r\n        if (side == 1) return to;\r\n      }\r\n    }\r\n    return from && {from: from, to: to};\r\n  };\r\n\r\n  // Signals that the marker's widget changed, and surrounding layout\r\n  // should be recomputed.\r\n  TextMarker.prototype.changed = function() {\r\n    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\r\n    if (!pos || !cm) return;\r\n    runInOp(cm, function() {\r\n      var line = pos.line, lineN = lineNo(pos.line);\r\n      var view = findViewForLine(cm, lineN);\r\n      if (view) {\r\n        clearLineMeasurementCacheFor(view);\r\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\r\n      }\r\n      cm.curOp.updateMaxLine = true;\r\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\r\n        var oldHeight = widget.height;\r\n        widget.height = null;\r\n        var dHeight = widgetHeight(widget) - oldHeight;\r\n        if (dHeight)\r\n          updateLineHeight(line, line.height + dHeight);\r\n      }\r\n    });\r\n  };\r\n\r\n  TextMarker.prototype.attachLine = function(line) {\r\n    if (!this.lines.length && this.doc.cm) {\r\n      var op = this.doc.cm.curOp;\r\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\r\n        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\r\n    }\r\n    this.lines.push(line);\r\n  };\r\n  TextMarker.prototype.detachLine = function(line) {\r\n    this.lines.splice(indexOf(this.lines, line), 1);\r\n    if (!this.lines.length && this.doc.cm) {\r\n      var op = this.doc.cm.curOp;\r\n      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\r\n    }\r\n  };\r\n\r\n  // Collapsed markers have unique ids, in order to be able to order\r\n  // them, which is needed for uniquely determining an outer marker\r\n  // when they overlap (they may nest, but not partially overlap).\r\n  var nextMarkerId = 0;\r\n\r\n  // Create a marker, wire it up to the right lines, and\r\n  function markText(doc, from, to, options, type) {\r\n    // Shared markers (across linked documents) are handled separately\r\n    // (markTextShared will call out to this again, once per\r\n    // document).\r\n    if (options && options.shared) return markTextShared(doc, from, to, options, type);\r\n    // Ensure we are in an operation.\r\n    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);\r\n\r\n    var marker = new TextMarker(doc, type), diff = cmp(from, to);\r\n    if (options) copyObj(options, marker, false);\r\n    // Don't connect empty markers unless clearWhenEmpty is false\r\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\r\n      return marker;\r\n    if (marker.replacedWith) {\r\n      // Showing up as a widget implies collapsed (widget replaces text)\r\n      marker.collapsed = true;\r\n      marker.widgetNode = elt(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\r\n      if (!options.handleMouseEvents) marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\");\r\n      if (options.insertLeft) marker.widgetNode.insertLeft = true;\r\n    }\r\n    if (marker.collapsed) {\r\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\r\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\r\n        throw new Error(\"Inserting collapsed marker partially overlapping an existing one\");\r\n      sawCollapsedSpans = true;\r\n    }\r\n\r\n    if (marker.addToHistory)\r\n      addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN);\r\n\r\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\r\n    doc.iter(curLine, to.line + 1, function(line) {\r\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\r\n        updateMaxLine = true;\r\n      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);\r\n      addMarkedSpan(line, new MarkedSpan(marker,\r\n                                         curLine == from.line ? from.ch : null,\r\n                                         curLine == to.line ? to.ch : null));\r\n      ++curLine;\r\n    });\r\n    // lineIsHidden depends on the presence of the spans, so needs a second pass\r\n    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {\r\n      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\r\n    });\r\n\r\n    if (marker.clearOnEnter) on(marker, \"beforeCursorEnter\", function() { marker.clear(); });\r\n\r\n    if (marker.readOnly) {\r\n      sawReadOnlySpans = true;\r\n      if (doc.history.done.length || doc.history.undone.length)\r\n        doc.clearHistory();\r\n    }\r\n    if (marker.collapsed) {\r\n      marker.id = ++nextMarkerId;\r\n      marker.atomic = true;\r\n    }\r\n    if (cm) {\r\n      // Sync editor state\r\n      if (updateMaxLine) cm.curOp.updateMaxLine = true;\r\n      if (marker.collapsed)\r\n        regChange(cm, from.line, to.line + 1);\r\n      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\r\n        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, \"text\");\r\n      if (marker.atomic) reCheckSelection(cm.doc);\r\n      signalLater(cm, \"markerAdded\", cm, marker);\r\n    }\r\n    return marker;\r\n  }\r\n\r\n  // SHARED TEXTMARKERS\r\n\r\n  // A shared marker spans multiple linked documents. It is\r\n  // implemented as a meta-marker-object controlling multiple normal\r\n  // markers.\r\n  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {\r\n    this.markers = markers;\r\n    this.primary = primary;\r\n    for (var i = 0; i < markers.length; ++i)\r\n      markers[i].parent = this;\r\n  };\r\n  eventMixin(SharedTextMarker);\r\n\r\n  SharedTextMarker.prototype.clear = function() {\r\n    if (this.explicitlyCleared) return;\r\n    this.explicitlyCleared = true;\r\n    for (var i = 0; i < this.markers.length; ++i)\r\n      this.markers[i].clear();\r\n    signalLater(this, \"clear\");\r\n  };\r\n  SharedTextMarker.prototype.find = function(side, lineObj) {\r\n    return this.primary.find(side, lineObj);\r\n  };\r\n\r\n  function markTextShared(doc, from, to, options, type) {\r\n    options = copyObj(options);\r\n    options.shared = false;\r\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\r\n    var widget = options.widgetNode;\r\n    linkedDocs(doc, function(doc) {\r\n      if (widget) options.widgetNode = widget.cloneNode(true);\r\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\r\n      for (var i = 0; i < doc.linked.length; ++i)\r\n        if (doc.linked[i].isParent) return;\r\n      primary = lst(markers);\r\n    });\r\n    return new SharedTextMarker(markers, primary);\r\n  }\r\n\r\n  function findSharedMarkers(doc) {\r\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),\r\n                         function(m) { return m.parent; });\r\n  }\r\n\r\n  function copySharedMarkers(doc, markers) {\r\n    for (var i = 0; i < markers.length; i++) {\r\n      var marker = markers[i], pos = marker.find();\r\n      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\r\n      if (cmp(mFrom, mTo)) {\r\n        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\r\n        marker.markers.push(subMark);\r\n        subMark.parent = marker;\r\n      }\r\n    }\r\n  }\r\n\r\n  function detachSharedMarkers(markers) {\r\n    for (var i = 0; i < markers.length; i++) {\r\n      var marker = markers[i], linked = [marker.primary.doc];;\r\n      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });\r\n      for (var j = 0; j < marker.markers.length; j++) {\r\n        var subMarker = marker.markers[j];\r\n        if (indexOf(linked, subMarker.doc) == -1) {\r\n          subMarker.parent = null;\r\n          marker.markers.splice(j--, 1);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // TEXTMARKER SPANS\r\n\r\n  function MarkedSpan(marker, from, to) {\r\n    this.marker = marker;\r\n    this.from = from; this.to = to;\r\n  }\r\n\r\n  // Search an array of spans for a span matching the given marker.\r\n  function getMarkedSpanFor(spans, marker) {\r\n    if (spans) for (var i = 0; i < spans.length; ++i) {\r\n      var span = spans[i];\r\n      if (span.marker == marker) return span;\r\n    }\r\n  }\r\n  // Remove a span from an array, returning undefined if no spans are\r\n  // left (we don't store arrays for lines without spans).\r\n  function removeMarkedSpan(spans, span) {\r\n    for (var r, i = 0; i < spans.length; ++i)\r\n      if (spans[i] != span) (r || (r = [])).push(spans[i]);\r\n    return r;\r\n  }\r\n  // Add a span to a line.\r\n  function addMarkedSpan(line, span) {\r\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\r\n    span.marker.attachLine(line);\r\n  }\r\n\r\n  // Used for the algorithm that adjusts markers for a change in the\r\n  // document. These functions cut an array of spans at a given\r\n  // character position, returning an array of remaining chunks (or\r\n  // undefined if nothing remains).\r\n  function markedSpansBefore(old, startCh, isInsert) {\r\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\r\n      var span = old[i], marker = span.marker;\r\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\r\n      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\r\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\r\n        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\r\n      }\r\n    }\r\n    return nw;\r\n  }\r\n  function markedSpansAfter(old, endCh, isInsert) {\r\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\r\n      var span = old[i], marker = span.marker;\r\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\r\n      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\r\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\r\n        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\r\n                                              span.to == null ? null : span.to - endCh));\r\n      }\r\n    }\r\n    return nw;\r\n  }\r\n\r\n  // Given a change object, compute the new set of marker spans that\r\n  // cover the line in which the change took place. Removes spans\r\n  // entirely within the change, reconnects spans belonging to the\r\n  // same marker that appear on both sides of the change, and cuts off\r\n  // spans partially within the change. Returns an array of span\r\n  // arrays with one element for each line in (after) the change.\r\n  function stretchSpansOverChange(doc, change) {\r\n    if (change.full) return null;\r\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\r\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\r\n    if (!oldFirst && !oldLast) return null;\r\n\r\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\r\n    // Get the spans that 'stick out' on both sides\r\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\r\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\r\n\r\n    // Next, merge those two ends\r\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\r\n    if (first) {\r\n      // Fix up .to properties of first\r\n      for (var i = 0; i < first.length; ++i) {\r\n        var span = first[i];\r\n        if (span.to == null) {\r\n          var found = getMarkedSpanFor(last, span.marker);\r\n          if (!found) span.to = startCh;\r\n          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\r\n        }\r\n      }\r\n    }\r\n    if (last) {\r\n      // Fix up .from in last (or move them into first in case of sameLine)\r\n      for (var i = 0; i < last.length; ++i) {\r\n        var span = last[i];\r\n        if (span.to != null) span.to += offset;\r\n        if (span.from == null) {\r\n          var found = getMarkedSpanFor(first, span.marker);\r\n          if (!found) {\r\n            span.from = offset;\r\n            if (sameLine) (first || (first = [])).push(span);\r\n          }\r\n        } else {\r\n          span.from += offset;\r\n          if (sameLine) (first || (first = [])).push(span);\r\n        }\r\n      }\r\n    }\r\n    // Make sure we didn't create any zero-length spans\r\n    if (first) first = clearEmptySpans(first);\r\n    if (last && last != first) last = clearEmptySpans(last);\r\n\r\n    var newMarkers = [first];\r\n    if (!sameLine) {\r\n      // Fill gap with whole-line-spans\r\n      var gap = change.text.length - 2, gapMarkers;\r\n      if (gap > 0 && first)\r\n        for (var i = 0; i < first.length; ++i)\r\n          if (first[i].to == null)\r\n            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));\r\n      for (var i = 0; i < gap; ++i)\r\n        newMarkers.push(gapMarkers);\r\n      newMarkers.push(last);\r\n    }\r\n    return newMarkers;\r\n  }\r\n\r\n  // Remove spans that are empty and don't have a clearWhenEmpty\r\n  // option of false.\r\n  function clearEmptySpans(spans) {\r\n    for (var i = 0; i < spans.length; ++i) {\r\n      var span = spans[i];\r\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\r\n        spans.splice(i--, 1);\r\n    }\r\n    if (!spans.length) return null;\r\n    return spans;\r\n  }\r\n\r\n  // Used for un/re-doing changes from the history. Combines the\r\n  // result of computing the existing spans with the set of spans that\r\n  // existed in the history (so that deleting around a span and then\r\n  // undoing brings back the span).\r\n  function mergeOldSpans(doc, change) {\r\n    var old = getOldSpans(doc, change);\r\n    var stretched = stretchSpansOverChange(doc, change);\r\n    if (!old) return stretched;\r\n    if (!stretched) return old;\r\n\r\n    for (var i = 0; i < old.length; ++i) {\r\n      var oldCur = old[i], stretchCur = stretched[i];\r\n      if (oldCur && stretchCur) {\r\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\r\n          var span = stretchCur[j];\r\n          for (var k = 0; k < oldCur.length; ++k)\r\n            if (oldCur[k].marker == span.marker) continue spans;\r\n          oldCur.push(span);\r\n        }\r\n      } else if (stretchCur) {\r\n        old[i] = stretchCur;\r\n      }\r\n    }\r\n    return old;\r\n  }\r\n\r\n  // Used to 'clip' out readOnly ranges when making a change.\r\n  function removeReadOnlyRanges(doc, from, to) {\r\n    var markers = null;\r\n    doc.iter(from.line, to.line + 1, function(line) {\r\n      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\r\n        var mark = line.markedSpans[i].marker;\r\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\r\n          (markers || (markers = [])).push(mark);\r\n      }\r\n    });\r\n    if (!markers) return null;\r\n    var parts = [{from: from, to: to}];\r\n    for (var i = 0; i < markers.length; ++i) {\r\n      var mk = markers[i], m = mk.find(0);\r\n      for (var j = 0; j < parts.length; ++j) {\r\n        var p = parts[j];\r\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;\r\n        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\r\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\r\n          newParts.push({from: p.from, to: m.from});\r\n        if (dto > 0 || !mk.inclusiveRight && !dto)\r\n          newParts.push({from: m.to, to: p.to});\r\n        parts.splice.apply(parts, newParts);\r\n        j += newParts.length - 1;\r\n      }\r\n    }\r\n    return parts;\r\n  }\r\n\r\n  // Connect or disconnect spans from a line.\r\n  function detachMarkedSpans(line) {\r\n    var spans = line.markedSpans;\r\n    if (!spans) return;\r\n    for (var i = 0; i < spans.length; ++i)\r\n      spans[i].marker.detachLine(line);\r\n    line.markedSpans = null;\r\n  }\r\n  function attachMarkedSpans(line, spans) {\r\n    if (!spans) return;\r\n    for (var i = 0; i < spans.length; ++i)\r\n      spans[i].marker.attachLine(line);\r\n    line.markedSpans = spans;\r\n  }\r\n\r\n  // Helpers used when computing which overlapping collapsed span\r\n  // counts as the larger one.\r\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }\r\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }\r\n\r\n  // Returns a number indicating which of two overlapping collapsed\r\n  // spans is larger (and thus includes the other). Falls back to\r\n  // comparing ids when the spans cover exactly the same range.\r\n  function compareCollapsedMarkers(a, b) {\r\n    var lenDiff = a.lines.length - b.lines.length;\r\n    if (lenDiff != 0) return lenDiff;\r\n    var aPos = a.find(), bPos = b.find();\r\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\r\n    if (fromCmp) return -fromCmp;\r\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\r\n    if (toCmp) return toCmp;\r\n    return b.id - a.id;\r\n  }\r\n\r\n  // Find out whether a line ends or starts in a collapsed span. If\r\n  // so, return the marker for that span.\r\n  function collapsedSpanAtSide(line, start) {\r\n    var sps = sawCollapsedSpans && line.markedSpans, found;\r\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\r\n      sp = sps[i];\r\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\r\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\r\n        found = sp.marker;\r\n    }\r\n    return found;\r\n  }\r\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }\r\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }\r\n\r\n  // Test whether there exists a collapsed span that partially\r\n  // overlaps (covers the start or end, but not both) of a new span.\r\n  // Such overlap is not allowed.\r\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\r\n    var line = getLine(doc, lineNo);\r\n    var sps = sawCollapsedSpans && line.markedSpans;\r\n    if (sps) for (var i = 0; i < sps.length; ++i) {\r\n      var sp = sps[i];\r\n      if (!sp.marker.collapsed) continue;\r\n      var found = sp.marker.find(0);\r\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\r\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\r\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;\r\n      if (fromCmp <= 0 && (cmp(found.to, from) > 0 || (sp.marker.inclusiveRight && marker.inclusiveLeft)) ||\r\n          fromCmp >= 0 && (cmp(found.from, to) < 0 || (sp.marker.inclusiveLeft && marker.inclusiveRight)))\r\n        return true;\r\n    }\r\n  }\r\n\r\n  // A visual line is a line as drawn on the screen. Folding, for\r\n  // example, can cause multiple logical lines to appear on the same\r\n  // visual line. This finds the start of the visual line that the\r\n  // given line is part of (usually that is the line itself).\r\n  function visualLine(line) {\r\n    var merged;\r\n    while (merged = collapsedSpanAtStart(line))\r\n      line = merged.find(-1, true).line;\r\n    return line;\r\n  }\r\n\r\n  // Returns an array of logical lines that continue the visual line\r\n  // started by the argument, or undefined if there are no such lines.\r\n  function visualLineContinued(line) {\r\n    var merged, lines;\r\n    while (merged = collapsedSpanAtEnd(line)) {\r\n      line = merged.find(1, true).line;\r\n      (lines || (lines = [])).push(line);\r\n    }\r\n    return lines;\r\n  }\r\n\r\n  // Get the line number of the start of the visual line that the\r\n  // given line number is part of.\r\n  function visualLineNo(doc, lineN) {\r\n    var line = getLine(doc, lineN), vis = visualLine(line);\r\n    if (line == vis) return lineN;\r\n    return lineNo(vis);\r\n  }\r\n  // Get the line number of the start of the next visual line after\r\n  // the given line.\r\n  function visualLineEndNo(doc, lineN) {\r\n    if (lineN > doc.lastLine()) return lineN;\r\n    var line = getLine(doc, lineN), merged;\r\n    if (!lineIsHidden(doc, line)) return lineN;\r\n    while (merged = collapsedSpanAtEnd(line))\r\n      line = merged.find(1, true).line;\r\n    return lineNo(line) + 1;\r\n  }\r\n\r\n  // Compute whether a line is hidden. Lines count as hidden when they\r\n  // are part of a visual line that starts with another line, or when\r\n  // they are entirely covered by collapsed, non-widget span.\r\n  function lineIsHidden(doc, line) {\r\n    var sps = sawCollapsedSpans && line.markedSpans;\r\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\r\n      sp = sps[i];\r\n      if (!sp.marker.collapsed) continue;\r\n      if (sp.from == null) return true;\r\n      if (sp.marker.widgetNode) continue;\r\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\r\n        return true;\r\n    }\r\n  }\r\n  function lineIsHiddenInner(doc, line, span) {\r\n    if (span.to == null) {\r\n      var end = span.marker.find(1, true);\r\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\r\n    }\r\n    if (span.marker.inclusiveRight && span.to == line.text.length)\r\n      return true;\r\n    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\r\n      sp = line.markedSpans[i];\r\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\r\n          (sp.to == null || sp.to != span.from) &&\r\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\r\n          lineIsHiddenInner(doc, line, sp)) return true;\r\n    }\r\n  }\r\n\r\n  // LINE WIDGETS\r\n\r\n  // Line widgets are block elements displayed above or below a line.\r\n\r\n  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {\r\n    if (options) for (var opt in options) if (options.hasOwnProperty(opt))\r\n      this[opt] = options[opt];\r\n    this.doc = doc;\r\n    this.node = node;\r\n  };\r\n  eventMixin(LineWidget);\r\n\r\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\r\n    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\r\n      addToScrollPos(cm, null, diff);\r\n  }\r\n\r\n  LineWidget.prototype.clear = function() {\r\n    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\r\n    if (no == null || !ws) return;\r\n    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);\r\n    if (!ws.length) line.widgets = null;\r\n    var height = widgetHeight(this);\r\n    updateLineHeight(line, Math.max(0, line.height - height));\r\n    if (cm) runInOp(cm, function() {\r\n      adjustScrollWhenAboveVisible(cm, line, -height);\r\n      regLineChange(cm, no, \"widget\");\r\n    });\r\n  };\r\n  LineWidget.prototype.changed = function() {\r\n    var oldH = this.height, cm = this.doc.cm, line = this.line;\r\n    this.height = null;\r\n    var diff = widgetHeight(this) - oldH;\r\n    if (!diff) return;\r\n    updateLineHeight(line, line.height + diff);\r\n    if (cm) runInOp(cm, function() {\r\n      cm.curOp.forceUpdate = true;\r\n      adjustScrollWhenAboveVisible(cm, line, diff);\r\n    });\r\n  };\r\n\r\n  function widgetHeight(widget) {\r\n    if (widget.height != null) return widget.height;\r\n    var cm = widget.doc.cm;\r\n    if (!cm) return 0;\r\n    if (!contains(document.body, widget.node)) {\r\n      var parentStyle = \"position: relative;\";\r\n      if (widget.coverGutter)\r\n        parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\";\r\n      if (widget.noHScroll)\r\n        parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\";\r\n      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\r\n    }\r\n    return widget.height = widget.node.offsetHeight;\r\n  }\r\n\r\n  function addLineWidget(doc, handle, node, options) {\r\n    var widget = new LineWidget(doc, node, options);\r\n    var cm = doc.cm;\r\n    if (cm && widget.noHScroll) cm.display.alignWidgets = true;\r\n    changeLine(doc, handle, \"widget\", function(line) {\r\n      var widgets = line.widgets || (line.widgets = []);\r\n      if (widget.insertAt == null) widgets.push(widget);\r\n      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);\r\n      widget.line = line;\r\n      if (cm && !lineIsHidden(doc, line)) {\r\n        var aboveVisible = heightAtLine(line) < doc.scrollTop;\r\n        updateLineHeight(line, line.height + widgetHeight(widget));\r\n        if (aboveVisible) addToScrollPos(cm, null, widget.height);\r\n        cm.curOp.forceUpdate = true;\r\n      }\r\n      return true;\r\n    });\r\n    return widget;\r\n  }\r\n\r\n  // LINE DATA STRUCTURE\r\n\r\n  // Line objects. These hold state related to a line, including\r\n  // highlighting info (the styles array).\r\n  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {\r\n    this.text = text;\r\n    attachMarkedSpans(this, markedSpans);\r\n    this.height = estimateHeight ? estimateHeight(this) : 1;\r\n  };\r\n  eventMixin(Line);\r\n  Line.prototype.lineNo = function() { return lineNo(this); };\r\n\r\n  // Change the content (text, markers) of a line. Automatically\r\n  // invalidates cached information and tries to re-estimate the\r\n  // line's height.\r\n  function updateLine(line, text, markedSpans, estimateHeight) {\r\n    line.text = text;\r\n    if (line.stateAfter) line.stateAfter = null;\r\n    if (line.styles) line.styles = null;\r\n    if (line.order != null) line.order = null;\r\n    detachMarkedSpans(line);\r\n    attachMarkedSpans(line, markedSpans);\r\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\r\n    if (estHeight != line.height) updateLineHeight(line, estHeight);\r\n  }\r\n\r\n  // Detach a line from the document tree and its markers.\r\n  function cleanUpLine(line) {\r\n    line.parent = null;\r\n    detachMarkedSpans(line);\r\n  }\r\n\r\n  function extractLineClasses(type, output) {\r\n    if (type) for (;;) {\r\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\r\n      if (!lineClass) break;\r\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\r\n      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\r\n      if (output[prop] == null)\r\n        output[prop] = lineClass[2];\r\n      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\r\n        output[prop] += \" \" + lineClass[2];\r\n    }\r\n    return type;\r\n  }\r\n\r\n  function callBlankLine(mode, state) {\r\n    if (mode.blankLine) return mode.blankLine(state);\r\n    if (!mode.innerMode) return;\r\n    var inner = CodeMirror.innerMode(mode, state);\r\n    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);\r\n  }\r\n\r\n  function readToken(mode, stream, state, inner) {\r\n    for (var i = 0; i < 10; i++) {\r\n      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;\r\n      var style = mode.token(stream, state);\r\n      if (stream.pos > stream.start) return style;\r\n    }\r\n    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\");\r\n  }\r\n\r\n  // Utility for getTokenAt and getLineTokens\r\n  function takeToken(cm, pos, precise, asArray) {\r\n    function getObj(copy) {\r\n      return {start: stream.start, end: stream.pos,\r\n              string: stream.current(),\r\n              type: style || null,\r\n              state: copy ? copyState(doc.mode, state) : state};\r\n    }\r\n\r\n    var doc = cm.doc, mode = doc.mode, style;\r\n    pos = clipPos(doc, pos);\r\n    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);\r\n    var stream = new StringStream(line.text, cm.options.tabSize), tokens;\r\n    if (asArray) tokens = [];\r\n    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\r\n      stream.start = stream.pos;\r\n      style = readToken(mode, stream, state);\r\n      if (asArray) tokens.push(getObj(true));\r\n    }\r\n    return asArray ? tokens : getObj();\r\n  }\r\n\r\n  // Run the given mode's parser over a line, calling f for each token.\r\n  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\r\n    var flattenSpans = mode.flattenSpans;\r\n    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\r\n    var curStart = 0, curStyle = null;\r\n    var stream = new StringStream(text, cm.options.tabSize), style;\r\n    var inner = cm.options.addModeClass && [null];\r\n    if (text == \"\") extractLineClasses(callBlankLine(mode, state), lineClasses);\r\n    while (!stream.eol()) {\r\n      if (stream.pos > cm.options.maxHighlightLength) {\r\n        flattenSpans = false;\r\n        if (forceToEnd) processLine(cm, text, state, stream.pos);\r\n        stream.pos = text.length;\r\n        style = null;\r\n      } else {\r\n        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);\r\n      }\r\n      if (inner) {\r\n        var mName = inner[0].name;\r\n        if (mName) style = \"m-\" + (style ? mName + \" \" + style : mName);\r\n      }\r\n      if (!flattenSpans || curStyle != style) {\r\n        while (curStart < stream.start) {\r\n          curStart = Math.min(stream.start, curStart + 50000);\r\n          f(curStart, curStyle);\r\n        }\r\n        curStyle = style;\r\n      }\r\n      stream.start = stream.pos;\r\n    }\r\n    while (curStart < stream.pos) {\r\n      // Webkit seems to refuse to render text nodes longer than 57444 characters\r\n      var pos = Math.min(stream.pos, curStart + 50000);\r\n      f(pos, curStyle);\r\n      curStart = pos;\r\n    }\r\n  }\r\n\r\n  // Compute a style array (an array starting with a mode generation\r\n  // -- for invalidation -- followed by pairs of end positions and\r\n  // style strings), which is used to highlight the tokens on the\r\n  // line.\r\n  function highlightLine(cm, line, state, forceToEnd) {\r\n    // A styles array always starts with a number identifying the\r\n    // mode/overlays that it is based on (for easy invalidation).\r\n    var st = [cm.state.modeGen], lineClasses = {};\r\n    // Compute the base array of styles\r\n    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {\r\n      st.push(end, style);\r\n    }, lineClasses, forceToEnd);\r\n\r\n    // Run overlays, adjust style array.\r\n    for (var o = 0; o < cm.state.overlays.length; ++o) {\r\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\r\n      runMode(cm, line.text, overlay.mode, true, function(end, style) {\r\n        var start = i;\r\n        // Ensure there's a token end at the current position, and that i points at it\r\n        while (at < end) {\r\n          var i_end = st[i];\r\n          if (i_end > end)\r\n            st.splice(i, 1, end, st[i+1], i_end);\r\n          i += 2;\r\n          at = Math.min(end, i_end);\r\n        }\r\n        if (!style) return;\r\n        if (overlay.opaque) {\r\n          st.splice(start, i - start, end, \"cm-overlay \" + style);\r\n          i = start + 2;\r\n        } else {\r\n          for (; start < i; start += 2) {\r\n            var cur = st[start+1];\r\n            st[start+1] = (cur ? cur + \" \" : \"\") + \"cm-overlay \" + style;\r\n          }\r\n        }\r\n      }, lineClasses);\r\n    }\r\n\r\n    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};\r\n  }\r\n\r\n  function getLineStyles(cm, line, updateFrontier) {\r\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\r\n      var result = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));\r\n      line.styles = result.styles;\r\n      if (result.classes) line.styleClasses = result.classes;\r\n      else if (line.styleClasses) line.styleClasses = null;\r\n      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;\r\n    }\r\n    return line.styles;\r\n  }\r\n\r\n  // Lightweight form of highlight -- proceed over this line and\r\n  // update state, but don't save a style array. Used for lines that\r\n  // aren't currently visible.\r\n  function processLine(cm, text, state, startAt) {\r\n    var mode = cm.doc.mode;\r\n    var stream = new StringStream(text, cm.options.tabSize);\r\n    stream.start = stream.pos = startAt || 0;\r\n    if (text == \"\") callBlankLine(mode, state);\r\n    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {\r\n      readToken(mode, stream, state);\r\n      stream.start = stream.pos;\r\n    }\r\n  }\r\n\r\n  // Convert a style as returned by a mode (either null, or a string\r\n  // containing one or more styles) to a CSS style. This is cached,\r\n  // and also looks for line-wide styles.\r\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\r\n  function interpretTokenStyle(style, options) {\r\n    if (!style || /^\\s*$/.test(style)) return null;\r\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\r\n    return cache[style] ||\r\n      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"));\r\n  }\r\n\r\n  // Render the DOM representation of the text of a line. Also builds\r\n  // up a 'line map', which points at the DOM nodes that represent\r\n  // specific stretches of text, and is used by the measuring code.\r\n  // The returned object contains the DOM node, this map, and\r\n  // information about line-wide styles that were set by the mode.\r\n  function buildLineContent(cm, lineView) {\r\n    // The padding-right forces the element to have a 'border', which\r\n    // is needed on Webkit to be able to get line-level bounding\r\n    // rectangles for it (in measureChar).\r\n    var content = elt(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\r\n    var builder = {pre: elt(\"pre\", [content]), content: content,\r\n                   col: 0, pos: 0, cm: cm,\r\n                   splitSpaces: (ie || webkit) && cm.getOption(\"lineWrapping\")};\r\n    lineView.measure = {};\r\n\r\n    // Iterate over the logical lines that make up this visual line.\r\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\r\n      var line = i ? lineView.rest[i - 1] : lineView.line, order;\r\n      builder.pos = 0;\r\n      builder.addToken = buildToken;\r\n      // Optionally wire in some hacks into the token-rendering\r\n      // algorithm, to deal with browser quirks.\r\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))\r\n        builder.addToken = buildTokenBadBidi(builder.addToken, order);\r\n      builder.map = [];\r\n      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\r\n      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\r\n      if (line.styleClasses) {\r\n        if (line.styleClasses.bgClass)\r\n          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\");\r\n        if (line.styleClasses.textClass)\r\n          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\");\r\n      }\r\n\r\n      // Ensure at least a single node is present, for measuring.\r\n      if (builder.map.length == 0)\r\n        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\r\n\r\n      // Store the map and a cache object for the current logical line\r\n      if (i == 0) {\r\n        lineView.measure.map = builder.map;\r\n        lineView.measure.cache = {};\r\n      } else {\r\n        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\r\n        (lineView.measure.caches || (lineView.measure.caches = [])).push({});\r\n      }\r\n    }\r\n\r\n    // See issue #2901\r\n    if (webkit && /\\bcm-tab\\b/.test(builder.content.lastChild.className))\r\n      builder.content.className = \"cm-tab-wrap-hack\";\r\n\r\n    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\r\n    if (builder.pre.className)\r\n      builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\");\r\n\r\n    return builder;\r\n  }\r\n\r\n  function defaultSpecialCharPlaceholder(ch) {\r\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\r\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\r\n    token.setAttribute(\"aria-label\", token.title);\r\n    return token;\r\n  }\r\n\r\n  // Build up the DOM representation for a single token, and add it to\r\n  // the line map. Takes care to render special characters separately.\r\n  function buildToken(builder, text, style, startStyle, endStyle, title, css) {\r\n    if (!text) return;\r\n    var displayText = builder.splitSpaces ? text.replace(/ {3,}/g, splitSpaces) : text;\r\n    var special = builder.cm.state.specialChars, mustWrap = false;\r\n    if (!special.test(text)) {\r\n      builder.col += text.length;\r\n      var content = document.createTextNode(displayText);\r\n      builder.map.push(builder.pos, builder.pos + text.length, content);\r\n      if (ie && ie_version < 9) mustWrap = true;\r\n      builder.pos += text.length;\r\n    } else {\r\n      var content = document.createDocumentFragment(), pos = 0;\r\n      while (true) {\r\n        special.lastIndex = pos;\r\n        var m = special.exec(text);\r\n        var skipped = m ? m.index - pos : text.length - pos;\r\n        if (skipped) {\r\n          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\r\n          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\r\n          else content.appendChild(txt);\r\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\r\n          builder.col += skipped;\r\n          builder.pos += skipped;\r\n        }\r\n        if (!m) break;\r\n        pos += skipped + 1;\r\n        if (m[0] == \"\\t\") {\r\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\r\n          var txt = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\r\n          txt.setAttribute(\"role\", \"presentation\");\r\n          txt.setAttribute(\"cm-text\", \"\\t\");\r\n          builder.col += tabWidth;\r\n        } else {\r\n          var txt = builder.cm.options.specialCharPlaceholder(m[0]);\r\n          txt.setAttribute(\"cm-text\", m[0]);\r\n          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\r\n          else content.appendChild(txt);\r\n          builder.col += 1;\r\n        }\r\n        builder.map.push(builder.pos, builder.pos + 1, txt);\r\n        builder.pos++;\r\n      }\r\n    }\r\n    if (style || startStyle || endStyle || mustWrap || css) {\r\n      var fullStyle = style || \"\";\r\n      if (startStyle) fullStyle += startStyle;\r\n      if (endStyle) fullStyle += endStyle;\r\n      var token = elt(\"span\", [content], fullStyle, css);\r\n      if (title) token.title = title;\r\n      return builder.content.appendChild(token);\r\n    }\r\n    builder.content.appendChild(content);\r\n  }\r\n\r\n  function splitSpaces(old) {\r\n    var out = \" \";\r\n    for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? \" \" : \"\\u00a0\";\r\n    out += \" \";\r\n    return out;\r\n  }\r\n\r\n  // Work around nonsense dimensions being reported for stretches of\r\n  // right-to-left text.\r\n  function buildTokenBadBidi(inner, order) {\r\n    return function(builder, text, style, startStyle, endStyle, title, css) {\r\n      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\r\n      var start = builder.pos, end = start + text.length;\r\n      for (;;) {\r\n        // Find the part that overlaps with the start of this text\r\n        for (var i = 0; i < order.length; i++) {\r\n          var part = order[i];\r\n          if (part.to > start && part.from <= start) break;\r\n        }\r\n        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);\r\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\r\n        startStyle = null;\r\n        text = text.slice(part.to - start);\r\n        start = part.to;\r\n      }\r\n    };\r\n  }\r\n\r\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\r\n    var widget = !ignoreWidget && marker.widgetNode;\r\n    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);\r\n    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\r\n      if (!widget)\r\n        widget = builder.content.appendChild(document.createElement(\"span\"));\r\n      widget.setAttribute(\"cm-marker\", marker.id);\r\n    }\r\n    if (widget) {\r\n      builder.cm.display.input.setUneditable(widget);\r\n      builder.content.appendChild(widget);\r\n    }\r\n    builder.pos += size;\r\n  }\r\n\r\n  // Outputs a number of spans to make up a line, taking highlighting\r\n  // and marked text into account.\r\n  function insertLineContent(line, builder, styles) {\r\n    var spans = line.markedSpans, allText = line.text, at = 0;\r\n    if (!spans) {\r\n      for (var i = 1; i < styles.length; i+=2)\r\n        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));\r\n      return;\r\n    }\r\n\r\n    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\r\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\r\n    for (;;) {\r\n      if (nextChange == pos) { // Update current marker set\r\n        spanStyle = spanEndStyle = spanStartStyle = title = css = \"\";\r\n        collapsed = null; nextChange = Infinity;\r\n        var foundBookmarks = [];\r\n        for (var j = 0; j < spans.length; ++j) {\r\n          var sp = spans[j], m = sp.marker;\r\n          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {\r\n            if (sp.to != null && nextChange > sp.to) { nextChange = sp.to; spanEndStyle = \"\"; }\r\n            if (m.className) spanStyle += \" \" + m.className;\r\n            if (m.css) css = m.css;\r\n            if (m.startStyle && sp.from == pos) spanStartStyle += \" \" + m.startStyle;\r\n            if (m.endStyle && sp.to == nextChange) spanEndStyle += \" \" + m.endStyle;\r\n            if (m.title && !title) title = m.title;\r\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\r\n              collapsed = sp;\r\n          } else if (sp.from > pos && nextChange > sp.from) {\r\n            nextChange = sp.from;\r\n          }\r\n          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) foundBookmarks.push(m);\r\n        }\r\n        if (collapsed && (collapsed.from || 0) == pos) {\r\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\r\n                             collapsed.marker, collapsed.from == null);\r\n          if (collapsed.to == null) return;\r\n        }\r\n        if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j)\r\n          buildCollapsedSpan(builder, 0, foundBookmarks[j]);\r\n      }\r\n      if (pos >= len) break;\r\n\r\n      var upto = Math.min(len, nextChange);\r\n      while (true) {\r\n        if (text) {\r\n          var end = pos + text.length;\r\n          if (!collapsed) {\r\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\r\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\r\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title, css);\r\n          }\r\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\r\n          pos = end;\r\n          spanStartStyle = \"\";\r\n        }\r\n        text = allText.slice(at, at = styles[i++]);\r\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\r\n      }\r\n    }\r\n  }\r\n\r\n  // DOCUMENT DATA STRUCTURE\r\n\r\n  // By default, updates that start and end at the beginning of a line\r\n  // are treated specially, in order to make the association of line\r\n  // widgets and marker elements with the text behave more intuitive.\r\n  function isWholeLineUpdate(doc, change) {\r\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\r\n      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);\r\n  }\r\n\r\n  // Perform a change on the document data structure.\r\n  function updateDoc(doc, change, markedSpans, estimateHeight) {\r\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}\r\n    function update(line, text, spans) {\r\n      updateLine(line, text, spans, estimateHeight);\r\n      signalLater(line, \"change\", line, change);\r\n    }\r\n    function linesFor(start, end) {\r\n      for (var i = start, result = []; i < end; ++i)\r\n        result.push(new Line(text[i], spansFor(i), estimateHeight));\r\n      return result;\r\n    }\r\n\r\n    var from = change.from, to = change.to, text = change.text;\r\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\r\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\r\n\r\n    // Adjust the line structure\r\n    if (change.full) {\r\n      doc.insert(0, linesFor(0, text.length));\r\n      doc.remove(text.length, doc.size - text.length);\r\n    } else if (isWholeLineUpdate(doc, change)) {\r\n      // This is a whole-line replace. Treated specially to make\r\n      // sure line objects move the way they are supposed to.\r\n      var added = linesFor(0, text.length - 1);\r\n      update(lastLine, lastLine.text, lastSpans);\r\n      if (nlines) doc.remove(from.line, nlines);\r\n      if (added.length) doc.insert(from.line, added);\r\n    } else if (firstLine == lastLine) {\r\n      if (text.length == 1) {\r\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\r\n      } else {\r\n        var added = linesFor(1, text.length - 1);\r\n        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\r\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\r\n        doc.insert(from.line + 1, added);\r\n      }\r\n    } else if (text.length == 1) {\r\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\r\n      doc.remove(from.line + 1, nlines);\r\n    } else {\r\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\r\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\r\n      var added = linesFor(1, text.length - 1);\r\n      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\r\n      doc.insert(from.line + 1, added);\r\n    }\r\n\r\n    signalLater(doc, \"change\", doc, change);\r\n  }\r\n\r\n  // The document is represented as a BTree consisting of leaves, with\r\n  // chunk of lines in them, and branches, with up to ten leaves or\r\n  // other branch nodes below them. The top node is always a branch\r\n  // node, and is the document object itself (meaning it has\r\n  // additional methods and properties).\r\n  //\r\n  // All nodes have parent links. The tree is used both to go from\r\n  // line numbers to line objects, and to go from objects to numbers.\r\n  // It also indexes by height, and is used to convert between height\r\n  // and line object, and to find the total height of the document.\r\n  //\r\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\r\n\r\n  function LeafChunk(lines) {\r\n    this.lines = lines;\r\n    this.parent = null;\r\n    for (var i = 0, height = 0; i < lines.length; ++i) {\r\n      lines[i].parent = this;\r\n      height += lines[i].height;\r\n    }\r\n    this.height = height;\r\n  }\r\n\r\n  LeafChunk.prototype = {\r\n    chunkSize: function() { return this.lines.length; },\r\n    // Remove the n lines at offset 'at'.\r\n    removeInner: function(at, n) {\r\n      for (var i = at, e = at + n; i < e; ++i) {\r\n        var line = this.lines[i];\r\n        this.height -= line.height;\r\n        cleanUpLine(line);\r\n        signalLater(line, \"delete\");\r\n      }\r\n      this.lines.splice(at, n);\r\n    },\r\n    // Helper used to collapse a small branch into a single leaf.\r\n    collapse: function(lines) {\r\n      lines.push.apply(lines, this.lines);\r\n    },\r\n    // Insert the given array of lines at offset 'at', count them as\r\n    // having the given height.\r\n    insertInner: function(at, lines, height) {\r\n      this.height += height;\r\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\r\n      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;\r\n    },\r\n    // Used to iterate over a part of the tree.\r\n    iterN: function(at, n, op) {\r\n      for (var e = at + n; at < e; ++at)\r\n        if (op(this.lines[at])) return true;\r\n    }\r\n  };\r\n\r\n  function BranchChunk(children) {\r\n    this.children = children;\r\n    var size = 0, height = 0;\r\n    for (var i = 0; i < children.length; ++i) {\r\n      var ch = children[i];\r\n      size += ch.chunkSize(); height += ch.height;\r\n      ch.parent = this;\r\n    }\r\n    this.size = size;\r\n    this.height = height;\r\n    this.parent = null;\r\n  }\r\n\r\n  BranchChunk.prototype = {\r\n    chunkSize: function() { return this.size; },\r\n    removeInner: function(at, n) {\r\n      this.size -= n;\r\n      for (var i = 0; i < this.children.length; ++i) {\r\n        var child = this.children[i], sz = child.chunkSize();\r\n        if (at < sz) {\r\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\r\n          child.removeInner(at, rm);\r\n          this.height -= oldHeight - child.height;\r\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\r\n          if ((n -= rm) == 0) break;\r\n          at = 0;\r\n        } else at -= sz;\r\n      }\r\n      // If the result is smaller than 25 lines, ensure that it is a\r\n      // single leaf node.\r\n      if (this.size - n < 25 &&\r\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\r\n        var lines = [];\r\n        this.collapse(lines);\r\n        this.children = [new LeafChunk(lines)];\r\n        this.children[0].parent = this;\r\n      }\r\n    },\r\n    collapse: function(lines) {\r\n      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);\r\n    },\r\n    insertInner: function(at, lines, height) {\r\n      this.size += lines.length;\r\n      this.height += height;\r\n      for (var i = 0; i < this.children.length; ++i) {\r\n        var child = this.children[i], sz = child.chunkSize();\r\n        if (at <= sz) {\r\n          child.insertInner(at, lines, height);\r\n          if (child.lines && child.lines.length > 50) {\r\n            while (child.lines.length > 50) {\r\n              var spilled = child.lines.splice(child.lines.length - 25, 25);\r\n              var newleaf = new LeafChunk(spilled);\r\n              child.height -= newleaf.height;\r\n              this.children.splice(i + 1, 0, newleaf);\r\n              newleaf.parent = this;\r\n            }\r\n            this.maybeSpill();\r\n          }\r\n          break;\r\n        }\r\n        at -= sz;\r\n      }\r\n    },\r\n    // When a node has grown, check whether it should be split.\r\n    maybeSpill: function() {\r\n      if (this.children.length <= 10) return;\r\n      var me = this;\r\n      do {\r\n        var spilled = me.children.splice(me.children.length - 5, 5);\r\n        var sibling = new BranchChunk(spilled);\r\n        if (!me.parent) { // Become the parent node\r\n          var copy = new BranchChunk(me.children);\r\n          copy.parent = me;\r\n          me.children = [copy, sibling];\r\n          me = copy;\r\n        } else {\r\n          me.size -= sibling.size;\r\n          me.height -= sibling.height;\r\n          var myIndex = indexOf(me.parent.children, me);\r\n          me.parent.children.splice(myIndex + 1, 0, sibling);\r\n        }\r\n        sibling.parent = me.parent;\r\n      } while (me.children.length > 10);\r\n      me.parent.maybeSpill();\r\n    },\r\n    iterN: function(at, n, op) {\r\n      for (var i = 0; i < this.children.length; ++i) {\r\n        var child = this.children[i], sz = child.chunkSize();\r\n        if (at < sz) {\r\n          var used = Math.min(n, sz - at);\r\n          if (child.iterN(at, used, op)) return true;\r\n          if ((n -= used) == 0) break;\r\n          at = 0;\r\n        } else at -= sz;\r\n      }\r\n    }\r\n  };\r\n\r\n  var nextDocId = 0;\r\n  var Doc = CodeMirror.Doc = function(text, mode, firstLine) {\r\n    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);\r\n    if (firstLine == null) firstLine = 0;\r\n\r\n    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\r\n    this.first = firstLine;\r\n    this.scrollTop = this.scrollLeft = 0;\r\n    this.cantEdit = false;\r\n    this.cleanGeneration = 1;\r\n    this.frontier = firstLine;\r\n    var start = Pos(firstLine, 0);\r\n    this.sel = simpleSelection(start);\r\n    this.history = new History(null);\r\n    this.id = ++nextDocId;\r\n    this.modeOption = mode;\r\n\r\n    if (typeof text == \"string\") text = splitLines(text);\r\n    updateDoc(this, {from: start, to: start, text: text});\r\n    setSelection(this, simpleSelection(start), sel_dontScroll);\r\n  };\r\n\r\n  Doc.prototype = createObj(BranchChunk.prototype, {\r\n    constructor: Doc,\r\n    // Iterate over the document. Supports two forms -- with only one\r\n    // argument, it calls that for each line in the document. With\r\n    // three, it iterates over the range given by the first two (with\r\n    // the second being non-inclusive).\r\n    iter: function(from, to, op) {\r\n      if (op) this.iterN(from - this.first, to - from, op);\r\n      else this.iterN(this.first, this.first + this.size, from);\r\n    },\r\n\r\n    // Non-public interface for adding and removing lines.\r\n    insert: function(at, lines) {\r\n      var height = 0;\r\n      for (var i = 0; i < lines.length; ++i) height += lines[i].height;\r\n      this.insertInner(at - this.first, lines, height);\r\n    },\r\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\r\n\r\n    // From here, the methods are part of the public interface. Most\r\n    // are also available from CodeMirror (editor) instances.\r\n\r\n    getValue: function(lineSep) {\r\n      var lines = getLines(this, this.first, this.first + this.size);\r\n      if (lineSep === false) return lines;\r\n      return lines.join(lineSep || \"\\n\");\r\n    },\r\n    setValue: docMethodOp(function(code) {\r\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\r\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\r\n                        text: splitLines(code), origin: \"setValue\", full: true}, true);\r\n      setSelection(this, simpleSelection(top));\r\n    }),\r\n    replaceRange: function(code, from, to, origin) {\r\n      from = clipPos(this, from);\r\n      to = to ? clipPos(this, to) : from;\r\n      replaceRange(this, code, from, to, origin);\r\n    },\r\n    getRange: function(from, to, lineSep) {\r\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\r\n      if (lineSep === false) return lines;\r\n      return lines.join(lineSep || \"\\n\");\r\n    },\r\n\r\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\r\n\r\n    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},\r\n    getLineNumber: function(line) {return lineNo(line);},\r\n\r\n    getLineHandleVisualStart: function(line) {\r\n      if (typeof line == \"number\") line = getLine(this, line);\r\n      return visualLine(line);\r\n    },\r\n\r\n    lineCount: function() {return this.size;},\r\n    firstLine: function() {return this.first;},\r\n    lastLine: function() {return this.first + this.size - 1;},\r\n\r\n    clipPos: function(pos) {return clipPos(this, pos);},\r\n\r\n    getCursor: function(start) {\r\n      var range = this.sel.primary(), pos;\r\n      if (start == null || start == \"head\") pos = range.head;\r\n      else if (start == \"anchor\") pos = range.anchor;\r\n      else if (start == \"end\" || start == \"to\" || start === false) pos = range.to();\r\n      else pos = range.from();\r\n      return pos;\r\n    },\r\n    listSelections: function() { return this.sel.ranges; },\r\n    somethingSelected: function() {return this.sel.somethingSelected();},\r\n\r\n    setCursor: docMethodOp(function(line, ch, options) {\r\n      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\r\n    }),\r\n    setSelection: docMethodOp(function(anchor, head, options) {\r\n      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\r\n    }),\r\n    extendSelection: docMethodOp(function(head, other, options) {\r\n      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\r\n    }),\r\n    extendSelections: docMethodOp(function(heads, options) {\r\n      extendSelections(this, clipPosArray(this, heads, options));\r\n    }),\r\n    extendSelectionsBy: docMethodOp(function(f, options) {\r\n      extendSelections(this, map(this.sel.ranges, f), options);\r\n    }),\r\n    setSelections: docMethodOp(function(ranges, primary, options) {\r\n      if (!ranges.length) return;\r\n      for (var i = 0, out = []; i < ranges.length; i++)\r\n        out[i] = new Range(clipPos(this, ranges[i].anchor),\r\n                           clipPos(this, ranges[i].head));\r\n      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);\r\n      setSelection(this, normalizeSelection(out, primary), options);\r\n    }),\r\n    addSelection: docMethodOp(function(anchor, head, options) {\r\n      var ranges = this.sel.ranges.slice(0);\r\n      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\r\n      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\r\n    }),\r\n\r\n    getSelection: function(lineSep) {\r\n      var ranges = this.sel.ranges, lines;\r\n      for (var i = 0; i < ranges.length; i++) {\r\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\r\n        lines = lines ? lines.concat(sel) : sel;\r\n      }\r\n      if (lineSep === false) return lines;\r\n      else return lines.join(lineSep || \"\\n\");\r\n    },\r\n    getSelections: function(lineSep) {\r\n      var parts = [], ranges = this.sel.ranges;\r\n      for (var i = 0; i < ranges.length; i++) {\r\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\r\n        if (lineSep !== false) sel = sel.join(lineSep || \"\\n\");\r\n        parts[i] = sel;\r\n      }\r\n      return parts;\r\n    },\r\n    replaceSelection: function(code, collapse, origin) {\r\n      var dup = [];\r\n      for (var i = 0; i < this.sel.ranges.length; i++)\r\n        dup[i] = code;\r\n      this.replaceSelections(dup, collapse, origin || \"+input\");\r\n    },\r\n    replaceSelections: docMethodOp(function(code, collapse, origin) {\r\n      var changes = [], sel = this.sel;\r\n      for (var i = 0; i < sel.ranges.length; i++) {\r\n        var range = sel.ranges[i];\r\n        changes[i] = {from: range.from(), to: range.to(), text: splitLines(code[i]), origin: origin};\r\n      }\r\n      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\r\n      for (var i = changes.length - 1; i >= 0; i--)\r\n        makeChange(this, changes[i]);\r\n      if (newSel) setSelectionReplaceHistory(this, newSel);\r\n      else if (this.cm) ensureCursorVisible(this.cm);\r\n    }),\r\n    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\r\n    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\r\n    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\r\n    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\r\n\r\n    setExtending: function(val) {this.extend = val;},\r\n    getExtending: function() {return this.extend;},\r\n\r\n    historySize: function() {\r\n      var hist = this.history, done = 0, undone = 0;\r\n      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;\r\n      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;\r\n      return {undo: done, redo: undone};\r\n    },\r\n    clearHistory: function() {this.history = new History(this.history.maxGeneration);},\r\n\r\n    markClean: function() {\r\n      this.cleanGeneration = this.changeGeneration(true);\r\n    },\r\n    changeGeneration: function(forceSplit) {\r\n      if (forceSplit)\r\n        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\r\n      return this.history.generation;\r\n    },\r\n    isClean: function (gen) {\r\n      return this.history.generation == (gen || this.cleanGeneration);\r\n    },\r\n\r\n    getHistory: function() {\r\n      return {done: copyHistoryArray(this.history.done),\r\n              undone: copyHistoryArray(this.history.undone)};\r\n    },\r\n    setHistory: function(histData) {\r\n      var hist = this.history = new History(this.history.maxGeneration);\r\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\r\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\r\n    },\r\n\r\n    addLineClass: docMethodOp(function(handle, where, cls) {\r\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\r\n        var prop = where == \"text\" ? \"textClass\"\r\n                 : where == \"background\" ? \"bgClass\"\r\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\r\n        if (!line[prop]) line[prop] = cls;\r\n        else if (classTest(cls).test(line[prop])) return false;\r\n        else line[prop] += \" \" + cls;\r\n        return true;\r\n      });\r\n    }),\r\n    removeLineClass: docMethodOp(function(handle, where, cls) {\r\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\r\n        var prop = where == \"text\" ? \"textClass\"\r\n                 : where == \"background\" ? \"bgClass\"\r\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\r\n        var cur = line[prop];\r\n        if (!cur) return false;\r\n        else if (cls == null) line[prop] = null;\r\n        else {\r\n          var found = cur.match(classTest(cls));\r\n          if (!found) return false;\r\n          var end = found.index + found[0].length;\r\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\r\n        }\r\n        return true;\r\n      });\r\n    }),\r\n\r\n    addLineWidget: docMethodOp(function(handle, node, options) {\r\n      return addLineWidget(this, handle, node, options);\r\n    }),\r\n    removeLineWidget: function(widget) { widget.clear(); },\r\n\r\n    markText: function(from, to, options) {\r\n      return markText(this, clipPos(this, from), clipPos(this, to), options, \"range\");\r\n    },\r\n    setBookmark: function(pos, options) {\r\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\r\n                      insertLeft: options && options.insertLeft,\r\n                      clearWhenEmpty: false, shared: options && options.shared,\r\n                      handleMouseEvents: options && options.handleMouseEvents};\r\n      pos = clipPos(this, pos);\r\n      return markText(this, pos, pos, realOpts, \"bookmark\");\r\n    },\r\n    findMarksAt: function(pos) {\r\n      pos = clipPos(this, pos);\r\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\r\n      if (spans) for (var i = 0; i < spans.length; ++i) {\r\n        var span = spans[i];\r\n        if ((span.from == null || span.from <= pos.ch) &&\r\n            (span.to == null || span.to >= pos.ch))\r\n          markers.push(span.marker.parent || span.marker);\r\n      }\r\n      return markers;\r\n    },\r\n    findMarks: function(from, to, filter) {\r\n      from = clipPos(this, from); to = clipPos(this, to);\r\n      var found = [], lineNo = from.line;\r\n      this.iter(from.line, to.line + 1, function(line) {\r\n        var spans = line.markedSpans;\r\n        if (spans) for (var i = 0; i < spans.length; i++) {\r\n          var span = spans[i];\r\n          if (!(lineNo == from.line && from.ch > span.to ||\r\n                span.from == null && lineNo != from.line||\r\n                lineNo == to.line && span.from > to.ch) &&\r\n              (!filter || filter(span.marker)))\r\n            found.push(span.marker.parent || span.marker);\r\n        }\r\n        ++lineNo;\r\n      });\r\n      return found;\r\n    },\r\n    getAllMarks: function() {\r\n      var markers = [];\r\n      this.iter(function(line) {\r\n        var sps = line.markedSpans;\r\n        if (sps) for (var i = 0; i < sps.length; ++i)\r\n          if (sps[i].from != null) markers.push(sps[i].marker);\r\n      });\r\n      return markers;\r\n    },\r\n\r\n    posFromIndex: function(off) {\r\n      var ch, lineNo = this.first;\r\n      this.iter(function(line) {\r\n        var sz = line.text.length + 1;\r\n        if (sz > off) { ch = off; return true; }\r\n        off -= sz;\r\n        ++lineNo;\r\n      });\r\n      return clipPos(this, Pos(lineNo, ch));\r\n    },\r\n    indexFromPos: function (coords) {\r\n      coords = clipPos(this, coords);\r\n      var index = coords.ch;\r\n      if (coords.line < this.first || coords.ch < 0) return 0;\r\n      this.iter(this.first, coords.line, function (line) {\r\n        index += line.text.length + 1;\r\n      });\r\n      return index;\r\n    },\r\n\r\n    copy: function(copyHistory) {\r\n      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);\r\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\r\n      doc.sel = this.sel;\r\n      doc.extend = false;\r\n      if (copyHistory) {\r\n        doc.history.undoDepth = this.history.undoDepth;\r\n        doc.setHistory(this.getHistory());\r\n      }\r\n      return doc;\r\n    },\r\n\r\n    linkedDoc: function(options) {\r\n      if (!options) options = {};\r\n      var from = this.first, to = this.first + this.size;\r\n      if (options.from != null && options.from > from) from = options.from;\r\n      if (options.to != null && options.to < to) to = options.to;\r\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);\r\n      if (options.sharedHist) copy.history = this.history;\r\n      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\r\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\r\n      copySharedMarkers(copy, findSharedMarkers(this));\r\n      return copy;\r\n    },\r\n    unlinkDoc: function(other) {\r\n      if (other instanceof CodeMirror) other = other.doc;\r\n      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\r\n        var link = this.linked[i];\r\n        if (link.doc != other) continue;\r\n        this.linked.splice(i, 1);\r\n        other.unlinkDoc(this);\r\n        detachSharedMarkers(findSharedMarkers(this));\r\n        break;\r\n      }\r\n      // If the histories were shared, split them again\r\n      if (other.history == this.history) {\r\n        var splitIds = [other.id];\r\n        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);\r\n        other.history = new History(null);\r\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\r\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\r\n      }\r\n    },\r\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\r\n\r\n    getMode: function() {return this.mode;},\r\n    getEditor: function() {return this.cm;}\r\n  });\r\n\r\n  // Public alias.\r\n  Doc.prototype.eachLine = Doc.prototype.iter;\r\n\r\n  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\r\n  var dontDelegate = \"iter insert remove copy getEditor\".split(\" \");\r\n  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\r\n    CodeMirror.prototype[prop] = (function(method) {\r\n      return function() {return method.apply(this.doc, arguments);};\r\n    })(Doc.prototype[prop]);\r\n\r\n  eventMixin(Doc);\r\n\r\n  // Call f for all linked documents.\r\n  function linkedDocs(doc, f, sharedHistOnly) {\r\n    function propagate(doc, skip, sharedHist) {\r\n      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\r\n        var rel = doc.linked[i];\r\n        if (rel.doc == skip) continue;\r\n        var shared = sharedHist && rel.sharedHist;\r\n        if (sharedHistOnly && !shared) continue;\r\n        f(rel.doc, shared);\r\n        propagate(rel.doc, doc, shared);\r\n      }\r\n    }\r\n    propagate(doc, null, true);\r\n  }\r\n\r\n  // Attach a document to an editor.\r\n  function attachDoc(cm, doc) {\r\n    if (doc.cm) throw new Error(\"This document is already in use.\");\r\n    cm.doc = doc;\r\n    doc.cm = cm;\r\n    estimateLineHeights(cm);\r\n    loadMode(cm);\r\n    if (!cm.options.lineWrapping) findMaxLine(cm);\r\n    cm.options.mode = doc.modeOption;\r\n    regChange(cm);\r\n  }\r\n\r\n  // LINE UTILITIES\r\n\r\n  // Find the line object corresponding to the given line number.\r\n  function getLine(doc, n) {\r\n    n -= doc.first;\r\n    if (n < 0 || n >= doc.size) throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\");\r\n    for (var chunk = doc; !chunk.lines;) {\r\n      for (var i = 0;; ++i) {\r\n        var child = chunk.children[i], sz = child.chunkSize();\r\n        if (n < sz) { chunk = child; break; }\r\n        n -= sz;\r\n      }\r\n    }\r\n    return chunk.lines[n];\r\n  }\r\n\r\n  // Get the part of a document between two positions, as an array of\r\n  // strings.\r\n  function getBetween(doc, start, end) {\r\n    var out = [], n = start.line;\r\n    doc.iter(start.line, end.line + 1, function(line) {\r\n      var text = line.text;\r\n      if (n == end.line) text = text.slice(0, end.ch);\r\n      if (n == start.line) text = text.slice(start.ch);\r\n      out.push(text);\r\n      ++n;\r\n    });\r\n    return out;\r\n  }\r\n  // Get the lines between from and to, as array of strings.\r\n  function getLines(doc, from, to) {\r\n    var out = [];\r\n    doc.iter(from, to, function(line) { out.push(line.text); });\r\n    return out;\r\n  }\r\n\r\n  // Update the height of a line, propagating the height change\r\n  // upwards to parent nodes.\r\n  function updateLineHeight(line, height) {\r\n    var diff = height - line.height;\r\n    if (diff) for (var n = line; n; n = n.parent) n.height += diff;\r\n  }\r\n\r\n  // Given a line object, find its line number by walking up through\r\n  // its parent links.\r\n  function lineNo(line) {\r\n    if (line.parent == null) return null;\r\n    var cur = line.parent, no = indexOf(cur.lines, line);\r\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\r\n      for (var i = 0;; ++i) {\r\n        if (chunk.children[i] == cur) break;\r\n        no += chunk.children[i].chunkSize();\r\n      }\r\n    }\r\n    return no + cur.first;\r\n  }\r\n\r\n  // Find the line at the given vertical position, using the height\r\n  // information in the document tree.\r\n  function lineAtHeight(chunk, h) {\r\n    var n = chunk.first;\r\n    outer: do {\r\n      for (var i = 0; i < chunk.children.length; ++i) {\r\n        var child = chunk.children[i], ch = child.height;\r\n        if (h < ch) { chunk = child; continue outer; }\r\n        h -= ch;\r\n        n += child.chunkSize();\r\n      }\r\n      return n;\r\n    } while (!chunk.lines);\r\n    for (var i = 0; i < chunk.lines.length; ++i) {\r\n      var line = chunk.lines[i], lh = line.height;\r\n      if (h < lh) break;\r\n      h -= lh;\r\n    }\r\n    return n + i;\r\n  }\r\n\r\n\r\n  // Find the height above the given line.\r\n  function heightAtLine(lineObj) {\r\n    lineObj = visualLine(lineObj);\r\n\r\n    var h = 0, chunk = lineObj.parent;\r\n    for (var i = 0; i < chunk.lines.length; ++i) {\r\n      var line = chunk.lines[i];\r\n      if (line == lineObj) break;\r\n      else h += line.height;\r\n    }\r\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\r\n      for (var i = 0; i < p.children.length; ++i) {\r\n        var cur = p.children[i];\r\n        if (cur == chunk) break;\r\n        else h += cur.height;\r\n      }\r\n    }\r\n    return h;\r\n  }\r\n\r\n  // Get the bidi ordering for the given line (and cache it). Returns\r\n  // false for lines that are fully left-to-right, and an array of\r\n  // BidiSpan objects otherwise.\r\n  function getOrder(line) {\r\n    var order = line.order;\r\n    if (order == null) order = line.order = bidiOrdering(line.text);\r\n    return order;\r\n  }\r\n\r\n  // HISTORY\r\n\r\n  function History(startGen) {\r\n    // Arrays of change events and selections. Doing something adds an\r\n    // event to done and clears undo. Undoing moves events from done\r\n    // to undone, redoing moves them in the other direction.\r\n    this.done = []; this.undone = [];\r\n    this.undoDepth = Infinity;\r\n    // Used to track when changes can be merged into a single undo\r\n    // event\r\n    this.lastModTime = this.lastSelTime = 0;\r\n    this.lastOp = this.lastSelOp = null;\r\n    this.lastOrigin = this.lastSelOrigin = null;\r\n    // Used by the isClean() method\r\n    this.generation = this.maxGeneration = startGen || 1;\r\n  }\r\n\r\n  // Create a history change event from an updateDoc-style change\r\n  // object.\r\n  function historyChangeFromChange(doc, change) {\r\n    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\r\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\r\n    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);\r\n    return histChange;\r\n  }\r\n\r\n  // Pop all selection events off the end of a history array. Stop at\r\n  // a change event.\r\n  function clearSelectionEvents(array) {\r\n    while (array.length) {\r\n      var last = lst(array);\r\n      if (last.ranges) array.pop();\r\n      else break;\r\n    }\r\n  }\r\n\r\n  // Find the top change event in the history. Pop off selection\r\n  // events that are in the way.\r\n  function lastChangeEvent(hist, force) {\r\n    if (force) {\r\n      clearSelectionEvents(hist.done);\r\n      return lst(hist.done);\r\n    } else if (hist.done.length && !lst(hist.done).ranges) {\r\n      return lst(hist.done);\r\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\r\n      hist.done.pop();\r\n      return lst(hist.done);\r\n    }\r\n  }\r\n\r\n  // Register a change in the history. Merges changes that are within\r\n  // a single operation, ore are close together with an origin that\r\n  // allows merging (starting with \"+\") into a single event.\r\n  function addChangeToHistory(doc, change, selAfter, opId) {\r\n    var hist = doc.history;\r\n    hist.undone.length = 0;\r\n    var time = +new Date, cur;\r\n\r\n    if ((hist.lastOp == opId ||\r\n         hist.lastOrigin == change.origin && change.origin &&\r\n         ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\r\n          change.origin.charAt(0) == \"*\")) &&\r\n        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\r\n      // Merge this change into the last event\r\n      var last = lst(cur.changes);\r\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\r\n        // Optimized case for simple insertion -- don't want to add\r\n        // new changesets for every character typed\r\n        last.to = changeEnd(change);\r\n      } else {\r\n        // Add new sub-event\r\n        cur.changes.push(historyChangeFromChange(doc, change));\r\n      }\r\n    } else {\r\n      // Can not be merged, start a new event.\r\n      var before = lst(hist.done);\r\n      if (!before || !before.ranges)\r\n        pushSelectionToHistory(doc.sel, hist.done);\r\n      cur = {changes: [historyChangeFromChange(doc, change)],\r\n             generation: hist.generation};\r\n      hist.done.push(cur);\r\n      while (hist.done.length > hist.undoDepth) {\r\n        hist.done.shift();\r\n        if (!hist.done[0].ranges) hist.done.shift();\r\n      }\r\n    }\r\n    hist.done.push(selAfter);\r\n    hist.generation = ++hist.maxGeneration;\r\n    hist.lastModTime = hist.lastSelTime = time;\r\n    hist.lastOp = hist.lastSelOp = opId;\r\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\r\n\r\n    if (!last) signal(doc, \"historyAdded\");\r\n  }\r\n\r\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\r\n    var ch = origin.charAt(0);\r\n    return ch == \"*\" ||\r\n      ch == \"+\" &&\r\n      prev.ranges.length == sel.ranges.length &&\r\n      prev.somethingSelected() == sel.somethingSelected() &&\r\n      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\r\n  }\r\n\r\n  // Called whenever the selection changes, sets the new selection as\r\n  // the pending selection in the history, and pushes the old pending\r\n  // selection into the 'done' array when it was significantly\r\n  // different (in number of selected ranges, emptiness, or time).\r\n  function addSelectionToHistory(doc, sel, opId, options) {\r\n    var hist = doc.history, origin = options && options.origin;\r\n\r\n    // A new event is started when the previous origin does not match\r\n    // the current, or the origins don't allow matching. Origins\r\n    // starting with * are always merged, those starting with + are\r\n    // merged when similar and close together in time.\r\n    if (opId == hist.lastSelOp ||\r\n        (origin && hist.lastSelOrigin == origin &&\r\n         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\r\n          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\r\n      hist.done[hist.done.length - 1] = sel;\r\n    else\r\n      pushSelectionToHistory(sel, hist.done);\r\n\r\n    hist.lastSelTime = +new Date;\r\n    hist.lastSelOrigin = origin;\r\n    hist.lastSelOp = opId;\r\n    if (options && options.clearRedo !== false)\r\n      clearSelectionEvents(hist.undone);\r\n  }\r\n\r\n  function pushSelectionToHistory(sel, dest) {\r\n    var top = lst(dest);\r\n    if (!(top && top.ranges && top.equals(sel)))\r\n      dest.push(sel);\r\n  }\r\n\r\n  // Used to store marked span information in the history.\r\n  function attachLocalSpans(doc, change, from, to) {\r\n    var existing = change[\"spans_\" + doc.id], n = 0;\r\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\r\n      if (line.markedSpans)\r\n        (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans;\r\n      ++n;\r\n    });\r\n  }\r\n\r\n  // When un/re-doing restores text containing marked spans, those\r\n  // that have been explicitly cleared should not be restored.\r\n  function removeClearedSpans(spans) {\r\n    if (!spans) return null;\r\n    for (var i = 0, out; i < spans.length; ++i) {\r\n      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\r\n      else if (out) out.push(spans[i]);\r\n    }\r\n    return !out ? spans : out.length ? out : null;\r\n  }\r\n\r\n  // Retrieve and filter the old marked spans stored in a change event.\r\n  function getOldSpans(doc, change) {\r\n    var found = change[\"spans_\" + doc.id];\r\n    if (!found) return null;\r\n    for (var i = 0, nw = []; i < change.text.length; ++i)\r\n      nw.push(removeClearedSpans(found[i]));\r\n    return nw;\r\n  }\r\n\r\n  // Used both to provide a JSON-safe object in .getHistory, and, when\r\n  // detaching a document, to split the history in two\r\n  function copyHistoryArray(events, newGroup, instantiateSel) {\r\n    for (var i = 0, copy = []; i < events.length; ++i) {\r\n      var event = events[i];\r\n      if (event.ranges) {\r\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\r\n        continue;\r\n      }\r\n      var changes = event.changes, newChanges = [];\r\n      copy.push({changes: newChanges});\r\n      for (var j = 0; j < changes.length; ++j) {\r\n        var change = changes[j], m;\r\n        newChanges.push({from: change.from, to: change.to, text: change.text});\r\n        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\\d+)$/)) {\r\n          if (indexOf(newGroup, Number(m[1])) > -1) {\r\n            lst(newChanges)[prop] = change[prop];\r\n            delete change[prop];\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return copy;\r\n  }\r\n\r\n  // Rebasing/resetting history to deal with externally-sourced changes\r\n\r\n  function rebaseHistSelSingle(pos, from, to, diff) {\r\n    if (to < pos.line) {\r\n      pos.line += diff;\r\n    } else if (from < pos.line) {\r\n      pos.line = from;\r\n      pos.ch = 0;\r\n    }\r\n  }\r\n\r\n  // Tries to rebase an array of history events given a change in the\r\n  // document. If the change touches the same lines as the event, the\r\n  // event, and everything 'behind' it, is discarded. If the change is\r\n  // before the event, the event's positions are updated. Uses a\r\n  // copy-on-write scheme for the positions, to avoid having to\r\n  // reallocate them all on every rebase, but also avoid problems with\r\n  // shared position objects being unsafely updated.\r\n  function rebaseHistArray(array, from, to, diff) {\r\n    for (var i = 0; i < array.length; ++i) {\r\n      var sub = array[i], ok = true;\r\n      if (sub.ranges) {\r\n        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\r\n        for (var j = 0; j < sub.ranges.length; j++) {\r\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\r\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\r\n        }\r\n        continue;\r\n      }\r\n      for (var j = 0; j < sub.changes.length; ++j) {\r\n        var cur = sub.changes[j];\r\n        if (to < cur.from.line) {\r\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\r\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\r\n        } else if (from <= cur.to.line) {\r\n          ok = false;\r\n          break;\r\n        }\r\n      }\r\n      if (!ok) {\r\n        array.splice(0, i + 1);\r\n        i = 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  function rebaseHist(hist, change) {\r\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\r\n    rebaseHistArray(hist.done, from, to, diff);\r\n    rebaseHistArray(hist.undone, from, to, diff);\r\n  }\r\n\r\n  // EVENT UTILITIES\r\n\r\n  // Due to the fact that we still support jurassic IE versions, some\r\n  // compatibility wrappers are needed.\r\n\r\n  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {\r\n    if (e.preventDefault) e.preventDefault();\r\n    else e.returnValue = false;\r\n  };\r\n  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {\r\n    if (e.stopPropagation) e.stopPropagation();\r\n    else e.cancelBubble = true;\r\n  };\r\n  function e_defaultPrevented(e) {\r\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\r\n  }\r\n  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};\r\n\r\n  function e_target(e) {return e.target || e.srcElement;}\r\n  function e_button(e) {\r\n    var b = e.which;\r\n    if (b == null) {\r\n      if (e.button & 1) b = 1;\r\n      else if (e.button & 2) b = 3;\r\n      else if (e.button & 4) b = 2;\r\n    }\r\n    if (mac && e.ctrlKey && b == 1) b = 3;\r\n    return b;\r\n  }\r\n\r\n  // EVENT HANDLING\r\n\r\n  // Lightweight event framework. on/off also work on DOM nodes,\r\n  // registering native DOM handlers.\r\n\r\n  var on = CodeMirror.on = function(emitter, type, f) {\r\n    if (emitter.addEventListener)\r\n      emitter.addEventListener(type, f, false);\r\n    else if (emitter.attachEvent)\r\n      emitter.attachEvent(\"on\" + type, f);\r\n    else {\r\n      var map = emitter._handlers || (emitter._handlers = {});\r\n      var arr = map[type] || (map[type] = []);\r\n      arr.push(f);\r\n    }\r\n  };\r\n\r\n  var off = CodeMirror.off = function(emitter, type, f) {\r\n    if (emitter.removeEventListener)\r\n      emitter.removeEventListener(type, f, false);\r\n    else if (emitter.detachEvent)\r\n      emitter.detachEvent(\"on\" + type, f);\r\n    else {\r\n      var arr = emitter._handlers && emitter._handlers[type];\r\n      if (!arr) return;\r\n      for (var i = 0; i < arr.length; ++i)\r\n        if (arr[i] == f) { arr.splice(i, 1); break; }\r\n    }\r\n  };\r\n\r\n  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {\r\n    var arr = emitter._handlers && emitter._handlers[type];\r\n    if (!arr) return;\r\n    var args = Array.prototype.slice.call(arguments, 2);\r\n    for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);\r\n  };\r\n\r\n  var orphanDelayedCallbacks = null;\r\n\r\n  // Often, we want to signal events at a point where we are in the\r\n  // middle of some work, but don't want the handler to start calling\r\n  // other methods on the editor, which might be in an inconsistent\r\n  // state or simply not expect any other events to happen.\r\n  // signalLater looks whether there are any handlers, and schedules\r\n  // them to be executed when the last operation ends, or, if no\r\n  // operation is active, when a timeout fires.\r\n  function signalLater(emitter, type /*, values...*/) {\r\n    var arr = emitter._handlers && emitter._handlers[type];\r\n    if (!arr) return;\r\n    var args = Array.prototype.slice.call(arguments, 2), list;\r\n    if (operationGroup) {\r\n      list = operationGroup.delayedCallbacks;\r\n    } else if (orphanDelayedCallbacks) {\r\n      list = orphanDelayedCallbacks;\r\n    } else {\r\n      list = orphanDelayedCallbacks = [];\r\n      setTimeout(fireOrphanDelayed, 0);\r\n    }\r\n    function bnd(f) {return function(){f.apply(null, args);};};\r\n    for (var i = 0; i < arr.length; ++i)\r\n      list.push(bnd(arr[i]));\r\n  }\r\n\r\n  function fireOrphanDelayed() {\r\n    var delayed = orphanDelayedCallbacks;\r\n    orphanDelayedCallbacks = null;\r\n    for (var i = 0; i < delayed.length; ++i) delayed[i]();\r\n  }\r\n\r\n  // The DOM events that CodeMirror handles can be overridden by\r\n  // registering a (non-DOM) handler on the editor for the event name,\r\n  // and preventDefault-ing the event in that handler.\r\n  function signalDOMEvent(cm, e, override) {\r\n    if (typeof e == \"string\")\r\n      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};\r\n    signal(cm, override || e.type, cm, e);\r\n    return e_defaultPrevented(e) || e.codemirrorIgnore;\r\n  }\r\n\r\n  function signalCursorActivity(cm) {\r\n    var arr = cm._handlers && cm._handlers.cursorActivity;\r\n    if (!arr) return;\r\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\r\n    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)\r\n      set.push(arr[i]);\r\n  }\r\n\r\n  function hasHandler(emitter, type) {\r\n    var arr = emitter._handlers && emitter._handlers[type];\r\n    return arr && arr.length > 0;\r\n  }\r\n\r\n  // Add on and off methods to a constructor's prototype, to make\r\n  // registering events on such objects more convenient.\r\n  function eventMixin(ctor) {\r\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\r\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\r\n  }\r\n\r\n  // MISC UTILITIES\r\n\r\n  // Number of pixels added to scroller and sizer to hide scrollbar\r\n  var scrollerGap = 30;\r\n\r\n  // Returned or thrown by various protocols to signal 'I'm not\r\n  // handling this'.\r\n  var Pass = CodeMirror.Pass = {toString: function(){return \"CodeMirror.Pass\";}};\r\n\r\n  // Reused option objects for setSelection & friends\r\n  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\r\n\r\n  function Delayed() {this.id = null;}\r\n  Delayed.prototype.set = function(ms, f) {\r\n    clearTimeout(this.id);\r\n    this.id = setTimeout(f, ms);\r\n  };\r\n\r\n  // Counts the column offset in a string, taking tabs into account.\r\n  // Used mostly to find indentation.\r\n  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {\r\n    if (end == null) {\r\n      end = string.search(/[^\\s\\u00a0]/);\r\n      if (end == -1) end = string.length;\r\n    }\r\n    for (var i = startIndex || 0, n = startValue || 0;;) {\r\n      var nextTab = string.indexOf(\"\\t\", i);\r\n      if (nextTab < 0 || nextTab >= end)\r\n        return n + (end - i);\r\n      n += nextTab - i;\r\n      n += tabSize - (n % tabSize);\r\n      i = nextTab + 1;\r\n    }\r\n  };\r\n\r\n  // The inverse of countColumn -- find the offset that corresponds to\r\n  // a particular column.\r\n  function findColumn(string, goal, tabSize) {\r\n    for (var pos = 0, col = 0;;) {\r\n      var nextTab = string.indexOf(\"\\t\", pos);\r\n      if (nextTab == -1) nextTab = string.length;\r\n      var skipped = nextTab - pos;\r\n      if (nextTab == string.length || col + skipped >= goal)\r\n        return pos + Math.min(skipped, goal - col);\r\n      col += nextTab - pos;\r\n      col += tabSize - (col % tabSize);\r\n      pos = nextTab + 1;\r\n      if (col >= goal) return pos;\r\n    }\r\n  }\r\n\r\n  var spaceStrs = [\"\"];\r\n  function spaceStr(n) {\r\n    while (spaceStrs.length <= n)\r\n      spaceStrs.push(lst(spaceStrs) + \" \");\r\n    return spaceStrs[n];\r\n  }\r\n\r\n  function lst(arr) { return arr[arr.length-1]; }\r\n\r\n  var selectInput = function(node) { node.select(); };\r\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\r\n    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };\r\n  else if (ie) // Suppress mysterious IE10 errors\r\n    selectInput = function(node) { try { node.select(); } catch(_e) {} };\r\n\r\n  function indexOf(array, elt) {\r\n    for (var i = 0; i < array.length; ++i)\r\n      if (array[i] == elt) return i;\r\n    return -1;\r\n  }\r\n  function map(array, f) {\r\n    var out = [];\r\n    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);\r\n    return out;\r\n  }\r\n\r\n  function nothing() {}\r\n\r\n  function createObj(base, props) {\r\n    var inst;\r\n    if (Object.create) {\r\n      inst = Object.create(base);\r\n    } else {\r\n      nothing.prototype = base;\r\n      inst = new nothing();\r\n    }\r\n    if (props) copyObj(props, inst);\r\n    return inst;\r\n  };\r\n\r\n  function copyObj(obj, target, overwrite) {\r\n    if (!target) target = {};\r\n    for (var prop in obj)\r\n      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\r\n        target[prop] = obj[prop];\r\n    return target;\r\n  }\r\n\r\n  function bind(f) {\r\n    var args = Array.prototype.slice.call(arguments, 1);\r\n    return function(){return f.apply(null, args);};\r\n  }\r\n\r\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\r\n  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {\r\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\r\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\r\n  };\r\n  function isWordChar(ch, helper) {\r\n    if (!helper) return isWordCharBasic(ch);\r\n    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) return true;\r\n    return helper.test(ch);\r\n  }\r\n\r\n  function isEmpty(obj) {\r\n    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\r\n    return true;\r\n  }\r\n\r\n  // Extending unicode characters. A series of a non-extending char +\r\n  // any number of extending chars is treated as a single unit as far\r\n  // as editing and measuring is concerned. This is not fully correct,\r\n  // since some scripts/fonts/browsers also treat other configurations\r\n  // of code points as a group.\r\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\r\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }\r\n\r\n  // DOM UTILITIES\r\n\r\n  function elt(tag, content, className, style) {\r\n    var e = document.createElement(tag);\r\n    if (className) e.className = className;\r\n    if (style) e.style.cssText = style;\r\n    if (typeof content == \"string\") e.appendChild(document.createTextNode(content));\r\n    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\r\n    return e;\r\n  }\r\n\r\n  var range;\r\n  if (document.createRange) range = function(node, start, end, endNode) {\r\n    var r = document.createRange();\r\n    r.setEnd(endNode || node, end);\r\n    r.setStart(node, start);\r\n    return r;\r\n  };\r\n  else range = function(node, start, end) {\r\n    var r = document.body.createTextRange();\r\n    try { r.moveToElementText(node.parentNode); }\r\n    catch(e) { return r; }\r\n    r.collapse(true);\r\n    r.moveEnd(\"character\", end);\r\n    r.moveStart(\"character\", start);\r\n    return r;\r\n  };\r\n\r\n  function removeChildren(e) {\r\n    for (var count = e.childNodes.length; count > 0; --count)\r\n      e.removeChild(e.firstChild);\r\n    return e;\r\n  }\r\n\r\n  function removeChildrenAndAdd(parent, e) {\r\n    return removeChildren(parent).appendChild(e);\r\n  }\r\n\r\n  var contains = CodeMirror.contains = function(parent, child) {\r\n    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\r\n      child = child.parentNode;\r\n    if (parent.contains)\r\n      return parent.contains(child);\r\n    do {\r\n      if (child.nodeType == 11) child = child.host;\r\n      if (child == parent) return true;\r\n    } while (child = child.parentNode);\r\n  };\r\n\r\n  function activeElt() { return document.activeElement; }\r\n  // Older versions of IE throws unspecified error when touching\r\n  // document.activeElement in some cases (during loading, in iframe)\r\n  if (ie && ie_version < 11) activeElt = function() {\r\n    try { return document.activeElement; }\r\n    catch(e) { return document.body; }\r\n  };\r\n\r\n  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\"); }\r\n  var rmClass = CodeMirror.rmClass = function(node, cls) {\r\n    var current = node.className;\r\n    var match = classTest(cls).exec(current);\r\n    if (match) {\r\n      var after = current.slice(match.index + match[0].length);\r\n      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\r\n    }\r\n  };\r\n  var addClass = CodeMirror.addClass = function(node, cls) {\r\n    var current = node.className;\r\n    if (!classTest(cls).test(current)) node.className += (current ? \" \" : \"\") + cls;\r\n  };\r\n  function joinClasses(a, b) {\r\n    var as = a.split(\" \");\r\n    for (var i = 0; i < as.length; i++)\r\n      if (as[i] && !classTest(as[i]).test(b)) b += \" \" + as[i];\r\n    return b;\r\n  }\r\n\r\n  // WINDOW-WIDE EVENTS\r\n\r\n  // These must be handled carefully, because naively registering a\r\n  // handler for each editor will cause the editors to never be\r\n  // garbage collected.\r\n\r\n  function forEachCodeMirror(f) {\r\n    if (!document.body.getElementsByClassName) return;\r\n    var byClass = document.body.getElementsByClassName(\"CodeMirror\");\r\n    for (var i = 0; i < byClass.length; i++) {\r\n      var cm = byClass[i].CodeMirror;\r\n      if (cm) f(cm);\r\n    }\r\n  }\r\n\r\n  var globalsRegistered = false;\r\n  function ensureGlobalHandlers() {\r\n    if (globalsRegistered) return;\r\n    registerGlobalHandlers();\r\n    globalsRegistered = true;\r\n  }\r\n  function registerGlobalHandlers() {\r\n    // When the window resizes, we need to refresh active editors.\r\n    var resizeTimer;\r\n    on(window, \"resize\", function() {\r\n      if (resizeTimer == null) resizeTimer = setTimeout(function() {\r\n        resizeTimer = null;\r\n        forEachCodeMirror(onResize);\r\n      }, 100);\r\n    });\r\n    // When the window loses focus, we want to show the editor as blurred\r\n    on(window, \"blur\", function() {\r\n      forEachCodeMirror(onBlur);\r\n    });\r\n  }\r\n\r\n  // FEATURE DETECTION\r\n\r\n  // Detect drag-and-drop\r\n  var dragAndDrop = function() {\r\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\r\n    // couldn't get it to work yet.\r\n    if (ie && ie_version < 9) return false;\r\n    var div = elt('div');\r\n    return \"draggable\" in div || \"dragDrop\" in div;\r\n  }();\r\n\r\n  var zwspSupported;\r\n  function zeroWidthElement(measure) {\r\n    if (zwspSupported == null) {\r\n      var test = elt(\"span\", \"\\u200b\");\r\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\r\n      if (measure.firstChild.offsetHeight != 0)\r\n        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);\r\n    }\r\n    var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\r\n      elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\r\n    node.setAttribute(\"cm-text\", \"\");\r\n    return node;\r\n  }\r\n\r\n  // Feature-detect IE's crummy client rect reporting for bidi text\r\n  var badBidiRects;\r\n  function hasBadBidiRects(measure) {\r\n    if (badBidiRects != null) return badBidiRects;\r\n    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\r\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\r\n    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)\r\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\r\n    return badBidiRects = (r1.right - r0.right < 3);\r\n  }\r\n\r\n  // See if \"\".split is the broken IE version, if so, provide an\r\n  // alternative way to split lines.\r\n  var splitLines = CodeMirror.splitLines = \"\\n\\nb\".split(/\\n/).length != 3 ? function(string) {\r\n    var pos = 0, result = [], l = string.length;\r\n    while (pos <= l) {\r\n      var nl = string.indexOf(\"\\n\", pos);\r\n      if (nl == -1) nl = string.length;\r\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\r\n      var rt = line.indexOf(\"\\r\");\r\n      if (rt != -1) {\r\n        result.push(line.slice(0, rt));\r\n        pos += rt + 1;\r\n      } else {\r\n        result.push(line);\r\n        pos = nl + 1;\r\n      }\r\n    }\r\n    return result;\r\n  } : function(string){return string.split(/\\r\\n?|\\n/);};\r\n\r\n  var hasSelection = window.getSelection ? function(te) {\r\n    try { return te.selectionStart != te.selectionEnd; }\r\n    catch(e) { return false; }\r\n  } : function(te) {\r\n    try {var range = te.ownerDocument.selection.createRange();}\r\n    catch(e) {}\r\n    if (!range || range.parentElement() != te) return false;\r\n    return range.compareEndPoints(\"StartToEnd\", range) != 0;\r\n  };\r\n\r\n  var hasCopyEvent = (function() {\r\n    var e = elt(\"div\");\r\n    if (\"oncopy\" in e) return true;\r\n    e.setAttribute(\"oncopy\", \"return;\");\r\n    return typeof e.oncopy == \"function\";\r\n  })();\r\n\r\n  var badZoomedRects = null;\r\n  function hasBadZoomedRects(measure) {\r\n    if (badZoomedRects != null) return badZoomedRects;\r\n    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\r\n    var normal = node.getBoundingClientRect();\r\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\r\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\r\n  }\r\n\r\n  // KEY NAMES\r\n\r\n  var keyNames = {3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\r\n                  19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\r\n                  36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\r\n                  46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\", 107: \"=\", 109: \"-\", 127: \"Delete\",\r\n                  173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\r\n                  221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\r\n                  63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"};\r\n  CodeMirror.keyNames = keyNames;\r\n  (function() {\r\n    // Number keys\r\n    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);\r\n    // Alphabetic keys\r\n    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\r\n    // Function keys\r\n    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = \"F\" + i;\r\n  })();\r\n\r\n  // BIDI HELPERS\r\n\r\n  function iterateBidiSections(order, from, to, f) {\r\n    if (!order) return f(from, to, \"ltr\");\r\n    var found = false;\r\n    for (var i = 0; i < order.length; ++i) {\r\n      var part = order[i];\r\n      if (part.from < to && part.to > from || from == to && part.to == from) {\r\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\r\n        found = true;\r\n      }\r\n    }\r\n    if (!found) f(from, to, \"ltr\");\r\n  }\r\n\r\n  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\r\n  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\r\n\r\n  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\r\n  function lineRight(line) {\r\n    var order = getOrder(line);\r\n    if (!order) return line.text.length;\r\n    return bidiRight(lst(order));\r\n  }\r\n\r\n  function lineStart(cm, lineN) {\r\n    var line = getLine(cm.doc, lineN);\r\n    var visual = visualLine(line);\r\n    if (visual != line) lineN = lineNo(visual);\r\n    var order = getOrder(visual);\r\n    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\r\n    return Pos(lineN, ch);\r\n  }\r\n  function lineEnd(cm, lineN) {\r\n    var merged, line = getLine(cm.doc, lineN);\r\n    while (merged = collapsedSpanAtEnd(line)) {\r\n      line = merged.find(1, true).line;\r\n      lineN = null;\r\n    }\r\n    var order = getOrder(line);\r\n    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\r\n    return Pos(lineN == null ? lineNo(line) : lineN, ch);\r\n  }\r\n  function lineStartSmart(cm, pos) {\r\n    var start = lineStart(cm, pos.line);\r\n    var line = getLine(cm.doc, start.line);\r\n    var order = getOrder(line);\r\n    if (!order || order[0].level == 0) {\r\n      var firstNonWS = Math.max(0, line.text.search(/\\S/));\r\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\r\n      return Pos(start.line, inWS ? 0 : firstNonWS);\r\n    }\r\n    return start;\r\n  }\r\n\r\n  function compareBidiLevel(order, a, b) {\r\n    var linedir = order[0].level;\r\n    if (a == linedir) return true;\r\n    if (b == linedir) return false;\r\n    return a < b;\r\n  }\r\n  var bidiOther;\r\n  function getBidiPartAt(order, pos) {\r\n    bidiOther = null;\r\n    for (var i = 0, found; i < order.length; ++i) {\r\n      var cur = order[i];\r\n      if (cur.from < pos && cur.to > pos) return i;\r\n      if ((cur.from == pos || cur.to == pos)) {\r\n        if (found == null) {\r\n          found = i;\r\n        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\r\n          if (cur.from != cur.to) bidiOther = found;\r\n          return i;\r\n        } else {\r\n          if (cur.from != cur.to) bidiOther = i;\r\n          return found;\r\n        }\r\n      }\r\n    }\r\n    return found;\r\n  }\r\n\r\n  function moveInLine(line, pos, dir, byUnit) {\r\n    if (!byUnit) return pos + dir;\r\n    do pos += dir;\r\n    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));\r\n    return pos;\r\n  }\r\n\r\n  // This is needed in order to move 'visually' through bi-directional\r\n  // text -- i.e., pressing left should make the cursor go left, even\r\n  // when in RTL text. The tricky part is the 'jumps', where RTL and\r\n  // LTR text touch each other. This often requires the cursor offset\r\n  // to move more than one unit, in order to visually move one unit.\r\n  function moveVisually(line, start, dir, byUnit) {\r\n    var bidi = getOrder(line);\r\n    if (!bidi) return moveLogically(line, start, dir, byUnit);\r\n    var pos = getBidiPartAt(bidi, start), part = bidi[pos];\r\n    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\r\n\r\n    for (;;) {\r\n      if (target > part.from && target < part.to) return target;\r\n      if (target == part.from || target == part.to) {\r\n        if (getBidiPartAt(bidi, target) == pos) return target;\r\n        part = bidi[pos += dir];\r\n        return (dir > 0) == part.level % 2 ? part.to : part.from;\r\n      } else {\r\n        part = bidi[pos += dir];\r\n        if (!part) return null;\r\n        if ((dir > 0) == part.level % 2)\r\n          target = moveInLine(line, part.to, -1, byUnit);\r\n        else\r\n          target = moveInLine(line, part.from, 1, byUnit);\r\n      }\r\n    }\r\n  }\r\n\r\n  function moveLogically(line, start, dir, byUnit) {\r\n    var target = start + dir;\r\n    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;\r\n    return target < 0 || target > line.text.length ? null : target;\r\n  }\r\n\r\n  // Bidirectional ordering algorithm\r\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\r\n  // that this (partially) implements.\r\n\r\n  // One-char codes used for character types:\r\n  // L (L):   Left-to-Right\r\n  // R (R):   Right-to-Left\r\n  // r (AL):  Right-to-Left Arabic\r\n  // 1 (EN):  European Number\r\n  // + (ES):  European Number Separator\r\n  // % (ET):  European Number Terminator\r\n  // n (AN):  Arabic Number\r\n  // , (CS):  Common Number Separator\r\n  // m (NSM): Non-Spacing Mark\r\n  // b (BN):  Boundary Neutral\r\n  // s (B):   Paragraph Separator\r\n  // t (S):   Segment Separator\r\n  // w (WS):  Whitespace\r\n  // N (ON):  Other Neutrals\r\n\r\n  // Returns null if characters are ordered as they appear\r\n  // (left-to-right), or an array of sections ({from, to, level}\r\n  // objects) in the order in which they occur visually.\r\n  var bidiOrdering = (function() {\r\n    // Character types for codepoints 0 to 0xff\r\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\r\n    // Character types for codepoints 0x600 to 0x6ff\r\n    var arabicTypes = \"rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm\";\r\n    function charType(code) {\r\n      if (code <= 0xf7) return lowTypes.charAt(code);\r\n      else if (0x590 <= code && code <= 0x5f4) return \"R\";\r\n      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);\r\n      else if (0x6ee <= code && code <= 0x8ac) return \"r\";\r\n      else if (0x2000 <= code && code <= 0x200b) return \"w\";\r\n      else if (code == 0x200c) return \"b\";\r\n      else return \"L\";\r\n    }\r\n\r\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\r\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\r\n    // Browsers seem to always treat the boundaries of block elements as being L.\r\n    var outerType = \"L\";\r\n\r\n    function BidiSpan(level, from, to) {\r\n      this.level = level;\r\n      this.from = from; this.to = to;\r\n    }\r\n\r\n    return function(str) {\r\n      if (!bidiRE.test(str)) return false;\r\n      var len = str.length, types = [];\r\n      for (var i = 0, type; i < len; ++i)\r\n        types.push(type = charType(str.charCodeAt(i)));\r\n\r\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\r\n      // change the type of the NSM to the type of the previous\r\n      // character. If the NSM is at the start of the level run, it will\r\n      // get the type of sor.\r\n      for (var i = 0, prev = outerType; i < len; ++i) {\r\n        var type = types[i];\r\n        if (type == \"m\") types[i] = prev;\r\n        else prev = type;\r\n      }\r\n\r\n      // W2. Search backwards from each instance of a European number\r\n      // until the first strong type (R, L, AL, or sor) is found. If an\r\n      // AL is found, change the type of the European number to Arabic\r\n      // number.\r\n      // W3. Change all ALs to R.\r\n      for (var i = 0, cur = outerType; i < len; ++i) {\r\n        var type = types[i];\r\n        if (type == \"1\" && cur == \"r\") types[i] = \"n\";\r\n        else if (isStrong.test(type)) { cur = type; if (type == \"r\") types[i] = \"R\"; }\r\n      }\r\n\r\n      // W4. A single European separator between two European numbers\r\n      // changes to a European number. A single common separator between\r\n      // two numbers of the same type changes to that type.\r\n      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\r\n        var type = types[i];\r\n        if (type == \"+\" && prev == \"1\" && types[i+1] == \"1\") types[i] = \"1\";\r\n        else if (type == \",\" && prev == types[i+1] &&\r\n                 (prev == \"1\" || prev == \"n\")) types[i] = prev;\r\n        prev = type;\r\n      }\r\n\r\n      // W5. A sequence of European terminators adjacent to European\r\n      // numbers changes to all European numbers.\r\n      // W6. Otherwise, separators and terminators change to Other\r\n      // Neutral.\r\n      for (var i = 0; i < len; ++i) {\r\n        var type = types[i];\r\n        if (type == \",\") types[i] = \"N\";\r\n        else if (type == \"%\") {\r\n          for (var end = i + 1; end < len && types[end] == \"%\"; ++end) {}\r\n          var replace = (i && types[i-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\r\n          for (var j = i; j < end; ++j) types[j] = replace;\r\n          i = end - 1;\r\n        }\r\n      }\r\n\r\n      // W7. Search backwards from each instance of a European number\r\n      // until the first strong type (R, L, or sor) is found. If an L is\r\n      // found, then change the type of the European number to L.\r\n      for (var i = 0, cur = outerType; i < len; ++i) {\r\n        var type = types[i];\r\n        if (cur == \"L\" && type == \"1\") types[i] = \"L\";\r\n        else if (isStrong.test(type)) cur = type;\r\n      }\r\n\r\n      // N1. A sequence of neutrals takes the direction of the\r\n      // surrounding strong text if the text on both sides has the same\r\n      // direction. European and Arabic numbers act as if they were R in\r\n      // terms of their influence on neutrals. Start-of-level-run (sor)\r\n      // and end-of-level-run (eor) are used at level run boundaries.\r\n      // N2. Any remaining neutrals take the embedding direction.\r\n      for (var i = 0; i < len; ++i) {\r\n        if (isNeutral.test(types[i])) {\r\n          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\r\n          var before = (i ? types[i-1] : outerType) == \"L\";\r\n          var after = (end < len ? types[end] : outerType) == \"L\";\r\n          var replace = before || after ? \"L\" : \"R\";\r\n          for (var j = i; j < end; ++j) types[j] = replace;\r\n          i = end - 1;\r\n        }\r\n      }\r\n\r\n      // Here we depart from the documented algorithm, in order to avoid\r\n      // building up an actual levels array. Since there are only three\r\n      // levels (0, 1, 2) in an implementation that doesn't take\r\n      // explicit embedding into account, we can build up the order on\r\n      // the fly, without following the level-based algorithm.\r\n      var order = [], m;\r\n      for (var i = 0; i < len;) {\r\n        if (countsAsLeft.test(types[i])) {\r\n          var start = i;\r\n          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\r\n          order.push(new BidiSpan(0, start, i));\r\n        } else {\r\n          var pos = i, at = order.length;\r\n          for (++i; i < len && types[i] != \"L\"; ++i) {}\r\n          for (var j = pos; j < i;) {\r\n            if (countsAsNum.test(types[j])) {\r\n              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));\r\n              var nstart = j;\r\n              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\r\n              order.splice(at, 0, new BidiSpan(2, nstart, j));\r\n              pos = j;\r\n            } else ++j;\r\n          }\r\n          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));\r\n        }\r\n      }\r\n      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\r\n        order[0].from = m[0].length;\r\n        order.unshift(new BidiSpan(0, 0, m[0].length));\r\n      }\r\n      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\r\n        lst(order).to -= m[0].length;\r\n        order.push(new BidiSpan(0, len - m[0].length, len));\r\n      }\r\n      if (order[0].level != lst(order).level)\r\n        order.push(new BidiSpan(order[0].level, len, len));\r\n\r\n      return order;\r\n    };\r\n  })();\r\n\r\n  // THE END\r\n\r\n  CodeMirror.version = \"5.1.1\";\r\n\r\n  return CodeMirror;\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb2RlbWlycm9yL2xpYi9jb2RlbWlycm9yLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5qcz8xMTJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXHJcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxyXG5cclxuLy8gVGhpcyBpcyBDb2RlTWlycm9yIChodHRwOi8vY29kZW1pcnJvci5uZXQpLCBhIGNvZGUgZWRpdG9yXHJcbi8vIGltcGxlbWVudGVkIGluIEphdmFTY3JpcHQgb24gdG9wIG9mIHRoZSBicm93c2VyJ3MgRE9NLlxyXG4vL1xyXG4vLyBZb3UgY2FuIGZpbmQgc29tZSB0ZWNobmljYWwgYmFja2dyb3VuZCBmb3Igc29tZSBvZiB0aGUgY29kZSBiZWxvd1xyXG4vLyBhdCBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2Jsb2cvI2NtLWludGVybmFscyAuXHJcblxyXG4oZnVuY3Rpb24obW9kKSB7XHJcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtb2QoKTtcclxuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcclxuICAgIHJldHVybiBkZWZpbmUoW10sIG1vZCk7XHJcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxyXG4gICAgdGhpcy5Db2RlTWlycm9yID0gbW9kKCk7XHJcbn0pKGZ1bmN0aW9uKCkge1xyXG4gIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAvLyBCUk9XU0VSIFNOSUZGSU5HXHJcblxyXG4gIC8vIEtsdWRnZXMgZm9yIGJ1Z3MgYW5kIGJlaGF2aW9yIGRpZmZlcmVuY2VzIHRoYXQgY2FuJ3QgYmUgZmVhdHVyZVxyXG4gIC8vIGRldGVjdGVkIGFyZSBlbmFibGVkIGJhc2VkIG9uIHVzZXJBZ2VudCBldGMgc25pZmZpbmcuXHJcblxyXG4gIHZhciBnZWNrbyA9IC9nZWNrb1xcL1xcZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcbiAgdmFyIGllX3VwdG8xMCA9IC9NU0lFIFxcZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcclxuICB2YXIgaWVfMTF1cCA9IC9UcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KTtcclxuICB2YXIgaWUgPSBpZV91cHRvMTAgfHwgaWVfMTF1cDtcclxuICB2YXIgaWVfdmVyc2lvbiA9IGllICYmIChpZV91cHRvMTAgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgfHwgNiA6IGllXzExdXBbMV0pO1xyXG4gIHZhciB3ZWJraXQgPSAvV2ViS2l0XFwvLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG4gIHZhciBxdHdlYmtpdCA9IHdlYmtpdCAmJiAvUXRcXC9cXGQrXFwuXFxkKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcclxuICB2YXIgY2hyb21lID0gL0Nocm9tZVxcLy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcclxuICB2YXIgcHJlc3RvID0gL09wZXJhXFwvLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG4gIHZhciBzYWZhcmkgPSAvQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2aWdhdG9yLnZlbmRvcik7XHJcbiAgdmFyIG1hY19nZU1vdW50YWluTGlvbiA9IC9NYWMgT1MgWCAxXFxkXFxEKFs4LTldfFxcZFxcZClcXEQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcbiAgdmFyIHBoYW50b20gPSAvUGhhbnRvbUpTLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG5cclxuICB2YXIgaW9zID0gL0FwcGxlV2ViS2l0Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmIC9Nb2JpbGVcXC9cXHcrLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG4gIC8vIFRoaXMgaXMgd29lZnVsbHkgaW5jb21wbGV0ZS4gU3VnZ2VzdGlvbnMgZm9yIGFsdGVybmF0aXZlIG1ldGhvZHMgd2VsY29tZS5cclxuICB2YXIgbW9iaWxlID0gaW9zIHx8IC9BbmRyb2lkfHdlYk9TfEJsYWNrQmVycnl8T3BlcmEgTWluaXxPcGVyYSBNb2JpfElFTW9iaWxlL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcclxuICB2YXIgbWFjID0gaW9zIHx8IC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcclxuICB2YXIgd2luZG93cyA9IC93aW4vaS50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XHJcblxyXG4gIHZhciBwcmVzdG9fdmVyc2lvbiA9IHByZXN0byAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFwvKFxcZCpcXC5cXGQqKS8pO1xyXG4gIGlmIChwcmVzdG9fdmVyc2lvbikgcHJlc3RvX3ZlcnNpb24gPSBOdW1iZXIocHJlc3RvX3ZlcnNpb25bMV0pO1xyXG4gIGlmIChwcmVzdG9fdmVyc2lvbiAmJiBwcmVzdG9fdmVyc2lvbiA+PSAxNSkgeyBwcmVzdG8gPSBmYWxzZTsgd2Via2l0ID0gdHJ1ZTsgfVxyXG4gIC8vIFNvbWUgYnJvd3NlcnMgdXNlIHRoZSB3cm9uZyBldmVudCBwcm9wZXJ0aWVzIHRvIHNpZ25hbCBjbWQvY3RybCBvbiBPUyBYXHJcbiAgdmFyIGZsaXBDdHJsQ21kID0gbWFjICYmIChxdHdlYmtpdCB8fCBwcmVzdG8gJiYgKHByZXN0b192ZXJzaW9uID09IG51bGwgfHwgcHJlc3RvX3ZlcnNpb24gPCAxMi4xMSkpO1xyXG4gIHZhciBjYXB0dXJlUmlnaHRDbGljayA9IGdlY2tvIHx8IChpZSAmJiBpZV92ZXJzaW9uID49IDkpO1xyXG5cclxuICAvLyBPcHRpbWl6ZSBzb21lIGNvZGUgd2hlbiB0aGVzZSBmZWF0dXJlcyBhcmUgbm90IHVzZWQuXHJcbiAgdmFyIHNhd1JlYWRPbmx5U3BhbnMgPSBmYWxzZSwgc2F3Q29sbGFwc2VkU3BhbnMgPSBmYWxzZTtcclxuXHJcbiAgLy8gRURJVE9SIENPTlNUUlVDVE9SXHJcblxyXG4gIC8vIEEgQ29kZU1pcnJvciBpbnN0YW5jZSByZXByZXNlbnRzIGFuIGVkaXRvci4gVGhpcyBpcyB0aGUgb2JqZWN0XHJcbiAgLy8gdGhhdCB1c2VyIGNvZGUgaXMgdXN1YWxseSBkZWFsaW5nIHdpdGguXHJcblxyXG4gIGZ1bmN0aW9uIENvZGVNaXJyb3IocGxhY2UsIG9wdGlvbnMpIHtcclxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb2RlTWlycm9yKSkgcmV0dXJuIG5ldyBDb2RlTWlycm9yKHBsYWNlLCBvcHRpb25zKTtcclxuXHJcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gb3B0aW9ucyA/IGNvcHlPYmoob3B0aW9ucykgOiB7fTtcclxuICAgIC8vIERldGVybWluZSBlZmZlY3RpdmUgb3B0aW9ucyBiYXNlZCBvbiBnaXZlbiB2YWx1ZXMgYW5kIGRlZmF1bHRzLlxyXG4gICAgY29weU9iaihkZWZhdWx0cywgb3B0aW9ucywgZmFsc2UpO1xyXG4gICAgc2V0R3V0dGVyc0ZvckxpbmVOdW1iZXJzKG9wdGlvbnMpO1xyXG5cclxuICAgIHZhciBkb2MgPSBvcHRpb25zLnZhbHVlO1xyXG4gICAgaWYgKHR5cGVvZiBkb2MgPT0gXCJzdHJpbmdcIikgZG9jID0gbmV3IERvYyhkb2MsIG9wdGlvbnMubW9kZSk7XHJcbiAgICB0aGlzLmRvYyA9IGRvYztcclxuXHJcbiAgICB2YXIgaW5wdXQgPSBuZXcgQ29kZU1pcnJvci5pbnB1dFN0eWxlc1tvcHRpb25zLmlucHV0U3R5bGVdKHRoaXMpO1xyXG4gICAgdmFyIGRpc3BsYXkgPSB0aGlzLmRpc3BsYXkgPSBuZXcgRGlzcGxheShwbGFjZSwgZG9jLCBpbnB1dCk7XHJcbiAgICBkaXNwbGF5LndyYXBwZXIuQ29kZU1pcnJvciA9IHRoaXM7XHJcbiAgICB1cGRhdGVHdXR0ZXJzKHRoaXMpO1xyXG4gICAgdGhlbWVDaGFuZ2VkKHRoaXMpO1xyXG4gICAgaWYgKG9wdGlvbnMubGluZVdyYXBwaW5nKVxyXG4gICAgICB0aGlzLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWUgKz0gXCIgQ29kZU1pcnJvci13cmFwXCI7XHJcbiAgICBpZiAob3B0aW9ucy5hdXRvZm9jdXMgJiYgIW1vYmlsZSkgZGlzcGxheS5pbnB1dC5mb2N1cygpO1xyXG4gICAgaW5pdFNjcm9sbGJhcnModGhpcyk7XHJcblxyXG4gICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAga2V5TWFwczogW10sICAvLyBzdG9yZXMgbWFwcyBhZGRlZCBieSBhZGRLZXlNYXBcclxuICAgICAgb3ZlcmxheXM6IFtdLCAvLyBoaWdobGlnaHRpbmcgb3ZlcmxheXMsIGFzIGFkZGVkIGJ5IGFkZE92ZXJsYXlcclxuICAgICAgbW9kZUdlbjogMCwgICAvLyBidW1wZWQgd2hlbiBtb2RlL292ZXJsYXkgY2hhbmdlcywgdXNlZCB0byBpbnZhbGlkYXRlIGhpZ2hsaWdodGluZyBpbmZvXHJcbiAgICAgIG92ZXJ3cml0ZTogZmFsc2UsXHJcbiAgICAgIGRlbGF5aW5nQmx1ckV2ZW50OiBmYWxzZSxcclxuICAgICAgZm9jdXNlZDogZmFsc2UsXHJcbiAgICAgIHN1cHByZXNzRWRpdHM6IGZhbHNlLCAvLyB1c2VkIHRvIGRpc2FibGUgZWRpdGluZyBkdXJpbmcga2V5IGhhbmRsZXJzIHdoZW4gaW4gcmVhZE9ubHkgbW9kZVxyXG4gICAgICBwYXN0ZUluY29taW5nOiBmYWxzZSwgY3V0SW5jb21pbmc6IGZhbHNlLCAvLyBoZWxwIHJlY29nbml6ZSBwYXN0ZS9jdXQgZWRpdHMgaW4gaW5wdXQucG9sbFxyXG4gICAgICBkcmFnZ2luZ1RleHQ6IGZhbHNlLFxyXG4gICAgICBoaWdobGlnaHQ6IG5ldyBEZWxheWVkKCksIC8vIHN0b3JlcyBoaWdobGlnaHQgd29ya2VyIHRpbWVvdXRcclxuICAgICAga2V5U2VxOiBudWxsLCAgLy8gVW5maW5pc2hlZCBrZXkgc2VxdWVuY2VcclxuICAgICAgc3BlY2lhbENoYXJzOiBudWxsXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBjbSA9IHRoaXM7XHJcblxyXG4gICAgLy8gT3ZlcnJpZGUgbWFnaWMgdGV4dGFyZWEgY29udGVudCByZXN0b3JlIHRoYXQgSUUgc29tZXRpbWVzIGRvZXNcclxuICAgIC8vIG9uIG91ciBoaWRkZW4gdGV4dGFyZWEgb24gcmVsb2FkXHJcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDExKSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KHRydWUpOyB9LCAyMCk7XHJcblxyXG4gICAgcmVnaXN0ZXJFdmVudEhhbmRsZXJzKHRoaXMpO1xyXG4gICAgZW5zdXJlR2xvYmFsSGFuZGxlcnMoKTtcclxuXHJcbiAgICBzdGFydE9wZXJhdGlvbih0aGlzKTtcclxuICAgIHRoaXMuY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xyXG4gICAgYXR0YWNoRG9jKHRoaXMsIGRvYyk7XHJcblxyXG4gICAgaWYgKChvcHRpb25zLmF1dG9mb2N1cyAmJiAhbW9iaWxlKSB8fCBjbS5oYXNGb2N1cygpKVxyXG4gICAgICBzZXRUaW1lb3V0KGJpbmQob25Gb2N1cywgdGhpcyksIDIwKTtcclxuICAgIGVsc2VcclxuICAgICAgb25CbHVyKHRoaXMpO1xyXG5cclxuICAgIGZvciAodmFyIG9wdCBpbiBvcHRpb25IYW5kbGVycykgaWYgKG9wdGlvbkhhbmRsZXJzLmhhc093blByb3BlcnR5KG9wdCkpXHJcbiAgICAgIG9wdGlvbkhhbmRsZXJzW29wdF0odGhpcywgb3B0aW9uc1tvcHRdLCBJbml0KTtcclxuICAgIG1heWJlVXBkYXRlTGluZU51bWJlcldpZHRoKHRoaXMpO1xyXG4gICAgaWYgKG9wdGlvbnMuZmluaXNoSW5pdCkgb3B0aW9ucy5maW5pc2hJbml0KHRoaXMpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0SG9va3MubGVuZ3RoOyArK2kpIGluaXRIb29rc1tpXSh0aGlzKTtcclxuICAgIGVuZE9wZXJhdGlvbih0aGlzKTtcclxuICAgIC8vIFN1cHByZXNzIG9wdGltaXplbGVnaWJpbGl0eSBpbiBXZWJraXQsIHNpbmNlIGl0IGJyZWFrcyB0ZXh0XHJcbiAgICAvLyBtZWFzdXJpbmcgb24gbGluZSB3cmFwcGluZyBib3VuZGFyaWVzLlxyXG4gICAgaWYgKHdlYmtpdCAmJiBvcHRpb25zLmxpbmVXcmFwcGluZyAmJlxyXG4gICAgICAgIGdldENvbXB1dGVkU3R5bGUoZGlzcGxheS5saW5lRGl2KS50ZXh0UmVuZGVyaW5nID09IFwib3B0aW1pemVsZWdpYmlsaXR5XCIpXHJcbiAgICAgIGRpc3BsYXkubGluZURpdi5zdHlsZS50ZXh0UmVuZGVyaW5nID0gXCJhdXRvXCI7XHJcbiAgfVxyXG5cclxuICAvLyBESVNQTEFZIENPTlNUUlVDVE9SXHJcblxyXG4gIC8vIFRoZSBkaXNwbGF5IGhhbmRsZXMgdGhlIERPTSBpbnRlZ3JhdGlvbiwgYm90aCBmb3IgaW5wdXQgcmVhZGluZ1xyXG4gIC8vIGFuZCBjb250ZW50IGRyYXdpbmcuIEl0IGhvbGRzIHJlZmVyZW5jZXMgdG8gRE9NIG5vZGVzIGFuZFxyXG4gIC8vIGRpc3BsYXktcmVsYXRlZCBzdGF0ZS5cclxuXHJcbiAgZnVuY3Rpb24gRGlzcGxheShwbGFjZSwgZG9jLCBpbnB1dCkge1xyXG4gICAgdmFyIGQgPSB0aGlzO1xyXG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xyXG5cclxuICAgIC8vIENvdmVycyBib3R0b20tcmlnaHQgc3F1YXJlIHdoZW4gYm90aCBzY3JvbGxiYXJzIGFyZSBwcmVzZW50LlxyXG4gICAgZC5zY3JvbGxiYXJGaWxsZXIgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLXNjcm9sbGJhci1maWxsZXJcIik7XHJcbiAgICBkLnNjcm9sbGJhckZpbGxlci5zZXRBdHRyaWJ1dGUoXCJjbS1ub3QtY29udGVudFwiLCBcInRydWVcIik7XHJcbiAgICAvLyBDb3ZlcnMgYm90dG9tIG9mIGd1dHRlciB3aGVuIGNvdmVyR3V0dGVyTmV4dFRvU2Nyb2xsYmFyIGlzIG9uXHJcbiAgICAvLyBhbmQgaCBzY3JvbGxiYXIgaXMgcHJlc2VudC5cclxuICAgIGQuZ3V0dGVyRmlsbGVyID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1ndXR0ZXItZmlsbGVyXCIpO1xyXG4gICAgZC5ndXR0ZXJGaWxsZXIuc2V0QXR0cmlidXRlKFwiY20tbm90LWNvbnRlbnRcIiwgXCJ0cnVlXCIpO1xyXG4gICAgLy8gV2lsbCBjb250YWluIHRoZSBhY3R1YWwgY29kZSwgcG9zaXRpb25lZCB0byBjb3ZlciB0aGUgdmlld3BvcnQuXHJcbiAgICBkLmxpbmVEaXYgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWNvZGVcIik7XHJcbiAgICAvLyBFbGVtZW50cyBhcmUgYWRkZWQgdG8gdGhlc2UgdG8gcmVwcmVzZW50IHNlbGVjdGlvbiBhbmQgY3Vyc29ycy5cclxuICAgIGQuc2VsZWN0aW9uRGl2ID0gZWx0KFwiZGl2XCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IHJlbGF0aXZlOyB6LWluZGV4OiAxXCIpO1xyXG4gICAgZC5jdXJzb3JEaXYgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWN1cnNvcnNcIik7XHJcbiAgICAvLyBBIHZpc2liaWxpdHk6IGhpZGRlbiBlbGVtZW50IHVzZWQgdG8gZmluZCB0aGUgc2l6ZSBvZiB0aGluZ3MuXHJcbiAgICBkLm1lYXN1cmUgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLW1lYXN1cmVcIik7XHJcbiAgICAvLyBXaGVuIGxpbmVzIG91dHNpZGUgb2YgdGhlIHZpZXdwb3J0IGFyZSBtZWFzdXJlZCwgdGhleSBhcmUgZHJhd24gaW4gdGhpcy5cclxuICAgIGQubGluZU1lYXN1cmUgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLW1lYXN1cmVcIik7XHJcbiAgICAvLyBXcmFwcyBldmVyeXRoaW5nIHRoYXQgbmVlZHMgdG8gZXhpc3QgaW5zaWRlIHRoZSB2ZXJ0aWNhbGx5LXBhZGRlZCBjb29yZGluYXRlIHN5c3RlbVxyXG4gICAgZC5saW5lU3BhY2UgPSBlbHQoXCJkaXZcIiwgW2QubWVhc3VyZSwgZC5saW5lTWVhc3VyZSwgZC5zZWxlY3Rpb25EaXYsIGQuY3Vyc29yRGl2LCBkLmxpbmVEaXZdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCwgXCJwb3NpdGlvbjogcmVsYXRpdmU7IG91dGxpbmU6IG5vbmVcIik7XHJcbiAgICAvLyBNb3ZlZCBhcm91bmQgaXRzIHBhcmVudCB0byBjb3ZlciB2aXNpYmxlIHZpZXcuXHJcbiAgICBkLm1vdmVyID0gZWx0KFwiZGl2XCIsIFtlbHQoXCJkaXZcIiwgW2QubGluZVNwYWNlXSwgXCJDb2RlTWlycm9yLWxpbmVzXCIpXSwgbnVsbCwgXCJwb3NpdGlvbjogcmVsYXRpdmVcIik7XHJcbiAgICAvLyBTZXQgdG8gdGhlIGhlaWdodCBvZiB0aGUgZG9jdW1lbnQsIGFsbG93aW5nIHNjcm9sbGluZy5cclxuICAgIGQuc2l6ZXIgPSBlbHQoXCJkaXZcIiwgW2QubW92ZXJdLCBcIkNvZGVNaXJyb3Itc2l6ZXJcIik7XHJcbiAgICBkLnNpemVyV2lkdGggPSBudWxsO1xyXG4gICAgLy8gQmVoYXZpb3Igb2YgZWx0cyB3aXRoIG92ZXJmbG93OiBhdXRvIGFuZCBwYWRkaW5nIGlzXHJcbiAgICAvLyBpbmNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzLiBUaGlzIGlzIHVzZWQgdG8gZW5zdXJlIHRoZVxyXG4gICAgLy8gc2Nyb2xsYWJsZSBhcmVhIGlzIGJpZyBlbm91Z2guXHJcbiAgICBkLmhlaWdodEZvcmNlciA9IGVsdChcImRpdlwiLCBudWxsLCBudWxsLCBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgaGVpZ2h0OiBcIiArIHNjcm9sbGVyR2FwICsgXCJweDsgd2lkdGg6IDFweDtcIik7XHJcbiAgICAvLyBXaWxsIGNvbnRhaW4gdGhlIGd1dHRlcnMsIGlmIGFueS5cclxuICAgIGQuZ3V0dGVycyA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItZ3V0dGVyc1wiKTtcclxuICAgIGQubGluZUd1dHRlciA9IG51bGw7XHJcbiAgICAvLyBBY3R1YWwgc2Nyb2xsYWJsZSBlbGVtZW50LlxyXG4gICAgZC5zY3JvbGxlciA9IGVsdChcImRpdlwiLCBbZC5zaXplciwgZC5oZWlnaHRGb3JjZXIsIGQuZ3V0dGVyc10sIFwiQ29kZU1pcnJvci1zY3JvbGxcIik7XHJcbiAgICBkLnNjcm9sbGVyLnNldEF0dHJpYnV0ZShcInRhYkluZGV4XCIsIFwiLTFcIik7XHJcbiAgICAvLyBUaGUgZWxlbWVudCBpbiB3aGljaCB0aGUgZWRpdG9yIGxpdmVzLlxyXG4gICAgZC53cmFwcGVyID0gZWx0KFwiZGl2XCIsIFtkLnNjcm9sbGJhckZpbGxlciwgZC5ndXR0ZXJGaWxsZXIsIGQuc2Nyb2xsZXJdLCBcIkNvZGVNaXJyb3JcIik7XHJcblxyXG4gICAgLy8gV29yayBhcm91bmQgSUU3IHotaW5kZXggYnVnIChub3QgcGVyZmVjdCwgaGVuY2UgSUU3IG5vdCByZWFsbHkgYmVpbmcgc3VwcG9ydGVkKVxyXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA4KSB7IGQuZ3V0dGVycy5zdHlsZS56SW5kZXggPSAtMTsgZC5zY3JvbGxlci5zdHlsZS5wYWRkaW5nUmlnaHQgPSAwOyB9XHJcbiAgICBpZiAoIXdlYmtpdCAmJiAhKGdlY2tvICYmIG1vYmlsZSkpIGQuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAocGxhY2UpIHtcclxuICAgICAgaWYgKHBsYWNlLmFwcGVuZENoaWxkKSBwbGFjZS5hcHBlbmRDaGlsZChkLndyYXBwZXIpO1xyXG4gICAgICBlbHNlIHBsYWNlKGQud3JhcHBlcik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3VycmVudCByZW5kZXJlZCByYW5nZSAobWF5IGJlIGJpZ2dlciB0aGFuIHRoZSB2aWV3IHdpbmRvdykuXHJcbiAgICBkLnZpZXdGcm9tID0gZC52aWV3VG8gPSBkb2MuZmlyc3Q7XHJcbiAgICBkLnJlcG9ydGVkVmlld0Zyb20gPSBkLnJlcG9ydGVkVmlld1RvID0gZG9jLmZpcnN0O1xyXG4gICAgLy8gSW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlbmRlcmVkIGxpbmVzLlxyXG4gICAgZC52aWV3ID0gW107XHJcbiAgICBkLnJlbmRlcmVkVmlldyA9IG51bGw7XHJcbiAgICAvLyBIb2xkcyBpbmZvIGFib3V0IGEgc2luZ2xlIHJlbmRlcmVkIGxpbmUgd2hlbiBpdCB3YXMgcmVuZGVyZWRcclxuICAgIC8vIGZvciBtZWFzdXJlbWVudCwgd2hpbGUgbm90IGluIHZpZXcuXHJcbiAgICBkLmV4dGVybmFsTWVhc3VyZWQgPSBudWxsO1xyXG4gICAgLy8gRW1wdHkgc3BhY2UgKGluIHBpeGVscykgYWJvdmUgdGhlIHZpZXdcclxuICAgIGQudmlld09mZnNldCA9IDA7XHJcbiAgICBkLmxhc3RXcmFwSGVpZ2h0ID0gZC5sYXN0V3JhcFdpZHRoID0gMDtcclxuICAgIGQudXBkYXRlTGluZU51bWJlcnMgPSBudWxsO1xyXG5cclxuICAgIGQubmF0aXZlQmFyV2lkdGggPSBkLmJhckhlaWdodCA9IGQuYmFyV2lkdGggPSAwO1xyXG4gICAgZC5zY3JvbGxiYXJzQ2xpcHBlZCA9IGZhbHNlO1xyXG5cclxuICAgIC8vIFVzZWQgdG8gb25seSByZXNpemUgdGhlIGxpbmUgbnVtYmVyIGd1dHRlciB3aGVuIG5lY2Vzc2FyeSAod2hlblxyXG4gICAgLy8gdGhlIGFtb3VudCBvZiBsaW5lcyBjcm9zc2VzIGEgYm91bmRhcnkgdGhhdCBtYWtlcyBpdHMgd2lkdGggY2hhbmdlKVxyXG4gICAgZC5saW5lTnVtV2lkdGggPSBkLmxpbmVOdW1Jbm5lcldpZHRoID0gZC5saW5lTnVtQ2hhcnMgPSBudWxsO1xyXG4gICAgLy8gU2V0IHRvIHRydWUgd2hlbiBhIG5vbi1ob3Jpem9udGFsLXNjcm9sbGluZyBsaW5lIHdpZGdldCBpc1xyXG4gICAgLy8gYWRkZWQuIEFzIGFuIG9wdGltaXphdGlvbiwgbGluZSB3aWRnZXQgYWxpZ25pbmcgaXMgc2tpcHBlZCB3aGVuXHJcbiAgICAvLyB0aGlzIGlzIGZhbHNlLlxyXG4gICAgZC5hbGlnbldpZGdldHMgPSBmYWxzZTtcclxuXHJcbiAgICBkLmNhY2hlZENoYXJXaWR0aCA9IGQuY2FjaGVkVGV4dEhlaWdodCA9IGQuY2FjaGVkUGFkZGluZ0ggPSBudWxsO1xyXG5cclxuICAgIC8vIFRyYWNrcyB0aGUgbWF4aW11bSBsaW5lIGxlbmd0aCBzbyB0aGF0IHRoZSBob3Jpem9udGFsIHNjcm9sbGJhclxyXG4gICAgLy8gY2FuIGJlIGtlcHQgc3RhdGljIHdoZW4gc2Nyb2xsaW5nLlxyXG4gICAgZC5tYXhMaW5lID0gbnVsbDtcclxuICAgIGQubWF4TGluZUxlbmd0aCA9IDA7XHJcbiAgICBkLm1heExpbmVDaGFuZ2VkID0gZmFsc2U7XHJcblxyXG4gICAgLy8gVXNlZCBmb3IgbWVhc3VyaW5nIHdoZWVsIHNjcm9sbGluZyBncmFudWxhcml0eVxyXG4gICAgZC53aGVlbERYID0gZC53aGVlbERZID0gZC53aGVlbFN0YXJ0WCA9IGQud2hlZWxTdGFydFkgPSBudWxsO1xyXG5cclxuICAgIC8vIFRydWUgd2hlbiBzaGlmdCBpcyBoZWxkIGRvd24uXHJcbiAgICBkLnNoaWZ0ID0gZmFsc2U7XHJcblxyXG4gICAgLy8gVXNlZCB0byB0cmFjayB3aGV0aGVyIGFueXRoaW5nIGhhcHBlbmVkIHNpbmNlIHRoZSBjb250ZXh0IG1lbnVcclxuICAgIC8vIHdhcyBvcGVuZWQuXHJcbiAgICBkLnNlbEZvckNvbnRleHRNZW51ID0gbnVsbDtcclxuXHJcbiAgICBkLmFjdGl2ZVRvdWNoID0gbnVsbDtcclxuXHJcbiAgICBpbnB1dC5pbml0KGQpO1xyXG4gIH1cclxuXHJcbiAgLy8gU1RBVEUgVVBEQVRFU1xyXG5cclxuICAvLyBVc2VkIHRvIGdldCB0aGUgZWRpdG9yIGludG8gYSBjb25zaXN0ZW50IHN0YXRlIGFnYWluIHdoZW4gb3B0aW9ucyBjaGFuZ2UuXHJcblxyXG4gIGZ1bmN0aW9uIGxvYWRNb2RlKGNtKSB7XHJcbiAgICBjbS5kb2MubW9kZSA9IENvZGVNaXJyb3IuZ2V0TW9kZShjbS5vcHRpb25zLCBjbS5kb2MubW9kZU9wdGlvbik7XHJcbiAgICByZXNldE1vZGVTdGF0ZShjbSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZXNldE1vZGVTdGF0ZShjbSkge1xyXG4gICAgY20uZG9jLml0ZXIoZnVuY3Rpb24obGluZSkge1xyXG4gICAgICBpZiAobGluZS5zdGF0ZUFmdGVyKSBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsO1xyXG4gICAgICBpZiAobGluZS5zdHlsZXMpIGxpbmUuc3R5bGVzID0gbnVsbDtcclxuICAgIH0pO1xyXG4gICAgY20uZG9jLmZyb250aWVyID0gY20uZG9jLmZpcnN0O1xyXG4gICAgc3RhcnRXb3JrZXIoY20sIDEwMCk7XHJcbiAgICBjbS5zdGF0ZS5tb2RlR2VuKys7XHJcbiAgICBpZiAoY20uY3VyT3ApIHJlZ0NoYW5nZShjbSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB3cmFwcGluZ0NoYW5nZWQoY20pIHtcclxuICAgIGlmIChjbS5vcHRpb25zLmxpbmVXcmFwcGluZykge1xyXG4gICAgICBhZGRDbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIFwiQ29kZU1pcnJvci13cmFwXCIpO1xyXG4gICAgICBjbS5kaXNwbGF5LnNpemVyLnN0eWxlLm1pbldpZHRoID0gXCJcIjtcclxuICAgICAgY20uZGlzcGxheS5zaXplcldpZHRoID0gbnVsbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJtQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBcIkNvZGVNaXJyb3Itd3JhcFwiKTtcclxuICAgICAgZmluZE1heExpbmUoY20pO1xyXG4gICAgfVxyXG4gICAgZXN0aW1hdGVMaW5lSGVpZ2h0cyhjbSk7XHJcbiAgICByZWdDaGFuZ2UoY20pO1xyXG4gICAgY2xlYXJDYWNoZXMoY20pO1xyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe3VwZGF0ZVNjcm9sbGJhcnMoY20pO30sIDEwMCk7XHJcbiAgfVxyXG5cclxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBlc3RpbWF0ZXMgdGhlIGhlaWdodCBvZiBhIGxpbmUsIHRvIHVzZSBhc1xyXG4gIC8vIGZpcnN0IGFwcHJveGltYXRpb24gdW50aWwgdGhlIGxpbmUgYmVjb21lcyB2aXNpYmxlIChhbmQgaXMgdGh1c1xyXG4gIC8vIHByb3Blcmx5IG1lYXN1cmFibGUpLlxyXG4gIGZ1bmN0aW9uIGVzdGltYXRlSGVpZ2h0KGNtKSB7XHJcbiAgICB2YXIgdGggPSB0ZXh0SGVpZ2h0KGNtLmRpc3BsYXkpLCB3cmFwcGluZyA9IGNtLm9wdGlvbnMubGluZVdyYXBwaW5nO1xyXG4gICAgdmFyIHBlckxpbmUgPSB3cmFwcGluZyAmJiBNYXRoLm1heCg1LCBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoIC8gY2hhcldpZHRoKGNtLmRpc3BsYXkpIC0gMyk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24obGluZSkge1xyXG4gICAgICBpZiAobGluZUlzSGlkZGVuKGNtLmRvYywgbGluZSkpIHJldHVybiAwO1xyXG5cclxuICAgICAgdmFyIHdpZGdldHNIZWlnaHQgPSAwO1xyXG4gICAgICBpZiAobGluZS53aWRnZXRzKSBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUud2lkZ2V0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChsaW5lLndpZGdldHNbaV0uaGVpZ2h0KSB3aWRnZXRzSGVpZ2h0ICs9IGxpbmUud2lkZ2V0c1tpXS5oZWlnaHQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh3cmFwcGluZylcclxuICAgICAgICByZXR1cm4gd2lkZ2V0c0hlaWdodCArIChNYXRoLmNlaWwobGluZS50ZXh0Lmxlbmd0aCAvIHBlckxpbmUpIHx8IDEpICogdGg7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gd2lkZ2V0c0hlaWdodCArIHRoO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGVzdGltYXRlTGluZUhlaWdodHMoY20pIHtcclxuICAgIHZhciBkb2MgPSBjbS5kb2MsIGVzdCA9IGVzdGltYXRlSGVpZ2h0KGNtKTtcclxuICAgIGRvYy5pdGVyKGZ1bmN0aW9uKGxpbmUpIHtcclxuICAgICAgdmFyIGVzdEhlaWdodCA9IGVzdChsaW5lKTtcclxuICAgICAgaWYgKGVzdEhlaWdodCAhPSBsaW5lLmhlaWdodCkgdXBkYXRlTGluZUhlaWdodChsaW5lLCBlc3RIZWlnaHQpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0aGVtZUNoYW5nZWQoY20pIHtcclxuICAgIGNtLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWUgPSBjbS5kaXNwbGF5LndyYXBwZXIuY2xhc3NOYW1lLnJlcGxhY2UoL1xccypjbS1zLVxcUysvZywgXCJcIikgK1xyXG4gICAgICBjbS5vcHRpb25zLnRoZW1lLnJlcGxhY2UoLyhefFxccylcXHMqL2csIFwiIGNtLXMtXCIpO1xyXG4gICAgY2xlYXJDYWNoZXMoY20pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ3V0dGVyc0NoYW5nZWQoY20pIHtcclxuICAgIHVwZGF0ZUd1dHRlcnMoY20pO1xyXG4gICAgcmVnQ2hhbmdlKGNtKTtcclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXthbGlnbkhvcml6b250YWxseShjbSk7fSwgMjApO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVidWlsZCB0aGUgZ3V0dGVyIGVsZW1lbnRzLCBlbnN1cmUgdGhlIG1hcmdpbiB0byB0aGUgbGVmdCBvZiB0aGVcclxuICAvLyBjb2RlIG1hdGNoZXMgdGhlaXIgd2lkdGguXHJcbiAgZnVuY3Rpb24gdXBkYXRlR3V0dGVycyhjbSkge1xyXG4gICAgdmFyIGd1dHRlcnMgPSBjbS5kaXNwbGF5Lmd1dHRlcnMsIHNwZWNzID0gY20ub3B0aW9ucy5ndXR0ZXJzO1xyXG4gICAgcmVtb3ZlQ2hpbGRyZW4oZ3V0dGVycyk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwZWNzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIHZhciBndXR0ZXJDbGFzcyA9IHNwZWNzW2ldO1xyXG4gICAgICB2YXIgZ0VsdCA9IGd1dHRlcnMuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1ndXR0ZXIgXCIgKyBndXR0ZXJDbGFzcykpO1xyXG4gICAgICBpZiAoZ3V0dGVyQ2xhc3MgPT0gXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCIpIHtcclxuICAgICAgICBjbS5kaXNwbGF5LmxpbmVHdXR0ZXIgPSBnRWx0O1xyXG4gICAgICAgIGdFbHQuc3R5bGUud2lkdGggPSAoY20uZGlzcGxheS5saW5lTnVtV2lkdGggfHwgMSkgKyBcInB4XCI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGd1dHRlcnMuc3R5bGUuZGlzcGxheSA9IGkgPyBcIlwiIDogXCJub25lXCI7XHJcbiAgICB1cGRhdGVHdXR0ZXJTcGFjZShjbSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB1cGRhdGVHdXR0ZXJTcGFjZShjbSkge1xyXG4gICAgdmFyIHdpZHRoID0gY20uZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoO1xyXG4gICAgY20uZGlzcGxheS5zaXplci5zdHlsZS5tYXJnaW5MZWZ0ID0gd2lkdGggKyBcInB4XCI7XHJcbiAgfVxyXG5cclxuICAvLyBDb21wdXRlIHRoZSBjaGFyYWN0ZXIgbGVuZ3RoIG9mIGEgbGluZSwgdGFraW5nIGludG8gYWNjb3VudFxyXG4gIC8vIGNvbGxhcHNlZCByYW5nZXMgKHNlZSBtYXJrVGV4dCkgdGhhdCBtaWdodCBoaWRlIHBhcnRzLCBhbmQgam9pblxyXG4gIC8vIG90aGVyIGxpbmVzIG9udG8gaXQuXHJcbiAgZnVuY3Rpb24gbGluZUxlbmd0aChsaW5lKSB7XHJcbiAgICBpZiAobGluZS5oZWlnaHQgPT0gMCkgcmV0dXJuIDA7XHJcbiAgICB2YXIgbGVuID0gbGluZS50ZXh0Lmxlbmd0aCwgbWVyZ2VkLCBjdXIgPSBsaW5lO1xyXG4gICAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdFN0YXJ0KGN1cikpIHtcclxuICAgICAgdmFyIGZvdW5kID0gbWVyZ2VkLmZpbmQoMCwgdHJ1ZSk7XHJcbiAgICAgIGN1ciA9IGZvdW5kLmZyb20ubGluZTtcclxuICAgICAgbGVuICs9IGZvdW5kLmZyb20uY2ggLSBmb3VuZC50by5jaDtcclxuICAgIH1cclxuICAgIGN1ciA9IGxpbmU7XHJcbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGN1cikpIHtcclxuICAgICAgdmFyIGZvdW5kID0gbWVyZ2VkLmZpbmQoMCwgdHJ1ZSk7XHJcbiAgICAgIGxlbiAtPSBjdXIudGV4dC5sZW5ndGggLSBmb3VuZC5mcm9tLmNoO1xyXG4gICAgICBjdXIgPSBmb3VuZC50by5saW5lO1xyXG4gICAgICBsZW4gKz0gY3VyLnRleHQubGVuZ3RoIC0gZm91bmQudG8uY2g7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVuO1xyXG4gIH1cclxuXHJcbiAgLy8gRmluZCB0aGUgbG9uZ2VzdCBsaW5lIGluIHRoZSBkb2N1bWVudC5cclxuICBmdW5jdGlvbiBmaW5kTWF4TGluZShjbSkge1xyXG4gICAgdmFyIGQgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XHJcbiAgICBkLm1heExpbmUgPSBnZXRMaW5lKGRvYywgZG9jLmZpcnN0KTtcclxuICAgIGQubWF4TGluZUxlbmd0aCA9IGxpbmVMZW5ndGgoZC5tYXhMaW5lKTtcclxuICAgIGQubWF4TGluZUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgZG9jLml0ZXIoZnVuY3Rpb24obGluZSkge1xyXG4gICAgICB2YXIgbGVuID0gbGluZUxlbmd0aChsaW5lKTtcclxuICAgICAgaWYgKGxlbiA+IGQubWF4TGluZUxlbmd0aCkge1xyXG4gICAgICAgIGQubWF4TGluZUxlbmd0aCA9IGxlbjtcclxuICAgICAgICBkLm1heExpbmUgPSBsaW5lO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIE1ha2Ugc3VyZSB0aGUgZ3V0dGVycyBvcHRpb25zIGNvbnRhaW5zIHRoZSBlbGVtZW50XHJcbiAgLy8gXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCIgd2hlbiB0aGUgbGluZU51bWJlcnMgb3B0aW9uIGlzIHRydWUuXHJcbiAgZnVuY3Rpb24gc2V0R3V0dGVyc0ZvckxpbmVOdW1iZXJzKG9wdGlvbnMpIHtcclxuICAgIHZhciBmb3VuZCA9IGluZGV4T2Yob3B0aW9ucy5ndXR0ZXJzLCBcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIik7XHJcbiAgICBpZiAoZm91bmQgPT0gLTEgJiYgb3B0aW9ucy5saW5lTnVtYmVycykge1xyXG4gICAgICBvcHRpb25zLmd1dHRlcnMgPSBvcHRpb25zLmd1dHRlcnMuY29uY2F0KFtcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIl0pO1xyXG4gICAgfSBlbHNlIGlmIChmb3VuZCA+IC0xICYmICFvcHRpb25zLmxpbmVOdW1iZXJzKSB7XHJcbiAgICAgIG9wdGlvbnMuZ3V0dGVycyA9IG9wdGlvbnMuZ3V0dGVycy5zbGljZSgwKTtcclxuICAgICAgb3B0aW9ucy5ndXR0ZXJzLnNwbGljZShmb3VuZCwgMSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTQ1JPTExCQVJTXHJcblxyXG4gIC8vIFByZXBhcmUgRE9NIHJlYWRzIG5lZWRlZCB0byB1cGRhdGUgdGhlIHNjcm9sbGJhcnMuIERvbmUgaW4gb25lXHJcbiAgLy8gc2hvdCB0byBtaW5pbWl6ZSB1cGRhdGUvbWVhc3VyZSByb3VuZHRyaXBzLlxyXG4gIGZ1bmN0aW9uIG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKSB7XHJcbiAgICB2YXIgZCA9IGNtLmRpc3BsYXksIGd1dHRlclcgPSBkLmd1dHRlcnMub2Zmc2V0V2lkdGg7XHJcbiAgICB2YXIgZG9jSCA9IE1hdGgucm91bmQoY20uZG9jLmhlaWdodCArIHBhZGRpbmdWZXJ0KGNtLmRpc3BsYXkpKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNsaWVudEhlaWdodDogZC5zY3JvbGxlci5jbGllbnRIZWlnaHQsXHJcbiAgICAgIHZpZXdIZWlnaHQ6IGQud3JhcHBlci5jbGllbnRIZWlnaHQsXHJcbiAgICAgIHNjcm9sbFdpZHRoOiBkLnNjcm9sbGVyLnNjcm9sbFdpZHRoLCBjbGllbnRXaWR0aDogZC5zY3JvbGxlci5jbGllbnRXaWR0aCxcclxuICAgICAgdmlld1dpZHRoOiBkLndyYXBwZXIuY2xpZW50V2lkdGgsXHJcbiAgICAgIGJhckxlZnQ6IGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIgPyBndXR0ZXJXIDogMCxcclxuICAgICAgZG9jSGVpZ2h0OiBkb2NILFxyXG4gICAgICBzY3JvbGxIZWlnaHQ6IGRvY0ggKyBzY3JvbGxHYXAoY20pICsgZC5iYXJIZWlnaHQsXHJcbiAgICAgIG5hdGl2ZUJhcldpZHRoOiBkLm5hdGl2ZUJhcldpZHRoLFxyXG4gICAgICBndXR0ZXJXaWR0aDogZ3V0dGVyV1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIE5hdGl2ZVNjcm9sbGJhcnMocGxhY2UsIHNjcm9sbCwgY20pIHtcclxuICAgIHRoaXMuY20gPSBjbTtcclxuICAgIHZhciB2ZXJ0ID0gdGhpcy52ZXJ0ID0gZWx0KFwiZGl2XCIsIFtlbHQoXCJkaXZcIiwgbnVsbCwgbnVsbCwgXCJtaW4td2lkdGg6IDFweFwiKV0sIFwiQ29kZU1pcnJvci12c2Nyb2xsYmFyXCIpO1xyXG4gICAgdmFyIGhvcml6ID0gdGhpcy5ob3JpeiA9IGVsdChcImRpdlwiLCBbZWx0KFwiZGl2XCIsIG51bGwsIG51bGwsIFwiaGVpZ2h0OiAxMDAlOyBtaW4taGVpZ2h0OiAxcHhcIildLCBcIkNvZGVNaXJyb3ItaHNjcm9sbGJhclwiKTtcclxuICAgIHBsYWNlKHZlcnQpOyBwbGFjZShob3Jpeik7XHJcblxyXG4gICAgb24odmVydCwgXCJzY3JvbGxcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICh2ZXJ0LmNsaWVudEhlaWdodCkgc2Nyb2xsKHZlcnQuc2Nyb2xsVG9wLCBcInZlcnRpY2FsXCIpO1xyXG4gICAgfSk7XHJcbiAgICBvbihob3JpeiwgXCJzY3JvbGxcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmIChob3Jpei5jbGllbnRXaWR0aCkgc2Nyb2xsKGhvcml6LnNjcm9sbExlZnQsIFwiaG9yaXpvbnRhbFwiKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuY2hlY2tlZE92ZXJsYXkgPSBmYWxzZTtcclxuICAgIC8vIE5lZWQgdG8gc2V0IGEgbWluaW11bSB3aWR0aCB0byBzZWUgdGhlIHNjcm9sbGJhciBvbiBJRTcgKGJ1dCBtdXN0IG5vdCBzZXQgaXQgb24gSUU4KS5cclxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOCkgdGhpcy5ob3Jpei5zdHlsZS5taW5IZWlnaHQgPSB0aGlzLnZlcnQuc3R5bGUubWluV2lkdGggPSBcIjE4cHhcIjtcclxuICB9XHJcblxyXG4gIE5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlID0gY29weU9iaih7XHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKG1lYXN1cmUpIHtcclxuICAgICAgdmFyIG5lZWRzSCA9IG1lYXN1cmUuc2Nyb2xsV2lkdGggPiBtZWFzdXJlLmNsaWVudFdpZHRoICsgMTtcclxuICAgICAgdmFyIG5lZWRzViA9IG1lYXN1cmUuc2Nyb2xsSGVpZ2h0ID4gbWVhc3VyZS5jbGllbnRIZWlnaHQgKyAxO1xyXG4gICAgICB2YXIgc1dpZHRoID0gbWVhc3VyZS5uYXRpdmVCYXJXaWR0aDtcclxuXHJcbiAgICAgIGlmIChuZWVkc1YpIHtcclxuICAgICAgICB0aGlzLnZlcnQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcclxuICAgICAgICB0aGlzLnZlcnQuc3R5bGUuYm90dG9tID0gbmVlZHNIID8gc1dpZHRoICsgXCJweFwiIDogXCIwXCI7XHJcbiAgICAgICAgdmFyIHRvdGFsSGVpZ2h0ID0gbWVhc3VyZS52aWV3SGVpZ2h0IC0gKG5lZWRzSCA/IHNXaWR0aCA6IDApO1xyXG4gICAgICAgIC8vIEEgYnVnIGluIElFOCBjYW4gY2F1c2UgdGhpcyB2YWx1ZSB0byBiZSBuZWdhdGl2ZSwgc28gZ3VhcmQgaXQuXHJcbiAgICAgICAgdGhpcy52ZXJ0LmZpcnN0Q2hpbGQuc3R5bGUuaGVpZ2h0ID1cclxuICAgICAgICAgIE1hdGgubWF4KDAsIG1lYXN1cmUuc2Nyb2xsSGVpZ2h0IC0gbWVhc3VyZS5jbGllbnRIZWlnaHQgKyB0b3RhbEhlaWdodCkgKyBcInB4XCI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy52ZXJ0LnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xyXG4gICAgICAgIHRoaXMudmVydC5maXJzdENoaWxkLnN0eWxlLmhlaWdodCA9IFwiMFwiO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobmVlZHNIKSB7XHJcbiAgICAgICAgdGhpcy5ob3Jpei5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xyXG4gICAgICAgIHRoaXMuaG9yaXouc3R5bGUucmlnaHQgPSBuZWVkc1YgPyBzV2lkdGggKyBcInB4XCIgOiBcIjBcIjtcclxuICAgICAgICB0aGlzLmhvcml6LnN0eWxlLmxlZnQgPSBtZWFzdXJlLmJhckxlZnQgKyBcInB4XCI7XHJcbiAgICAgICAgdmFyIHRvdGFsV2lkdGggPSBtZWFzdXJlLnZpZXdXaWR0aCAtIG1lYXN1cmUuYmFyTGVmdCAtIChuZWVkc1YgPyBzV2lkdGggOiAwKTtcclxuICAgICAgICB0aGlzLmhvcml6LmZpcnN0Q2hpbGQuc3R5bGUud2lkdGggPVxyXG4gICAgICAgICAgKG1lYXN1cmUuc2Nyb2xsV2lkdGggLSBtZWFzdXJlLmNsaWVudFdpZHRoICsgdG90YWxXaWR0aCkgKyBcInB4XCI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5ob3Jpei5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcclxuICAgICAgICB0aGlzLmhvcml6LmZpcnN0Q2hpbGQuc3R5bGUud2lkdGggPSBcIjBcIjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCF0aGlzLmNoZWNrZWRPdmVybGF5ICYmIG1lYXN1cmUuY2xpZW50SGVpZ2h0ID4gMCkge1xyXG4gICAgICAgIGlmIChzV2lkdGggPT0gMCkgdGhpcy5vdmVybGF5SGFjaygpO1xyXG4gICAgICAgIHRoaXMuY2hlY2tlZE92ZXJsYXkgPSB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4ge3JpZ2h0OiBuZWVkc1YgPyBzV2lkdGggOiAwLCBib3R0b206IG5lZWRzSCA/IHNXaWR0aCA6IDB9O1xyXG4gICAgfSxcclxuICAgIHNldFNjcm9sbExlZnQ6IGZ1bmN0aW9uKHBvcykge1xyXG4gICAgICBpZiAodGhpcy5ob3Jpei5zY3JvbGxMZWZ0ICE9IHBvcykgdGhpcy5ob3Jpei5zY3JvbGxMZWZ0ID0gcG9zO1xyXG4gICAgfSxcclxuICAgIHNldFNjcm9sbFRvcDogZnVuY3Rpb24ocG9zKSB7XHJcbiAgICAgIGlmICh0aGlzLnZlcnQuc2Nyb2xsVG9wICE9IHBvcykgdGhpcy52ZXJ0LnNjcm9sbFRvcCA9IHBvcztcclxuICAgIH0sXHJcbiAgICBvdmVybGF5SGFjazogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciB3ID0gbWFjICYmICFtYWNfZ2VNb3VudGFpbkxpb24gPyBcIjEycHhcIiA6IFwiMThweFwiO1xyXG4gICAgICB0aGlzLmhvcml6LnN0eWxlLm1pbkhlaWdodCA9IHRoaXMudmVydC5zdHlsZS5taW5XaWR0aCA9IHc7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgdmFyIGJhck1vdXNlRG93biA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICBpZiAoZV90YXJnZXQoZSkgIT0gc2VsZi52ZXJ0ICYmIGVfdGFyZ2V0KGUpICE9IHNlbGYuaG9yaXopXHJcbiAgICAgICAgICBvcGVyYXRpb24oc2VsZi5jbSwgb25Nb3VzZURvd24pKGUpO1xyXG4gICAgICB9O1xyXG4gICAgICBvbih0aGlzLnZlcnQsIFwibW91c2Vkb3duXCIsIGJhck1vdXNlRG93bik7XHJcbiAgICAgIG9uKHRoaXMuaG9yaXosIFwibW91c2Vkb3duXCIsIGJhck1vdXNlRG93bik7XHJcbiAgICB9LFxyXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5ob3Jpei5wYXJlbnROb2RlO1xyXG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5ob3Jpeik7XHJcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLnZlcnQpO1xyXG4gICAgfVxyXG4gIH0sIE5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlKTtcclxuXHJcbiAgZnVuY3Rpb24gTnVsbFNjcm9sbGJhcnMoKSB7fVxyXG5cclxuICBOdWxsU2Nyb2xsYmFycy5wcm90b3R5cGUgPSBjb3B5T2JqKHtcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7IHJldHVybiB7Ym90dG9tOiAwLCByaWdodDogMH07IH0sXHJcbiAgICBzZXRTY3JvbGxMZWZ0OiBmdW5jdGlvbigpIHt9LFxyXG4gICAgc2V0U2Nyb2xsVG9wOiBmdW5jdGlvbigpIHt9LFxyXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge31cclxuICB9LCBOdWxsU2Nyb2xsYmFycy5wcm90b3R5cGUpO1xyXG5cclxuICBDb2RlTWlycm9yLnNjcm9sbGJhck1vZGVsID0ge1wibmF0aXZlXCI6IE5hdGl2ZVNjcm9sbGJhcnMsIFwibnVsbFwiOiBOdWxsU2Nyb2xsYmFyc307XHJcblxyXG4gIGZ1bmN0aW9uIGluaXRTY3JvbGxiYXJzKGNtKSB7XHJcbiAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxiYXJzKSB7XHJcbiAgICAgIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5jbGVhcigpO1xyXG4gICAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzKVxyXG4gICAgICAgIHJtQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpO1xyXG4gICAgfVxyXG5cclxuICAgIGNtLmRpc3BsYXkuc2Nyb2xsYmFycyA9IG5ldyBDb2RlTWlycm9yLnNjcm9sbGJhck1vZGVsW2NtLm9wdGlvbnMuc2Nyb2xsYmFyU3R5bGVdKGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgY20uZGlzcGxheS53cmFwcGVyLmluc2VydEJlZm9yZShub2RlLCBjbS5kaXNwbGF5LnNjcm9sbGJhckZpbGxlcik7XHJcbiAgICAgIC8vIFByZXZlbnQgY2xpY2tzIGluIHRoZSBzY3JvbGxiYXJzIGZyb20ga2lsbGluZyBmb2N1c1xyXG4gICAgICBvbihub2RlLCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoY20uc3RhdGUuZm9jdXNlZCkgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY20uZGlzcGxheS5pbnB1dC5mb2N1cygpOyB9LCAwKTtcclxuICAgICAgfSk7XHJcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiY20tbm90LWNvbnRlbnRcIiwgXCJ0cnVlXCIpO1xyXG4gICAgfSwgZnVuY3Rpb24ocG9zLCBheGlzKSB7XHJcbiAgICAgIGlmIChheGlzID09IFwiaG9yaXpvbnRhbFwiKSBzZXRTY3JvbGxMZWZ0KGNtLCBwb3MpO1xyXG4gICAgICBlbHNlIHNldFNjcm9sbFRvcChjbSwgcG9zKTtcclxuICAgIH0sIGNtKTtcclxuICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpXHJcbiAgICAgIGFkZENsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgY20uZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbGJhcnMoY20sIG1lYXN1cmUpIHtcclxuICAgIGlmICghbWVhc3VyZSkgbWVhc3VyZSA9IG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKTtcclxuICAgIHZhciBzdGFydFdpZHRoID0gY20uZGlzcGxheS5iYXJXaWR0aCwgc3RhcnRIZWlnaHQgPSBjbS5kaXNwbGF5LmJhckhlaWdodDtcclxuICAgIHVwZGF0ZVNjcm9sbGJhcnNJbm5lcihjbSwgbWVhc3VyZSk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQgJiYgc3RhcnRXaWR0aCAhPSBjbS5kaXNwbGF5LmJhcldpZHRoIHx8IHN0YXJ0SGVpZ2h0ICE9IGNtLmRpc3BsYXkuYmFySGVpZ2h0OyBpKyspIHtcclxuICAgICAgaWYgKHN0YXJ0V2lkdGggIT0gY20uZGlzcGxheS5iYXJXaWR0aCAmJiBjbS5vcHRpb25zLmxpbmVXcmFwcGluZylcclxuICAgICAgICB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSk7XHJcbiAgICAgIHVwZGF0ZVNjcm9sbGJhcnNJbm5lcihjbSwgbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pKTtcclxuICAgICAgc3RhcnRXaWR0aCA9IGNtLmRpc3BsYXkuYmFyV2lkdGg7IHN0YXJ0SGVpZ2h0ID0gY20uZGlzcGxheS5iYXJIZWlnaHQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBSZS1zeW5jaHJvbml6ZSB0aGUgZmFrZSBzY3JvbGxiYXJzIHdpdGggdGhlIGFjdHVhbCBzaXplIG9mIHRoZVxyXG4gIC8vIGNvbnRlbnQuXHJcbiAgZnVuY3Rpb24gdXBkYXRlU2Nyb2xsYmFyc0lubmVyKGNtLCBtZWFzdXJlKSB7XHJcbiAgICB2YXIgZCA9IGNtLmRpc3BsYXk7XHJcbiAgICB2YXIgc2l6ZXMgPSBkLnNjcm9sbGJhcnMudXBkYXRlKG1lYXN1cmUpO1xyXG5cclxuICAgIGQuc2l6ZXIuc3R5bGUucGFkZGluZ1JpZ2h0ID0gKGQuYmFyV2lkdGggPSBzaXplcy5yaWdodCkgKyBcInB4XCI7XHJcbiAgICBkLnNpemVyLnN0eWxlLnBhZGRpbmdCb3R0b20gPSAoZC5iYXJIZWlnaHQgPSBzaXplcy5ib3R0b20pICsgXCJweFwiO1xyXG5cclxuICAgIGlmIChzaXplcy5yaWdodCAmJiBzaXplcy5ib3R0b20pIHtcclxuICAgICAgZC5zY3JvbGxiYXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcclxuICAgICAgZC5zY3JvbGxiYXJGaWxsZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZXMuYm90dG9tICsgXCJweFwiO1xyXG4gICAgICBkLnNjcm9sbGJhckZpbGxlci5zdHlsZS53aWR0aCA9IHNpemVzLnJpZ2h0ICsgXCJweFwiO1xyXG4gICAgfSBlbHNlIGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xyXG4gICAgaWYgKHNpemVzLmJvdHRvbSAmJiBjbS5vcHRpb25zLmNvdmVyR3V0dGVyTmV4dFRvU2Nyb2xsYmFyICYmIGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpIHtcclxuICAgICAgZC5ndXR0ZXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcclxuICAgICAgZC5ndXR0ZXJGaWxsZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZXMuYm90dG9tICsgXCJweFwiO1xyXG4gICAgICBkLmd1dHRlckZpbGxlci5zdHlsZS53aWR0aCA9IG1lYXN1cmUuZ3V0dGVyV2lkdGggKyBcInB4XCI7XHJcbiAgICB9IGVsc2UgZC5ndXR0ZXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFwiXCI7XHJcbiAgfVxyXG5cclxuICAvLyBDb21wdXRlIHRoZSBsaW5lcyB0aGF0IGFyZSB2aXNpYmxlIGluIGEgZ2l2ZW4gdmlld3BvcnQgKGRlZmF1bHRzXHJcbiAgLy8gdGhlIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbikuIHZpZXdwb3J0IG1heSBjb250YWluIHRvcCxcclxuICAvLyBoZWlnaHQsIGFuZCBlbnN1cmUgKHNlZSBvcC5zY3JvbGxUb1BvcykgcHJvcGVydGllcy5cclxuICBmdW5jdGlvbiB2aXNpYmxlTGluZXMoZGlzcGxheSwgZG9jLCB2aWV3cG9ydCkge1xyXG4gICAgdmFyIHRvcCA9IHZpZXdwb3J0ICYmIHZpZXdwb3J0LnRvcCAhPSBudWxsID8gTWF0aC5tYXgoMCwgdmlld3BvcnQudG9wKSA6IGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wO1xyXG4gICAgdG9wID0gTWF0aC5mbG9vcih0b3AgLSBwYWRkaW5nVG9wKGRpc3BsYXkpKTtcclxuICAgIHZhciBib3R0b20gPSB2aWV3cG9ydCAmJiB2aWV3cG9ydC5ib3R0b20gIT0gbnVsbCA/IHZpZXdwb3J0LmJvdHRvbSA6IHRvcCArIGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQ7XHJcblxyXG4gICAgdmFyIGZyb20gPSBsaW5lQXRIZWlnaHQoZG9jLCB0b3ApLCB0byA9IGxpbmVBdEhlaWdodChkb2MsIGJvdHRvbSk7XHJcbiAgICAvLyBFbnN1cmUgaXMgYSB7ZnJvbToge2xpbmUsIGNofSwgdG86IHtsaW5lLCBjaH19IG9iamVjdCwgYW5kXHJcbiAgICAvLyBmb3JjZXMgdGhvc2UgbGluZXMgaW50byB0aGUgdmlld3BvcnQgKGlmIHBvc3NpYmxlKS5cclxuICAgIGlmICh2aWV3cG9ydCAmJiB2aWV3cG9ydC5lbnN1cmUpIHtcclxuICAgICAgdmFyIGVuc3VyZUZyb20gPSB2aWV3cG9ydC5lbnN1cmUuZnJvbS5saW5lLCBlbnN1cmVUbyA9IHZpZXdwb3J0LmVuc3VyZS50by5saW5lO1xyXG4gICAgICBpZiAoZW5zdXJlRnJvbSA8IGZyb20pIHtcclxuICAgICAgICBmcm9tID0gZW5zdXJlRnJvbTtcclxuICAgICAgICB0byA9IGxpbmVBdEhlaWdodChkb2MsIGhlaWdodEF0TGluZShnZXRMaW5lKGRvYywgZW5zdXJlRnJvbSkpICsgZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoTWF0aC5taW4oZW5zdXJlVG8sIGRvYy5sYXN0TGluZSgpKSA+PSB0bykge1xyXG4gICAgICAgIGZyb20gPSBsaW5lQXRIZWlnaHQoZG9jLCBoZWlnaHRBdExpbmUoZ2V0TGluZShkb2MsIGVuc3VyZVRvKSkgLSBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0KTtcclxuICAgICAgICB0byA9IGVuc3VyZVRvO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge2Zyb206IGZyb20sIHRvOiBNYXRoLm1heCh0bywgZnJvbSArIDEpfTtcclxuICB9XHJcblxyXG4gIC8vIExJTkUgTlVNQkVSU1xyXG5cclxuICAvLyBSZS1hbGlnbiBsaW5lIG51bWJlcnMgYW5kIGd1dHRlciBtYXJrcyB0byBjb21wZW5zYXRlIGZvclxyXG4gIC8vIGhvcml6b250YWwgc2Nyb2xsaW5nLlxyXG4gIGZ1bmN0aW9uIGFsaWduSG9yaXpvbnRhbGx5KGNtKSB7XHJcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHZpZXcgPSBkaXNwbGF5LnZpZXc7XHJcbiAgICBpZiAoIWRpc3BsYXkuYWxpZ25XaWRnZXRzICYmICghZGlzcGxheS5ndXR0ZXJzLmZpcnN0Q2hpbGQgfHwgIWNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpKSByZXR1cm47XHJcbiAgICB2YXIgY29tcCA9IGNvbXBlbnNhdGVGb3JIU2Nyb2xsKGRpc3BsYXkpIC0gZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ICsgY20uZG9jLnNjcm9sbExlZnQ7XHJcbiAgICB2YXIgZ3V0dGVyVyA9IGRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aCwgbGVmdCA9IGNvbXAgKyBcInB4XCI7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIGlmICghdmlld1tpXS5oaWRkZW4pIHtcclxuICAgICAgaWYgKGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIgJiYgdmlld1tpXS5ndXR0ZXIpXHJcbiAgICAgICAgdmlld1tpXS5ndXR0ZXIuc3R5bGUubGVmdCA9IGxlZnQ7XHJcbiAgICAgIHZhciBhbGlnbiA9IHZpZXdbaV0uYWxpZ25hYmxlO1xyXG4gICAgICBpZiAoYWxpZ24pIGZvciAodmFyIGogPSAwOyBqIDwgYWxpZ24ubGVuZ3RoOyBqKyspXHJcbiAgICAgICAgYWxpZ25bal0uc3R5bGUubGVmdCA9IGxlZnQ7XHJcbiAgICB9XHJcbiAgICBpZiAoY20ub3B0aW9ucy5maXhlZEd1dHRlcilcclxuICAgICAgZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmxlZnQgPSAoY29tcCArIGd1dHRlclcpICsgXCJweFwiO1xyXG4gIH1cclxuXHJcbiAgLy8gVXNlZCB0byBlbnN1cmUgdGhhdCB0aGUgbGluZSBudW1iZXIgZ3V0dGVyIGlzIHN0aWxsIHRoZSByaWdodFxyXG4gIC8vIHNpemUgZm9yIHRoZSBjdXJyZW50IGRvY3VtZW50IHNpemUuIFJldHVybnMgdHJ1ZSB3aGVuIGFuIHVwZGF0ZVxyXG4gIC8vIGlzIG5lZWRlZC5cclxuICBmdW5jdGlvbiBtYXliZVVwZGF0ZUxpbmVOdW1iZXJXaWR0aChjbSkge1xyXG4gICAgaWYgKCFjbS5vcHRpb25zLmxpbmVOdW1iZXJzKSByZXR1cm4gZmFsc2U7XHJcbiAgICB2YXIgZG9jID0gY20uZG9jLCBsYXN0ID0gbGluZU51bWJlckZvcihjbS5vcHRpb25zLCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcclxuICAgIGlmIChsYXN0Lmxlbmd0aCAhPSBkaXNwbGF5LmxpbmVOdW1DaGFycykge1xyXG4gICAgICB2YXIgdGVzdCA9IGRpc3BsYXkubWVhc3VyZS5hcHBlbmRDaGlsZChlbHQoXCJkaXZcIiwgW2VsdChcImRpdlwiLCBsYXN0KV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvZGVNaXJyb3ItbGluZW51bWJlciBDb2RlTWlycm9yLWd1dHRlci1lbHRcIikpO1xyXG4gICAgICB2YXIgaW5uZXJXID0gdGVzdC5maXJzdENoaWxkLm9mZnNldFdpZHRoLCBwYWRkaW5nID0gdGVzdC5vZmZzZXRXaWR0aCAtIGlubmVyVztcclxuICAgICAgZGlzcGxheS5saW5lR3V0dGVyLnN0eWxlLndpZHRoID0gXCJcIjtcclxuICAgICAgZGlzcGxheS5saW5lTnVtSW5uZXJXaWR0aCA9IE1hdGgubWF4KGlubmVyVywgZGlzcGxheS5saW5lR3V0dGVyLm9mZnNldFdpZHRoIC0gcGFkZGluZykgKyAxO1xyXG4gICAgICBkaXNwbGF5LmxpbmVOdW1XaWR0aCA9IGRpc3BsYXkubGluZU51bUlubmVyV2lkdGggKyBwYWRkaW5nO1xyXG4gICAgICBkaXNwbGF5LmxpbmVOdW1DaGFycyA9IGRpc3BsYXkubGluZU51bUlubmVyV2lkdGggPyBsYXN0Lmxlbmd0aCA6IC0xO1xyXG4gICAgICBkaXNwbGF5LmxpbmVHdXR0ZXIuc3R5bGUud2lkdGggPSBkaXNwbGF5LmxpbmVOdW1XaWR0aCArIFwicHhcIjtcclxuICAgICAgdXBkYXRlR3V0dGVyU3BhY2UoY20pO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGxpbmVOdW1iZXJGb3Iob3B0aW9ucywgaSkge1xyXG4gICAgcmV0dXJuIFN0cmluZyhvcHRpb25zLmxpbmVOdW1iZXJGb3JtYXR0ZXIoaSArIG9wdGlvbnMuZmlyc3RMaW5lTnVtYmVyKSk7XHJcbiAgfVxyXG5cclxuICAvLyBDb21wdXRlcyBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgKyBkaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGgsXHJcbiAgLy8gYnV0IHVzaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCB0byBnZXQgYSBzdWItcGl4ZWwtYWNjdXJhdGVcclxuICAvLyByZXN1bHQuXHJcbiAgZnVuY3Rpb24gY29tcGVuc2F0ZUZvckhTY3JvbGwoZGlzcGxheSkge1xyXG4gICAgcmV0dXJuIGRpc3BsYXkuc2Nyb2xsZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtIGRpc3BsYXkuc2l6ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcclxuICB9XHJcblxyXG4gIC8vIERJU1BMQVkgRFJBV0lOR1xyXG5cclxuICBmdW5jdGlvbiBEaXNwbGF5VXBkYXRlKGNtLCB2aWV3cG9ydCwgZm9yY2UpIHtcclxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcclxuXHJcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XHJcbiAgICAvLyBTdG9yZSBzb21lIHZhbHVlcyB0aGF0IHdlJ2xsIG5lZWQgbGF0ZXIgKGJ1dCBkb24ndCB3YW50IHRvIGZvcmNlIGEgcmVsYXlvdXQgZm9yKVxyXG4gICAgdGhpcy52aXNpYmxlID0gdmlzaWJsZUxpbmVzKGRpc3BsYXksIGNtLmRvYywgdmlld3BvcnQpO1xyXG4gICAgdGhpcy5lZGl0b3JJc0hpZGRlbiA9ICFkaXNwbGF5LndyYXBwZXIub2Zmc2V0V2lkdGg7XHJcbiAgICB0aGlzLndyYXBwZXJIZWlnaHQgPSBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0O1xyXG4gICAgdGhpcy53cmFwcGVyV2lkdGggPSBkaXNwbGF5LndyYXBwZXIuY2xpZW50V2lkdGg7XHJcbiAgICB0aGlzLm9sZERpc3BsYXlXaWR0aCA9IGRpc3BsYXlXaWR0aChjbSk7XHJcbiAgICB0aGlzLmZvcmNlID0gZm9yY2U7XHJcbiAgICB0aGlzLmRpbXMgPSBnZXREaW1lbnNpb25zKGNtKTtcclxuICAgIHRoaXMuZXZlbnRzID0gW107XHJcbiAgfVxyXG5cclxuICBEaXNwbGF5VXBkYXRlLnByb3RvdHlwZS5zaWduYWwgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XHJcbiAgICBpZiAoaGFzSGFuZGxlcihlbWl0dGVyLCB0eXBlKSlcclxuICAgICAgdGhpcy5ldmVudHMucHVzaChhcmd1bWVudHMpO1xyXG4gIH07XHJcbiAgRGlzcGxheVVwZGF0ZS5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24oKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXZlbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICBzaWduYWwuYXBwbHkobnVsbCwgdGhpcy5ldmVudHNbaV0pO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIG1heWJlQ2xpcFNjcm9sbGJhcnMoY20pIHtcclxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcclxuICAgIGlmICghZGlzcGxheS5zY3JvbGxiYXJzQ2xpcHBlZCAmJiBkaXNwbGF5LnNjcm9sbGVyLm9mZnNldFdpZHRoKSB7XHJcbiAgICAgIGRpc3BsYXkubmF0aXZlQmFyV2lkdGggPSBkaXNwbGF5LnNjcm9sbGVyLm9mZnNldFdpZHRoIC0gZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aDtcclxuICAgICAgZGlzcGxheS5oZWlnaHRGb3JjZXIuc3R5bGUuaGVpZ2h0ID0gc2Nyb2xsR2FwKGNtKSArIFwicHhcIjtcclxuICAgICAgZGlzcGxheS5zaXplci5zdHlsZS5tYXJnaW5Cb3R0b20gPSAtZGlzcGxheS5uYXRpdmVCYXJXaWR0aCArIFwicHhcIjtcclxuICAgICAgZGlzcGxheS5zaXplci5zdHlsZS5ib3JkZXJSaWdodFdpZHRoID0gc2Nyb2xsR2FwKGNtKSArIFwicHhcIjtcclxuICAgICAgZGlzcGxheS5zY3JvbGxiYXJzQ2xpcHBlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBEb2VzIHRoZSBhY3R1YWwgdXBkYXRpbmcgb2YgdGhlIGxpbmUgZGlzcGxheS4gQmFpbHMgb3V0XHJcbiAgLy8gKHJldHVybmluZyBmYWxzZSkgd2hlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGJlIGRvbmUgYW5kIGZvcmNlZCBpc1xyXG4gIC8vIGZhbHNlLlxyXG4gIGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXlJZk5lZWRlZChjbSwgdXBkYXRlKSB7XHJcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcclxuXHJcbiAgICBpZiAodXBkYXRlLmVkaXRvcklzSGlkZGVuKSB7XHJcbiAgICAgIHJlc2V0VmlldyhjbSk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBCYWlsIG91dCBpZiB0aGUgdmlzaWJsZSBhcmVhIGlzIGFscmVhZHkgcmVuZGVyZWQgYW5kIG5vdGhpbmcgY2hhbmdlZC5cclxuICAgIGlmICghdXBkYXRlLmZvcmNlICYmXHJcbiAgICAgICAgdXBkYXRlLnZpc2libGUuZnJvbSA+PSBkaXNwbGF5LnZpZXdGcm9tICYmIHVwZGF0ZS52aXNpYmxlLnRvIDw9IGRpc3BsYXkudmlld1RvICYmXHJcbiAgICAgICAgKGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPT0gbnVsbCB8fCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID49IGRpc3BsYXkudmlld1RvKSAmJlxyXG4gICAgICAgIGRpc3BsYXkucmVuZGVyZWRWaWV3ID09IGRpc3BsYXkudmlldyAmJiBjb3VudERpcnR5VmlldyhjbSkgPT0gMClcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIGlmIChtYXliZVVwZGF0ZUxpbmVOdW1iZXJXaWR0aChjbSkpIHtcclxuICAgICAgcmVzZXRWaWV3KGNtKTtcclxuICAgICAgdXBkYXRlLmRpbXMgPSBnZXREaW1lbnNpb25zKGNtKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb21wdXRlIGEgc3VpdGFibGUgbmV3IHZpZXdwb3J0IChmcm9tICYgdG8pXHJcbiAgICB2YXIgZW5kID0gZG9jLmZpcnN0ICsgZG9jLnNpemU7XHJcbiAgICB2YXIgZnJvbSA9IE1hdGgubWF4KHVwZGF0ZS52aXNpYmxlLmZyb20gLSBjbS5vcHRpb25zLnZpZXdwb3J0TWFyZ2luLCBkb2MuZmlyc3QpO1xyXG4gICAgdmFyIHRvID0gTWF0aC5taW4oZW5kLCB1cGRhdGUudmlzaWJsZS50byArIGNtLm9wdGlvbnMudmlld3BvcnRNYXJnaW4pO1xyXG4gICAgaWYgKGRpc3BsYXkudmlld0Zyb20gPCBmcm9tICYmIGZyb20gLSBkaXNwbGF5LnZpZXdGcm9tIDwgMjApIGZyb20gPSBNYXRoLm1heChkb2MuZmlyc3QsIGRpc3BsYXkudmlld0Zyb20pO1xyXG4gICAgaWYgKGRpc3BsYXkudmlld1RvID4gdG8gJiYgZGlzcGxheS52aWV3VG8gLSB0byA8IDIwKSB0byA9IE1hdGgubWluKGVuZCwgZGlzcGxheS52aWV3VG8pO1xyXG4gICAgaWYgKHNhd0NvbGxhcHNlZFNwYW5zKSB7XHJcbiAgICAgIGZyb20gPSB2aXN1YWxMaW5lTm8oY20uZG9jLCBmcm9tKTtcclxuICAgICAgdG8gPSB2aXN1YWxMaW5lRW5kTm8oY20uZG9jLCB0byk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRpZmZlcmVudCA9IGZyb20gIT0gZGlzcGxheS52aWV3RnJvbSB8fCB0byAhPSBkaXNwbGF5LnZpZXdUbyB8fFxyXG4gICAgICBkaXNwbGF5Lmxhc3RXcmFwSGVpZ2h0ICE9IHVwZGF0ZS53cmFwcGVySGVpZ2h0IHx8IGRpc3BsYXkubGFzdFdyYXBXaWR0aCAhPSB1cGRhdGUud3JhcHBlcldpZHRoO1xyXG4gICAgYWRqdXN0VmlldyhjbSwgZnJvbSwgdG8pO1xyXG5cclxuICAgIGRpc3BsYXkudmlld09mZnNldCA9IGhlaWdodEF0TGluZShnZXRMaW5lKGNtLmRvYywgZGlzcGxheS52aWV3RnJvbSkpO1xyXG4gICAgLy8gUG9zaXRpb24gdGhlIG1vdmVyIGRpdiB0byBhbGlnbiB3aXRoIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvblxyXG4gICAgY20uZGlzcGxheS5tb3Zlci5zdHlsZS50b3AgPSBkaXNwbGF5LnZpZXdPZmZzZXQgKyBcInB4XCI7XHJcblxyXG4gICAgdmFyIHRvVXBkYXRlID0gY291bnREaXJ0eVZpZXcoY20pO1xyXG4gICAgaWYgKCFkaWZmZXJlbnQgJiYgdG9VcGRhdGUgPT0gMCAmJiAhdXBkYXRlLmZvcmNlICYmIGRpc3BsYXkucmVuZGVyZWRWaWV3ID09IGRpc3BsYXkudmlldyAmJlxyXG4gICAgICAgIChkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID09IG51bGwgfHwgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA+PSBkaXNwbGF5LnZpZXdUbykpXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAvLyBGb3IgYmlnIGNoYW5nZXMsIHdlIGhpZGUgdGhlIGVuY2xvc2luZyBlbGVtZW50IGR1cmluZyB0aGVcclxuICAgIC8vIHVwZGF0ZSwgc2luY2UgdGhhdCBzcGVlZHMgdXAgdGhlIG9wZXJhdGlvbnMgb24gbW9zdCBicm93c2Vycy5cclxuICAgIHZhciBmb2N1c2VkID0gYWN0aXZlRWx0KCk7XHJcbiAgICBpZiAodG9VcGRhdGUgPiA0KSBkaXNwbGF5LmxpbmVEaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgcGF0Y2hEaXNwbGF5KGNtLCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzLCB1cGRhdGUuZGltcyk7XHJcbiAgICBpZiAodG9VcGRhdGUgPiA0KSBkaXNwbGF5LmxpbmVEaXYuc3R5bGUuZGlzcGxheSA9IFwiXCI7XHJcbiAgICBkaXNwbGF5LnJlbmRlcmVkVmlldyA9IGRpc3BsYXkudmlldztcclxuICAgIC8vIFRoZXJlIG1pZ2h0IGhhdmUgYmVlbiBhIHdpZGdldCB3aXRoIGEgZm9jdXNlZCBlbGVtZW50IHRoYXQgZ290XHJcbiAgICAvLyBoaWRkZW4gb3IgdXBkYXRlZCwgaWYgc28gcmUtZm9jdXMgaXQuXHJcbiAgICBpZiAoZm9jdXNlZCAmJiBhY3RpdmVFbHQoKSAhPSBmb2N1c2VkICYmIGZvY3VzZWQub2Zmc2V0SGVpZ2h0KSBmb2N1c2VkLmZvY3VzKCk7XHJcblxyXG4gICAgLy8gUHJldmVudCBzZWxlY3Rpb24gYW5kIGN1cnNvcnMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIHRoZSBzY3JvbGxcclxuICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQuXHJcbiAgICByZW1vdmVDaGlsZHJlbihkaXNwbGF5LmN1cnNvckRpdik7XHJcbiAgICByZW1vdmVDaGlsZHJlbihkaXNwbGF5LnNlbGVjdGlvbkRpdik7XHJcbiAgICBkaXNwbGF5Lmd1dHRlcnMuc3R5bGUuaGVpZ2h0ID0gMDtcclxuXHJcbiAgICBpZiAoZGlmZmVyZW50KSB7XHJcbiAgICAgIGRpc3BsYXkubGFzdFdyYXBIZWlnaHQgPSB1cGRhdGUud3JhcHBlckhlaWdodDtcclxuICAgICAgZGlzcGxheS5sYXN0V3JhcFdpZHRoID0gdXBkYXRlLndyYXBwZXJXaWR0aDtcclxuICAgICAgc3RhcnRXb3JrZXIoY20sIDQwMCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA9IG51bGw7XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwb3N0VXBkYXRlRGlzcGxheShjbSwgdXBkYXRlKSB7XHJcbiAgICB2YXIgZm9yY2UgPSB1cGRhdGUuZm9yY2UsIHZpZXdwb3J0ID0gdXBkYXRlLnZpZXdwb3J0O1xyXG4gICAgZm9yICh2YXIgZmlyc3QgPSB0cnVlOzsgZmlyc3QgPSBmYWxzZSkge1xyXG4gICAgICBpZiAoZmlyc3QgJiYgY20ub3B0aW9ucy5saW5lV3JhcHBpbmcgJiYgdXBkYXRlLm9sZERpc3BsYXlXaWR0aCAhPSBkaXNwbGF5V2lkdGgoY20pKSB7XHJcbiAgICAgICAgZm9yY2UgPSB0cnVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvcmNlID0gZmFsc2U7XHJcbiAgICAgICAgLy8gQ2xpcCBmb3JjZWQgdmlld3BvcnQgdG8gYWN0dWFsIHNjcm9sbGFibGUgYXJlYS5cclxuICAgICAgICBpZiAodmlld3BvcnQgJiYgdmlld3BvcnQudG9wICE9IG51bGwpXHJcbiAgICAgICAgICB2aWV3cG9ydCA9IHt0b3A6IE1hdGgubWluKGNtLmRvYy5oZWlnaHQgKyBwYWRkaW5nVmVydChjbS5kaXNwbGF5KSAtIGRpc3BsYXlIZWlnaHQoY20pLCB2aWV3cG9ydC50b3ApfTtcclxuICAgICAgICAvLyBVcGRhdGVkIGxpbmUgaGVpZ2h0cyBtaWdodCByZXN1bHQgaW4gdGhlIGRyYXduIGFyZWEgbm90XHJcbiAgICAgICAgLy8gYWN0dWFsbHkgY292ZXJpbmcgdGhlIHZpZXdwb3J0LiBLZWVwIGxvb3BpbmcgdW50aWwgaXQgZG9lcy5cclxuICAgICAgICB1cGRhdGUudmlzaWJsZSA9IHZpc2libGVMaW5lcyhjbS5kaXNwbGF5LCBjbS5kb2MsIHZpZXdwb3J0KTtcclxuICAgICAgICBpZiAodXBkYXRlLnZpc2libGUuZnJvbSA+PSBjbS5kaXNwbGF5LnZpZXdGcm9tICYmIHVwZGF0ZS52aXNpYmxlLnRvIDw9IGNtLmRpc3BsYXkudmlld1RvKVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF1cGRhdGVEaXNwbGF5SWZOZWVkZWQoY20sIHVwZGF0ZSkpIGJyZWFrO1xyXG4gICAgICB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSk7XHJcbiAgICAgIHZhciBiYXJNZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pO1xyXG4gICAgICB1cGRhdGVTZWxlY3Rpb24oY20pO1xyXG4gICAgICBzZXREb2N1bWVudEhlaWdodChjbSwgYmFyTWVhc3VyZSk7XHJcbiAgICAgIHVwZGF0ZVNjcm9sbGJhcnMoY20sIGJhck1lYXN1cmUpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZS5zaWduYWwoY20sIFwidXBkYXRlXCIsIGNtKTtcclxuICAgIGlmIChjbS5kaXNwbGF5LnZpZXdGcm9tICE9IGNtLmRpc3BsYXkucmVwb3J0ZWRWaWV3RnJvbSB8fCBjbS5kaXNwbGF5LnZpZXdUbyAhPSBjbS5kaXNwbGF5LnJlcG9ydGVkVmlld1RvKSB7XHJcbiAgICAgIHVwZGF0ZS5zaWduYWwoY20sIFwidmlld3BvcnRDaGFuZ2VcIiwgY20sIGNtLmRpc3BsYXkudmlld0Zyb20sIGNtLmRpc3BsYXkudmlld1RvKTtcclxuICAgICAgY20uZGlzcGxheS5yZXBvcnRlZFZpZXdGcm9tID0gY20uZGlzcGxheS52aWV3RnJvbTsgY20uZGlzcGxheS5yZXBvcnRlZFZpZXdUbyA9IGNtLmRpc3BsYXkudmlld1RvO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdXBkYXRlRGlzcGxheVNpbXBsZShjbSwgdmlld3BvcnQpIHtcclxuICAgIHZhciB1cGRhdGUgPSBuZXcgRGlzcGxheVVwZGF0ZShjbSwgdmlld3BvcnQpO1xyXG4gICAgaWYgKHVwZGF0ZURpc3BsYXlJZk5lZWRlZChjbSwgdXBkYXRlKSkge1xyXG4gICAgICB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSk7XHJcbiAgICAgIHBvc3RVcGRhdGVEaXNwbGF5KGNtLCB1cGRhdGUpO1xyXG4gICAgICB2YXIgYmFyTWVhc3VyZSA9IG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKTtcclxuICAgICAgdXBkYXRlU2VsZWN0aW9uKGNtKTtcclxuICAgICAgc2V0RG9jdW1lbnRIZWlnaHQoY20sIGJhck1lYXN1cmUpO1xyXG4gICAgICB1cGRhdGVTY3JvbGxiYXJzKGNtLCBiYXJNZWFzdXJlKTtcclxuICAgICAgdXBkYXRlLmZpbmlzaCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2V0RG9jdW1lbnRIZWlnaHQoY20sIG1lYXN1cmUpIHtcclxuICAgIGNtLmRpc3BsYXkuc2l6ZXIuc3R5bGUubWluSGVpZ2h0ID0gbWVhc3VyZS5kb2NIZWlnaHQgKyBcInB4XCI7XHJcbiAgICB2YXIgdG90YWwgPSBtZWFzdXJlLmRvY0hlaWdodCArIGNtLmRpc3BsYXkuYmFySGVpZ2h0O1xyXG4gICAgY20uZGlzcGxheS5oZWlnaHRGb3JjZXIuc3R5bGUudG9wID0gdG90YWwgKyBcInB4XCI7XHJcbiAgICBjbS5kaXNwbGF5Lmd1dHRlcnMuc3R5bGUuaGVpZ2h0ID0gTWF0aC5tYXgodG90YWwgKyBzY3JvbGxHYXAoY20pLCBtZWFzdXJlLmNsaWVudEhlaWdodCkgKyBcInB4XCI7XHJcbiAgfVxyXG5cclxuICAvLyBSZWFkIHRoZSBhY3R1YWwgaGVpZ2h0cyBvZiB0aGUgcmVuZGVyZWQgbGluZXMsIGFuZCB1cGRhdGUgdGhlaXJcclxuICAvLyBzdG9yZWQgaGVpZ2h0cyB0byBtYXRjaC5cclxuICBmdW5jdGlvbiB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSkge1xyXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xyXG4gICAgdmFyIHByZXZCb3R0b20gPSBkaXNwbGF5LmxpbmVEaXYub2Zmc2V0VG9wO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwbGF5LnZpZXcubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGN1ciA9IGRpc3BsYXkudmlld1tpXSwgaGVpZ2h0O1xyXG4gICAgICBpZiAoY3VyLmhpZGRlbikgY29udGludWU7XHJcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOCkge1xyXG4gICAgICAgIHZhciBib3QgPSBjdXIubm9kZS5vZmZzZXRUb3AgKyBjdXIubm9kZS5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgaGVpZ2h0ID0gYm90IC0gcHJldkJvdHRvbTtcclxuICAgICAgICBwcmV2Qm90dG9tID0gYm90O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBib3ggPSBjdXIubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBoZWlnaHQgPSBib3guYm90dG9tIC0gYm94LnRvcDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgZGlmZiA9IGN1ci5saW5lLmhlaWdodCAtIGhlaWdodDtcclxuICAgICAgaWYgKGhlaWdodCA8IDIpIGhlaWdodCA9IHRleHRIZWlnaHQoZGlzcGxheSk7XHJcbiAgICAgIGlmIChkaWZmID4gLjAwMSB8fCBkaWZmIDwgLS4wMDEpIHtcclxuICAgICAgICB1cGRhdGVMaW5lSGVpZ2h0KGN1ci5saW5lLCBoZWlnaHQpO1xyXG4gICAgICAgIHVwZGF0ZVdpZGdldEhlaWdodChjdXIubGluZSk7XHJcbiAgICAgICAgaWYgKGN1ci5yZXN0KSBmb3IgKHZhciBqID0gMDsgaiA8IGN1ci5yZXN0Lmxlbmd0aDsgaisrKVxyXG4gICAgICAgICAgdXBkYXRlV2lkZ2V0SGVpZ2h0KGN1ci5yZXN0W2pdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUmVhZCBhbmQgc3RvcmUgdGhlIGhlaWdodCBvZiBsaW5lIHdpZGdldHMgYXNzb2NpYXRlZCB3aXRoIHRoZVxyXG4gIC8vIGdpdmVuIGxpbmUuXHJcbiAgZnVuY3Rpb24gdXBkYXRlV2lkZ2V0SGVpZ2h0KGxpbmUpIHtcclxuICAgIGlmIChsaW5lLndpZGdldHMpIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS53aWRnZXRzLmxlbmd0aDsgKytpKVxyXG4gICAgICBsaW5lLndpZGdldHNbaV0uaGVpZ2h0ID0gbGluZS53aWRnZXRzW2ldLm5vZGUub2Zmc2V0SGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgLy8gRG8gYSBidWxrLXJlYWQgb2YgdGhlIERPTSBwb3NpdGlvbnMgYW5kIHNpemVzIG5lZWRlZCB0byBkcmF3IHRoZVxyXG4gIC8vIHZpZXcsIHNvIHRoYXQgd2UgZG9uJ3QgaW50ZXJsZWF2ZSByZWFkaW5nIGFuZCB3cml0aW5nIHRvIHRoZSBET00uXHJcbiAgZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyhjbSkge1xyXG4gICAgdmFyIGQgPSBjbS5kaXNwbGF5LCBsZWZ0ID0ge30sIHdpZHRoID0ge307XHJcbiAgICB2YXIgZ3V0dGVyTGVmdCA9IGQuZ3V0dGVycy5jbGllbnRMZWZ0O1xyXG4gICAgZm9yICh2YXIgbiA9IGQuZ3V0dGVycy5maXJzdENoaWxkLCBpID0gMDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcsICsraSkge1xyXG4gICAgICBsZWZ0W2NtLm9wdGlvbnMuZ3V0dGVyc1tpXV0gPSBuLm9mZnNldExlZnQgKyBuLmNsaWVudExlZnQgKyBndXR0ZXJMZWZ0O1xyXG4gICAgICB3aWR0aFtjbS5vcHRpb25zLmd1dHRlcnNbaV1dID0gbi5jbGllbnRXaWR0aDtcclxuICAgIH1cclxuICAgIHJldHVybiB7Zml4ZWRQb3M6IGNvbXBlbnNhdGVGb3JIU2Nyb2xsKGQpLFxyXG4gICAgICAgICAgICBndXR0ZXJUb3RhbFdpZHRoOiBkLmd1dHRlcnMub2Zmc2V0V2lkdGgsXHJcbiAgICAgICAgICAgIGd1dHRlckxlZnQ6IGxlZnQsXHJcbiAgICAgICAgICAgIGd1dHRlcldpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgd3JhcHBlcldpZHRoOiBkLndyYXBwZXIuY2xpZW50V2lkdGh9O1xyXG4gIH1cclxuXHJcbiAgLy8gU3luYyB0aGUgYWN0dWFsIGRpc3BsYXkgRE9NIHN0cnVjdHVyZSB3aXRoIGRpc3BsYXkudmlldywgcmVtb3ZpbmdcclxuICAvLyBub2RlcyBmb3IgbGluZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHZpZXcsIGFuZCBjcmVhdGluZyB0aGUgb25lc1xyXG4gIC8vIHRoYXQgYXJlIG5vdCB0aGVyZSB5ZXQsIGFuZCB1cGRhdGluZyB0aGUgb25lcyB0aGF0IGFyZSBvdXQgb2ZcclxuICAvLyBkYXRlLlxyXG4gIGZ1bmN0aW9uIHBhdGNoRGlzcGxheShjbSwgdXBkYXRlTnVtYmVyc0Zyb20sIGRpbXMpIHtcclxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgbGluZU51bWJlcnMgPSBjbS5vcHRpb25zLmxpbmVOdW1iZXJzO1xyXG4gICAgdmFyIGNvbnRhaW5lciA9IGRpc3BsYXkubGluZURpdiwgY3VyID0gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XHJcblxyXG4gICAgZnVuY3Rpb24gcm0obm9kZSkge1xyXG4gICAgICB2YXIgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XHJcbiAgICAgIC8vIFdvcmtzIGFyb3VuZCBhIHRocm93LXNjcm9sbCBidWcgaW4gT1MgWCBXZWJraXRcclxuICAgICAgaWYgKHdlYmtpdCAmJiBtYWMgJiYgY20uZGlzcGxheS5jdXJyZW50V2hlZWxUYXJnZXQgPT0gbm9kZSlcclxuICAgICAgICBub2RlLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcclxuICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHZpZXcgPSBkaXNwbGF5LnZpZXcsIGxpbmVOID0gZGlzcGxheS52aWV3RnJvbTtcclxuICAgIC8vIExvb3Agb3ZlciB0aGUgZWxlbWVudHMgaW4gdGhlIHZpZXcsIHN5bmNpbmcgY3VyICh0aGUgRE9NIG5vZGVzXHJcbiAgICAvLyBpbiBkaXNwbGF5LmxpbmVEaXYpIHdpdGggdGhlIHZpZXcgYXMgd2UgZ28uXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGxpbmVWaWV3ID0gdmlld1tpXTtcclxuICAgICAgaWYgKGxpbmVWaWV3LmhpZGRlbikge1xyXG4gICAgICB9IGVsc2UgaWYgKCFsaW5lVmlldy5ub2RlIHx8IGxpbmVWaWV3Lm5vZGUucGFyZW50Tm9kZSAhPSBjb250YWluZXIpIHsgLy8gTm90IGRyYXduIHlldFxyXG4gICAgICAgIHZhciBub2RlID0gYnVpbGRMaW5lRWxlbWVudChjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKTtcclxuICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKG5vZGUsIGN1cik7XHJcbiAgICAgIH0gZWxzZSB7IC8vIEFscmVhZHkgZHJhd25cclxuICAgICAgICB3aGlsZSAoY3VyICE9IGxpbmVWaWV3Lm5vZGUpIGN1ciA9IHJtKGN1cik7XHJcbiAgICAgICAgdmFyIHVwZGF0ZU51bWJlciA9IGxpbmVOdW1iZXJzICYmIHVwZGF0ZU51bWJlcnNGcm9tICE9IG51bGwgJiZcclxuICAgICAgICAgIHVwZGF0ZU51bWJlcnNGcm9tIDw9IGxpbmVOICYmIGxpbmVWaWV3LmxpbmVOdW1iZXI7XHJcbiAgICAgICAgaWYgKGxpbmVWaWV3LmNoYW5nZXMpIHtcclxuICAgICAgICAgIGlmIChpbmRleE9mKGxpbmVWaWV3LmNoYW5nZXMsIFwiZ3V0dGVyXCIpID4gLTEpIHVwZGF0ZU51bWJlciA9IGZhbHNlO1xyXG4gICAgICAgICAgdXBkYXRlTGluZUZvckNoYW5nZXMoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1cGRhdGVOdW1iZXIpIHtcclxuICAgICAgICAgIHJlbW92ZUNoaWxkcmVuKGxpbmVWaWV3LmxpbmVOdW1iZXIpO1xyXG4gICAgICAgICAgbGluZVZpZXcubGluZU51bWJlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lTnVtYmVyRm9yKGNtLm9wdGlvbnMsIGxpbmVOKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXIgPSBsaW5lVmlldy5ub2RlLm5leHRTaWJsaW5nO1xyXG4gICAgICB9XHJcbiAgICAgIGxpbmVOICs9IGxpbmVWaWV3LnNpemU7XHJcbiAgICB9XHJcbiAgICB3aGlsZSAoY3VyKSBjdXIgPSBybShjdXIpO1xyXG4gIH1cclxuXHJcbiAgLy8gV2hlbiBhbiBhc3BlY3Qgb2YgYSBsaW5lIGNoYW5nZXMsIGEgc3RyaW5nIGlzIGFkZGVkIHRvXHJcbiAgLy8gbGluZVZpZXcuY2hhbmdlcy4gVGhpcyB1cGRhdGVzIHRoZSByZWxldmFudCBwYXJ0IG9mIHRoZSBsaW5lJ3NcclxuICAvLyBET00gc3RydWN0dXJlLlxyXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmVGb3JDaGFuZ2VzKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpIHtcclxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZVZpZXcuY2hhbmdlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICB2YXIgdHlwZSA9IGxpbmVWaWV3LmNoYW5nZXNbal07XHJcbiAgICAgIGlmICh0eXBlID09IFwidGV4dFwiKSB1cGRhdGVMaW5lVGV4dChjbSwgbGluZVZpZXcpO1xyXG4gICAgICBlbHNlIGlmICh0eXBlID09IFwiZ3V0dGVyXCIpIHVwZGF0ZUxpbmVHdXR0ZXIoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcyk7XHJcbiAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJjbGFzc1wiKSB1cGRhdGVMaW5lQ2xhc3NlcyhsaW5lVmlldyk7XHJcbiAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJ3aWRnZXRcIikgdXBkYXRlTGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKTtcclxuICAgIH1cclxuICAgIGxpbmVWaWV3LmNoYW5nZXMgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLy8gTGluZXMgd2l0aCBndXR0ZXIgZWxlbWVudHMsIHdpZGdldHMgb3IgYSBiYWNrZ3JvdW5kIGNsYXNzIG5lZWQgdG9cclxuICAvLyBiZSB3cmFwcGVkLCBhbmQgaGF2ZSB0aGUgZXh0cmEgZWxlbWVudHMgYWRkZWQgdG8gdGhlIHdyYXBwZXIgZGl2XHJcbiAgZnVuY3Rpb24gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpIHtcclxuICAgIGlmIChsaW5lVmlldy5ub2RlID09IGxpbmVWaWV3LnRleHQpIHtcclxuICAgICAgbGluZVZpZXcubm9kZSA9IGVsdChcImRpdlwiLCBudWxsLCBudWxsLCBcInBvc2l0aW9uOiByZWxhdGl2ZVwiKTtcclxuICAgICAgaWYgKGxpbmVWaWV3LnRleHQucGFyZW50Tm9kZSlcclxuICAgICAgICBsaW5lVmlldy50ZXh0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGxpbmVWaWV3Lm5vZGUsIGxpbmVWaWV3LnRleHQpO1xyXG4gICAgICBsaW5lVmlldy5ub2RlLmFwcGVuZENoaWxkKGxpbmVWaWV3LnRleHQpO1xyXG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDgpIGxpbmVWaWV3Lm5vZGUuc3R5bGUuekluZGV4ID0gMjtcclxuICAgIH1cclxuICAgIHJldHVybiBsaW5lVmlldy5ub2RlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdXBkYXRlTGluZUJhY2tncm91bmQobGluZVZpZXcpIHtcclxuICAgIHZhciBjbHMgPSBsaW5lVmlldy5iZ0NsYXNzID8gbGluZVZpZXcuYmdDbGFzcyArIFwiIFwiICsgKGxpbmVWaWV3LmxpbmUuYmdDbGFzcyB8fCBcIlwiKSA6IGxpbmVWaWV3LmxpbmUuYmdDbGFzcztcclxuICAgIGlmIChjbHMpIGNscyArPSBcIiBDb2RlTWlycm9yLWxpbmViYWNrZ3JvdW5kXCI7XHJcbiAgICBpZiAobGluZVZpZXcuYmFja2dyb3VuZCkge1xyXG4gICAgICBpZiAoY2xzKSBsaW5lVmlldy5iYWNrZ3JvdW5kLmNsYXNzTmFtZSA9IGNscztcclxuICAgICAgZWxzZSB7IGxpbmVWaWV3LmJhY2tncm91bmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsaW5lVmlldy5iYWNrZ3JvdW5kKTsgbGluZVZpZXcuYmFja2dyb3VuZCA9IG51bGw7IH1cclxuICAgIH0gZWxzZSBpZiAoY2xzKSB7XHJcbiAgICAgIHZhciB3cmFwID0gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpO1xyXG4gICAgICBsaW5lVmlldy5iYWNrZ3JvdW5kID0gd3JhcC5pbnNlcnRCZWZvcmUoZWx0KFwiZGl2XCIsIG51bGwsIGNscyksIHdyYXAuZmlyc3RDaGlsZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBXcmFwcGVyIGFyb3VuZCBidWlsZExpbmVDb250ZW50IHdoaWNoIHdpbGwgcmV1c2UgdGhlIHN0cnVjdHVyZVxyXG4gIC8vIGluIGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCB3aGVuIHBvc3NpYmxlLlxyXG4gIGZ1bmN0aW9uIGdldExpbmVDb250ZW50KGNtLCBsaW5lVmlldykge1xyXG4gICAgdmFyIGV4dCA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtcclxuICAgIGlmIChleHQgJiYgZXh0LmxpbmUgPT0gbGluZVZpZXcubGluZSkge1xyXG4gICAgICBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgPSBudWxsO1xyXG4gICAgICBsaW5lVmlldy5tZWFzdXJlID0gZXh0Lm1lYXN1cmU7XHJcbiAgICAgIHJldHVybiBleHQuYnVpbHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYnVpbGRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVkcmF3IHRoZSBsaW5lJ3MgdGV4dC4gSW50ZXJhY3RzIHdpdGggdGhlIGJhY2tncm91bmQgYW5kIHRleHRcclxuICAvLyBjbGFzc2VzIGJlY2F1c2UgdGhlIG1vZGUgbWF5IG91dHB1dCB0b2tlbnMgdGhhdCBpbmZsdWVuY2UgdGhlc2VcclxuICAvLyBjbGFzc2VzLlxyXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmVUZXh0KGNtLCBsaW5lVmlldykge1xyXG4gICAgdmFyIGNscyA9IGxpbmVWaWV3LnRleHQuY2xhc3NOYW1lO1xyXG4gICAgdmFyIGJ1aWx0ID0gZ2V0TGluZUNvbnRlbnQoY20sIGxpbmVWaWV3KTtcclxuICAgIGlmIChsaW5lVmlldy50ZXh0ID09IGxpbmVWaWV3Lm5vZGUpIGxpbmVWaWV3Lm5vZGUgPSBidWlsdC5wcmU7XHJcbiAgICBsaW5lVmlldy50ZXh0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGJ1aWx0LnByZSwgbGluZVZpZXcudGV4dCk7XHJcbiAgICBsaW5lVmlldy50ZXh0ID0gYnVpbHQucHJlO1xyXG4gICAgaWYgKGJ1aWx0LmJnQ2xhc3MgIT0gbGluZVZpZXcuYmdDbGFzcyB8fCBidWlsdC50ZXh0Q2xhc3MgIT0gbGluZVZpZXcudGV4dENsYXNzKSB7XHJcbiAgICAgIGxpbmVWaWV3LmJnQ2xhc3MgPSBidWlsdC5iZ0NsYXNzO1xyXG4gICAgICBsaW5lVmlldy50ZXh0Q2xhc3MgPSBidWlsdC50ZXh0Q2xhc3M7XHJcbiAgICAgIHVwZGF0ZUxpbmVDbGFzc2VzKGxpbmVWaWV3KTtcclxuICAgIH0gZWxzZSBpZiAoY2xzKSB7XHJcbiAgICAgIGxpbmVWaWV3LnRleHQuY2xhc3NOYW1lID0gY2xzO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdXBkYXRlTGluZUNsYXNzZXMobGluZVZpZXcpIHtcclxuICAgIHVwZGF0ZUxpbmVCYWNrZ3JvdW5kKGxpbmVWaWV3KTtcclxuICAgIGlmIChsaW5lVmlldy5saW5lLndyYXBDbGFzcylcclxuICAgICAgZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpLmNsYXNzTmFtZSA9IGxpbmVWaWV3LmxpbmUud3JhcENsYXNzO1xyXG4gICAgZWxzZSBpZiAobGluZVZpZXcubm9kZSAhPSBsaW5lVmlldy50ZXh0KVxyXG4gICAgICBsaW5lVmlldy5ub2RlLmNsYXNzTmFtZSA9IFwiXCI7XHJcbiAgICB2YXIgdGV4dENsYXNzID0gbGluZVZpZXcudGV4dENsYXNzID8gbGluZVZpZXcudGV4dENsYXNzICsgXCIgXCIgKyAobGluZVZpZXcubGluZS50ZXh0Q2xhc3MgfHwgXCJcIikgOiBsaW5lVmlldy5saW5lLnRleHRDbGFzcztcclxuICAgIGxpbmVWaWV3LnRleHQuY2xhc3NOYW1lID0gdGV4dENsYXNzIHx8IFwiXCI7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB1cGRhdGVMaW5lR3V0dGVyKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpIHtcclxuICAgIGlmIChsaW5lVmlldy5ndXR0ZXIpIHtcclxuICAgICAgbGluZVZpZXcubm9kZS5yZW1vdmVDaGlsZChsaW5lVmlldy5ndXR0ZXIpO1xyXG4gICAgICBsaW5lVmlldy5ndXR0ZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgdmFyIG1hcmtlcnMgPSBsaW5lVmlldy5saW5lLmd1dHRlck1hcmtlcnM7XHJcbiAgICBpZiAoY20ub3B0aW9ucy5saW5lTnVtYmVycyB8fCBtYXJrZXJzKSB7XHJcbiAgICAgIHZhciB3cmFwID0gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpO1xyXG4gICAgICB2YXIgZ3V0dGVyV3JhcCA9IGxpbmVWaWV3Lmd1dHRlciA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItZ3V0dGVyLXdyYXBwZXJcIiwgXCJsZWZ0OiBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gZGltcy5maXhlZFBvcyA6IC1kaW1zLmd1dHRlclRvdGFsV2lkdGgpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJweDsgd2lkdGg6IFwiICsgZGltcy5ndXR0ZXJUb3RhbFdpZHRoICsgXCJweFwiKTtcclxuICAgICAgY20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKGd1dHRlcldyYXApO1xyXG4gICAgICB3cmFwLmluc2VydEJlZm9yZShndXR0ZXJXcmFwLCBsaW5lVmlldy50ZXh0KTtcclxuICAgICAgaWYgKGxpbmVWaWV3LmxpbmUuZ3V0dGVyQ2xhc3MpXHJcbiAgICAgICAgZ3V0dGVyV3JhcC5jbGFzc05hbWUgKz0gXCIgXCIgKyBsaW5lVmlldy5saW5lLmd1dHRlckNsYXNzO1xyXG4gICAgICBpZiAoY20ub3B0aW9ucy5saW5lTnVtYmVycyAmJiAoIW1hcmtlcnMgfHwgIW1hcmtlcnNbXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCJdKSlcclxuICAgICAgICBsaW5lVmlldy5saW5lTnVtYmVyID0gZ3V0dGVyV3JhcC5hcHBlbmRDaGlsZChcclxuICAgICAgICAgIGVsdChcImRpdlwiLCBsaW5lTnVtYmVyRm9yKGNtLm9wdGlvbnMsIGxpbmVOKSxcclxuICAgICAgICAgICAgICBcIkNvZGVNaXJyb3ItbGluZW51bWJlciBDb2RlTWlycm9yLWd1dHRlci1lbHRcIixcclxuICAgICAgICAgICAgICBcImxlZnQ6IFwiICsgZGltcy5ndXR0ZXJMZWZ0W1wiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiXSArIFwicHg7IHdpZHRoOiBcIlxyXG4gICAgICAgICAgICAgICsgY20uZGlzcGxheS5saW5lTnVtSW5uZXJXaWR0aCArIFwicHhcIikpO1xyXG4gICAgICBpZiAobWFya2VycykgZm9yICh2YXIgayA9IDA7IGsgPCBjbS5vcHRpb25zLmd1dHRlcnMubGVuZ3RoOyArK2spIHtcclxuICAgICAgICB2YXIgaWQgPSBjbS5vcHRpb25zLmd1dHRlcnNba10sIGZvdW5kID0gbWFya2Vycy5oYXNPd25Qcm9wZXJ0eShpZCkgJiYgbWFya2Vyc1tpZF07XHJcbiAgICAgICAgaWYgKGZvdW5kKVxyXG4gICAgICAgICAgZ3V0dGVyV3JhcC5hcHBlbmRDaGlsZChlbHQoXCJkaXZcIiwgW2ZvdW5kXSwgXCJDb2RlTWlycm9yLWd1dHRlci1lbHRcIiwgXCJsZWZ0OiBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW1zLmd1dHRlckxlZnRbaWRdICsgXCJweDsgd2lkdGg6IFwiICsgZGltcy5ndXR0ZXJXaWR0aFtpZF0gKyBcInB4XCIpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdXBkYXRlTGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKSB7XHJcbiAgICBpZiAobGluZVZpZXcuYWxpZ25hYmxlKSBsaW5lVmlldy5hbGlnbmFibGUgPSBudWxsO1xyXG4gICAgZm9yICh2YXIgbm9kZSA9IGxpbmVWaWV3Lm5vZGUuZmlyc3RDaGlsZCwgbmV4dDsgbm9kZTsgbm9kZSA9IG5leHQpIHtcclxuICAgICAgdmFyIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xyXG4gICAgICBpZiAobm9kZS5jbGFzc05hbWUgPT0gXCJDb2RlTWlycm9yLWxpbmV3aWRnZXRcIilcclxuICAgICAgICBsaW5lVmlldy5ub2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xyXG4gICAgfVxyXG4gICAgaW5zZXJ0TGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKTtcclxuICB9XHJcblxyXG4gIC8vIEJ1aWxkIGEgbGluZSdzIERPTSByZXByZXNlbnRhdGlvbiBmcm9tIHNjcmF0Y2hcclxuICBmdW5jdGlvbiBidWlsZExpbmVFbGVtZW50KGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpIHtcclxuICAgIHZhciBidWlsdCA9IGdldExpbmVDb250ZW50KGNtLCBsaW5lVmlldyk7XHJcbiAgICBsaW5lVmlldy50ZXh0ID0gbGluZVZpZXcubm9kZSA9IGJ1aWx0LnByZTtcclxuICAgIGlmIChidWlsdC5iZ0NsYXNzKSBsaW5lVmlldy5iZ0NsYXNzID0gYnVpbHQuYmdDbGFzcztcclxuICAgIGlmIChidWlsdC50ZXh0Q2xhc3MpIGxpbmVWaWV3LnRleHRDbGFzcyA9IGJ1aWx0LnRleHRDbGFzcztcclxuXHJcbiAgICB1cGRhdGVMaW5lQ2xhc3NlcyhsaW5lVmlldyk7XHJcbiAgICB1cGRhdGVMaW5lR3V0dGVyKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpO1xyXG4gICAgaW5zZXJ0TGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKTtcclxuICAgIHJldHVybiBsaW5lVmlldy5ub2RlO1xyXG4gIH1cclxuXHJcbiAgLy8gQSBsaW5lVmlldyBtYXkgY29udGFpbiBtdWx0aXBsZSBsb2dpY2FsIGxpbmVzICh3aGVuIG1lcmdlZCBieVxyXG4gIC8vIGNvbGxhcHNlZCBzcGFucykuIFRoZSB3aWRnZXRzIGZvciBhbGwgb2YgdGhlbSBuZWVkIHRvIGJlIGRyYXduLlxyXG4gIGZ1bmN0aW9uIGluc2VydExpbmVXaWRnZXRzKGNtLCBsaW5lVmlldywgZGltcykge1xyXG4gICAgaW5zZXJ0TGluZVdpZGdldHNGb3IoY20sIGxpbmVWaWV3LmxpbmUsIGxpbmVWaWV3LCBkaW1zLCB0cnVlKTtcclxuICAgIGlmIChsaW5lVmlldy5yZXN0KSBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVWaWV3LnJlc3QubGVuZ3RoOyBpKyspXHJcbiAgICAgIGluc2VydExpbmVXaWRnZXRzRm9yKGNtLCBsaW5lVmlldy5yZXN0W2ldLCBsaW5lVmlldywgZGltcywgZmFsc2UpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW5zZXJ0TGluZVdpZGdldHNGb3IoY20sIGxpbmUsIGxpbmVWaWV3LCBkaW1zLCBhbGxvd0Fib3ZlKSB7XHJcbiAgICBpZiAoIWxpbmUud2lkZ2V0cykgcmV0dXJuO1xyXG4gICAgdmFyIHdyYXAgPSBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldyk7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgd3MgPSBsaW5lLndpZGdldHM7IGkgPCB3cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICB2YXIgd2lkZ2V0ID0gd3NbaV0sIG5vZGUgPSBlbHQoXCJkaXZcIiwgW3dpZGdldC5ub2RlXSwgXCJDb2RlTWlycm9yLWxpbmV3aWRnZXRcIik7XHJcbiAgICAgIGlmICghd2lkZ2V0LmhhbmRsZU1vdXNlRXZlbnRzKSBub2RlLnNldEF0dHJpYnV0ZShcImNtLWlnbm9yZS1ldmVudHNcIiwgXCJ0cnVlXCIpO1xyXG4gICAgICBwb3NpdGlvbkxpbmVXaWRnZXQod2lkZ2V0LCBub2RlLCBsaW5lVmlldywgZGltcyk7XHJcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShub2RlKTtcclxuICAgICAgaWYgKGFsbG93QWJvdmUgJiYgd2lkZ2V0LmFib3ZlKVxyXG4gICAgICAgIHdyYXAuaW5zZXJ0QmVmb3JlKG5vZGUsIGxpbmVWaWV3Lmd1dHRlciB8fCBsaW5lVmlldy50ZXh0KTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQobm9kZSk7XHJcbiAgICAgIHNpZ25hbExhdGVyKHdpZGdldCwgXCJyZWRyYXdcIik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwb3NpdGlvbkxpbmVXaWRnZXQod2lkZ2V0LCBub2RlLCBsaW5lVmlldywgZGltcykge1xyXG4gICAgaWYgKHdpZGdldC5ub0hTY3JvbGwpIHtcclxuICAgICAgKGxpbmVWaWV3LmFsaWduYWJsZSB8fCAobGluZVZpZXcuYWxpZ25hYmxlID0gW10pKS5wdXNoKG5vZGUpO1xyXG4gICAgICB2YXIgd2lkdGggPSBkaW1zLndyYXBwZXJXaWR0aDtcclxuICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gZGltcy5maXhlZFBvcyArIFwicHhcIjtcclxuICAgICAgaWYgKCF3aWRnZXQuY292ZXJHdXR0ZXIpIHtcclxuICAgICAgICB3aWR0aCAtPSBkaW1zLmd1dHRlclRvdGFsV2lkdGg7XHJcbiAgICAgICAgbm9kZS5zdHlsZS5wYWRkaW5nTGVmdCA9IGRpbXMuZ3V0dGVyVG90YWxXaWR0aCArIFwicHhcIjtcclxuICAgICAgfVxyXG4gICAgICBub2RlLnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XHJcbiAgICB9XHJcbiAgICBpZiAod2lkZ2V0LmNvdmVyR3V0dGVyKSB7XHJcbiAgICAgIG5vZGUuc3R5bGUuekluZGV4ID0gNTtcclxuICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcclxuICAgICAgaWYgKCF3aWRnZXQubm9IU2Nyb2xsKSBub2RlLnN0eWxlLm1hcmdpbkxlZnQgPSAtZGltcy5ndXR0ZXJUb3RhbFdpZHRoICsgXCJweFwiO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUE9TSVRJT04gT0JKRUNUXHJcblxyXG4gIC8vIEEgUG9zIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwb3NpdGlvbiB3aXRoaW4gdGhlIHRleHQuXHJcbiAgdmFyIFBvcyA9IENvZGVNaXJyb3IuUG9zID0gZnVuY3Rpb24obGluZSwgY2gpIHtcclxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQb3MpKSByZXR1cm4gbmV3IFBvcyhsaW5lLCBjaCk7XHJcbiAgICB0aGlzLmxpbmUgPSBsaW5lOyB0aGlzLmNoID0gY2g7XHJcbiAgfTtcclxuXHJcbiAgLy8gQ29tcGFyZSB0d28gcG9zaXRpb25zLCByZXR1cm4gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgYSBuZWdhdGl2ZVxyXG4gIC8vIG51bWJlciB3aGVuIGEgaXMgbGVzcywgYW5kIGEgcG9zaXRpdmUgbnVtYmVyIG90aGVyd2lzZS5cclxuICB2YXIgY21wID0gQ29kZU1pcnJvci5jbXBQb3MgPSBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhLmxpbmUgLSBiLmxpbmUgfHwgYS5jaCAtIGIuY2g7IH07XHJcblxyXG4gIGZ1bmN0aW9uIGNvcHlQb3MoeCkge3JldHVybiBQb3MoeC5saW5lLCB4LmNoKTt9XHJcbiAgZnVuY3Rpb24gbWF4UG9zKGEsIGIpIHsgcmV0dXJuIGNtcChhLCBiKSA8IDAgPyBiIDogYTsgfVxyXG4gIGZ1bmN0aW9uIG1pblBvcyhhLCBiKSB7IHJldHVybiBjbXAoYSwgYikgPCAwID8gYSA6IGI7IH1cclxuXHJcbiAgLy8gSU5QVVQgSEFORExJTkdcclxuXHJcbiAgZnVuY3Rpb24gZW5zdXJlRm9jdXMoY20pIHtcclxuICAgIGlmICghY20uc3RhdGUuZm9jdXNlZCkgeyBjbS5kaXNwbGF5LmlucHV0LmZvY3VzKCk7IG9uRm9jdXMoY20pOyB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpc1JlYWRPbmx5KGNtKSB7XHJcbiAgICByZXR1cm4gY20ub3B0aW9ucy5yZWFkT25seSB8fCBjbS5kb2MuY2FudEVkaXQ7XHJcbiAgfVxyXG5cclxuICAvLyBUaGlzIHdpbGwgYmUgc2V0IHRvIGFuIGFycmF5IG9mIHN0cmluZ3Mgd2hlbiBjb3B5aW5nLCBzbyB0aGF0LFxyXG4gIC8vIHdoZW4gcGFzdGluZywgd2Uga25vdyB3aGF0IGtpbmQgb2Ygc2VsZWN0aW9ucyB0aGUgY29waWVkIHRleHRcclxuICAvLyB3YXMgbWFkZSBvdXQgb2YuXHJcbiAgdmFyIGxhc3RDb3BpZWQgPSBudWxsO1xyXG5cclxuICBmdW5jdGlvbiBhcHBseVRleHRJbnB1dChjbSwgaW5zZXJ0ZWQsIGRlbGV0ZWQsIHNlbCkge1xyXG4gICAgdmFyIGRvYyA9IGNtLmRvYztcclxuICAgIGNtLmRpc3BsYXkuc2hpZnQgPSBmYWxzZTtcclxuICAgIGlmICghc2VsKSBzZWwgPSBkb2Muc2VsO1xyXG5cclxuICAgIHZhciB0ZXh0TGluZXMgPSBzcGxpdExpbmVzKGluc2VydGVkKSwgbXVsdGlQYXN0ZSA9IG51bGw7XHJcbiAgICAvLyBXaGVuIHBhc2luZyBOIGxpbmVzIGludG8gTiBzZWxlY3Rpb25zLCBpbnNlcnQgb25lIGxpbmUgcGVyIHNlbGVjdGlvblxyXG4gICAgaWYgKGNtLnN0YXRlLnBhc3RlSW5jb21pbmcgJiYgc2VsLnJhbmdlcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgIGlmIChsYXN0Q29waWVkICYmIGxhc3RDb3BpZWQuam9pbihcIlxcblwiKSA9PSBpbnNlcnRlZClcclxuICAgICAgICBtdWx0aVBhc3RlID0gc2VsLnJhbmdlcy5sZW5ndGggJSBsYXN0Q29waWVkLmxlbmd0aCA9PSAwICYmIG1hcChsYXN0Q29waWVkLCBzcGxpdExpbmVzKTtcclxuICAgICAgZWxzZSBpZiAodGV4dExpbmVzLmxlbmd0aCA9PSBzZWwucmFuZ2VzLmxlbmd0aClcclxuICAgICAgICBtdWx0aVBhc3RlID0gbWFwKHRleHRMaW5lcywgZnVuY3Rpb24obCkgeyByZXR1cm4gW2xdOyB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOb3JtYWwgYmVoYXZpb3IgaXMgdG8gaW5zZXJ0IHRoZSBuZXcgdGV4dCBpbnRvIGV2ZXJ5IHNlbGVjdGlvblxyXG4gICAgZm9yICh2YXIgaSA9IHNlbC5yYW5nZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgdmFyIHJhbmdlID0gc2VsLnJhbmdlc1tpXTtcclxuICAgICAgdmFyIGZyb20gPSByYW5nZS5mcm9tKCksIHRvID0gcmFuZ2UudG8oKTtcclxuICAgICAgaWYgKHJhbmdlLmVtcHR5KCkpIHtcclxuICAgICAgICBpZiAoZGVsZXRlZCAmJiBkZWxldGVkID4gMCkgLy8gSGFuZGxlIGRlbGV0aW9uXHJcbiAgICAgICAgICBmcm9tID0gUG9zKGZyb20ubGluZSwgZnJvbS5jaCAtIGRlbGV0ZWQpO1xyXG4gICAgICAgIGVsc2UgaWYgKGNtLnN0YXRlLm92ZXJ3cml0ZSAmJiAhY20uc3RhdGUucGFzdGVJbmNvbWluZykgLy8gSGFuZGxlIG92ZXJ3cml0ZVxyXG4gICAgICAgICAgdG8gPSBQb3ModG8ubGluZSwgTWF0aC5taW4oZ2V0TGluZShkb2MsIHRvLmxpbmUpLnRleHQubGVuZ3RoLCB0by5jaCArIGxzdCh0ZXh0TGluZXMpLmxlbmd0aCkpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciB1cGRhdGVJbnB1dCA9IGNtLmN1ck9wLnVwZGF0ZUlucHV0O1xyXG4gICAgICB2YXIgY2hhbmdlRXZlbnQgPSB7ZnJvbTogZnJvbSwgdG86IHRvLCB0ZXh0OiBtdWx0aVBhc3RlID8gbXVsdGlQYXN0ZVtpICUgbXVsdGlQYXN0ZS5sZW5ndGhdIDogdGV4dExpbmVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBjbS5zdGF0ZS5wYXN0ZUluY29taW5nID8gXCJwYXN0ZVwiIDogY20uc3RhdGUuY3V0SW5jb21pbmcgPyBcImN1dFwiIDogXCIraW5wdXRcIn07XHJcbiAgICAgIG1ha2VDaGFuZ2UoY20uZG9jLCBjaGFuZ2VFdmVudCk7XHJcbiAgICAgIHNpZ25hbExhdGVyKGNtLCBcImlucHV0UmVhZFwiLCBjbSwgY2hhbmdlRXZlbnQpO1xyXG4gICAgICAvLyBXaGVuIGFuICdlbGVjdHJpYycgY2hhcmFjdGVyIGlzIGluc2VydGVkLCBpbW1lZGlhdGVseSB0cmlnZ2VyIGEgcmVpbmRlbnRcclxuICAgICAgaWYgKGluc2VydGVkICYmICFjbS5zdGF0ZS5wYXN0ZUluY29taW5nICYmIGNtLm9wdGlvbnMuZWxlY3RyaWNDaGFycyAmJlxyXG4gICAgICAgICAgY20ub3B0aW9ucy5zbWFydEluZGVudCAmJiByYW5nZS5oZWFkLmNoIDwgMTAwICYmXHJcbiAgICAgICAgICAoIWkgfHwgc2VsLnJhbmdlc1tpIC0gMV0uaGVhZC5saW5lICE9IHJhbmdlLmhlYWQubGluZSkpIHtcclxuICAgICAgICB2YXIgbW9kZSA9IGNtLmdldE1vZGVBdChyYW5nZS5oZWFkKTtcclxuICAgICAgICB2YXIgZW5kID0gY2hhbmdlRW5kKGNoYW5nZUV2ZW50KTtcclxuICAgICAgICBpZiAobW9kZS5lbGVjdHJpY0NoYXJzKSB7XHJcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1vZGUuZWxlY3RyaWNDaGFycy5sZW5ndGg7IGorKylcclxuICAgICAgICAgICAgaWYgKGluc2VydGVkLmluZGV4T2YobW9kZS5lbGVjdHJpY0NoYXJzLmNoYXJBdChqKSkgPiAtMSkge1xyXG4gICAgICAgICAgICAgIGluZGVudExpbmUoY20sIGVuZC5saW5lLCBcInNtYXJ0XCIpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChtb2RlLmVsZWN0cmljSW5wdXQpIHtcclxuICAgICAgICAgIGlmIChtb2RlLmVsZWN0cmljSW5wdXQudGVzdChnZXRMaW5lKGRvYywgZW5kLmxpbmUpLnRleHQuc2xpY2UoMCwgZW5kLmNoKSkpXHJcbiAgICAgICAgICAgIGluZGVudExpbmUoY20sIGVuZC5saW5lLCBcInNtYXJ0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSk7XHJcbiAgICBjbS5jdXJPcC51cGRhdGVJbnB1dCA9IHVwZGF0ZUlucHV0O1xyXG4gICAgY20uY3VyT3AudHlwaW5nID0gdHJ1ZTtcclxuICAgIGNtLnN0YXRlLnBhc3RlSW5jb21pbmcgPSBjbS5zdGF0ZS5jdXRJbmNvbWluZyA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY29weWFibGVSYW5nZXMoY20pIHtcclxuICAgIHZhciB0ZXh0ID0gW10sIHJhbmdlcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbS5kb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgbGluZSA9IGNtLmRvYy5zZWwucmFuZ2VzW2ldLmhlYWQubGluZTtcclxuICAgICAgdmFyIGxpbmVSYW5nZSA9IHthbmNob3I6IFBvcyhsaW5lLCAwKSwgaGVhZDogUG9zKGxpbmUgKyAxLCAwKX07XHJcbiAgICAgIHJhbmdlcy5wdXNoKGxpbmVSYW5nZSk7XHJcbiAgICAgIHRleHQucHVzaChjbS5nZXRSYW5nZShsaW5lUmFuZ2UuYW5jaG9yLCBsaW5lUmFuZ2UuaGVhZCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHt0ZXh0OiB0ZXh0LCByYW5nZXM6IHJhbmdlc307XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBkaXNhYmxlQnJvd3Nlck1hZ2ljKGZpZWxkKSB7XHJcbiAgICBmaWVsZC5zZXRBdHRyaWJ1dGUoXCJhdXRvY29ycmVjdFwiLCBcIm9mZlwiKTtcclxuICAgIGZpZWxkLnNldEF0dHJpYnV0ZShcImF1dG9jYXBpdGFsaXplXCIsIFwib2ZmXCIpO1xyXG4gICAgZmllbGQuc2V0QXR0cmlidXRlKFwic3BlbGxjaGVja1wiLCBcImZhbHNlXCIpO1xyXG4gIH1cclxuXHJcbiAgLy8gVEVYVEFSRUEgSU5QVVQgU1RZTEVcclxuXHJcbiAgZnVuY3Rpb24gVGV4dGFyZWFJbnB1dChjbSkge1xyXG4gICAgdGhpcy5jbSA9IGNtO1xyXG4gICAgLy8gU2VlIGlucHV0LnBvbGwgYW5kIGlucHV0LnJlc2V0XHJcbiAgICB0aGlzLnByZXZJbnB1dCA9IFwiXCI7XHJcblxyXG4gICAgLy8gRmxhZyB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHdlIGV4cGVjdCBpbnB1dCB0byBhcHBlYXIgcmVhbCBzb29uXHJcbiAgICAvLyBub3cgKGFmdGVyIHNvbWUgZXZlbnQgbGlrZSAna2V5cHJlc3MnIG9yICdpbnB1dCcpIGFuZCBhcmVcclxuICAgIC8vIHBvbGxpbmcgaW50ZW5zaXZlbHkuXHJcbiAgICB0aGlzLnBvbGxpbmdGYXN0ID0gZmFsc2U7XHJcbiAgICAvLyBTZWxmLXJlc2V0dGluZyB0aW1lb3V0IGZvciB0aGUgcG9sbGVyXHJcbiAgICB0aGlzLnBvbGxpbmcgPSBuZXcgRGVsYXllZCgpO1xyXG4gICAgLy8gVHJhY2tzIHdoZW4gaW5wdXQucmVzZXQgaGFzIHB1bnRlZCB0byBqdXN0IHB1dHRpbmcgYSBzaG9ydFxyXG4gICAgLy8gc3RyaW5nIGludG8gdGhlIHRleHRhcmVhIGluc3RlYWQgb2YgdGhlIGZ1bGwgc2VsZWN0aW9uLlxyXG4gICAgdGhpcy5pbmFjY3VyYXRlU2VsZWN0aW9uID0gZmFsc2U7XHJcbiAgICAvLyBVc2VkIHRvIHdvcmsgYXJvdW5kIElFIGlzc3VlIHdpdGggc2VsZWN0aW9uIGJlaW5nIGZvcmdvdHRlbiB3aGVuIGZvY3VzIG1vdmVzIGF3YXkgZnJvbSB0ZXh0YXJlYVxyXG4gICAgdGhpcy5oYXNTZWxlY3Rpb24gPSBmYWxzZTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBoaWRkZW5UZXh0YXJlYSgpIHtcclxuICAgIHZhciB0ZSA9IGVsdChcInRleHRhcmVhXCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IGFic29sdXRlOyBwYWRkaW5nOiAwOyB3aWR0aDogMXB4OyBoZWlnaHQ6IDFlbTsgb3V0bGluZTogbm9uZVwiKTtcclxuICAgIHZhciBkaXYgPSBlbHQoXCJkaXZcIiwgW3RlXSwgbnVsbCwgXCJvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7IHdpZHRoOiAzcHg7IGhlaWdodDogMHB4O1wiKTtcclxuICAgIC8vIFRoZSB0ZXh0YXJlYSBpcyBrZXB0IHBvc2l0aW9uZWQgbmVhciB0aGUgY3Vyc29yIHRvIHByZXZlbnQgdGhlXHJcbiAgICAvLyBmYWN0IHRoYXQgaXQnbGwgYmUgc2Nyb2xsZWQgaW50byB2aWV3IG9uIGlucHV0IGZyb20gc2Nyb2xsaW5nXHJcbiAgICAvLyBvdXIgZmFrZSBjdXJzb3Igb3V0IG9mIHZpZXcuIE9uIHdlYmtpdCwgd2hlbiB3cmFwPW9mZiwgcGFzdGUgaXNcclxuICAgIC8vIHZlcnkgc2xvdy4gU28gbWFrZSB0aGUgYXJlYSB3aWRlIGluc3RlYWQuXHJcbiAgICBpZiAod2Via2l0KSB0ZS5zdHlsZS53aWR0aCA9IFwiMTAwMHB4XCI7XHJcbiAgICBlbHNlIHRlLnNldEF0dHJpYnV0ZShcIndyYXBcIiwgXCJvZmZcIik7XHJcbiAgICAvLyBJZiBib3JkZXI6IDA7IC0tIGlPUyBmYWlscyB0byBvcGVuIGtleWJvYXJkIChpc3N1ZSAjMTI4NylcclxuICAgIGlmIChpb3MpIHRlLnN0eWxlLmJvcmRlciA9IFwiMXB4IHNvbGlkIGJsYWNrXCI7XHJcbiAgICBkaXNhYmxlQnJvd3Nlck1hZ2ljKHRlKTtcclxuICAgIHJldHVybiBkaXY7XHJcbiAgfVxyXG5cclxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZSA9IGNvcHlPYmooe1xyXG4gICAgaW5pdDogZnVuY3Rpb24oZGlzcGxheSkge1xyXG4gICAgICB2YXIgaW5wdXQgPSB0aGlzLCBjbSA9IHRoaXMuY207XHJcblxyXG4gICAgICAvLyBXcmFwcyBhbmQgaGlkZXMgaW5wdXQgdGV4dGFyZWFcclxuICAgICAgdmFyIGRpdiA9IHRoaXMud3JhcHBlciA9IGhpZGRlblRleHRhcmVhKCk7XHJcbiAgICAgIC8vIFRoZSBzZW1paGlkZGVuIHRleHRhcmVhIHRoYXQgaXMgZm9jdXNlZCB3aGVuIHRoZSBlZGl0b3IgaXNcclxuICAgICAgLy8gZm9jdXNlZCwgYW5kIHJlY2VpdmVzIGlucHV0LlxyXG4gICAgICB2YXIgdGUgPSB0aGlzLnRleHRhcmVhID0gZGl2LmZpcnN0Q2hpbGQ7XHJcbiAgICAgIGRpc3BsYXkud3JhcHBlci5pbnNlcnRCZWZvcmUoZGl2LCBkaXNwbGF5LndyYXBwZXIuZmlyc3RDaGlsZCk7XHJcblxyXG4gICAgICAvLyBOZWVkZWQgdG8gaGlkZSBiaWcgYmx1ZSBibGlua2luZyBjdXJzb3Igb24gTW9iaWxlIFNhZmFyaSAoZG9lc24ndCBzZWVtIHRvIHdvcmsgaW4gaU9TIDggYW55bW9yZSlcclxuICAgICAgaWYgKGlvcykgdGUuc3R5bGUud2lkdGggPSBcIjBweFwiO1xyXG5cclxuICAgICAgb24odGUsIFwiaW5wdXRcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSAmJiBpbnB1dC5oYXNTZWxlY3Rpb24pIGlucHV0Lmhhc1NlbGVjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgaW5wdXQucG9sbCgpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIG9uKHRlLCBcInBhc3RlXCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIFdvcmthcm91bmQgZm9yIHdlYmtpdCBidWcgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTkwMjA2XHJcbiAgICAgICAgLy8gQWRkIGEgY2hhciB0byB0aGUgZW5kIG9mIHRleHRhcmVhIGJlZm9yZSBwYXN0ZSBvY2N1ciBzbyB0aGF0XHJcbiAgICAgICAgLy8gc2VsZWN0aW9uIGRvZXNuJ3Qgc3BhbiB0byB0aGUgZW5kIG9mIHRleHRhcmVhLlxyXG4gICAgICAgIGlmICh3ZWJraXQgJiYgIWNtLnN0YXRlLmZha2VkTGFzdENoYXIgJiYgIShuZXcgRGF0ZSAtIGNtLnN0YXRlLmxhc3RNaWRkbGVEb3duIDwgMjAwKSkge1xyXG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGUuc2VsZWN0aW9uU3RhcnQsIGVuZCA9IHRlLnNlbGVjdGlvbkVuZDtcclxuICAgICAgICAgIHRlLnZhbHVlICs9IFwiJFwiO1xyXG4gICAgICAgICAgLy8gVGhlIHNlbGVjdGlvbiBlbmQgbmVlZHMgdG8gYmUgc2V0IGJlZm9yZSB0aGUgc3RhcnQsIG90aGVyd2lzZSB0aGVyZVxyXG4gICAgICAgICAgLy8gY2FuIGJlIGFuIGludGVybWVkaWF0ZSBub24tZW1wdHkgc2VsZWN0aW9uIGJldHdlZW4gdGhlIHR3bywgd2hpY2hcclxuICAgICAgICAgIC8vIGNhbiBvdmVycmlkZSB0aGUgbWlkZGxlLWNsaWNrIHBhc3RlIGJ1ZmZlciBvbiBsaW51eCBhbmQgY2F1c2UgdGhlXHJcbiAgICAgICAgICAvLyB3cm9uZyB0aGluZyB0byBnZXQgcGFzdGVkLlxyXG4gICAgICAgICAgdGUuc2VsZWN0aW9uRW5kID0gZW5kO1xyXG4gICAgICAgICAgdGUuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcclxuICAgICAgICAgIGNtLnN0YXRlLmZha2VkTGFzdENoYXIgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbS5zdGF0ZS5wYXN0ZUluY29taW5nID0gdHJ1ZTtcclxuICAgICAgICBpbnB1dC5mYXN0UG9sbCgpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIHByZXBhcmVDb3B5Q3V0KGUpIHtcclxuICAgICAgICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xyXG4gICAgICAgICAgbGFzdENvcGllZCA9IGNtLmdldFNlbGVjdGlvbnMoKTtcclxuICAgICAgICAgIGlmIChpbnB1dC5pbmFjY3VyYXRlU2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGlucHV0LnByZXZJbnB1dCA9IFwiXCI7XHJcbiAgICAgICAgICAgIGlucHV0LmluYWNjdXJhdGVTZWxlY3Rpb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGUudmFsdWUgPSBsYXN0Q29waWVkLmpvaW4oXCJcXG5cIik7XHJcbiAgICAgICAgICAgIHNlbGVjdElucHV0KHRlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFyIHJhbmdlcyA9IGNvcHlhYmxlUmFuZ2VzKGNtKTtcclxuICAgICAgICAgIGxhc3RDb3BpZWQgPSByYW5nZXMudGV4dDtcclxuICAgICAgICAgIGlmIChlLnR5cGUgPT0gXCJjdXRcIikge1xyXG4gICAgICAgICAgICBjbS5zZXRTZWxlY3Rpb25zKHJhbmdlcy5yYW5nZXMsIG51bGwsIHNlbF9kb250U2Nyb2xsKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlucHV0LnByZXZJbnB1dCA9IFwiXCI7XHJcbiAgICAgICAgICAgIHRlLnZhbHVlID0gcmFuZ2VzLnRleHQuam9pbihcIlxcblwiKTtcclxuICAgICAgICAgICAgc2VsZWN0SW5wdXQodGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZS50eXBlID09IFwiY3V0XCIpIGNtLnN0YXRlLmN1dEluY29taW5nID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBvbih0ZSwgXCJjdXRcIiwgcHJlcGFyZUNvcHlDdXQpO1xyXG4gICAgICBvbih0ZSwgXCJjb3B5XCIsIHByZXBhcmVDb3B5Q3V0KTtcclxuXHJcbiAgICAgIG9uKGRpc3BsYXkuc2Nyb2xsZXIsIFwicGFzdGVcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIGlmIChldmVudEluV2lkZ2V0KGRpc3BsYXksIGUpKSByZXR1cm47XHJcbiAgICAgICAgY20uc3RhdGUucGFzdGVJbmNvbWluZyA9IHRydWU7XHJcbiAgICAgICAgaW5wdXQuZm9jdXMoKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBQcmV2ZW50IG5vcm1hbCBzZWxlY3Rpb24gaW4gdGhlIGVkaXRvciAod2UgaGFuZGxlIG91ciBvd24pXHJcbiAgICAgIG9uKGRpc3BsYXkubGluZVNwYWNlLCBcInNlbGVjdHN0YXJ0XCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICBpZiAoIWV2ZW50SW5XaWRnZXQoZGlzcGxheSwgZSkpIGVfcHJldmVudERlZmF1bHQoZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBwcmVwYXJlU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgLy8gUmVkcmF3IHRoZSBzZWxlY3Rpb24gYW5kL29yIGN1cnNvclxyXG4gICAgICB2YXIgY20gPSB0aGlzLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jO1xyXG4gICAgICB2YXIgcmVzdWx0ID0gcHJlcGFyZVNlbGVjdGlvbihjbSk7XHJcblxyXG4gICAgICAvLyBNb3ZlIHRoZSBoaWRkZW4gdGV4dGFyZWEgbmVhciB0aGUgY3Vyc29yIHRvIHByZXZlbnQgc2Nyb2xsaW5nIGFydGlmYWN0c1xyXG4gICAgICBpZiAoY20ub3B0aW9ucy5tb3ZlSW5wdXRXaXRoQ3Vyc29yKSB7XHJcbiAgICAgICAgdmFyIGhlYWRQb3MgPSBjdXJzb3JDb29yZHMoY20sIGRvYy5zZWwucHJpbWFyeSgpLmhlYWQsIFwiZGl2XCIpO1xyXG4gICAgICAgIHZhciB3cmFwT2ZmID0gZGlzcGxheS53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBsaW5lT2ZmID0gZGlzcGxheS5saW5lRGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIHJlc3VsdC50ZVRvcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQgLSAxMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkUG9zLnRvcCArIGxpbmVPZmYudG9wIC0gd3JhcE9mZi50b3ApKTtcclxuICAgICAgICByZXN1bHQudGVMZWZ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGlzcGxheS53cmFwcGVyLmNsaWVudFdpZHRoIC0gMTAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRQb3MubGVmdCArIGxpbmVPZmYubGVmdCAtIHdyYXBPZmYubGVmdCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxuXHJcbiAgICBzaG93U2VsZWN0aW9uOiBmdW5jdGlvbihkcmF3bikge1xyXG4gICAgICB2YXIgY20gPSB0aGlzLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcclxuICAgICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5jdXJzb3JEaXYsIGRyYXduLmN1cnNvcnMpO1xyXG4gICAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5LnNlbGVjdGlvbkRpdiwgZHJhd24uc2VsZWN0aW9uKTtcclxuICAgICAgaWYgKGRyYXduLnRlVG9wICE9IG51bGwpIHtcclxuICAgICAgICB0aGlzLndyYXBwZXIuc3R5bGUudG9wID0gZHJhd24udGVUb3AgKyBcInB4XCI7XHJcbiAgICAgICAgdGhpcy53cmFwcGVyLnN0eWxlLmxlZnQgPSBkcmF3bi50ZUxlZnQgKyBcInB4XCI7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gUmVzZXQgdGhlIGlucHV0IHRvIGNvcnJlc3BvbmQgdG8gdGhlIHNlbGVjdGlvbiAob3IgdG8gYmUgZW1wdHksXHJcbiAgICAvLyB3aGVuIG5vdCB0eXBpbmcgYW5kIG5vdGhpbmcgaXMgc2VsZWN0ZWQpXHJcbiAgICByZXNldDogZnVuY3Rpb24odHlwaW5nKSB7XHJcbiAgICAgIGlmICh0aGlzLmNvbnRleHRNZW51UGVuZGluZykgcmV0dXJuO1xyXG4gICAgICB2YXIgbWluaW1hbCwgc2VsZWN0ZWQsIGNtID0gdGhpcy5jbSwgZG9jID0gY20uZG9jO1xyXG4gICAgICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xyXG4gICAgICAgIHRoaXMucHJldklucHV0ID0gXCJcIjtcclxuICAgICAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnByaW1hcnkoKTtcclxuICAgICAgICBtaW5pbWFsID0gaGFzQ29weUV2ZW50ICYmXHJcbiAgICAgICAgICAocmFuZ2UudG8oKS5saW5lIC0gcmFuZ2UuZnJvbSgpLmxpbmUgPiAxMDAgfHwgKHNlbGVjdGVkID0gY20uZ2V0U2VsZWN0aW9uKCkpLmxlbmd0aCA+IDEwMDApO1xyXG4gICAgICAgIHZhciBjb250ZW50ID0gbWluaW1hbCA/IFwiLVwiIDogc2VsZWN0ZWQgfHwgY20uZ2V0U2VsZWN0aW9uKCk7XHJcbiAgICAgICAgdGhpcy50ZXh0YXJlYS52YWx1ZSA9IGNvbnRlbnQ7XHJcbiAgICAgICAgaWYgKGNtLnN0YXRlLmZvY3VzZWQpIHNlbGVjdElucHV0KHRoaXMudGV4dGFyZWEpO1xyXG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkpIHRoaXMuaGFzU2VsZWN0aW9uID0gY29udGVudDtcclxuICAgICAgfSBlbHNlIGlmICghdHlwaW5nKSB7XHJcbiAgICAgICAgdGhpcy5wcmV2SW5wdXQgPSB0aGlzLnRleHRhcmVhLnZhbHVlID0gXCJcIjtcclxuICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5KSB0aGlzLmhhc1NlbGVjdGlvbiA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5pbmFjY3VyYXRlU2VsZWN0aW9uID0gbWluaW1hbDtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0RmllbGQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50ZXh0YXJlYTsgfSxcclxuXHJcbiAgICBzdXBwb3J0c1RvdWNoOiBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9LFxyXG5cclxuICAgIGZvY3VzOiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKHRoaXMuY20ub3B0aW9ucy5yZWFkT25seSAhPSBcIm5vY3Vyc29yXCIgJiYgKCFtb2JpbGUgfHwgYWN0aXZlRWx0KCkgIT0gdGhpcy50ZXh0YXJlYSkpIHtcclxuICAgICAgICB0cnkgeyB0aGlzLnRleHRhcmVhLmZvY3VzKCk7IH1cclxuICAgICAgICBjYXRjaCAoZSkge30gLy8gSUU4IHdpbGwgdGhyb3cgaWYgdGhlIHRleHRhcmVhIGlzIGRpc3BsYXk6IG5vbmUgb3Igbm90IGluIERPTVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGJsdXI6IGZ1bmN0aW9uKCkgeyB0aGlzLnRleHRhcmVhLmJsdXIoKTsgfSxcclxuXHJcbiAgICByZXNldFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy53cmFwcGVyLnN0eWxlLnRvcCA9IHRoaXMud3JhcHBlci5zdHlsZS5sZWZ0ID0gMDtcclxuICAgIH0sXHJcblxyXG4gICAgcmVjZWl2ZWRGb2N1czogZnVuY3Rpb24oKSB7IHRoaXMuc2xvd1BvbGwoKTsgfSxcclxuXHJcbiAgICAvLyBQb2xsIGZvciBpbnB1dCBjaGFuZ2VzLCB1c2luZyB0aGUgbm9ybWFsIHJhdGUgb2YgcG9sbGluZy4gVGhpc1xyXG4gICAgLy8gcnVucyBhcyBsb25nIGFzIHRoZSBlZGl0b3IgaXMgZm9jdXNlZC5cclxuICAgIHNsb3dQb2xsOiBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGlucHV0ID0gdGhpcztcclxuICAgICAgaWYgKGlucHV0LnBvbGxpbmdGYXN0KSByZXR1cm47XHJcbiAgICAgIGlucHV0LnBvbGxpbmcuc2V0KHRoaXMuY20ub3B0aW9ucy5wb2xsSW50ZXJ2YWwsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlucHV0LnBvbGwoKTtcclxuICAgICAgICBpZiAoaW5wdXQuY20uc3RhdGUuZm9jdXNlZCkgaW5wdXQuc2xvd1BvbGwoKTtcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFdoZW4gYW4gZXZlbnQgaGFzIGp1c3QgY29tZSBpbiB0aGF0IGlzIGxpa2VseSB0byBhZGQgb3IgY2hhbmdlXHJcbiAgICAvLyBzb21ldGhpbmcgaW4gdGhlIGlucHV0IHRleHRhcmVhLCB3ZSBwb2xsIGZhc3RlciwgdG8gZW5zdXJlIHRoYXRcclxuICAgIC8vIHRoZSBjaGFuZ2UgYXBwZWFycyBvbiB0aGUgc2NyZWVuIHF1aWNrbHkuXHJcbiAgICBmYXN0UG9sbDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBtaXNzZWQgPSBmYWxzZSwgaW5wdXQgPSB0aGlzO1xyXG4gICAgICBpbnB1dC5wb2xsaW5nRmFzdCA9IHRydWU7XHJcbiAgICAgIGZ1bmN0aW9uIHAoKSB7XHJcbiAgICAgICAgdmFyIGNoYW5nZWQgPSBpbnB1dC5wb2xsKCk7XHJcbiAgICAgICAgaWYgKCFjaGFuZ2VkICYmICFtaXNzZWQpIHttaXNzZWQgPSB0cnVlOyBpbnB1dC5wb2xsaW5nLnNldCg2MCwgcCk7fVxyXG4gICAgICAgIGVsc2Uge2lucHV0LnBvbGxpbmdGYXN0ID0gZmFsc2U7IGlucHV0LnNsb3dQb2xsKCk7fVxyXG4gICAgICB9XHJcbiAgICAgIGlucHV0LnBvbGxpbmcuc2V0KDIwLCBwKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gUmVhZCBpbnB1dCBmcm9tIHRoZSB0ZXh0YXJlYSwgYW5kIHVwZGF0ZSB0aGUgZG9jdW1lbnQgdG8gbWF0Y2guXHJcbiAgICAvLyBXaGVuIHNvbWV0aGluZyBpcyBzZWxlY3RlZCwgaXQgaXMgcHJlc2VudCBpbiB0aGUgdGV4dGFyZWEsIGFuZFxyXG4gICAgLy8gc2VsZWN0ZWQgKHVubGVzcyBpdCBpcyBodWdlLCBpbiB3aGljaCBjYXNlIGEgcGxhY2Vob2xkZXIgaXNcclxuICAgIC8vIHVzZWQpLiBXaGVuIG5vdGhpbmcgaXMgc2VsZWN0ZWQsIHRoZSBjdXJzb3Igc2l0cyBhZnRlciBwcmV2aW91c2x5XHJcbiAgICAvLyBzZWVuIHRleHQgKGNhbiBiZSBlbXB0eSksIHdoaWNoIGlzIHN0b3JlZCBpbiBwcmV2SW5wdXQgKHdlIG11c3RcclxuICAgIC8vIG5vdCByZXNldCB0aGUgdGV4dGFyZWEgd2hlbiB0eXBpbmcsIGJlY2F1c2UgdGhhdCBicmVha3MgSU1FKS5cclxuICAgIHBvbGw6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgY20gPSB0aGlzLmNtLCBpbnB1dCA9IHRoaXMudGV4dGFyZWEsIHByZXZJbnB1dCA9IHRoaXMucHJldklucHV0O1xyXG4gICAgICAvLyBTaW5jZSB0aGlzIGlzIGNhbGxlZCBhICpsb3QqLCB0cnkgdG8gYmFpbCBvdXQgYXMgY2hlYXBseSBhc1xyXG4gICAgICAvLyBwb3NzaWJsZSB3aGVuIGl0IGlzIGNsZWFyIHRoYXQgbm90aGluZyBoYXBwZW5lZC4gaGFzU2VsZWN0aW9uXHJcbiAgICAgIC8vIHdpbGwgYmUgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBhIGxvdCBvZiB0ZXh0IGluIHRoZSB0ZXh0YXJlYSxcclxuICAgICAgLy8gaW4gd2hpY2ggY2FzZSByZWFkaW5nIGl0cyB2YWx1ZSB3b3VsZCBiZSBleHBlbnNpdmUuXHJcbiAgICAgIGlmICghY20uc3RhdGUuZm9jdXNlZCB8fCAoaGFzU2VsZWN0aW9uKGlucHV0KSAmJiAhcHJldklucHV0KSB8fFxyXG4gICAgICAgICAgaXNSZWFkT25seShjbSkgfHwgY20ub3B0aW9ucy5kaXNhYmxlSW5wdXQgfHwgY20uc3RhdGUua2V5U2VxKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgLy8gU2VlIHBhc3RlIGhhbmRsZXIgZm9yIG1vcmUgb24gdGhlIGZha2VkTGFzdENoYXIga2x1ZGdlXHJcbiAgICAgIGlmIChjbS5zdGF0ZS5wYXN0ZUluY29taW5nICYmIGNtLnN0YXRlLmZha2VkTGFzdENoYXIpIHtcclxuICAgICAgICBpbnB1dC52YWx1ZSA9IGlucHV0LnZhbHVlLnN1YnN0cmluZygwLCBpbnB1dC52YWx1ZS5sZW5ndGggLSAxKTtcclxuICAgICAgICBjbS5zdGF0ZS5mYWtlZExhc3RDaGFyID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHRleHQgPSBpbnB1dC52YWx1ZTtcclxuICAgICAgLy8gSWYgbm90aGluZyBjaGFuZ2VkLCBiYWlsLlxyXG4gICAgICBpZiAodGV4dCA9PSBwcmV2SW5wdXQgJiYgIWNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHJldHVybiBmYWxzZTtcclxuICAgICAgLy8gV29yayBhcm91bmQgbm9uc2Vuc2ljYWwgc2VsZWN0aW9uIHJlc2V0dGluZyBpbiBJRTkvMTAsIGFuZFxyXG4gICAgICAvLyBpbmV4cGxpY2FibGUgYXBwZWFyYW5jZSBvZiBwcml2YXRlIGFyZWEgdW5pY29kZSBjaGFyYWN0ZXJzIG9uXHJcbiAgICAgIC8vIHNvbWUga2V5IGNvbWJvcyBpbiBNYWMgKCMyNjg5KS5cclxuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSAmJiB0aGlzLmhhc1NlbGVjdGlvbiA9PT0gdGV4dCB8fFxyXG4gICAgICAgICAgbWFjICYmIC9bXFx1ZjcwMC1cXHVmN2ZmXS8udGVzdCh0ZXh0KSkge1xyXG4gICAgICAgIGNtLmRpc3BsYXkuaW5wdXQucmVzZXQoKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjbS5kb2Muc2VsID09IGNtLmRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUpIHtcclxuICAgICAgICB2YXIgZmlyc3QgPSB0ZXh0LmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgaWYgKGZpcnN0ID09IDB4MjAwYiAmJiAhcHJldklucHV0KSBwcmV2SW5wdXQgPSBcIlxcdTIwMGJcIjtcclxuICAgICAgICBpZiAoZmlyc3QgPT0gMHgyMWRhKSB7IHRoaXMucmVzZXQoKTsgcmV0dXJuIHRoaXMuY20uZXhlY0NvbW1hbmQoXCJ1bmRvXCIpOyB9XHJcbiAgICAgIH1cclxuICAgICAgLy8gRmluZCB0aGUgcGFydCBvZiB0aGUgaW5wdXQgdGhhdCBpcyBhY3R1YWxseSBuZXdcclxuICAgICAgdmFyIHNhbWUgPSAwLCBsID0gTWF0aC5taW4ocHJldklucHV0Lmxlbmd0aCwgdGV4dC5sZW5ndGgpO1xyXG4gICAgICB3aGlsZSAoc2FtZSA8IGwgJiYgcHJldklucHV0LmNoYXJDb2RlQXQoc2FtZSkgPT0gdGV4dC5jaGFyQ29kZUF0KHNhbWUpKSArK3NhbWU7XHJcblxyXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGFwcGx5VGV4dElucHV0KGNtLCB0ZXh0LnNsaWNlKHNhbWUpLCBwcmV2SW5wdXQubGVuZ3RoIC0gc2FtZSk7XHJcblxyXG4gICAgICAgIC8vIERvbid0IGxlYXZlIGxvbmcgdGV4dCBpbiB0aGUgdGV4dGFyZWEsIHNpbmNlIGl0IG1ha2VzIGZ1cnRoZXIgcG9sbGluZyBzbG93XHJcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMTAwMCB8fCB0ZXh0LmluZGV4T2YoXCJcXG5cIikgPiAtMSkgaW5wdXQudmFsdWUgPSBzZWxmLnByZXZJbnB1dCA9IFwiXCI7XHJcbiAgICAgICAgZWxzZSBzZWxmLnByZXZJbnB1dCA9IHRleHQ7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgZW5zdXJlUG9sbGVkOiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKHRoaXMucG9sbGluZ0Zhc3QgJiYgdGhpcy5wb2xsKCkpIHRoaXMucG9sbGluZ0Zhc3QgPSBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgb25LZXlQcmVzczogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkpIHRoaXMuaGFzU2VsZWN0aW9uID0gbnVsbDtcclxuICAgICAgdGhpcy5mYXN0UG9sbCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbkNvbnRleHRNZW51OiBmdW5jdGlvbihlKSB7XHJcbiAgICAgIHZhciBpbnB1dCA9IHRoaXMsIGNtID0gaW5wdXQuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCB0ZSA9IGlucHV0LnRleHRhcmVhO1xyXG4gICAgICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlKSwgc2Nyb2xsUG9zID0gZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3A7XHJcbiAgICAgIGlmICghcG9zIHx8IHByZXN0bykgcmV0dXJuOyAvLyBPcGVyYSBpcyBkaWZmaWN1bHQuXHJcblxyXG4gICAgICAvLyBSZXNldCB0aGUgY3VycmVudCB0ZXh0IHNlbGVjdGlvbiBvbmx5IGlmIHRoZSBjbGljayBpcyBkb25lIG91dHNpZGUgb2YgdGhlIHNlbGVjdGlvblxyXG4gICAgICAvLyBhbmQgJ3Jlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudScgb3B0aW9uIGlzIHRydWUuXHJcbiAgICAgIHZhciByZXNldCA9IGNtLm9wdGlvbnMucmVzZXRTZWxlY3Rpb25PbkNvbnRleHRNZW51O1xyXG4gICAgICBpZiAocmVzZXQgJiYgY20uZG9jLnNlbC5jb250YWlucyhwb3MpID09IC0xKVxyXG4gICAgICAgIG9wZXJhdGlvbihjbSwgc2V0U2VsZWN0aW9uKShjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihwb3MpLCBzZWxfZG9udFNjcm9sbCk7XHJcblxyXG4gICAgICB2YXIgb2xkQ1NTID0gdGUuc3R5bGUuY3NzVGV4dDtcclxuICAgICAgaW5wdXQud3JhcHBlci5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcclxuICAgICAgdGUuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyB3aWR0aDogMzBweDsgaGVpZ2h0OiAzMHB4OyB0b3A6IFwiICsgKGUuY2xpZW50WSAtIDUpICtcclxuICAgICAgICBcInB4OyBsZWZ0OiBcIiArIChlLmNsaWVudFggLSA1KSArIFwicHg7IHotaW5kZXg6IDEwMDA7IGJhY2tncm91bmQ6IFwiICtcclxuICAgICAgICAoaWUgPyBcInJnYmEoMjU1LCAyNTUsIDI1NSwgLjA1KVwiIDogXCJ0cmFuc3BhcmVudFwiKSArXHJcbiAgICAgICAgXCI7IG91dGxpbmU6IG5vbmU7IGJvcmRlci13aWR0aDogMDsgb3V0bGluZTogbm9uZTsgb3ZlcmZsb3c6IGhpZGRlbjsgb3BhY2l0eTogLjA1OyBmaWx0ZXI6IGFscGhhKG9wYWNpdHk9NSk7XCI7XHJcbiAgICAgIGlmICh3ZWJraXQpIHZhciBvbGRTY3JvbGxZID0gd2luZG93LnNjcm9sbFk7IC8vIFdvcmsgYXJvdW5kIENocm9tZSBpc3N1ZSAoIzI3MTIpXHJcbiAgICAgIGRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcclxuICAgICAgaWYgKHdlYmtpdCkgd2luZG93LnNjcm9sbFRvKG51bGwsIG9sZFNjcm9sbFkpO1xyXG4gICAgICBkaXNwbGF5LmlucHV0LnJlc2V0KCk7XHJcbiAgICAgIC8vIEFkZHMgXCJTZWxlY3QgYWxsXCIgdG8gY29udGV4dCBtZW51IGluIEZGXHJcbiAgICAgIGlmICghY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkgdGUudmFsdWUgPSBpbnB1dC5wcmV2SW5wdXQgPSBcIiBcIjtcclxuICAgICAgaW5wdXQuY29udGV4dE1lbnVQZW5kaW5nID0gdHJ1ZTtcclxuICAgICAgZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9IGNtLmRvYy5zZWw7XHJcbiAgICAgIGNsZWFyVGltZW91dChkaXNwbGF5LmRldGVjdGluZ1NlbGVjdEFsbCk7XHJcblxyXG4gICAgICAvLyBTZWxlY3QtYWxsIHdpbGwgYmUgZ3JleWVkIG91dCBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2VsZWN0LCBzb1xyXG4gICAgICAvLyB0aGlzIGFkZHMgYSB6ZXJvLXdpZHRoIHNwYWNlIHNvIHRoYXQgd2UgY2FuIGxhdGVyIGNoZWNrIHdoZXRoZXJcclxuICAgICAgLy8gaXQgZ290IHNlbGVjdGVkLlxyXG4gICAgICBmdW5jdGlvbiBwcmVwYXJlU2VsZWN0QWxsSGFjaygpIHtcclxuICAgICAgICBpZiAodGUuc2VsZWN0aW9uU3RhcnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgdmFyIHNlbGVjdGVkID0gY20uc29tZXRoaW5nU2VsZWN0ZWQoKTtcclxuICAgICAgICAgIHRlLnZhbHVlID0gXCJcXHUyMWRhXCI7IC8vIFVzZWQgdG8gY2F0Y2ggY29udGV4dC1tZW51IHVuZG9cclxuICAgICAgICAgIHZhciBleHR2YWwgPSB0ZS52YWx1ZSA9IFwiXFx1MjAwYlwiICsgKHNlbGVjdGVkID8gdGUudmFsdWUgOiBcIlwiKTtcclxuICAgICAgICAgIGlucHV0LnByZXZJbnB1dCA9IHNlbGVjdGVkID8gXCJcIiA6IFwiXFx1MjAwYlwiO1xyXG4gICAgICAgICAgdGUuc2VsZWN0aW9uU3RhcnQgPSAxOyB0ZS5zZWxlY3Rpb25FbmQgPSBleHR2YWwubGVuZ3RoO1xyXG4gICAgICAgICAgLy8gUmUtc2V0IHRoaXMsIGluIGNhc2Ugc29tZSBvdGhlciBoYW5kbGVyIHRvdWNoZWQgdGhlXHJcbiAgICAgICAgICAvLyBzZWxlY3Rpb24gaW4gdGhlIG1lYW50aW1lLlxyXG4gICAgICAgICAgZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9IGNtLmRvYy5zZWw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGZ1bmN0aW9uIHJlaGlkZSgpIHtcclxuICAgICAgICBpbnB1dC5jb250ZXh0TWVudVBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICBpbnB1dC53cmFwcGVyLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xyXG4gICAgICAgIHRlLnN0eWxlLmNzc1RleHQgPSBvbGRDU1M7XHJcbiAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5KSBkaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsVG9wKGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wID0gc2Nyb2xsUG9zKTtcclxuXHJcbiAgICAgICAgLy8gVHJ5IHRvIGRldGVjdCB0aGUgdXNlciBjaG9vc2luZyBzZWxlY3QtYWxsXHJcbiAgICAgICAgaWYgKHRlLnNlbGVjdGlvblN0YXJ0ICE9IG51bGwpIHtcclxuICAgICAgICAgIGlmICghaWUgfHwgKGllICYmIGllX3ZlcnNpb24gPCA5KSkgcHJlcGFyZVNlbGVjdEFsbEhhY2soKTtcclxuICAgICAgICAgIHZhciBpID0gMCwgcG9sbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9PSBjbS5kb2Muc2VsICYmIHRlLnNlbGVjdGlvblN0YXJ0ID09IDAgJiYgaW5wdXQucHJldklucHV0ID09IFwiXFx1MjAwYlwiKVxyXG4gICAgICAgICAgICAgIG9wZXJhdGlvbihjbSwgY29tbWFuZHMuc2VsZWN0QWxsKShjbSk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGkrKyA8IDEwKSBkaXNwbGF5LmRldGVjdGluZ1NlbGVjdEFsbCA9IHNldFRpbWVvdXQocG9sbCwgNTAwKTtcclxuICAgICAgICAgICAgZWxzZSBkaXNwbGF5LmlucHV0LnJlc2V0KCk7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgZGlzcGxheS5kZXRlY3RpbmdTZWxlY3RBbGwgPSBzZXRUaW1lb3V0KHBvbGwsIDIwMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5KSBwcmVwYXJlU2VsZWN0QWxsSGFjaygpO1xyXG4gICAgICBpZiAoY2FwdHVyZVJpZ2h0Q2xpY2spIHtcclxuICAgICAgICBlX3N0b3AoZSk7XHJcbiAgICAgICAgdmFyIG1vdXNldXAgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIG9mZih3aW5kb3csIFwibW91c2V1cFwiLCBtb3VzZXVwKTtcclxuICAgICAgICAgIHNldFRpbWVvdXQocmVoaWRlLCAyMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBvbih3aW5kb3csIFwibW91c2V1cFwiLCBtb3VzZXVwKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZXRUaW1lb3V0KHJlaGlkZSwgNTApO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFVuZWRpdGFibGU6IG5vdGhpbmcsXHJcblxyXG4gICAgbmVlZHNDb250ZW50QXR0cmlidXRlOiBmYWxzZVxyXG4gIH0sIFRleHRhcmVhSW5wdXQucHJvdG90eXBlKTtcclxuXHJcbiAgLy8gQ09OVEVOVEVESVRBQkxFIElOUFVUIFNUWUxFXHJcblxyXG4gIGZ1bmN0aW9uIENvbnRlbnRFZGl0YWJsZUlucHV0KGNtKSB7XHJcbiAgICB0aGlzLmNtID0gY207XHJcbiAgICB0aGlzLmxhc3RBbmNob3JOb2RlID0gdGhpcy5sYXN0QW5jaG9yT2Zmc2V0ID0gdGhpcy5sYXN0Rm9jdXNOb2RlID0gdGhpcy5sYXN0Rm9jdXNPZmZzZXQgPSBudWxsO1xyXG4gICAgdGhpcy5wb2xsaW5nID0gbmV3IERlbGF5ZWQoKTtcclxuICAgIHRoaXMuZ3JhY2VQZXJpb2QgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZSA9IGNvcHlPYmooe1xyXG4gICAgaW5pdDogZnVuY3Rpb24oZGlzcGxheSkge1xyXG4gICAgICB2YXIgaW5wdXQgPSB0aGlzLCBjbSA9IGlucHV0LmNtO1xyXG4gICAgICB2YXIgZGl2ID0gaW5wdXQuZGl2ID0gZGlzcGxheS5saW5lRGl2O1xyXG4gICAgICBkaXYuY29udGVudEVkaXRhYmxlID0gXCJ0cnVlXCI7XHJcbiAgICAgIGRpc2FibGVCcm93c2VyTWFnaWMoZGl2KTtcclxuXHJcbiAgICAgIG9uKGRpdiwgXCJwYXN0ZVwiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgdmFyIHBhc3RlZCA9IGUuY2xpcGJvYXJkRGF0YSAmJiBlLmNsaXBib2FyZERhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIik7XHJcbiAgICAgICAgaWYgKHBhc3RlZCkge1xyXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbihwYXN0ZWQsIG51bGwsIFwicGFzdGVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIG9uKGRpdiwgXCJjb21wb3NpdGlvbnN0YXJ0XCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IGUuZGF0YTtcclxuICAgICAgICBpbnB1dC5jb21wb3NpbmcgPSB7c2VsOiBjbS5kb2Muc2VsLCBkYXRhOiBkYXRhLCBzdGFydERhdGE6IGRhdGF9O1xyXG4gICAgICAgIGlmICghZGF0YSkgcmV0dXJuO1xyXG4gICAgICAgIHZhciBwcmltID0gY20uZG9jLnNlbC5wcmltYXJ5KCk7XHJcbiAgICAgICAgdmFyIGxpbmUgPSBjbS5nZXRMaW5lKHByaW0uaGVhZC5saW5lKTtcclxuICAgICAgICB2YXIgZm91bmQgPSBsaW5lLmluZGV4T2YoZGF0YSwgTWF0aC5tYXgoMCwgcHJpbS5oZWFkLmNoIC0gZGF0YS5sZW5ndGgpKTtcclxuICAgICAgICBpZiAoZm91bmQgPiAtMSAmJiBmb3VuZCA8PSBwcmltLmhlYWQuY2gpXHJcbiAgICAgICAgICBpbnB1dC5jb21wb3Npbmcuc2VsID0gc2ltcGxlU2VsZWN0aW9uKFBvcyhwcmltLmhlYWQubGluZSwgZm91bmQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb3MocHJpbS5oZWFkLmxpbmUsIGZvdW5kICsgZGF0YS5sZW5ndGgpKTtcclxuICAgICAgfSk7XHJcbiAgICAgIG9uKGRpdiwgXCJjb21wb3NpdGlvbnVwZGF0ZVwiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgaW5wdXQuY29tcG9zaW5nLmRhdGEgPSBlLmRhdGE7XHJcbiAgICAgIH0pO1xyXG4gICAgICBvbihkaXYsIFwiY29tcG9zaXRpb25lbmRcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIHZhciBvdXJzID0gaW5wdXQuY29tcG9zaW5nO1xyXG4gICAgICAgIGlmICghb3VycykgcmV0dXJuO1xyXG4gICAgICAgIGlmIChlLmRhdGEgIT0gb3Vycy5zdGFydERhdGEgJiYgIS9cXHUyMDBiLy50ZXN0KGUuZGF0YSkpXHJcbiAgICAgICAgICBvdXJzLmRhdGEgPSBlLmRhdGE7XHJcbiAgICAgICAgLy8gTmVlZCBhIHNtYWxsIGRlbGF5IHRvIHByZXZlbnQgb3RoZXIgY29kZSAoaW5wdXQgZXZlbnQsXHJcbiAgICAgICAgLy8gc2VsZWN0aW9uIHBvbGxpbmcpIGZyb20gZG9pbmcgZGFtYWdlIHdoZW4gZmlyZWQgcmlnaHQgYWZ0ZXJcclxuICAgICAgICAvLyBjb21wb3NpdGlvbmVuZC5cclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgaWYgKCFvdXJzLmhhbmRsZWQpXHJcbiAgICAgICAgICAgIGlucHV0LmFwcGx5Q29tcG9zaXRpb24ob3Vycyk7XHJcbiAgICAgICAgICBpZiAoaW5wdXQuY29tcG9zaW5nID09IG91cnMpXHJcbiAgICAgICAgICAgIGlucHV0LmNvbXBvc2luZyA9IG51bGw7XHJcbiAgICAgICAgfSwgNTApO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIG9uKGRpdiwgXCJ0b3VjaHN0YXJ0XCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlucHV0LmZvcmNlQ29tcG9zaXRpb25FbmQoKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBvbihkaXYsIFwiaW5wdXRcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKGlucHV0LmNvbXBvc2luZykgcmV0dXJuO1xyXG4gICAgICAgIGlmICghaW5wdXQucG9sbENvbnRlbnQoKSlcclxuICAgICAgICAgIHJ1bkluT3AoaW5wdXQuY20sIGZ1bmN0aW9uKCkge3JlZ0NoYW5nZShjbSk7fSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgZnVuY3Rpb24gb25Db3B5Q3V0KGUpIHtcclxuICAgICAgICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xyXG4gICAgICAgICAgbGFzdENvcGllZCA9IGNtLmdldFNlbGVjdGlvbnMoKTtcclxuICAgICAgICAgIGlmIChlLnR5cGUgPT0gXCJjdXRcIikgY20ucmVwbGFjZVNlbGVjdGlvbihcIlwiLCBudWxsLCBcImN1dFwiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFyIHJhbmdlcyA9IGNvcHlhYmxlUmFuZ2VzKGNtKTtcclxuICAgICAgICAgIGxhc3RDb3BpZWQgPSByYW5nZXMudGV4dDtcclxuICAgICAgICAgIGlmIChlLnR5cGUgPT0gXCJjdXRcIikge1xyXG4gICAgICAgICAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgY20uc2V0U2VsZWN0aW9ucyhyYW5nZXMucmFuZ2VzLCAwLCBzZWxfZG9udFNjcm9sbCk7XHJcbiAgICAgICAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbihcIlwiLCBudWxsLCBcImN1dFwiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlPUyBleHBvc2VzIHRoZSBjbGlwYm9hcmQgQVBJLCBidXQgc2VlbXMgdG8gZGlzY2FyZCBjb250ZW50IGluc2VydGVkIGludG8gaXRcclxuICAgICAgICBpZiAoZS5jbGlwYm9hcmREYXRhICYmICFpb3MpIHtcclxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgIGUuY2xpcGJvYXJkRGF0YS5jbGVhckRhdGEoKTtcclxuICAgICAgICAgIGUuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCBsYXN0Q29waWVkLmpvaW4oXCJcXG5cIikpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBPbGQtZmFzaGlvbmVkIGJyaWVmbHktZm9jdXMtYS10ZXh0YXJlYSBoYWNrXHJcbiAgICAgICAgICB2YXIga2x1ZGdlID0gaGlkZGVuVGV4dGFyZWEoKSwgdGUgPSBrbHVkZ2UuZmlyc3RDaGlsZDtcclxuICAgICAgICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLmluc2VydEJlZm9yZShrbHVkZ2UsIGNtLmRpc3BsYXkubGluZVNwYWNlLmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgICAgdGUudmFsdWUgPSBsYXN0Q29waWVkLmpvaW4oXCJcXG5cIik7XHJcbiAgICAgICAgICB2YXIgaGFkRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xyXG4gICAgICAgICAgc2VsZWN0SW5wdXQodGUpO1xyXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgY20uZGlzcGxheS5saW5lU3BhY2UucmVtb3ZlQ2hpbGQoa2x1ZGdlKTtcclxuICAgICAgICAgICAgaGFkRm9jdXMuZm9jdXMoKTtcclxuICAgICAgICAgIH0sIDUwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgb24oZGl2LCBcImNvcHlcIiwgb25Db3B5Q3V0KTtcclxuICAgICAgb24oZGl2LCBcImN1dFwiLCBvbkNvcHlDdXQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBwcmVwYXJlU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IHByZXBhcmVTZWxlY3Rpb24odGhpcy5jbSwgZmFsc2UpO1xyXG4gICAgICByZXN1bHQuZm9jdXMgPSB0aGlzLmNtLnN0YXRlLmZvY3VzZWQ7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHNob3dTZWxlY3Rpb246IGZ1bmN0aW9uKGluZm8pIHtcclxuICAgICAgaWYgKCFpbmZvIHx8ICF0aGlzLmNtLmRpc3BsYXkudmlldy5sZW5ndGgpIHJldHVybjtcclxuICAgICAgaWYgKGluZm8uZm9jdXMpIHRoaXMuc2hvd1ByaW1hcnlTZWxlY3Rpb24oKTtcclxuICAgICAgdGhpcy5zaG93TXVsdGlwbGVTZWxlY3Rpb25zKGluZm8pO1xyXG4gICAgfSxcclxuXHJcbiAgICBzaG93UHJpbWFyeVNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksIHByaW0gPSB0aGlzLmNtLmRvYy5zZWwucHJpbWFyeSgpO1xyXG4gICAgICB2YXIgY3VyQW5jaG9yID0gZG9tVG9Qb3ModGhpcy5jbSwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpO1xyXG4gICAgICB2YXIgY3VyRm9jdXMgPSBkb21Ub1Bvcyh0aGlzLmNtLCBzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xyXG4gICAgICBpZiAoY3VyQW5jaG9yICYmICFjdXJBbmNob3IuYmFkICYmIGN1ckZvY3VzICYmICFjdXJGb2N1cy5iYWQgJiZcclxuICAgICAgICAgIGNtcChtaW5Qb3MoY3VyQW5jaG9yLCBjdXJGb2N1cyksIHByaW0uZnJvbSgpKSA9PSAwICYmXHJcbiAgICAgICAgICBjbXAobWF4UG9zKGN1ckFuY2hvciwgY3VyRm9jdXMpLCBwcmltLnRvKCkpID09IDApXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgdmFyIHN0YXJ0ID0gcG9zVG9ET00odGhpcy5jbSwgcHJpbS5mcm9tKCkpO1xyXG4gICAgICB2YXIgZW5kID0gcG9zVG9ET00odGhpcy5jbSwgcHJpbS50bygpKTtcclxuICAgICAgaWYgKCFzdGFydCAmJiAhZW5kKSByZXR1cm47XHJcblxyXG4gICAgICB2YXIgdmlldyA9IHRoaXMuY20uZGlzcGxheS52aWV3O1xyXG4gICAgICB2YXIgb2xkID0gc2VsLnJhbmdlQ291bnQgJiYgc2VsLmdldFJhbmdlQXQoMCk7XHJcbiAgICAgIGlmICghc3RhcnQpIHtcclxuICAgICAgICBzdGFydCA9IHtub2RlOiB2aWV3WzBdLm1lYXN1cmUubWFwWzJdLCBvZmZzZXQ6IDB9O1xyXG4gICAgICB9IGVsc2UgaWYgKCFlbmQpIHsgLy8gRklYTUUgZGFuZ2Vyb3VzbHkgaGFja3lcclxuICAgICAgICB2YXIgbWVhc3VyZSA9IHZpZXdbdmlldy5sZW5ndGggLSAxXS5tZWFzdXJlO1xyXG4gICAgICAgIHZhciBtYXAgPSBtZWFzdXJlLm1hcHMgPyBtZWFzdXJlLm1hcHNbbWVhc3VyZS5tYXBzLmxlbmd0aCAtIDFdIDogbWVhc3VyZS5tYXA7XHJcbiAgICAgICAgZW5kID0ge25vZGU6IG1hcFttYXAubGVuZ3RoIC0gMV0sIG9mZnNldDogbWFwW21hcC5sZW5ndGggLSAyXSAtIG1hcFttYXAubGVuZ3RoIC0gM119O1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0cnkgeyB2YXIgcm5nID0gcmFuZ2Uoc3RhcnQubm9kZSwgc3RhcnQub2Zmc2V0LCBlbmQub2Zmc2V0LCBlbmQubm9kZSk7IH1cclxuICAgICAgY2F0Y2goZSkge30gLy8gT3VyIG1vZGVsIG9mIHRoZSBET00gbWlnaHQgYmUgb3V0ZGF0ZWQsIGluIHdoaWNoIGNhc2UgdGhlIHJhbmdlIHdlIHRyeSB0byBzZXQgY2FuIGJlIGltcG9zc2libGVcclxuICAgICAgaWYgKHJuZykge1xyXG4gICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcclxuICAgICAgICBzZWwuYWRkUmFuZ2Uocm5nKTtcclxuICAgICAgICBpZiAob2xkICYmIHNlbC5hbmNob3JOb2RlID09IG51bGwpIHNlbC5hZGRSYW5nZShvbGQpO1xyXG4gICAgICAgIGVsc2UgaWYgKGdlY2tvKSB0aGlzLnN0YXJ0R3JhY2VQZXJpb2QoKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnJlbWVtYmVyU2VsZWN0aW9uKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0R3JhY2VQZXJpb2Q6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgaW5wdXQgPSB0aGlzO1xyXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5ncmFjZVBlcmlvZCk7XHJcbiAgICAgIHRoaXMuZ3JhY2VQZXJpb2QgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlucHV0LmdyYWNlUGVyaW9kID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGlucHV0LnNlbGVjdGlvbkNoYW5nZWQoKSlcclxuICAgICAgICAgIGlucHV0LmNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHsgaW5wdXQuY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7IH0pO1xyXG4gICAgICB9LCAyMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNob3dNdWx0aXBsZVNlbGVjdGlvbnM6IGZ1bmN0aW9uKGluZm8pIHtcclxuICAgICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQodGhpcy5jbS5kaXNwbGF5LmN1cnNvckRpdiwgaW5mby5jdXJzb3JzKTtcclxuICAgICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQodGhpcy5jbS5kaXNwbGF5LnNlbGVjdGlvbkRpdiwgaW5mby5zZWxlY3Rpb24pO1xyXG4gICAgfSxcclxuXHJcbiAgICByZW1lbWJlclNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XHJcbiAgICAgIHRoaXMubGFzdEFuY2hvck5vZGUgPSBzZWwuYW5jaG9yTm9kZTsgdGhpcy5sYXN0QW5jaG9yT2Zmc2V0ID0gc2VsLmFuY2hvck9mZnNldDtcclxuICAgICAgdGhpcy5sYXN0Rm9jdXNOb2RlID0gc2VsLmZvY3VzTm9kZTsgdGhpcy5sYXN0Rm9jdXNPZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHNlbGVjdGlvbkluRWRpdG9yOiBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcclxuICAgICAgaWYgKCFzZWwucmFuZ2VDb3VudCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB2YXIgbm9kZSA9IHNlbC5nZXRSYW5nZUF0KDApLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xyXG4gICAgICByZXR1cm4gY29udGFpbnModGhpcy5kaXYsIG5vZGUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBmb2N1czogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICh0aGlzLmNtLm9wdGlvbnMucmVhZE9ubHkgIT0gXCJub2N1cnNvclwiKSB0aGlzLmRpdi5mb2N1cygpO1xyXG4gICAgfSxcclxuICAgIGJsdXI6IGZ1bmN0aW9uKCkgeyB0aGlzLmRpdi5ibHVyKCk7IH0sXHJcbiAgICBnZXRGaWVsZDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmRpdjsgfSxcclxuXHJcbiAgICBzdXBwb3J0c1RvdWNoOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0sXHJcblxyXG4gICAgcmVjZWl2ZWRGb2N1czogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBpbnB1dCA9IHRoaXM7XHJcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbkluRWRpdG9yKCkpXHJcbiAgICAgICAgdGhpcy5wb2xsU2VsZWN0aW9uKCk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBydW5Jbk9wKHRoaXMuY20sIGZ1bmN0aW9uKCkgeyBpbnB1dC5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTsgfSk7XHJcblxyXG4gICAgICBmdW5jdGlvbiBwb2xsKCkge1xyXG4gICAgICAgIGlmIChpbnB1dC5jbS5zdGF0ZS5mb2N1c2VkKSB7XHJcbiAgICAgICAgICBpbnB1dC5wb2xsU2VsZWN0aW9uKCk7XHJcbiAgICAgICAgICBpbnB1dC5wb2xsaW5nLnNldChpbnB1dC5jbS5vcHRpb25zLnBvbGxJbnRlcnZhbCwgcG9sbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucG9sbGluZy5zZXQodGhpcy5jbS5vcHRpb25zLnBvbGxJbnRlcnZhbCwgcG9sbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNlbGVjdGlvbkNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xyXG4gICAgICByZXR1cm4gc2VsLmFuY2hvck5vZGUgIT0gdGhpcy5sYXN0QW5jaG9yTm9kZSB8fCBzZWwuYW5jaG9yT2Zmc2V0ICE9IHRoaXMubGFzdEFuY2hvck9mZnNldCB8fFxyXG4gICAgICAgIHNlbC5mb2N1c05vZGUgIT0gdGhpcy5sYXN0Rm9jdXNOb2RlIHx8IHNlbC5mb2N1c09mZnNldCAhPSB0aGlzLmxhc3RGb2N1c09mZnNldDtcclxuICAgIH0sXHJcblxyXG4gICAgcG9sbFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICghdGhpcy5jb21wb3NpbmcgJiYgIXRoaXMuZ3JhY2VQZXJpb2QgJiYgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkKCkpIHtcclxuICAgICAgICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpLCBjbSA9IHRoaXMuY207XHJcbiAgICAgICAgdGhpcy5yZW1lbWJlclNlbGVjdGlvbigpO1xyXG4gICAgICAgIHZhciBhbmNob3IgPSBkb21Ub1BvcyhjbSwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpO1xyXG4gICAgICAgIHZhciBoZWFkID0gZG9tVG9Qb3MoY20sIHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XHJcbiAgICAgICAgaWYgKGFuY2hvciAmJiBoZWFkKSBydW5Jbk9wKGNtLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHNldFNlbGVjdGlvbihjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihhbmNob3IsIGhlYWQpLCBzZWxfZG9udFNjcm9sbCk7XHJcbiAgICAgICAgICBpZiAoYW5jaG9yLmJhZCB8fCBoZWFkLmJhZCkgY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcG9sbENvbnRlbnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgY20gPSB0aGlzLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgc2VsID0gY20uZG9jLnNlbC5wcmltYXJ5KCk7XHJcbiAgICAgIHZhciBmcm9tID0gc2VsLmZyb20oKSwgdG8gPSBzZWwudG8oKTtcclxuICAgICAgaWYgKGZyb20ubGluZSA8IGRpc3BsYXkudmlld0Zyb20gfHwgdG8ubGluZSA+IGRpc3BsYXkudmlld1RvIC0gMSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgdmFyIGZyb21JbmRleDtcclxuICAgICAgaWYgKGZyb20ubGluZSA9PSBkaXNwbGF5LnZpZXdGcm9tIHx8IChmcm9tSW5kZXggPSBmaW5kVmlld0luZGV4KGNtLCBmcm9tLmxpbmUpKSA9PSAwKSB7XHJcbiAgICAgICAgdmFyIGZyb21MaW5lID0gbGluZU5vKGRpc3BsYXkudmlld1swXS5saW5lKTtcclxuICAgICAgICB2YXIgZnJvbU5vZGUgPSBkaXNwbGF5LnZpZXdbMF0ubm9kZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgZnJvbUxpbmUgPSBsaW5lTm8oZGlzcGxheS52aWV3W2Zyb21JbmRleF0ubGluZSk7XHJcbiAgICAgICAgdmFyIGZyb21Ob2RlID0gZGlzcGxheS52aWV3W2Zyb21JbmRleCAtIDFdLm5vZGUubmV4dFNpYmxpbmc7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHRvSW5kZXggPSBmaW5kVmlld0luZGV4KGNtLCB0by5saW5lKTtcclxuICAgICAgaWYgKHRvSW5kZXggPT0gZGlzcGxheS52aWV3Lmxlbmd0aCAtIDEpIHtcclxuICAgICAgICB2YXIgdG9MaW5lID0gZGlzcGxheS52aWV3VG8gLSAxO1xyXG4gICAgICAgIHZhciB0b05vZGUgPSBkaXNwbGF5LnZpZXdbdG9JbmRleF0ubm9kZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgdG9MaW5lID0gbGluZU5vKGRpc3BsYXkudmlld1t0b0luZGV4ICsgMV0ubGluZSkgLSAxO1xyXG4gICAgICAgIHZhciB0b05vZGUgPSBkaXNwbGF5LnZpZXdbdG9JbmRleCArIDFdLm5vZGUucHJldmlvdXNTaWJsaW5nO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgbmV3VGV4dCA9IHNwbGl0TGluZXMoZG9tVGV4dEJldHdlZW4oY20sIGZyb21Ob2RlLCB0b05vZGUsIGZyb21MaW5lLCB0b0xpbmUpKTtcclxuICAgICAgdmFyIG9sZFRleHQgPSBnZXRCZXR3ZWVuKGNtLmRvYywgUG9zKGZyb21MaW5lLCAwKSwgUG9zKHRvTGluZSwgZ2V0TGluZShjbS5kb2MsIHRvTGluZSkudGV4dC5sZW5ndGgpKTtcclxuICAgICAgd2hpbGUgKG5ld1RleHQubGVuZ3RoID4gMSAmJiBvbGRUZXh0Lmxlbmd0aCA+IDEpIHtcclxuICAgICAgICBpZiAobHN0KG5ld1RleHQpID09IGxzdChvbGRUZXh0KSkgeyBuZXdUZXh0LnBvcCgpOyBvbGRUZXh0LnBvcCgpOyB0b0xpbmUtLTsgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5ld1RleHRbMF0gPT0gb2xkVGV4dFswXSkgeyBuZXdUZXh0LnNoaWZ0KCk7IG9sZFRleHQuc2hpZnQoKTsgZnJvbUxpbmUrKzsgfVxyXG4gICAgICAgIGVsc2UgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBjdXRGcm9udCA9IDAsIGN1dEVuZCA9IDA7XHJcbiAgICAgIHZhciBuZXdUb3AgPSBuZXdUZXh0WzBdLCBvbGRUb3AgPSBvbGRUZXh0WzBdLCBtYXhDdXRGcm9udCA9IE1hdGgubWluKG5ld1RvcC5sZW5ndGgsIG9sZFRvcC5sZW5ndGgpO1xyXG4gICAgICB3aGlsZSAoY3V0RnJvbnQgPCBtYXhDdXRGcm9udCAmJiBuZXdUb3AuY2hhckNvZGVBdChjdXRGcm9udCkgPT0gb2xkVG9wLmNoYXJDb2RlQXQoY3V0RnJvbnQpKVxyXG4gICAgICAgICsrY3V0RnJvbnQ7XHJcbiAgICAgIHZhciBuZXdCb3QgPSBsc3QobmV3VGV4dCksIG9sZEJvdCA9IGxzdChvbGRUZXh0KTtcclxuICAgICAgdmFyIG1heEN1dEVuZCA9IE1hdGgubWluKG5ld0JvdC5sZW5ndGggLSAobmV3VGV4dC5sZW5ndGggPT0gMSA/IGN1dEZyb250IDogMCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRCb3QubGVuZ3RoIC0gKG9sZFRleHQubGVuZ3RoID09IDEgPyBjdXRGcm9udCA6IDApKTtcclxuICAgICAgd2hpbGUgKGN1dEVuZCA8IG1heEN1dEVuZCAmJlxyXG4gICAgICAgICAgICAgbmV3Qm90LmNoYXJDb2RlQXQobmV3Qm90Lmxlbmd0aCAtIGN1dEVuZCAtIDEpID09IG9sZEJvdC5jaGFyQ29kZUF0KG9sZEJvdC5sZW5ndGggLSBjdXRFbmQgLSAxKSlcclxuICAgICAgICArK2N1dEVuZDtcclxuXHJcbiAgICAgIG5ld1RleHRbbmV3VGV4dC5sZW5ndGggLSAxXSA9IG5ld0JvdC5zbGljZSgwLCBuZXdCb3QubGVuZ3RoIC0gY3V0RW5kKTtcclxuICAgICAgbmV3VGV4dFswXSA9IG5ld1RleHRbMF0uc2xpY2UoY3V0RnJvbnQpO1xyXG5cclxuICAgICAgdmFyIGNoRnJvbSA9IFBvcyhmcm9tTGluZSwgY3V0RnJvbnQpO1xyXG4gICAgICB2YXIgY2hUbyA9IFBvcyh0b0xpbmUsIG9sZFRleHQubGVuZ3RoID8gbHN0KG9sZFRleHQpLmxlbmd0aCAtIGN1dEVuZCA6IDApO1xyXG4gICAgICBpZiAobmV3VGV4dC5sZW5ndGggPiAxIHx8IG5ld1RleHRbMF0gfHwgY21wKGNoRnJvbSwgY2hUbykpIHtcclxuICAgICAgICByZXBsYWNlUmFuZ2UoY20uZG9jLCBuZXdUZXh0LCBjaEZyb20sIGNoVG8sIFwiK2lucHV0XCIpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGVuc3VyZVBvbGxlZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMuZm9yY2VDb21wb3NpdGlvbkVuZCgpO1xyXG4gICAgfSxcclxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy5mb3JjZUNvbXBvc2l0aW9uRW5kKCk7XHJcbiAgICB9LFxyXG4gICAgZm9yY2VDb21wb3NpdGlvbkVuZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICghdGhpcy5jb21wb3NpbmcgfHwgdGhpcy5jb21wb3NpbmcuaGFuZGxlZCkgcmV0dXJuO1xyXG4gICAgICB0aGlzLmFwcGx5Q29tcG9zaXRpb24odGhpcy5jb21wb3NpbmcpO1xyXG4gICAgICB0aGlzLmNvbXBvc2luZy5oYW5kbGVkID0gdHJ1ZTtcclxuICAgICAgdGhpcy5kaXYuYmx1cigpO1xyXG4gICAgICB0aGlzLmRpdi5mb2N1cygpO1xyXG4gICAgfSxcclxuICAgIGFwcGx5Q29tcG9zaXRpb246IGZ1bmN0aW9uKGNvbXBvc2luZykge1xyXG4gICAgICBpZiAoY29tcG9zaW5nLmRhdGEgJiYgY29tcG9zaW5nLmRhdGEgIT0gY29tcG9zaW5nLnN0YXJ0RGF0YSlcclxuICAgICAgICBvcGVyYXRpb24odGhpcy5jbSwgYXBwbHlUZXh0SW5wdXQpKHRoaXMuY20sIGNvbXBvc2luZy5kYXRhLCAwLCBjb21wb3Npbmcuc2VsKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VW5lZGl0YWJsZTogZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiLCBcImZhbHNlXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBvbktleVByZXNzOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgb3BlcmF0aW9uKHRoaXMuY20sIGFwcGx5VGV4dElucHV0KSh0aGlzLmNtLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGUuY2hhckNvZGUgPT0gbnVsbCA/IGUua2V5Q29kZSA6IGUuY2hhckNvZGUpLCAwKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25Db250ZXh0TWVudTogbm90aGluZyxcclxuICAgIHJlc2V0UG9zaXRpb246IG5vdGhpbmcsXHJcblxyXG4gICAgbmVlZHNDb250ZW50QXR0cmlidXRlOiB0cnVlXHJcbiAgfSwgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlKTtcclxuXHJcbiAgZnVuY3Rpb24gcG9zVG9ET00oY20sIHBvcykge1xyXG4gICAgdmFyIHZpZXcgPSBmaW5kVmlld0ZvckxpbmUoY20sIHBvcy5saW5lKTtcclxuICAgIGlmICghdmlldyB8fCB2aWV3LmhpZGRlbikgcmV0dXJuIG51bGw7XHJcbiAgICB2YXIgbGluZSA9IGdldExpbmUoY20uZG9jLCBwb3MubGluZSk7XHJcbiAgICB2YXIgaW5mbyA9IG1hcEZyb21MaW5lVmlldyh2aWV3LCBsaW5lLCBwb3MubGluZSk7XHJcblxyXG4gICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZSksIHNpZGUgPSBcImxlZnRcIjtcclxuICAgIGlmIChvcmRlcikge1xyXG4gICAgICB2YXIgcGFydFBvcyA9IGdldEJpZGlQYXJ0QXQob3JkZXIsIHBvcy5jaCk7XHJcbiAgICAgIHNpZGUgPSBwYXJ0UG9zICUgMiA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xyXG4gICAgfVxyXG4gICAgdmFyIHJlc3VsdCA9IG5vZGVBbmRPZmZzZXRJbkxpbmVNYXAoaW5mby5tYXAsIHBvcy5jaCwgXCJsZWZ0XCIpO1xyXG4gICAgcmVzdWx0Lm9mZnNldCA9IHJlc3VsdC5jb2xsYXBzZSA9PSBcInJpZ2h0XCIgPyByZXN1bHQuZW5kIDogcmVzdWx0LnN0YXJ0O1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGJhZFBvcyhwb3MsIGJhZCkgeyBpZiAoYmFkKSBwb3MuYmFkID0gdHJ1ZTsgcmV0dXJuIHBvczsgfVxyXG5cclxuICBmdW5jdGlvbiBkb21Ub1BvcyhjbSwgbm9kZSwgb2Zmc2V0KSB7XHJcbiAgICB2YXIgbGluZU5vZGU7XHJcbiAgICBpZiAobm9kZSA9PSBjbS5kaXNwbGF5LmxpbmVEaXYpIHtcclxuICAgICAgbGluZU5vZGUgPSBjbS5kaXNwbGF5LmxpbmVEaXYuY2hpbGROb2Rlc1tvZmZzZXRdO1xyXG4gICAgICBpZiAoIWxpbmVOb2RlKSByZXR1cm4gYmFkUG9zKGNtLmNsaXBQb3MoUG9zKGNtLmRpc3BsYXkudmlld1RvIC0gMSkpLCB0cnVlKTtcclxuICAgICAgbm9kZSA9IG51bGw7IG9mZnNldCA9IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmb3IgKGxpbmVOb2RlID0gbm9kZTs7IGxpbmVOb2RlID0gbGluZU5vZGUucGFyZW50Tm9kZSkge1xyXG4gICAgICAgIGlmICghbGluZU5vZGUgfHwgbGluZU5vZGUgPT0gY20uZGlzcGxheS5saW5lRGl2KSByZXR1cm4gbnVsbDtcclxuICAgICAgICBpZiAobGluZU5vZGUucGFyZW50Tm9kZSAmJiBsaW5lTm9kZS5wYXJlbnROb2RlID09IGNtLmRpc3BsYXkubGluZURpdikgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY20uZGlzcGxheS52aWV3Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBsaW5lVmlldyA9IGNtLmRpc3BsYXkudmlld1tpXTtcclxuICAgICAgaWYgKGxpbmVWaWV3Lm5vZGUgPT0gbGluZU5vZGUpXHJcbiAgICAgICAgcmV0dXJuIGxvY2F0ZU5vZGVJbkxpbmVWaWV3KGxpbmVWaWV3LCBub2RlLCBvZmZzZXQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbG9jYXRlTm9kZUluTGluZVZpZXcobGluZVZpZXcsIG5vZGUsIG9mZnNldCkge1xyXG4gICAgdmFyIHdyYXBwZXIgPSBsaW5lVmlldy50ZXh0LmZpcnN0Q2hpbGQsIGJhZCA9IGZhbHNlO1xyXG4gICAgaWYgKCFub2RlIHx8ICFjb250YWlucyh3cmFwcGVyLCBub2RlKSkgcmV0dXJuIGJhZFBvcyhQb3MobGluZU5vKGxpbmVWaWV3LmxpbmUpLCAwKSwgdHJ1ZSk7XHJcbiAgICBpZiAobm9kZSA9PSB3cmFwcGVyKSB7XHJcbiAgICAgIGJhZCA9IHRydWU7XHJcbiAgICAgIG5vZGUgPSB3cmFwcGVyLmNoaWxkTm9kZXNbb2Zmc2V0XTtcclxuICAgICAgb2Zmc2V0ID0gMDtcclxuICAgICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lVmlldy5yZXN0ID8gbHN0KGxpbmVWaWV3LnJlc3QpIDogbGluZVZpZXcubGluZTtcclxuICAgICAgICByZXR1cm4gYmFkUG9zKFBvcyhsaW5lTm8obGluZSksIGxpbmUudGV4dC5sZW5ndGgpLCBiYWQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRleHROb2RlID0gbm9kZS5ub2RlVHlwZSA9PSAzID8gbm9kZSA6IG51bGwsIHRvcE5vZGUgPSBub2RlO1xyXG4gICAgaWYgKCF0ZXh0Tm9kZSAmJiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoID09IDEgJiYgbm9kZS5maXJzdENoaWxkLm5vZGVUeXBlID09IDMpIHtcclxuICAgICAgdGV4dE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XHJcbiAgICAgIGlmIChvZmZzZXQpIG9mZnNldCA9IHRleHROb2RlLm5vZGVWYWx1ZS5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICB3aGlsZSAodG9wTm9kZS5wYXJlbnROb2RlICE9IHdyYXBwZXIpIHRvcE5vZGUgPSB0b3BOb2RlLnBhcmVudE5vZGU7XHJcbiAgICB2YXIgbWVhc3VyZSA9IGxpbmVWaWV3Lm1lYXN1cmUsIG1hcHMgPSBtZWFzdXJlLm1hcHM7XHJcblxyXG4gICAgZnVuY3Rpb24gZmluZCh0ZXh0Tm9kZSwgdG9wTm9kZSwgb2Zmc2V0KSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAtMTsgaSA8IChtYXBzID8gbWFwcy5sZW5ndGggOiAwKTsgaSsrKSB7XHJcbiAgICAgICAgdmFyIG1hcCA9IGkgPCAwID8gbWVhc3VyZS5tYXAgOiBtYXBzW2ldO1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWFwLmxlbmd0aDsgaiArPSAzKSB7XHJcbiAgICAgICAgICB2YXIgY3VyTm9kZSA9IG1hcFtqICsgMl07XHJcbiAgICAgICAgICBpZiAoY3VyTm9kZSA9PSB0ZXh0Tm9kZSB8fCBjdXJOb2RlID09IHRvcE5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIGxpbmUgPSBsaW5lTm8oaSA8IDAgPyBsaW5lVmlldy5saW5lIDogbGluZVZpZXcucmVzdFtpXSk7XHJcbiAgICAgICAgICAgIHZhciBjaCA9IG1hcFtqXSArIG9mZnNldDtcclxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgY3VyTm9kZSAhPSB0ZXh0Tm9kZSkgY2ggPSBtYXBbaiArIChvZmZzZXQgPyAxIDogMCldO1xyXG4gICAgICAgICAgICByZXR1cm4gUG9zKGxpbmUsIGNoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBmb3VuZCA9IGZpbmQodGV4dE5vZGUsIHRvcE5vZGUsIG9mZnNldCk7XHJcbiAgICBpZiAoZm91bmQpIHJldHVybiBiYWRQb3MoZm91bmQsIGJhZCk7XHJcblxyXG4gICAgLy8gRklYTUUgdGhpcyBpcyBhbGwgcmVhbGx5IHNoYWt5LiBtaWdodCBoYW5kbGUgdGhlIGZldyBjYXNlcyBpdCBuZWVkcyB0byBoYW5kbGUsIGJ1dCBsaWtlbHkgdG8gY2F1c2UgcHJvYmxlbXNcclxuICAgIGZvciAodmFyIGFmdGVyID0gdG9wTm9kZS5uZXh0U2libGluZywgZGlzdCA9IHRleHROb2RlID8gdGV4dE5vZGUubm9kZVZhbHVlLmxlbmd0aCAtIG9mZnNldCA6IDA7IGFmdGVyOyBhZnRlciA9IGFmdGVyLm5leHRTaWJsaW5nKSB7XHJcbiAgICAgIGZvdW5kID0gZmluZChhZnRlciwgYWZ0ZXIuZmlyc3RDaGlsZCwgMCk7XHJcbiAgICAgIGlmIChmb3VuZClcclxuICAgICAgICByZXR1cm4gYmFkUG9zKFBvcyhmb3VuZC5saW5lLCBmb3VuZC5jaCAtIGRpc3QpLCBiYWQpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgZGlzdCArPSBhZnRlci50ZXh0Q29udGVudC5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBiZWZvcmUgPSB0b3BOb2RlLnByZXZpb3VzU2libGluZywgZGlzdCA9IG9mZnNldDsgYmVmb3JlOyBiZWZvcmUgPSBiZWZvcmUucHJldmlvdXNTaWJsaW5nKSB7XHJcbiAgICAgIGZvdW5kID0gZmluZChiZWZvcmUsIGJlZm9yZS5maXJzdENoaWxkLCAtMSk7XHJcbiAgICAgIGlmIChmb3VuZClcclxuICAgICAgICByZXR1cm4gYmFkUG9zKFBvcyhmb3VuZC5saW5lLCBmb3VuZC5jaCArIGRpc3QpLCBiYWQpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgZGlzdCArPSBhZnRlci50ZXh0Q29udGVudC5sZW5ndGg7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBkb21UZXh0QmV0d2VlbihjbSwgZnJvbSwgdG8sIGZyb21MaW5lLCB0b0xpbmUpIHtcclxuICAgIHZhciB0ZXh0ID0gXCJcIiwgY2xvc2luZyA9IGZhbHNlO1xyXG4gICAgZnVuY3Rpb24gcmVjb2duaXplTWFya2VyKGlkKSB7IHJldHVybiBmdW5jdGlvbihtYXJrZXIpIHsgcmV0dXJuIG1hcmtlci5pZCA9PSBpZDsgfTsgfVxyXG4gICAgZnVuY3Rpb24gd2Fsayhub2RlKSB7XHJcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcclxuICAgICAgICB2YXIgY21UZXh0ID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIpO1xyXG4gICAgICAgIGlmIChjbVRleHQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgaWYgKGNtVGV4dCA9PSBcIlwiKSBjbVRleHQgPSBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoL1xcdTIwMGIvZywgXCJcIik7XHJcbiAgICAgICAgICB0ZXh0ICs9IGNtVGV4dDtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1hcmtlcklEID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJjbS1tYXJrZXJcIiksIHJhbmdlO1xyXG4gICAgICAgIGlmIChtYXJrZXJJRCkge1xyXG4gICAgICAgICAgdmFyIGZvdW5kID0gY20uZmluZE1hcmtzKFBvcyhmcm9tTGluZSwgMCksIFBvcyh0b0xpbmUgKyAxLCAwKSwgcmVjb2duaXplTWFya2VyKCttYXJrZXJJRCkpO1xyXG4gICAgICAgICAgaWYgKGZvdW5kLmxlbmd0aCAmJiAocmFuZ2UgPSBmb3VuZFswXS5maW5kKCkpKVxyXG4gICAgICAgICAgICB0ZXh0ICs9IGdldEJldHdlZW4oY20uZG9jLCByYW5nZS5mcm9tLCByYW5nZS50bykuam9pbihcIlxcblwiKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpID09IFwiZmFsc2VcIikgcmV0dXJuO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgd2Fsayhub2RlLmNoaWxkTm9kZXNbaV0pO1xyXG4gICAgICAgIGlmICgvXihwcmV8ZGl2fHApJC9pLnRlc3Qobm9kZS5ub2RlTmFtZSkpXHJcbiAgICAgICAgICBjbG9zaW5nID0gdHJ1ZTtcclxuICAgICAgfSBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcclxuICAgICAgICB2YXIgdmFsID0gbm9kZS5ub2RlVmFsdWU7XHJcbiAgICAgICAgaWYgKCF2YWwpIHJldHVybjtcclxuICAgICAgICBpZiAoY2xvc2luZykge1xyXG4gICAgICAgICAgdGV4dCArPSBcIlxcblwiO1xyXG4gICAgICAgICAgY2xvc2luZyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0ZXh0ICs9IHZhbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yICg7Oykge1xyXG4gICAgICB3YWxrKGZyb20pO1xyXG4gICAgICBpZiAoZnJvbSA9PSB0bykgYnJlYWs7XHJcbiAgICAgIGZyb20gPSBmcm9tLm5leHRTaWJsaW5nO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRleHQ7XHJcbiAgfVxyXG5cclxuICBDb2RlTWlycm9yLmlucHV0U3R5bGVzID0ge1widGV4dGFyZWFcIjogVGV4dGFyZWFJbnB1dCwgXCJjb250ZW50ZWRpdGFibGVcIjogQ29udGVudEVkaXRhYmxlSW5wdXR9O1xyXG5cclxuICAvLyBTRUxFQ1RJT04gLyBDVVJTT1JcclxuXHJcbiAgLy8gU2VsZWN0aW9uIG9iamVjdHMgYXJlIGltbXV0YWJsZS4gQSBuZXcgb25lIGlzIGNyZWF0ZWQgZXZlcnkgdGltZVxyXG4gIC8vIHRoZSBzZWxlY3Rpb24gY2hhbmdlcy4gQSBzZWxlY3Rpb24gaXMgb25lIG9yIG1vcmUgbm9uLW92ZXJsYXBwaW5nXHJcbiAgLy8gKGFuZCBub24tdG91Y2hpbmcpIHJhbmdlcywgc29ydGVkLCBhbmQgYW4gaW50ZWdlciB0aGF0IGluZGljYXRlc1xyXG4gIC8vIHdoaWNoIG9uZSBpcyB0aGUgcHJpbWFyeSBzZWxlY3Rpb24gKHRoZSBvbmUgdGhhdCdzIHNjcm9sbGVkIGludG9cclxuICAvLyB2aWV3LCB0aGF0IGdldEN1cnNvciByZXR1cm5zLCBldGMpLlxyXG4gIGZ1bmN0aW9uIFNlbGVjdGlvbihyYW5nZXMsIHByaW1JbmRleCkge1xyXG4gICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XHJcbiAgICB0aGlzLnByaW1JbmRleCA9IHByaW1JbmRleDtcclxuICB9XHJcblxyXG4gIFNlbGVjdGlvbi5wcm90b3R5cGUgPSB7XHJcbiAgICBwcmltYXJ5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMucmFuZ2VzW3RoaXMucHJpbUluZGV4XTsgfSxcclxuICAgIGVxdWFsczogZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgICAgaWYgKG90aGVyID09IHRoaXMpIHJldHVybiB0cnVlO1xyXG4gICAgICBpZiAob3RoZXIucHJpbUluZGV4ICE9IHRoaXMucHJpbUluZGV4IHx8IG90aGVyLnJhbmdlcy5sZW5ndGggIT0gdGhpcy5yYW5nZXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgaGVyZSA9IHRoaXMucmFuZ2VzW2ldLCB0aGVyZSA9IG90aGVyLnJhbmdlc1tpXTtcclxuICAgICAgICBpZiAoY21wKGhlcmUuYW5jaG9yLCB0aGVyZS5hbmNob3IpICE9IDAgfHwgY21wKGhlcmUuaGVhZCwgdGhlcmUuaGVhZCkgIT0gMCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuICAgIGRlZXBDb3B5OiBmdW5jdGlvbigpIHtcclxuICAgICAgZm9yICh2YXIgb3V0ID0gW10sIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgb3V0W2ldID0gbmV3IFJhbmdlKGNvcHlQb3ModGhpcy5yYW5nZXNbaV0uYW5jaG9yKSwgY29weVBvcyh0aGlzLnJhbmdlc1tpXS5oZWFkKSk7XHJcbiAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKG91dCwgdGhpcy5wcmltSW5kZXgpO1xyXG4gICAgfSxcclxuICAgIHNvbWV0aGluZ1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKylcclxuICAgICAgICBpZiAoIXRoaXMucmFuZ2VzW2ldLmVtcHR5KCkpIHJldHVybiB0cnVlO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgY29udGFpbnM6IGZ1bmN0aW9uKHBvcywgZW5kKSB7XHJcbiAgICAgIGlmICghZW5kKSBlbmQgPSBwb3M7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnJhbmdlc1tpXTtcclxuICAgICAgICBpZiAoY21wKGVuZCwgcmFuZ2UuZnJvbSgpKSA+PSAwICYmIGNtcChwb3MsIHJhbmdlLnRvKCkpIDw9IDApXHJcbiAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gUmFuZ2UoYW5jaG9yLCBoZWFkKSB7XHJcbiAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjsgdGhpcy5oZWFkID0gaGVhZDtcclxuICB9XHJcblxyXG4gIFJhbmdlLnByb3RvdHlwZSA9IHtcclxuICAgIGZyb206IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWluUG9zKHRoaXMuYW5jaG9yLCB0aGlzLmhlYWQpOyB9LFxyXG4gICAgdG86IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWF4UG9zKHRoaXMuYW5jaG9yLCB0aGlzLmhlYWQpOyB9LFxyXG4gICAgZW1wdHk6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5oZWFkLmxpbmUgPT0gdGhpcy5hbmNob3IubGluZSAmJiB0aGlzLmhlYWQuY2ggPT0gdGhpcy5hbmNob3IuY2g7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gVGFrZSBhbiB1bnNvcnRlZCwgcG90ZW50aWFsbHkgb3ZlcmxhcHBpbmcgc2V0IG9mIHJhbmdlcywgYW5kXHJcbiAgLy8gYnVpbGQgYSBzZWxlY3Rpb24gb3V0IG9mIGl0LiAnQ29uc3VtZXMnIHJhbmdlcyBhcnJheSAobW9kaWZ5aW5nXHJcbiAgLy8gaXQpLlxyXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMsIHByaW1JbmRleCkge1xyXG4gICAgdmFyIHByaW0gPSByYW5nZXNbcHJpbUluZGV4XTtcclxuICAgIHJhbmdlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGNtcChhLmZyb20oKSwgYi5mcm9tKCkpOyB9KTtcclxuICAgIHByaW1JbmRleCA9IGluZGV4T2YocmFuZ2VzLCBwcmltKTtcclxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBjdXIgPSByYW5nZXNbaV0sIHByZXYgPSByYW5nZXNbaSAtIDFdO1xyXG4gICAgICBpZiAoY21wKHByZXYudG8oKSwgY3VyLmZyb20oKSkgPj0gMCkge1xyXG4gICAgICAgIHZhciBmcm9tID0gbWluUG9zKHByZXYuZnJvbSgpLCBjdXIuZnJvbSgpKSwgdG8gPSBtYXhQb3MocHJldi50bygpLCBjdXIudG8oKSk7XHJcbiAgICAgICAgdmFyIGludiA9IHByZXYuZW1wdHkoKSA/IGN1ci5mcm9tKCkgPT0gY3VyLmhlYWQgOiBwcmV2LmZyb20oKSA9PSBwcmV2LmhlYWQ7XHJcbiAgICAgICAgaWYgKGkgPD0gcHJpbUluZGV4KSAtLXByaW1JbmRleDtcclxuICAgICAgICByYW5nZXMuc3BsaWNlKC0taSwgMiwgbmV3IFJhbmdlKGludiA/IHRvIDogZnJvbSwgaW52ID8gZnJvbSA6IHRvKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHJhbmdlcywgcHJpbUluZGV4KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNpbXBsZVNlbGVjdGlvbihhbmNob3IsIGhlYWQpIHtcclxuICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKFtuZXcgUmFuZ2UoYW5jaG9yLCBoZWFkIHx8IGFuY2hvcildLCAwKTtcclxuICB9XHJcblxyXG4gIC8vIE1vc3Qgb2YgdGhlIGV4dGVybmFsIEFQSSBjbGlwcyBnaXZlbiBwb3NpdGlvbnMgdG8gbWFrZSBzdXJlIHRoZXlcclxuICAvLyBhY3R1YWxseSBleGlzdCB3aXRoaW4gdGhlIGRvY3VtZW50LlxyXG4gIGZ1bmN0aW9uIGNsaXBMaW5lKGRvYywgbikge3JldHVybiBNYXRoLm1heChkb2MuZmlyc3QsIE1hdGgubWluKG4sIGRvYy5maXJzdCArIGRvYy5zaXplIC0gMSkpO31cclxuICBmdW5jdGlvbiBjbGlwUG9zKGRvYywgcG9zKSB7XHJcbiAgICBpZiAocG9zLmxpbmUgPCBkb2MuZmlyc3QpIHJldHVybiBQb3MoZG9jLmZpcnN0LCAwKTtcclxuICAgIHZhciBsYXN0ID0gZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxO1xyXG4gICAgaWYgKHBvcy5saW5lID4gbGFzdCkgcmV0dXJuIFBvcyhsYXN0LCBnZXRMaW5lKGRvYywgbGFzdCkudGV4dC5sZW5ndGgpO1xyXG4gICAgcmV0dXJuIGNsaXBUb0xlbihwb3MsIGdldExpbmUoZG9jLCBwb3MubGluZSkudGV4dC5sZW5ndGgpO1xyXG4gIH1cclxuICBmdW5jdGlvbiBjbGlwVG9MZW4ocG9zLCBsaW5lbGVuKSB7XHJcbiAgICB2YXIgY2ggPSBwb3MuY2g7XHJcbiAgICBpZiAoY2ggPT0gbnVsbCB8fCBjaCA+IGxpbmVsZW4pIHJldHVybiBQb3MocG9zLmxpbmUsIGxpbmVsZW4pO1xyXG4gICAgZWxzZSBpZiAoY2ggPCAwKSByZXR1cm4gUG9zKHBvcy5saW5lLCAwKTtcclxuICAgIGVsc2UgcmV0dXJuIHBvcztcclxuICB9XHJcbiAgZnVuY3Rpb24gaXNMaW5lKGRvYywgbCkge3JldHVybiBsID49IGRvYy5maXJzdCAmJiBsIDwgZG9jLmZpcnN0ICsgZG9jLnNpemU7fVxyXG4gIGZ1bmN0aW9uIGNsaXBQb3NBcnJheShkb2MsIGFycmF5KSB7XHJcbiAgICBmb3IgKHZhciBvdXQgPSBbXSwgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykgb3V0W2ldID0gY2xpcFBvcyhkb2MsIGFycmF5W2ldKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbiAgfVxyXG5cclxuICAvLyBTRUxFQ1RJT04gVVBEQVRFU1xyXG5cclxuICAvLyBUaGUgJ3Njcm9sbCcgcGFyYW1ldGVyIGdpdmVuIHRvIG1hbnkgb2YgdGhlc2UgaW5kaWNhdGVkIHdoZXRoZXJcclxuICAvLyB0aGUgbmV3IGN1cnNvciBwb3NpdGlvbiBzaG91bGQgYmUgc2Nyb2xsZWQgaW50byB2aWV3IGFmdGVyXHJcbiAgLy8gbW9kaWZ5aW5nIHRoZSBzZWxlY3Rpb24uXHJcblxyXG4gIC8vIElmIHNoaWZ0IGlzIGhlbGQgb3IgdGhlIGV4dGVuZCBmbGFnIGlzIHNldCwgZXh0ZW5kcyBhIHJhbmdlIHRvXHJcbiAgLy8gaW5jbHVkZSBhIGdpdmVuIHBvc2l0aW9uIChhbmQgb3B0aW9uYWxseSBhIHNlY29uZCBwb3NpdGlvbikuXHJcbiAgLy8gT3RoZXJ3aXNlLCBzaW1wbHkgcmV0dXJucyB0aGUgcmFuZ2UgYmV0d2VlbiB0aGUgZ2l2ZW4gcG9zaXRpb25zLlxyXG4gIC8vIFVzZWQgZm9yIGN1cnNvciBtb3Rpb24gYW5kIHN1Y2guXHJcbiAgZnVuY3Rpb24gZXh0ZW5kUmFuZ2UoZG9jLCByYW5nZSwgaGVhZCwgb3RoZXIpIHtcclxuICAgIGlmIChkb2MuY20gJiYgZG9jLmNtLmRpc3BsYXkuc2hpZnQgfHwgZG9jLmV4dGVuZCkge1xyXG4gICAgICB2YXIgYW5jaG9yID0gcmFuZ2UuYW5jaG9yO1xyXG4gICAgICBpZiAob3RoZXIpIHtcclxuICAgICAgICB2YXIgcG9zQmVmb3JlID0gY21wKGhlYWQsIGFuY2hvcikgPCAwO1xyXG4gICAgICAgIGlmIChwb3NCZWZvcmUgIT0gKGNtcChvdGhlciwgYW5jaG9yKSA8IDApKSB7XHJcbiAgICAgICAgICBhbmNob3IgPSBoZWFkO1xyXG4gICAgICAgICAgaGVhZCA9IG90aGVyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocG9zQmVmb3JlICE9IChjbXAoaGVhZCwgb3RoZXIpIDwgMCkpIHtcclxuICAgICAgICAgIGhlYWQgPSBvdGhlcjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5ldyBSYW5nZShhbmNob3IsIGhlYWQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIG5ldyBSYW5nZShvdGhlciB8fCBoZWFkLCBoZWFkKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEV4dGVuZCB0aGUgcHJpbWFyeSBzZWxlY3Rpb24gcmFuZ2UsIGRpc2NhcmQgdGhlIHJlc3QuXHJcbiAgZnVuY3Rpb24gZXh0ZW5kU2VsZWN0aW9uKGRvYywgaGVhZCwgb3RoZXIsIG9wdGlvbnMpIHtcclxuICAgIHNldFNlbGVjdGlvbihkb2MsIG5ldyBTZWxlY3Rpb24oW2V4dGVuZFJhbmdlKGRvYywgZG9jLnNlbC5wcmltYXJ5KCksIGhlYWQsIG90aGVyKV0sIDApLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8vIEV4dGVuZCBhbGwgc2VsZWN0aW9ucyAocG9zIGlzIGFuIGFycmF5IG9mIHNlbGVjdGlvbnMgd2l0aCBsZW5ndGhcclxuICAvLyBlcXVhbCB0aGUgbnVtYmVyIG9mIHNlbGVjdGlvbnMpXHJcbiAgZnVuY3Rpb24gZXh0ZW5kU2VsZWN0aW9ucyhkb2MsIGhlYWRzLCBvcHRpb25zKSB7XHJcbiAgICBmb3IgKHZhciBvdXQgPSBbXSwgaSA9IDA7IGkgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKylcclxuICAgICAgb3V0W2ldID0gZXh0ZW5kUmFuZ2UoZG9jLCBkb2Muc2VsLnJhbmdlc1tpXSwgaGVhZHNbaV0sIG51bGwpO1xyXG4gICAgdmFyIG5ld1NlbCA9IG5vcm1hbGl6ZVNlbGVjdGlvbihvdXQsIGRvYy5zZWwucHJpbUluZGV4KTtcclxuICAgIHNldFNlbGVjdGlvbihkb2MsIG5ld1NlbCwgb3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvLyBVcGRhdGVzIGEgc2luZ2xlIHJhbmdlIGluIHRoZSBzZWxlY3Rpb24uXHJcbiAgZnVuY3Rpb24gcmVwbGFjZU9uZVNlbGVjdGlvbihkb2MsIGksIHJhbmdlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgcmFuZ2VzID0gZG9jLnNlbC5yYW5nZXMuc2xpY2UoMCk7XHJcbiAgICByYW5nZXNbaV0gPSByYW5nZTtcclxuICAgIHNldFNlbGVjdGlvbihkb2MsIG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMsIGRvYy5zZWwucHJpbUluZGV4KSwgb3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvLyBSZXNldCB0aGUgc2VsZWN0aW9uIHRvIGEgc2luZ2xlIHJhbmdlLlxyXG4gIGZ1bmN0aW9uIHNldFNpbXBsZVNlbGVjdGlvbihkb2MsIGFuY2hvciwgaGVhZCwgb3B0aW9ucykge1xyXG4gICAgc2V0U2VsZWN0aW9uKGRvYywgc2ltcGxlU2VsZWN0aW9uKGFuY2hvciwgaGVhZCksIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLy8gR2l2ZSBiZWZvcmVTZWxlY3Rpb25DaGFuZ2UgaGFuZGxlcnMgYSBjaGFuZ2UgdG8gaW5mbHVlbmNlIGFcclxuICAvLyBzZWxlY3Rpb24gdXBkYXRlLlxyXG4gIGZ1bmN0aW9uIGZpbHRlclNlbGVjdGlvbkNoYW5nZShkb2MsIHNlbCkge1xyXG4gICAgdmFyIG9iaiA9IHtcclxuICAgICAgcmFuZ2VzOiBzZWwucmFuZ2VzLFxyXG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uKHJhbmdlcykge1xyXG4gICAgICAgIHRoaXMucmFuZ2VzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICB0aGlzLnJhbmdlc1tpXSA9IG5ldyBSYW5nZShjbGlwUG9zKGRvYywgcmFuZ2VzW2ldLmFuY2hvciksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwUG9zKGRvYywgcmFuZ2VzW2ldLmhlYWQpKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHNpZ25hbChkb2MsIFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIsIGRvYywgb2JqKTtcclxuICAgIGlmIChkb2MuY20pIHNpZ25hbChkb2MuY20sIFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIsIGRvYy5jbSwgb2JqKTtcclxuICAgIGlmIChvYmoucmFuZ2VzICE9IHNlbC5yYW5nZXMpIHJldHVybiBub3JtYWxpemVTZWxlY3Rpb24ob2JqLnJhbmdlcywgb2JqLnJhbmdlcy5sZW5ndGggLSAxKTtcclxuICAgIGVsc2UgcmV0dXJuIHNlbDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5KGRvYywgc2VsLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgZG9uZSA9IGRvYy5oaXN0b3J5LmRvbmUsIGxhc3QgPSBsc3QoZG9uZSk7XHJcbiAgICBpZiAobGFzdCAmJiBsYXN0LnJhbmdlcykge1xyXG4gICAgICBkb25lW2RvbmUubGVuZ3RoIC0gMV0gPSBzZWw7XHJcbiAgICAgIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbCwgb3B0aW9ucyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzZXRTZWxlY3Rpb24oZG9jLCBzZWwsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gU2V0IGEgbmV3IHNlbGVjdGlvbi5cclxuICBmdW5jdGlvbiBzZXRTZWxlY3Rpb24oZG9jLCBzZWwsIG9wdGlvbnMpIHtcclxuICAgIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbCwgb3B0aW9ucyk7XHJcbiAgICBhZGRTZWxlY3Rpb25Ub0hpc3RvcnkoZG9jLCBkb2Muc2VsLCBkb2MuY20gPyBkb2MuY20uY3VyT3AuaWQgOiBOYU4sIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2V0U2VsZWN0aW9uTm9VbmRvKGRvYywgc2VsLCBvcHRpb25zKSB7XHJcbiAgICBpZiAoaGFzSGFuZGxlcihkb2MsIFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIpIHx8IGRvYy5jbSAmJiBoYXNIYW5kbGVyKGRvYy5jbSwgXCJiZWZvcmVTZWxlY3Rpb25DaGFuZ2VcIikpXHJcbiAgICAgIHNlbCA9IGZpbHRlclNlbGVjdGlvbkNoYW5nZShkb2MsIHNlbCk7XHJcblxyXG4gICAgdmFyIGJpYXMgPSBvcHRpb25zICYmIG9wdGlvbnMuYmlhcyB8fFxyXG4gICAgICAoY21wKHNlbC5wcmltYXJ5KCkuaGVhZCwgZG9jLnNlbC5wcmltYXJ5KCkuaGVhZCkgPCAwID8gLTEgOiAxKTtcclxuICAgIHNldFNlbGVjdGlvbklubmVyKGRvYywgc2tpcEF0b21pY0luU2VsZWN0aW9uKGRvYywgc2VsLCBiaWFzLCB0cnVlKSk7XHJcblxyXG4gICAgaWYgKCEob3B0aW9ucyAmJiBvcHRpb25zLnNjcm9sbCA9PT0gZmFsc2UpICYmIGRvYy5jbSlcclxuICAgICAgZW5zdXJlQ3Vyc29yVmlzaWJsZShkb2MuY20pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2V0U2VsZWN0aW9uSW5uZXIoZG9jLCBzZWwpIHtcclxuICAgIGlmIChzZWwuZXF1YWxzKGRvYy5zZWwpKSByZXR1cm47XHJcblxyXG4gICAgZG9jLnNlbCA9IHNlbDtcclxuXHJcbiAgICBpZiAoZG9jLmNtKSB7XHJcbiAgICAgIGRvYy5jbS5jdXJPcC51cGRhdGVJbnB1dCA9IGRvYy5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgc2lnbmFsQ3Vyc29yQWN0aXZpdHkoZG9jLmNtKTtcclxuICAgIH1cclxuICAgIHNpZ25hbExhdGVyKGRvYywgXCJjdXJzb3JBY3Rpdml0eVwiLCBkb2MpO1xyXG4gIH1cclxuXHJcbiAgLy8gVmVyaWZ5IHRoYXQgdGhlIHNlbGVjdGlvbiBkb2VzIG5vdCBwYXJ0aWFsbHkgc2VsZWN0IGFueSBhdG9taWNcclxuICAvLyBtYXJrZWQgcmFuZ2VzLlxyXG4gIGZ1bmN0aW9uIHJlQ2hlY2tTZWxlY3Rpb24oZG9jKSB7XHJcbiAgICBzZXRTZWxlY3Rpb25Jbm5lcihkb2MsIHNraXBBdG9taWNJblNlbGVjdGlvbihkb2MsIGRvYy5zZWwsIG51bGwsIGZhbHNlKSwgc2VsX2RvbnRTY3JvbGwpO1xyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJuIGEgc2VsZWN0aW9uIHRoYXQgZG9lcyBub3QgcGFydGlhbGx5IHNlbGVjdCBhbnkgYXRvbWljXHJcbiAgLy8gcmFuZ2VzLlxyXG4gIGZ1bmN0aW9uIHNraXBBdG9taWNJblNlbGVjdGlvbihkb2MsIHNlbCwgYmlhcywgbWF5Q2xlYXIpIHtcclxuICAgIHZhciBvdXQ7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHJhbmdlID0gc2VsLnJhbmdlc1tpXTtcclxuICAgICAgdmFyIG5ld0FuY2hvciA9IHNraXBBdG9taWMoZG9jLCByYW5nZS5hbmNob3IsIGJpYXMsIG1heUNsZWFyKTtcclxuICAgICAgdmFyIG5ld0hlYWQgPSBza2lwQXRvbWljKGRvYywgcmFuZ2UuaGVhZCwgYmlhcywgbWF5Q2xlYXIpO1xyXG4gICAgICBpZiAob3V0IHx8IG5ld0FuY2hvciAhPSByYW5nZS5hbmNob3IgfHwgbmV3SGVhZCAhPSByYW5nZS5oZWFkKSB7XHJcbiAgICAgICAgaWYgKCFvdXQpIG91dCA9IHNlbC5yYW5nZXMuc2xpY2UoMCwgaSk7XHJcbiAgICAgICAgb3V0W2ldID0gbmV3IFJhbmdlKG5ld0FuY2hvciwgbmV3SGVhZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvdXQgPyBub3JtYWxpemVTZWxlY3Rpb24ob3V0LCBzZWwucHJpbUluZGV4KSA6IHNlbDtcclxuICB9XHJcblxyXG4gIC8vIEVuc3VyZSBhIGdpdmVuIHBvc2l0aW9uIGlzIG5vdCBpbnNpZGUgYW4gYXRvbWljIHJhbmdlLlxyXG4gIGZ1bmN0aW9uIHNraXBBdG9taWMoZG9jLCBwb3MsIGJpYXMsIG1heUNsZWFyKSB7XHJcbiAgICB2YXIgZmxpcHBlZCA9IGZhbHNlLCBjdXJQb3MgPSBwb3M7XHJcbiAgICB2YXIgZGlyID0gYmlhcyB8fCAxO1xyXG4gICAgZG9jLmNhbnRFZGl0ID0gZmFsc2U7XHJcbiAgICBzZWFyY2g6IGZvciAoOzspIHtcclxuICAgICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgY3VyUG9zLmxpbmUpO1xyXG4gICAgICBpZiAobGluZS5tYXJrZWRTcGFucykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5tYXJrZWRTcGFucy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgdmFyIHNwID0gbGluZS5tYXJrZWRTcGFuc1tpXSwgbSA9IHNwLm1hcmtlcjtcclxuICAgICAgICAgIGlmICgoc3AuZnJvbSA9PSBudWxsIHx8IChtLmluY2x1c2l2ZUxlZnQgPyBzcC5mcm9tIDw9IGN1clBvcy5jaCA6IHNwLmZyb20gPCBjdXJQb3MuY2gpKSAmJlxyXG4gICAgICAgICAgICAgIChzcC50byA9PSBudWxsIHx8IChtLmluY2x1c2l2ZVJpZ2h0ID8gc3AudG8gPj0gY3VyUG9zLmNoIDogc3AudG8gPiBjdXJQb3MuY2gpKSkge1xyXG4gICAgICAgICAgICBpZiAobWF5Q2xlYXIpIHtcclxuICAgICAgICAgICAgICBzaWduYWwobSwgXCJiZWZvcmVDdXJzb3JFbnRlclwiKTtcclxuICAgICAgICAgICAgICBpZiAobS5leHBsaWNpdGx5Q2xlYXJlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFsaW5lLm1hcmtlZFNwYW5zKSBicmVhaztcclxuICAgICAgICAgICAgICAgIGVsc2Ugey0taTsgY29udGludWU7fVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW0uYXRvbWljKSBjb250aW51ZTtcclxuICAgICAgICAgICAgdmFyIG5ld1BvcyA9IG0uZmluZChkaXIgPCAwID8gLTEgOiAxKTtcclxuICAgICAgICAgICAgaWYgKGNtcChuZXdQb3MsIGN1clBvcykgPT0gMCkge1xyXG4gICAgICAgICAgICAgIG5ld1Bvcy5jaCArPSBkaXI7XHJcbiAgICAgICAgICAgICAgaWYgKG5ld1Bvcy5jaCA8IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdQb3MubGluZSA+IGRvYy5maXJzdCkgbmV3UG9zID0gY2xpcFBvcyhkb2MsIFBvcyhuZXdQb3MubGluZSAtIDEpKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgbmV3UG9zID0gbnVsbDtcclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5ld1Bvcy5jaCA+IGxpbmUudGV4dC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdQb3MubGluZSA8IGRvYy5maXJzdCArIGRvYy5zaXplIC0gMSkgbmV3UG9zID0gUG9zKG5ld1Bvcy5saW5lICsgMSwgMCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIG5ld1BvcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmICghbmV3UG9zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmxpcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgICAvLyBEcml2ZW4gaW4gYSBjb3JuZXIgLS0gbm8gdmFsaWQgY3Vyc29yIHBvc2l0aW9uIGZvdW5kIGF0IGFsbFxyXG4gICAgICAgICAgICAgICAgICAvLyAtLSB0cnkgYWdhaW4gKndpdGgqIGNsZWFyaW5nLCBpZiB3ZSBkaWRuJ3QgYWxyZWFkeVxyXG4gICAgICAgICAgICAgICAgICBpZiAoIW1heUNsZWFyKSByZXR1cm4gc2tpcEF0b21pYyhkb2MsIHBvcywgYmlhcywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdHVybiBvZmYgZWRpdGluZyB1bnRpbCBmdXJ0aGVyIG5vdGljZSwgYW5kIHJldHVybiB0aGUgc3RhcnQgb2YgdGhlIGRvY1xyXG4gICAgICAgICAgICAgICAgICBkb2MuY2FudEVkaXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gUG9zKGRvYy5maXJzdCwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmbGlwcGVkID0gdHJ1ZTsgbmV3UG9zID0gcG9zOyBkaXIgPSAtZGlyO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJQb3MgPSBuZXdQb3M7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlIHNlYXJjaDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGN1clBvcztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFNFTEVDVElPTiBEUkFXSU5HXHJcblxyXG4gIGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbihjbSkge1xyXG4gICAgY20uZGlzcGxheS5pbnB1dC5zaG93U2VsZWN0aW9uKGNtLmRpc3BsYXkuaW5wdXQucHJlcGFyZVNlbGVjdGlvbigpKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHByZXBhcmVTZWxlY3Rpb24oY20sIHByaW1hcnkpIHtcclxuICAgIHZhciBkb2MgPSBjbS5kb2MsIHJlc3VsdCA9IHt9O1xyXG4gICAgdmFyIGN1ckZyYWdtZW50ID0gcmVzdWx0LmN1cnNvcnMgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcbiAgICB2YXIgc2VsRnJhZ21lbnQgPSByZXN1bHQuc2VsZWN0aW9uID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKHByaW1hcnkgPT09IGZhbHNlICYmIGkgPT0gZG9jLnNlbC5wcmltSW5kZXgpIGNvbnRpbnVlO1xyXG4gICAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnJhbmdlc1tpXTtcclxuICAgICAgdmFyIGNvbGxhcHNlZCA9IHJhbmdlLmVtcHR5KCk7XHJcbiAgICAgIGlmIChjb2xsYXBzZWQgfHwgY20ub3B0aW9ucy5zaG93Q3Vyc29yV2hlblNlbGVjdGluZylcclxuICAgICAgICBkcmF3U2VsZWN0aW9uQ3Vyc29yKGNtLCByYW5nZSwgY3VyRnJhZ21lbnQpO1xyXG4gICAgICBpZiAoIWNvbGxhcHNlZClcclxuICAgICAgICBkcmF3U2VsZWN0aW9uUmFuZ2UoY20sIHJhbmdlLCBzZWxGcmFnbWVudCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgLy8gRHJhd3MgYSBjdXJzb3IgZm9yIHRoZSBnaXZlbiByYW5nZVxyXG4gIGZ1bmN0aW9uIGRyYXdTZWxlY3Rpb25DdXJzb3IoY20sIHJhbmdlLCBvdXRwdXQpIHtcclxuICAgIHZhciBwb3MgPSBjdXJzb3JDb29yZHMoY20sIHJhbmdlLmhlYWQsIFwiZGl2XCIsIG51bGwsIG51bGwsICFjbS5vcHRpb25zLnNpbmdsZUN1cnNvckhlaWdodFBlckxpbmUpO1xyXG5cclxuICAgIHZhciBjdXJzb3IgPSBvdXRwdXQuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsIFwiXFx1MDBhMFwiLCBcIkNvZGVNaXJyb3ItY3Vyc29yXCIpKTtcclxuICAgIGN1cnNvci5zdHlsZS5sZWZ0ID0gcG9zLmxlZnQgKyBcInB4XCI7XHJcbiAgICBjdXJzb3Iuc3R5bGUudG9wID0gcG9zLnRvcCArIFwicHhcIjtcclxuICAgIGN1cnNvci5zdHlsZS5oZWlnaHQgPSBNYXRoLm1heCgwLCBwb3MuYm90dG9tIC0gcG9zLnRvcCkgKiBjbS5vcHRpb25zLmN1cnNvckhlaWdodCArIFwicHhcIjtcclxuXHJcbiAgICBpZiAocG9zLm90aGVyKSB7XHJcbiAgICAgIC8vIFNlY29uZGFyeSBjdXJzb3IsIHNob3duIHdoZW4gb24gYSAnanVtcCcgaW4gYmktZGlyZWN0aW9uYWwgdGV4dFxyXG4gICAgICB2YXIgb3RoZXJDdXJzb3IgPSBvdXRwdXQuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsIFwiXFx1MDBhMFwiLCBcIkNvZGVNaXJyb3ItY3Vyc29yIENvZGVNaXJyb3Itc2Vjb25kYXJ5Y3Vyc29yXCIpKTtcclxuICAgICAgb3RoZXJDdXJzb3Iuc3R5bGUuZGlzcGxheSA9IFwiXCI7XHJcbiAgICAgIG90aGVyQ3Vyc29yLnN0eWxlLmxlZnQgPSBwb3Mub3RoZXIubGVmdCArIFwicHhcIjtcclxuICAgICAgb3RoZXJDdXJzb3Iuc3R5bGUudG9wID0gcG9zLm90aGVyLnRvcCArIFwicHhcIjtcclxuICAgICAgb3RoZXJDdXJzb3Iuc3R5bGUuaGVpZ2h0ID0gKHBvcy5vdGhlci5ib3R0b20gLSBwb3Mub3RoZXIudG9wKSAqIC44NSArIFwicHhcIjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIERyYXdzIHRoZSBnaXZlbiByYW5nZSBhcyBhIGhpZ2hsaWdodGVkIHNlbGVjdGlvblxyXG4gIGZ1bmN0aW9uIGRyYXdTZWxlY3Rpb25SYW5nZShjbSwgcmFuZ2UsIG91dHB1dCkge1xyXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XHJcbiAgICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcbiAgICB2YXIgcGFkZGluZyA9IHBhZGRpbmdIKGNtLmRpc3BsYXkpLCBsZWZ0U2lkZSA9IHBhZGRpbmcubGVmdDtcclxuICAgIHZhciByaWdodFNpZGUgPSBNYXRoLm1heChkaXNwbGF5LnNpemVyV2lkdGgsIGRpc3BsYXlXaWR0aChjbSkgLSBkaXNwbGF5LnNpemVyLm9mZnNldExlZnQpIC0gcGFkZGluZy5yaWdodDtcclxuXHJcbiAgICBmdW5jdGlvbiBhZGQobGVmdCwgdG9wLCB3aWR0aCwgYm90dG9tKSB7XHJcbiAgICAgIGlmICh0b3AgPCAwKSB0b3AgPSAwO1xyXG4gICAgICB0b3AgPSBNYXRoLnJvdW5kKHRvcCk7XHJcbiAgICAgIGJvdHRvbSA9IE1hdGgucm91bmQoYm90dG9tKTtcclxuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1zZWxlY3RlZFwiLCBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogXCIgKyBsZWZ0ICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicHg7IHRvcDogXCIgKyB0b3AgKyBcInB4OyB3aWR0aDogXCIgKyAod2lkdGggPT0gbnVsbCA/IHJpZ2h0U2lkZSAtIGxlZnQgOiB3aWR0aCkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJweDsgaGVpZ2h0OiBcIiArIChib3R0b20gLSB0b3ApICsgXCJweFwiKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0ZvckxpbmUobGluZSwgZnJvbUFyZywgdG9BcmcpIHtcclxuICAgICAgdmFyIGxpbmVPYmogPSBnZXRMaW5lKGRvYywgbGluZSk7XHJcbiAgICAgIHZhciBsaW5lTGVuID0gbGluZU9iai50ZXh0Lmxlbmd0aDtcclxuICAgICAgdmFyIHN0YXJ0LCBlbmQ7XHJcbiAgICAgIGZ1bmN0aW9uIGNvb3JkcyhjaCwgYmlhcykge1xyXG4gICAgICAgIHJldHVybiBjaGFyQ29vcmRzKGNtLCBQb3MobGluZSwgY2gpLCBcImRpdlwiLCBsaW5lT2JqLCBiaWFzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaXRlcmF0ZUJpZGlTZWN0aW9ucyhnZXRPcmRlcihsaW5lT2JqKSwgZnJvbUFyZyB8fCAwLCB0b0FyZyA9PSBudWxsID8gbGluZUxlbiA6IHRvQXJnLCBmdW5jdGlvbihmcm9tLCB0bywgZGlyKSB7XHJcbiAgICAgICAgdmFyIGxlZnRQb3MgPSBjb29yZHMoZnJvbSwgXCJsZWZ0XCIpLCByaWdodFBvcywgbGVmdCwgcmlnaHQ7XHJcbiAgICAgICAgaWYgKGZyb20gPT0gdG8pIHtcclxuICAgICAgICAgIHJpZ2h0UG9zID0gbGVmdFBvcztcclxuICAgICAgICAgIGxlZnQgPSByaWdodCA9IGxlZnRQb3MubGVmdDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmlnaHRQb3MgPSBjb29yZHModG8gLSAxLCBcInJpZ2h0XCIpO1xyXG4gICAgICAgICAgaWYgKGRpciA9PSBcInJ0bFwiKSB7IHZhciB0bXAgPSBsZWZ0UG9zOyBsZWZ0UG9zID0gcmlnaHRQb3M7IHJpZ2h0UG9zID0gdG1wOyB9XHJcbiAgICAgICAgICBsZWZ0ID0gbGVmdFBvcy5sZWZ0O1xyXG4gICAgICAgICAgcmlnaHQgPSByaWdodFBvcy5yaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZyb21BcmcgPT0gbnVsbCAmJiBmcm9tID09IDApIGxlZnQgPSBsZWZ0U2lkZTtcclxuICAgICAgICBpZiAocmlnaHRQb3MudG9wIC0gbGVmdFBvcy50b3AgPiAzKSB7IC8vIERpZmZlcmVudCBsaW5lcywgZHJhdyB0b3AgcGFydFxyXG4gICAgICAgICAgYWRkKGxlZnQsIGxlZnRQb3MudG9wLCBudWxsLCBsZWZ0UG9zLmJvdHRvbSk7XHJcbiAgICAgICAgICBsZWZ0ID0gbGVmdFNpZGU7XHJcbiAgICAgICAgICBpZiAobGVmdFBvcy5ib3R0b20gPCByaWdodFBvcy50b3ApIGFkZChsZWZ0LCBsZWZ0UG9zLmJvdHRvbSwgbnVsbCwgcmlnaHRQb3MudG9wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRvQXJnID09IG51bGwgJiYgdG8gPT0gbGluZUxlbikgcmlnaHQgPSByaWdodFNpZGU7XHJcbiAgICAgICAgaWYgKCFzdGFydCB8fCBsZWZ0UG9zLnRvcCA8IHN0YXJ0LnRvcCB8fCBsZWZ0UG9zLnRvcCA9PSBzdGFydC50b3AgJiYgbGVmdFBvcy5sZWZ0IDwgc3RhcnQubGVmdClcclxuICAgICAgICAgIHN0YXJ0ID0gbGVmdFBvcztcclxuICAgICAgICBpZiAoIWVuZCB8fCByaWdodFBvcy5ib3R0b20gPiBlbmQuYm90dG9tIHx8IHJpZ2h0UG9zLmJvdHRvbSA9PSBlbmQuYm90dG9tICYmIHJpZ2h0UG9zLnJpZ2h0ID4gZW5kLnJpZ2h0KVxyXG4gICAgICAgICAgZW5kID0gcmlnaHRQb3M7XHJcbiAgICAgICAgaWYgKGxlZnQgPCBsZWZ0U2lkZSArIDEpIGxlZnQgPSBsZWZ0U2lkZTtcclxuICAgICAgICBhZGQobGVmdCwgcmlnaHRQb3MudG9wLCByaWdodCAtIGxlZnQsIHJpZ2h0UG9zLmJvdHRvbSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4ge3N0YXJ0OiBzdGFydCwgZW5kOiBlbmR9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzRnJvbSA9IHJhbmdlLmZyb20oKSwgc1RvID0gcmFuZ2UudG8oKTtcclxuICAgIGlmIChzRnJvbS5saW5lID09IHNUby5saW5lKSB7XHJcbiAgICAgIGRyYXdGb3JMaW5lKHNGcm9tLmxpbmUsIHNGcm9tLmNoLCBzVG8uY2gpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIGZyb21MaW5lID0gZ2V0TGluZShkb2MsIHNGcm9tLmxpbmUpLCB0b0xpbmUgPSBnZXRMaW5lKGRvYywgc1RvLmxpbmUpO1xyXG4gICAgICB2YXIgc2luZ2xlVkxpbmUgPSB2aXN1YWxMaW5lKGZyb21MaW5lKSA9PSB2aXN1YWxMaW5lKHRvTGluZSk7XHJcbiAgICAgIHZhciBsZWZ0RW5kID0gZHJhd0ZvckxpbmUoc0Zyb20ubGluZSwgc0Zyb20uY2gsIHNpbmdsZVZMaW5lID8gZnJvbUxpbmUudGV4dC5sZW5ndGggKyAxIDogbnVsbCkuZW5kO1xyXG4gICAgICB2YXIgcmlnaHRTdGFydCA9IGRyYXdGb3JMaW5lKHNUby5saW5lLCBzaW5nbGVWTGluZSA/IDAgOiBudWxsLCBzVG8uY2gpLnN0YXJ0O1xyXG4gICAgICBpZiAoc2luZ2xlVkxpbmUpIHtcclxuICAgICAgICBpZiAobGVmdEVuZC50b3AgPCByaWdodFN0YXJ0LnRvcCAtIDIpIHtcclxuICAgICAgICAgIGFkZChsZWZ0RW5kLnJpZ2h0LCBsZWZ0RW5kLnRvcCwgbnVsbCwgbGVmdEVuZC5ib3R0b20pO1xyXG4gICAgICAgICAgYWRkKGxlZnRTaWRlLCByaWdodFN0YXJ0LnRvcCwgcmlnaHRTdGFydC5sZWZ0LCByaWdodFN0YXJ0LmJvdHRvbSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGFkZChsZWZ0RW5kLnJpZ2h0LCBsZWZ0RW5kLnRvcCwgcmlnaHRTdGFydC5sZWZ0IC0gbGVmdEVuZC5yaWdodCwgbGVmdEVuZC5ib3R0b20pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAobGVmdEVuZC5ib3R0b20gPCByaWdodFN0YXJ0LnRvcClcclxuICAgICAgICBhZGQobGVmdFNpZGUsIGxlZnRFbmQuYm90dG9tLCBudWxsLCByaWdodFN0YXJ0LnRvcCk7XHJcbiAgICB9XHJcblxyXG4gICAgb3V0cHV0LmFwcGVuZENoaWxkKGZyYWdtZW50KTtcclxuICB9XHJcblxyXG4gIC8vIEN1cnNvci1ibGlua2luZ1xyXG4gIGZ1bmN0aW9uIHJlc3RhcnRCbGluayhjbSkge1xyXG4gICAgaWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSByZXR1cm47XHJcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XHJcbiAgICBjbGVhckludGVydmFsKGRpc3BsYXkuYmxpbmtlcik7XHJcbiAgICB2YXIgb24gPSB0cnVlO1xyXG4gICAgZGlzcGxheS5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eSA9IFwiXCI7XHJcbiAgICBpZiAoY20ub3B0aW9ucy5jdXJzb3JCbGlua1JhdGUgPiAwKVxyXG4gICAgICBkaXNwbGF5LmJsaW5rZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcclxuICAgICAgICBkaXNwbGF5LmN1cnNvckRpdi5zdHlsZS52aXNpYmlsaXR5ID0gKG9uID0gIW9uKSA/IFwiXCIgOiBcImhpZGRlblwiO1xyXG4gICAgICB9LCBjbS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZSk7XHJcbiAgICBlbHNlIGlmIChjbS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZSA8IDApXHJcbiAgICAgIGRpc3BsYXkuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xyXG4gIH1cclxuXHJcbiAgLy8gSElHSExJR0hUIFdPUktFUlxyXG5cclxuICBmdW5jdGlvbiBzdGFydFdvcmtlcihjbSwgdGltZSkge1xyXG4gICAgaWYgKGNtLmRvYy5tb2RlLnN0YXJ0U3RhdGUgJiYgY20uZG9jLmZyb250aWVyIDwgY20uZGlzcGxheS52aWV3VG8pXHJcbiAgICAgIGNtLnN0YXRlLmhpZ2hsaWdodC5zZXQodGltZSwgYmluZChoaWdobGlnaHRXb3JrZXIsIGNtKSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBoaWdobGlnaHRXb3JrZXIoY20pIHtcclxuICAgIHZhciBkb2MgPSBjbS5kb2M7XHJcbiAgICBpZiAoZG9jLmZyb250aWVyIDwgZG9jLmZpcnN0KSBkb2MuZnJvbnRpZXIgPSBkb2MuZmlyc3Q7XHJcbiAgICBpZiAoZG9jLmZyb250aWVyID49IGNtLmRpc3BsYXkudmlld1RvKSByZXR1cm47XHJcbiAgICB2YXIgZW5kID0gK25ldyBEYXRlICsgY20ub3B0aW9ucy53b3JrVGltZTtcclxuICAgIHZhciBzdGF0ZSA9IGNvcHlTdGF0ZShkb2MubW9kZSwgZ2V0U3RhdGVCZWZvcmUoY20sIGRvYy5mcm9udGllcikpO1xyXG4gICAgdmFyIGNoYW5nZWRMaW5lcyA9IFtdO1xyXG5cclxuICAgIGRvYy5pdGVyKGRvYy5mcm9udGllciwgTWF0aC5taW4oZG9jLmZpcnN0ICsgZG9jLnNpemUsIGNtLmRpc3BsYXkudmlld1RvICsgNTAwKSwgZnVuY3Rpb24obGluZSkge1xyXG4gICAgICBpZiAoZG9jLmZyb250aWVyID49IGNtLmRpc3BsYXkudmlld0Zyb20pIHsgLy8gVmlzaWJsZVxyXG4gICAgICAgIHZhciBvbGRTdHlsZXMgPSBsaW5lLnN0eWxlcztcclxuICAgICAgICB2YXIgaGlnaGxpZ2h0ZWQgPSBoaWdobGlnaHRMaW5lKGNtLCBsaW5lLCBzdGF0ZSwgdHJ1ZSk7XHJcbiAgICAgICAgbGluZS5zdHlsZXMgPSBoaWdobGlnaHRlZC5zdHlsZXM7XHJcbiAgICAgICAgdmFyIG9sZENscyA9IGxpbmUuc3R5bGVDbGFzc2VzLCBuZXdDbHMgPSBoaWdobGlnaHRlZC5jbGFzc2VzO1xyXG4gICAgICAgIGlmIChuZXdDbHMpIGxpbmUuc3R5bGVDbGFzc2VzID0gbmV3Q2xzO1xyXG4gICAgICAgIGVsc2UgaWYgKG9sZENscykgbGluZS5zdHlsZUNsYXNzZXMgPSBudWxsO1xyXG4gICAgICAgIHZhciBpc2NoYW5nZSA9ICFvbGRTdHlsZXMgfHwgb2xkU3R5bGVzLmxlbmd0aCAhPSBsaW5lLnN0eWxlcy5sZW5ndGggfHxcclxuICAgICAgICAgIG9sZENscyAhPSBuZXdDbHMgJiYgKCFvbGRDbHMgfHwgIW5ld0NscyB8fCBvbGRDbHMuYmdDbGFzcyAhPSBuZXdDbHMuYmdDbGFzcyB8fCBvbGRDbHMudGV4dENsYXNzICE9IG5ld0Nscy50ZXh0Q2xhc3MpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyAhaXNjaGFuZ2UgJiYgaSA8IG9sZFN0eWxlcy5sZW5ndGg7ICsraSkgaXNjaGFuZ2UgPSBvbGRTdHlsZXNbaV0gIT0gbGluZS5zdHlsZXNbaV07XHJcbiAgICAgICAgaWYgKGlzY2hhbmdlKSBjaGFuZ2VkTGluZXMucHVzaChkb2MuZnJvbnRpZXIpO1xyXG4gICAgICAgIGxpbmUuc3RhdGVBZnRlciA9IGNvcHlTdGF0ZShkb2MubW9kZSwgc3RhdGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHByb2Nlc3NMaW5lKGNtLCBsaW5lLnRleHQsIHN0YXRlKTtcclxuICAgICAgICBsaW5lLnN0YXRlQWZ0ZXIgPSBkb2MuZnJvbnRpZXIgJSA1ID09IDAgPyBjb3B5U3RhdGUoZG9jLm1vZGUsIHN0YXRlKSA6IG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgKytkb2MuZnJvbnRpZXI7XHJcbiAgICAgIGlmICgrbmV3IERhdGUgPiBlbmQpIHtcclxuICAgICAgICBzdGFydFdvcmtlcihjbSwgY20ub3B0aW9ucy53b3JrRGVsYXkpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGlmIChjaGFuZ2VkTGluZXMubGVuZ3RoKSBydW5Jbk9wKGNtLCBmdW5jdGlvbigpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VkTGluZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgcmVnTGluZUNoYW5nZShjbSwgY2hhbmdlZExpbmVzW2ldLCBcInRleHRcIik7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIEZpbmRzIHRoZSBsaW5lIHRvIHN0YXJ0IHdpdGggd2hlbiBzdGFydGluZyBhIHBhcnNlLiBUcmllcyB0b1xyXG4gIC8vIGZpbmQgYSBsaW5lIHdpdGggYSBzdGF0ZUFmdGVyLCBzbyB0aGF0IGl0IGNhbiBzdGFydCB3aXRoIGFcclxuICAvLyB2YWxpZCBzdGF0ZS4gSWYgdGhhdCBmYWlscywgaXQgcmV0dXJucyB0aGUgbGluZSB3aXRoIHRoZVxyXG4gIC8vIHNtYWxsZXN0IGluZGVudGF0aW9uLCB3aGljaCB0ZW5kcyB0byBuZWVkIHRoZSBsZWFzdCBjb250ZXh0IHRvXHJcbiAgLy8gcGFyc2UgY29ycmVjdGx5LlxyXG4gIGZ1bmN0aW9uIGZpbmRTdGFydExpbmUoY20sIG4sIHByZWNpc2UpIHtcclxuICAgIHZhciBtaW5pbmRlbnQsIG1pbmxpbmUsIGRvYyA9IGNtLmRvYztcclxuICAgIHZhciBsaW0gPSBwcmVjaXNlID8gLTEgOiBuIC0gKGNtLmRvYy5tb2RlLmlubmVyTW9kZSA/IDEwMDAgOiAxMDApO1xyXG4gICAgZm9yICh2YXIgc2VhcmNoID0gbjsgc2VhcmNoID4gbGltOyAtLXNlYXJjaCkge1xyXG4gICAgICBpZiAoc2VhcmNoIDw9IGRvYy5maXJzdCkgcmV0dXJuIGRvYy5maXJzdDtcclxuICAgICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgc2VhcmNoIC0gMSk7XHJcbiAgICAgIGlmIChsaW5lLnN0YXRlQWZ0ZXIgJiYgKCFwcmVjaXNlIHx8IHNlYXJjaCA8PSBkb2MuZnJvbnRpZXIpKSByZXR1cm4gc2VhcmNoO1xyXG4gICAgICB2YXIgaW5kZW50ZWQgPSBjb3VudENvbHVtbihsaW5lLnRleHQsIG51bGwsIGNtLm9wdGlvbnMudGFiU2l6ZSk7XHJcbiAgICAgIGlmIChtaW5saW5lID09IG51bGwgfHwgbWluaW5kZW50ID4gaW5kZW50ZWQpIHtcclxuICAgICAgICBtaW5saW5lID0gc2VhcmNoIC0gMTtcclxuICAgICAgICBtaW5pbmRlbnQgPSBpbmRlbnRlZDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1pbmxpbmU7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRTdGF0ZUJlZm9yZShjbSwgbiwgcHJlY2lzZSkge1xyXG4gICAgdmFyIGRvYyA9IGNtLmRvYywgZGlzcGxheSA9IGNtLmRpc3BsYXk7XHJcbiAgICBpZiAoIWRvYy5tb2RlLnN0YXJ0U3RhdGUpIHJldHVybiB0cnVlO1xyXG4gICAgdmFyIHBvcyA9IGZpbmRTdGFydExpbmUoY20sIG4sIHByZWNpc2UpLCBzdGF0ZSA9IHBvcyA+IGRvYy5maXJzdCAmJiBnZXRMaW5lKGRvYywgcG9zLTEpLnN0YXRlQWZ0ZXI7XHJcbiAgICBpZiAoIXN0YXRlKSBzdGF0ZSA9IHN0YXJ0U3RhdGUoZG9jLm1vZGUpO1xyXG4gICAgZWxzZSBzdGF0ZSA9IGNvcHlTdGF0ZShkb2MubW9kZSwgc3RhdGUpO1xyXG4gICAgZG9jLml0ZXIocG9zLCBuLCBmdW5jdGlvbihsaW5lKSB7XHJcbiAgICAgIHByb2Nlc3NMaW5lKGNtLCBsaW5lLnRleHQsIHN0YXRlKTtcclxuICAgICAgdmFyIHNhdmUgPSBwb3MgPT0gbiAtIDEgfHwgcG9zICUgNSA9PSAwIHx8IHBvcyA+PSBkaXNwbGF5LnZpZXdGcm9tICYmIHBvcyA8IGRpc3BsYXkudmlld1RvO1xyXG4gICAgICBsaW5lLnN0YXRlQWZ0ZXIgPSBzYXZlID8gY29weVN0YXRlKGRvYy5tb2RlLCBzdGF0ZSkgOiBudWxsO1xyXG4gICAgICArK3BvcztcclxuICAgIH0pO1xyXG4gICAgaWYgKHByZWNpc2UpIGRvYy5mcm9udGllciA9IHBvcztcclxuICAgIHJldHVybiBzdGF0ZTtcclxuICB9XHJcblxyXG4gIC8vIFBPU0lUSU9OIE1FQVNVUkVNRU5UXHJcblxyXG4gIGZ1bmN0aW9uIHBhZGRpbmdUb3AoZGlzcGxheSkge3JldHVybiBkaXNwbGF5LmxpbmVTcGFjZS5vZmZzZXRUb3A7fVxyXG4gIGZ1bmN0aW9uIHBhZGRpbmdWZXJ0KGRpc3BsYXkpIHtyZXR1cm4gZGlzcGxheS5tb3Zlci5vZmZzZXRIZWlnaHQgLSBkaXNwbGF5LmxpbmVTcGFjZS5vZmZzZXRIZWlnaHQ7fVxyXG4gIGZ1bmN0aW9uIHBhZGRpbmdIKGRpc3BsYXkpIHtcclxuICAgIGlmIChkaXNwbGF5LmNhY2hlZFBhZGRpbmdIKSByZXR1cm4gZGlzcGxheS5jYWNoZWRQYWRkaW5nSDtcclxuICAgIHZhciBlID0gcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5tZWFzdXJlLCBlbHQoXCJwcmVcIiwgXCJ4XCIpKTtcclxuICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID8gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZSkgOiBlLmN1cnJlbnRTdHlsZTtcclxuICAgIHZhciBkYXRhID0ge2xlZnQ6IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdMZWZ0KSwgcmlnaHQ6IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdSaWdodCl9O1xyXG4gICAgaWYgKCFpc05hTihkYXRhLmxlZnQpICYmICFpc05hTihkYXRhLnJpZ2h0KSkgZGlzcGxheS5jYWNoZWRQYWRkaW5nSCA9IGRhdGE7XHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNjcm9sbEdhcChjbSkgeyByZXR1cm4gc2Nyb2xsZXJHYXAgLSBjbS5kaXNwbGF5Lm5hdGl2ZUJhcldpZHRoOyB9XHJcbiAgZnVuY3Rpb24gZGlzcGxheVdpZHRoKGNtKSB7XHJcbiAgICByZXR1cm4gY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCAtIHNjcm9sbEdhcChjbSkgLSBjbS5kaXNwbGF5LmJhcldpZHRoO1xyXG4gIH1cclxuICBmdW5jdGlvbiBkaXNwbGF5SGVpZ2h0KGNtKSB7XHJcbiAgICByZXR1cm4gY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRIZWlnaHQgLSBzY3JvbGxHYXAoY20pIC0gY20uZGlzcGxheS5iYXJIZWlnaHQ7XHJcbiAgfVxyXG5cclxuICAvLyBFbnN1cmUgdGhlIGxpbmVWaWV3LndyYXBwaW5nLmhlaWdodHMgYXJyYXkgaXMgcG9wdWxhdGVkLiBUaGlzIGlzXHJcbiAgLy8gYW4gYXJyYXkgb2YgYm90dG9tIG9mZnNldHMgZm9yIHRoZSBsaW5lcyB0aGF0IG1ha2UgdXAgYSBkcmF3blxyXG4gIC8vIGxpbmUuIFdoZW4gbGluZVdyYXBwaW5nIGlzIG9uLCB0aGVyZSBtaWdodCBiZSBtb3JlIHRoYW4gb25lXHJcbiAgLy8gaGVpZ2h0LlxyXG4gIGZ1bmN0aW9uIGVuc3VyZUxpbmVIZWlnaHRzKGNtLCBsaW5lVmlldywgcmVjdCkge1xyXG4gICAgdmFyIHdyYXBwaW5nID0gY20ub3B0aW9ucy5saW5lV3JhcHBpbmc7XHJcbiAgICB2YXIgY3VyV2lkdGggPSB3cmFwcGluZyAmJiBkaXNwbGF5V2lkdGgoY20pO1xyXG4gICAgaWYgKCFsaW5lVmlldy5tZWFzdXJlLmhlaWdodHMgfHwgd3JhcHBpbmcgJiYgbGluZVZpZXcubWVhc3VyZS53aWR0aCAhPSBjdXJXaWR0aCkge1xyXG4gICAgICB2YXIgaGVpZ2h0cyA9IGxpbmVWaWV3Lm1lYXN1cmUuaGVpZ2h0cyA9IFtdO1xyXG4gICAgICBpZiAod3JhcHBpbmcpIHtcclxuICAgICAgICBsaW5lVmlldy5tZWFzdXJlLndpZHRoID0gY3VyV2lkdGg7XHJcbiAgICAgICAgdmFyIHJlY3RzID0gbGluZVZpZXcudGV4dC5maXJzdENoaWxkLmdldENsaWVudFJlY3RzKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgIHZhciBjdXIgPSByZWN0c1tpXSwgbmV4dCA9IHJlY3RzW2kgKyAxXTtcclxuICAgICAgICAgIGlmIChNYXRoLmFicyhjdXIuYm90dG9tIC0gbmV4dC5ib3R0b20pID4gMilcclxuICAgICAgICAgICAgaGVpZ2h0cy5wdXNoKChjdXIuYm90dG9tICsgbmV4dC50b3ApIC8gMiAtIHJlY3QudG9wKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaGVpZ2h0cy5wdXNoKHJlY3QuYm90dG9tIC0gcmVjdC50b3ApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRmluZCBhIGxpbmUgbWFwIChtYXBwaW5nIGNoYXJhY3RlciBvZmZzZXRzIHRvIHRleHQgbm9kZXMpIGFuZCBhXHJcbiAgLy8gbWVhc3VyZW1lbnQgY2FjaGUgZm9yIHRoZSBnaXZlbiBsaW5lIG51bWJlci4gKEEgbGluZSB2aWV3IG1pZ2h0XHJcbiAgLy8gY29udGFpbiBtdWx0aXBsZSBsaW5lcyB3aGVuIGNvbGxhcHNlZCByYW5nZXMgYXJlIHByZXNlbnQuKVxyXG4gIGZ1bmN0aW9uIG1hcEZyb21MaW5lVmlldyhsaW5lVmlldywgbGluZSwgbGluZU4pIHtcclxuICAgIGlmIChsaW5lVmlldy5saW5lID09IGxpbmUpXHJcbiAgICAgIHJldHVybiB7bWFwOiBsaW5lVmlldy5tZWFzdXJlLm1hcCwgY2FjaGU6IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGV9O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lVmlldy5yZXN0Lmxlbmd0aDsgaSsrKVxyXG4gICAgICBpZiAobGluZVZpZXcucmVzdFtpXSA9PSBsaW5lKVxyXG4gICAgICAgIHJldHVybiB7bWFwOiBsaW5lVmlldy5tZWFzdXJlLm1hcHNbaV0sIGNhY2hlOiBsaW5lVmlldy5tZWFzdXJlLmNhY2hlc1tpXX07XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVWaWV3LnJlc3QubGVuZ3RoOyBpKyspXHJcbiAgICAgIGlmIChsaW5lTm8obGluZVZpZXcucmVzdFtpXSkgPiBsaW5lTilcclxuICAgICAgICByZXR1cm4ge21hcDogbGluZVZpZXcubWVhc3VyZS5tYXBzW2ldLCBjYWNoZTogbGluZVZpZXcubWVhc3VyZS5jYWNoZXNbaV0sIGJlZm9yZTogdHJ1ZX07XHJcbiAgfVxyXG5cclxuICAvLyBSZW5kZXIgYSBsaW5lIGludG8gdGhlIGhpZGRlbiBub2RlIGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZC4gVXNlZFxyXG4gIC8vIHdoZW4gbWVhc3VyZW1lbnQgaXMgbmVlZGVkIGZvciBhIGxpbmUgdGhhdCdzIG5vdCBpbiB0aGUgdmlld3BvcnQuXHJcbiAgZnVuY3Rpb24gdXBkYXRlRXh0ZXJuYWxNZWFzdXJlbWVudChjbSwgbGluZSkge1xyXG4gICAgbGluZSA9IHZpc3VhbExpbmUobGluZSk7XHJcbiAgICB2YXIgbGluZU4gPSBsaW5lTm8obGluZSk7XHJcbiAgICB2YXIgdmlldyA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG5ldyBMaW5lVmlldyhjbS5kb2MsIGxpbmUsIGxpbmVOKTtcclxuICAgIHZpZXcubGluZU4gPSBsaW5lTjtcclxuICAgIHZhciBidWlsdCA9IHZpZXcuYnVpbHQgPSBidWlsZExpbmVDb250ZW50KGNtLCB2aWV3KTtcclxuICAgIHZpZXcudGV4dCA9IGJ1aWx0LnByZTtcclxuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGNtLmRpc3BsYXkubGluZU1lYXN1cmUsIGJ1aWx0LnByZSk7XHJcbiAgICByZXR1cm4gdmlldztcclxuICB9XHJcblxyXG4gIC8vIEdldCBhIHt0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHR9IGJveCAoaW4gbGluZS1sb2NhbCBjb29yZGluYXRlcylcclxuICAvLyBmb3IgYSBnaXZlbiBjaGFyYWN0ZXIuXHJcbiAgZnVuY3Rpb24gbWVhc3VyZUNoYXIoY20sIGxpbmUsIGNoLCBiaWFzKSB7XHJcbiAgICByZXR1cm4gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lKSwgY2gsIGJpYXMpO1xyXG4gIH1cclxuXHJcbiAgLy8gRmluZCBhIGxpbmUgdmlldyB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiBsaW5lIG51bWJlci5cclxuICBmdW5jdGlvbiBmaW5kVmlld0ZvckxpbmUoY20sIGxpbmVOKSB7XHJcbiAgICBpZiAobGluZU4gPj0gY20uZGlzcGxheS52aWV3RnJvbSAmJiBsaW5lTiA8IGNtLmRpc3BsYXkudmlld1RvKVxyXG4gICAgICByZXR1cm4gY20uZGlzcGxheS52aWV3W2ZpbmRWaWV3SW5kZXgoY20sIGxpbmVOKV07XHJcbiAgICB2YXIgZXh0ID0gY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkO1xyXG4gICAgaWYgKGV4dCAmJiBsaW5lTiA+PSBleHQubGluZU4gJiYgbGluZU4gPCBleHQubGluZU4gKyBleHQuc2l6ZSlcclxuICAgICAgcmV0dXJuIGV4dDtcclxuICB9XHJcblxyXG4gIC8vIE1lYXN1cmVtZW50IGNhbiBiZSBzcGxpdCBpbiB0d28gc3RlcHMsIHRoZSBzZXQtdXAgd29yayB0aGF0XHJcbiAgLy8gYXBwbGllcyB0byB0aGUgd2hvbGUgbGluZSwgYW5kIHRoZSBtZWFzdXJlbWVudCBvZiB0aGUgYWN0dWFsXHJcbiAgLy8gY2hhcmFjdGVyLiBGdW5jdGlvbnMgbGlrZSBjb29yZHNDaGFyLCB0aGF0IG5lZWQgdG8gZG8gYSBsb3Qgb2ZcclxuICAvLyBtZWFzdXJlbWVudHMgaW4gYSByb3csIGNhbiB0aHVzIGVuc3VyZSB0aGF0IHRoZSBzZXQtdXAgd29yayBpc1xyXG4gIC8vIG9ubHkgZG9uZSBvbmNlLlxyXG4gIGZ1bmN0aW9uIHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZSkge1xyXG4gICAgdmFyIGxpbmVOID0gbGluZU5vKGxpbmUpO1xyXG4gICAgdmFyIHZpZXcgPSBmaW5kVmlld0ZvckxpbmUoY20sIGxpbmVOKTtcclxuICAgIGlmICh2aWV3ICYmICF2aWV3LnRleHQpXHJcbiAgICAgIHZpZXcgPSBudWxsO1xyXG4gICAgZWxzZSBpZiAodmlldyAmJiB2aWV3LmNoYW5nZXMpXHJcbiAgICAgIHVwZGF0ZUxpbmVGb3JDaGFuZ2VzKGNtLCB2aWV3LCBsaW5lTiwgZ2V0RGltZW5zaW9ucyhjbSkpO1xyXG4gICAgaWYgKCF2aWV3KVxyXG4gICAgICB2aWV3ID0gdXBkYXRlRXh0ZXJuYWxNZWFzdXJlbWVudChjbSwgbGluZSk7XHJcblxyXG4gICAgdmFyIGluZm8gPSBtYXBGcm9tTGluZVZpZXcodmlldywgbGluZSwgbGluZU4pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbGluZTogbGluZSwgdmlldzogdmlldywgcmVjdDogbnVsbCxcclxuICAgICAgbWFwOiBpbmZvLm1hcCwgY2FjaGU6IGluZm8uY2FjaGUsIGJlZm9yZTogaW5mby5iZWZvcmUsXHJcbiAgICAgIGhhc0hlaWdodHM6IGZhbHNlXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gR2l2ZW4gYSBwcmVwYXJlZCBtZWFzdXJlbWVudCBvYmplY3QsIG1lYXN1cmVzIHRoZSBwb3NpdGlvbiBvZiBhblxyXG4gIC8vIGFjdHVhbCBjaGFyYWN0ZXIgKG9yIGZldGNoZXMgaXQgZnJvbSB0aGUgY2FjaGUpLlxyXG4gIGZ1bmN0aW9uIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkLCBjaCwgYmlhcywgdmFySGVpZ2h0KSB7XHJcbiAgICBpZiAocHJlcGFyZWQuYmVmb3JlKSBjaCA9IC0xO1xyXG4gICAgdmFyIGtleSA9IGNoICsgKGJpYXMgfHwgXCJcIiksIGZvdW5kO1xyXG4gICAgaWYgKHByZXBhcmVkLmNhY2hlLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgZm91bmQgPSBwcmVwYXJlZC5jYWNoZVtrZXldO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKCFwcmVwYXJlZC5yZWN0KVxyXG4gICAgICAgIHByZXBhcmVkLnJlY3QgPSBwcmVwYXJlZC52aWV3LnRleHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgIGlmICghcHJlcGFyZWQuaGFzSGVpZ2h0cykge1xyXG4gICAgICAgIGVuc3VyZUxpbmVIZWlnaHRzKGNtLCBwcmVwYXJlZC52aWV3LCBwcmVwYXJlZC5yZWN0KTtcclxuICAgICAgICBwcmVwYXJlZC5oYXNIZWlnaHRzID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBmb3VuZCA9IG1lYXN1cmVDaGFySW5uZXIoY20sIHByZXBhcmVkLCBjaCwgYmlhcyk7XHJcbiAgICAgIGlmICghZm91bmQuYm9ndXMpIHByZXBhcmVkLmNhY2hlW2tleV0gPSBmb3VuZDtcclxuICAgIH1cclxuICAgIHJldHVybiB7bGVmdDogZm91bmQubGVmdCwgcmlnaHQ6IGZvdW5kLnJpZ2h0LFxyXG4gICAgICAgICAgICB0b3A6IHZhckhlaWdodCA/IGZvdW5kLnJ0b3AgOiBmb3VuZC50b3AsXHJcbiAgICAgICAgICAgIGJvdHRvbTogdmFySGVpZ2h0ID8gZm91bmQucmJvdHRvbSA6IGZvdW5kLmJvdHRvbX07XHJcbiAgfVxyXG5cclxuICB2YXIgbnVsbFJlY3QgPSB7bGVmdDogMCwgcmlnaHQ6IDAsIHRvcDogMCwgYm90dG9tOiAwfTtcclxuXHJcbiAgZnVuY3Rpb24gbm9kZUFuZE9mZnNldEluTGluZU1hcChtYXAsIGNoLCBiaWFzKSB7XHJcbiAgICB2YXIgbm9kZSwgc3RhcnQsIGVuZCwgY29sbGFwc2U7XHJcbiAgICAvLyBGaXJzdCwgc2VhcmNoIHRoZSBsaW5lIG1hcCBmb3IgdGhlIHRleHQgbm9kZSBjb3JyZXNwb25kaW5nIHRvLFxyXG4gICAgLy8gb3IgY2xvc2VzdCB0bywgdGhlIHRhcmdldCBjaGFyYWN0ZXIuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcC5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgICB2YXIgbVN0YXJ0ID0gbWFwW2ldLCBtRW5kID0gbWFwW2kgKyAxXTtcclxuICAgICAgaWYgKGNoIDwgbVN0YXJ0KSB7XHJcbiAgICAgICAgc3RhcnQgPSAwOyBlbmQgPSAxO1xyXG4gICAgICAgIGNvbGxhcHNlID0gXCJsZWZ0XCI7XHJcbiAgICAgIH0gZWxzZSBpZiAoY2ggPCBtRW5kKSB7XHJcbiAgICAgICAgc3RhcnQgPSBjaCAtIG1TdGFydDtcclxuICAgICAgICBlbmQgPSBzdGFydCArIDE7XHJcbiAgICAgIH0gZWxzZSBpZiAoaSA9PSBtYXAubGVuZ3RoIC0gMyB8fCBjaCA9PSBtRW5kICYmIG1hcFtpICsgM10gPiBjaCkge1xyXG4gICAgICAgIGVuZCA9IG1FbmQgLSBtU3RhcnQ7XHJcbiAgICAgICAgc3RhcnQgPSBlbmQgLSAxO1xyXG4gICAgICAgIGlmIChjaCA+PSBtRW5kKSBjb2xsYXBzZSA9IFwicmlnaHRcIjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc3RhcnQgIT0gbnVsbCkge1xyXG4gICAgICAgIG5vZGUgPSBtYXBbaSArIDJdO1xyXG4gICAgICAgIGlmIChtU3RhcnQgPT0gbUVuZCAmJiBiaWFzID09IChub2RlLmluc2VydExlZnQgPyBcImxlZnRcIiA6IFwicmlnaHRcIikpXHJcbiAgICAgICAgICBjb2xsYXBzZSA9IGJpYXM7XHJcbiAgICAgICAgaWYgKGJpYXMgPT0gXCJsZWZ0XCIgJiYgc3RhcnQgPT0gMClcclxuICAgICAgICAgIHdoaWxlIChpICYmIG1hcFtpIC0gMl0gPT0gbWFwW2kgLSAzXSAmJiBtYXBbaSAtIDFdLmluc2VydExlZnQpIHtcclxuICAgICAgICAgICAgbm9kZSA9IG1hcFsoaSAtPSAzKSArIDJdO1xyXG4gICAgICAgICAgICBjb2xsYXBzZSA9IFwibGVmdFwiO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIGlmIChiaWFzID09IFwicmlnaHRcIiAmJiBzdGFydCA9PSBtRW5kIC0gbVN0YXJ0KVxyXG4gICAgICAgICAgd2hpbGUgKGkgPCBtYXAubGVuZ3RoIC0gMyAmJiBtYXBbaSArIDNdID09IG1hcFtpICsgNF0gJiYgIW1hcFtpICsgNV0uaW5zZXJ0TGVmdCkge1xyXG4gICAgICAgICAgICBub2RlID0gbWFwWyhpICs9IDMpICsgMl07XHJcbiAgICAgICAgICAgIGNvbGxhcHNlID0gXCJyaWdodFwiO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge25vZGU6IG5vZGUsIHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIGNvbGxhcHNlOiBjb2xsYXBzZSwgY292ZXJTdGFydDogbVN0YXJ0LCBjb3ZlckVuZDogbUVuZH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBtZWFzdXJlQ2hhcklubmVyKGNtLCBwcmVwYXJlZCwgY2gsIGJpYXMpIHtcclxuICAgIHZhciBwbGFjZSA9IG5vZGVBbmRPZmZzZXRJbkxpbmVNYXAocHJlcGFyZWQubWFwLCBjaCwgYmlhcyk7XHJcbiAgICB2YXIgbm9kZSA9IHBsYWNlLm5vZGUsIHN0YXJ0ID0gcGxhY2Uuc3RhcnQsIGVuZCA9IHBsYWNlLmVuZCwgY29sbGFwc2UgPSBwbGFjZS5jb2xsYXBzZTtcclxuXHJcbiAgICB2YXIgcmVjdDtcclxuICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHsgLy8gSWYgaXQgaXMgYSB0ZXh0IG5vZGUsIHVzZSBhIHJhbmdlIHRvIHJldHJpZXZlIHRoZSBjb29yZGluYXRlcy5cclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHsgLy8gUmV0cnkgYSBtYXhpbXVtIG9mIDQgdGltZXMgd2hlbiBub25zZW5zZSByZWN0YW5nbGVzIGFyZSByZXR1cm5lZFxyXG4gICAgICAgIHdoaWxlIChzdGFydCAmJiBpc0V4dGVuZGluZ0NoYXIocHJlcGFyZWQubGluZS50ZXh0LmNoYXJBdChwbGFjZS5jb3ZlclN0YXJ0ICsgc3RhcnQpKSkgLS1zdGFydDtcclxuICAgICAgICB3aGlsZSAocGxhY2UuY292ZXJTdGFydCArIGVuZCA8IHBsYWNlLmNvdmVyRW5kICYmIGlzRXh0ZW5kaW5nQ2hhcihwcmVwYXJlZC5saW5lLnRleHQuY2hhckF0KHBsYWNlLmNvdmVyU3RhcnQgKyBlbmQpKSkgKytlbmQ7XHJcbiAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5ICYmIHN0YXJ0ID09IDAgJiYgZW5kID09IHBsYWNlLmNvdmVyRW5kIC0gcGxhY2UuY292ZXJTdGFydCkge1xyXG4gICAgICAgICAgcmVjdCA9IG5vZGUucGFyZW50Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGllICYmIGNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XHJcbiAgICAgICAgICB2YXIgcmVjdHMgPSByYW5nZShub2RlLCBzdGFydCwgZW5kKS5nZXRDbGllbnRSZWN0cygpO1xyXG4gICAgICAgICAgaWYgKHJlY3RzLmxlbmd0aClcclxuICAgICAgICAgICAgcmVjdCA9IHJlY3RzW2JpYXMgPT0gXCJyaWdodFwiID8gcmVjdHMubGVuZ3RoIC0gMSA6IDBdO1xyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZWN0ID0gbnVsbFJlY3Q7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJlY3QgPSByYW5nZShub2RlLCBzdGFydCwgZW5kKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB8fCBudWxsUmVjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlY3QubGVmdCB8fCByZWN0LnJpZ2h0IHx8IHN0YXJ0ID09IDApIGJyZWFrO1xyXG4gICAgICAgIGVuZCA9IHN0YXJ0O1xyXG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgLSAxO1xyXG4gICAgICAgIGNvbGxhcHNlID0gXCJyaWdodFwiO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEpIHJlY3QgPSBtYXliZVVwZGF0ZVJlY3RGb3Jab29taW5nKGNtLmRpc3BsYXkubWVhc3VyZSwgcmVjdCk7XHJcbiAgICB9IGVsc2UgeyAvLyBJZiBpdCBpcyBhIHdpZGdldCwgc2ltcGx5IGdldCB0aGUgYm94IGZvciB0aGUgd2hvbGUgd2lkZ2V0LlxyXG4gICAgICBpZiAoc3RhcnQgPiAwKSBjb2xsYXBzZSA9IGJpYXMgPSBcInJpZ2h0XCI7XHJcbiAgICAgIHZhciByZWN0cztcclxuICAgICAgaWYgKGNtLm9wdGlvbnMubGluZVdyYXBwaW5nICYmIChyZWN0cyA9IG5vZGUuZ2V0Q2xpZW50UmVjdHMoKSkubGVuZ3RoID4gMSlcclxuICAgICAgICByZWN0ID0gcmVjdHNbYmlhcyA9PSBcInJpZ2h0XCIgPyByZWN0cy5sZW5ndGggLSAxIDogMF07XHJcbiAgICAgIGVsc2VcclxuICAgICAgICByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIH1cclxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSAmJiAhc3RhcnQgJiYgKCFyZWN0IHx8ICFyZWN0LmxlZnQgJiYgIXJlY3QucmlnaHQpKSB7XHJcbiAgICAgIHZhciByU3BhbiA9IG5vZGUucGFyZW50Tm9kZS5nZXRDbGllbnRSZWN0cygpWzBdO1xyXG4gICAgICBpZiAoclNwYW4pXHJcbiAgICAgICAgcmVjdCA9IHtsZWZ0OiByU3Bhbi5sZWZ0LCByaWdodDogclNwYW4ubGVmdCArIGNoYXJXaWR0aChjbS5kaXNwbGF5KSwgdG9wOiByU3Bhbi50b3AsIGJvdHRvbTogclNwYW4uYm90dG9tfTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHJlY3QgPSBudWxsUmVjdDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcnRvcCA9IHJlY3QudG9wIC0gcHJlcGFyZWQucmVjdC50b3AsIHJib3QgPSByZWN0LmJvdHRvbSAtIHByZXBhcmVkLnJlY3QudG9wO1xyXG4gICAgdmFyIG1pZCA9IChydG9wICsgcmJvdCkgLyAyO1xyXG4gICAgdmFyIGhlaWdodHMgPSBwcmVwYXJlZC52aWV3Lm1lYXN1cmUuaGVpZ2h0cztcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGVpZ2h0cy5sZW5ndGggLSAxOyBpKyspXHJcbiAgICAgIGlmIChtaWQgPCBoZWlnaHRzW2ldKSBicmVhaztcclxuICAgIHZhciB0b3AgPSBpID8gaGVpZ2h0c1tpIC0gMV0gOiAwLCBib3QgPSBoZWlnaHRzW2ldO1xyXG4gICAgdmFyIHJlc3VsdCA9IHtsZWZ0OiAoY29sbGFwc2UgPT0gXCJyaWdodFwiID8gcmVjdC5yaWdodCA6IHJlY3QubGVmdCkgLSBwcmVwYXJlZC5yZWN0LmxlZnQsXHJcbiAgICAgICAgICAgICAgICAgIHJpZ2h0OiAoY29sbGFwc2UgPT0gXCJsZWZ0XCIgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0KSAtIHByZXBhcmVkLnJlY3QubGVmdCxcclxuICAgICAgICAgICAgICAgICAgdG9wOiB0b3AsIGJvdHRvbTogYm90fTtcclxuICAgIGlmICghcmVjdC5sZWZ0ICYmICFyZWN0LnJpZ2h0KSByZXN1bHQuYm9ndXMgPSB0cnVlO1xyXG4gICAgaWYgKCFjbS5vcHRpb25zLnNpbmdsZUN1cnNvckhlaWdodFBlckxpbmUpIHsgcmVzdWx0LnJ0b3AgPSBydG9wOyByZXN1bHQucmJvdHRvbSA9IHJib3Q7IH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgLy8gV29yayBhcm91bmQgcHJvYmxlbSB3aXRoIGJvdW5kaW5nIGNsaWVudCByZWN0cyBvbiByYW5nZXMgYmVpbmdcclxuICAvLyByZXR1cm5lZCBpbmNvcnJlY3RseSB3aGVuIHpvb21lZCBvbiBJRTEwIGFuZCBiZWxvdy5cclxuICBmdW5jdGlvbiBtYXliZVVwZGF0ZVJlY3RGb3Jab29taW5nKG1lYXN1cmUsIHJlY3QpIHtcclxuICAgIGlmICghd2luZG93LnNjcmVlbiB8fCBzY3JlZW4ubG9naWNhbFhEUEkgPT0gbnVsbCB8fFxyXG4gICAgICAgIHNjcmVlbi5sb2dpY2FsWERQSSA9PSBzY3JlZW4uZGV2aWNlWERQSSB8fCAhaGFzQmFkWm9vbWVkUmVjdHMobWVhc3VyZSkpXHJcbiAgICAgIHJldHVybiByZWN0O1xyXG4gICAgdmFyIHNjYWxlWCA9IHNjcmVlbi5sb2dpY2FsWERQSSAvIHNjcmVlbi5kZXZpY2VYRFBJO1xyXG4gICAgdmFyIHNjYWxlWSA9IHNjcmVlbi5sb2dpY2FsWURQSSAvIHNjcmVlbi5kZXZpY2VZRFBJO1xyXG4gICAgcmV0dXJuIHtsZWZ0OiByZWN0LmxlZnQgKiBzY2FsZVgsIHJpZ2h0OiByZWN0LnJpZ2h0ICogc2NhbGVYLFxyXG4gICAgICAgICAgICB0b3A6IHJlY3QudG9wICogc2NhbGVZLCBib3R0b206IHJlY3QuYm90dG9tICogc2NhbGVZfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGVGb3IobGluZVZpZXcpIHtcclxuICAgIGlmIChsaW5lVmlldy5tZWFzdXJlKSB7XHJcbiAgICAgIGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGUgPSB7fTtcclxuICAgICAgbGluZVZpZXcubWVhc3VyZS5oZWlnaHRzID0gbnVsbDtcclxuICAgICAgaWYgKGxpbmVWaWV3LnJlc3QpIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkrKylcclxuICAgICAgICBsaW5lVmlldy5tZWFzdXJlLmNhY2hlc1tpXSA9IHt9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZShjbSkge1xyXG4gICAgY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmUgPSBudWxsO1xyXG4gICAgcmVtb3ZlQ2hpbGRyZW4oY20uZGlzcGxheS5saW5lTWVhc3VyZSk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNtLmRpc3BsYXkudmlldy5sZW5ndGg7IGkrKylcclxuICAgICAgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZUZvcihjbS5kaXNwbGF5LnZpZXdbaV0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2xlYXJDYWNoZXMoY20pIHtcclxuICAgIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGUoY20pO1xyXG4gICAgY20uZGlzcGxheS5jYWNoZWRDaGFyV2lkdGggPSBjbS5kaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQgPSBjbS5kaXNwbGF5LmNhY2hlZFBhZGRpbmdIID0gbnVsbDtcclxuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIGNtLmRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgY20uZGlzcGxheS5saW5lTnVtQ2hhcnMgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGFnZVNjcm9sbFgoKSB7IHJldHVybiB3aW5kb3cucGFnZVhPZmZzZXQgfHwgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5KS5zY3JvbGxMZWZ0OyB9XHJcbiAgZnVuY3Rpb24gcGFnZVNjcm9sbFkoKSB7IHJldHVybiB3aW5kb3cucGFnZVlPZmZzZXQgfHwgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5KS5zY3JvbGxUb3A7IH1cclxuXHJcbiAgLy8gQ29udmVydHMgYSB7dG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0fSBib3ggZnJvbSBsaW5lLWxvY2FsXHJcbiAgLy8gY29vcmRpbmF0ZXMgaW50byBhbm90aGVyIGNvb3JkaW5hdGUgc3lzdGVtLiBDb250ZXh0IG1heSBiZSBvbmUgb2ZcclxuICAvLyBcImxpbmVcIiwgXCJkaXZcIiAoZGlzcGxheS5saW5lRGl2KSwgXCJsb2NhbFwiL251bGwgKGVkaXRvciksIFwid2luZG93XCIsXHJcbiAgLy8gb3IgXCJwYWdlXCIuXHJcbiAgZnVuY3Rpb24gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCByZWN0LCBjb250ZXh0KSB7XHJcbiAgICBpZiAobGluZU9iai53aWRnZXRzKSBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVPYmoud2lkZ2V0cy5sZW5ndGg7ICsraSkgaWYgKGxpbmVPYmoud2lkZ2V0c1tpXS5hYm92ZSkge1xyXG4gICAgICB2YXIgc2l6ZSA9IHdpZGdldEhlaWdodChsaW5lT2JqLndpZGdldHNbaV0pO1xyXG4gICAgICByZWN0LnRvcCArPSBzaXplOyByZWN0LmJvdHRvbSArPSBzaXplO1xyXG4gICAgfVxyXG4gICAgaWYgKGNvbnRleHQgPT0gXCJsaW5lXCIpIHJldHVybiByZWN0O1xyXG4gICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gXCJsb2NhbFwiO1xyXG4gICAgdmFyIHlPZmYgPSBoZWlnaHRBdExpbmUobGluZU9iaik7XHJcbiAgICBpZiAoY29udGV4dCA9PSBcImxvY2FsXCIpIHlPZmYgKz0gcGFkZGluZ1RvcChjbS5kaXNwbGF5KTtcclxuICAgIGVsc2UgeU9mZiAtPSBjbS5kaXNwbGF5LnZpZXdPZmZzZXQ7XHJcbiAgICBpZiAoY29udGV4dCA9PSBcInBhZ2VcIiB8fCBjb250ZXh0ID09IFwid2luZG93XCIpIHtcclxuICAgICAgdmFyIGxPZmYgPSBjbS5kaXNwbGF5LmxpbmVTcGFjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgeU9mZiArPSBsT2ZmLnRvcCArIChjb250ZXh0ID09IFwid2luZG93XCIgPyAwIDogcGFnZVNjcm9sbFkoKSk7XHJcbiAgICAgIHZhciB4T2ZmID0gbE9mZi5sZWZ0ICsgKGNvbnRleHQgPT0gXCJ3aW5kb3dcIiA/IDAgOiBwYWdlU2Nyb2xsWCgpKTtcclxuICAgICAgcmVjdC5sZWZ0ICs9IHhPZmY7IHJlY3QucmlnaHQgKz0geE9mZjtcclxuICAgIH1cclxuICAgIHJlY3QudG9wICs9IHlPZmY7IHJlY3QuYm90dG9tICs9IHlPZmY7XHJcbiAgICByZXR1cm4gcmVjdDtcclxuICB9XHJcblxyXG4gIC8vIENvdmVydHMgYSBib3ggZnJvbSBcImRpdlwiIGNvb3JkcyB0byBhbm90aGVyIGNvb3JkaW5hdGUgc3lzdGVtLlxyXG4gIC8vIENvbnRleHQgbWF5IGJlIFwid2luZG93XCIsIFwicGFnZVwiLCBcImRpdlwiLCBvciBcImxvY2FsXCIvbnVsbC5cclxuICBmdW5jdGlvbiBmcm9tQ29vcmRTeXN0ZW0oY20sIGNvb3JkcywgY29udGV4dCkge1xyXG4gICAgaWYgKGNvbnRleHQgPT0gXCJkaXZcIikgcmV0dXJuIGNvb3JkcztcclxuICAgIHZhciBsZWZ0ID0gY29vcmRzLmxlZnQsIHRvcCA9IGNvb3Jkcy50b3A7XHJcbiAgICAvLyBGaXJzdCBtb3ZlIGludG8gXCJwYWdlXCIgY29vcmRpbmF0ZSBzeXN0ZW1cclxuICAgIGlmIChjb250ZXh0ID09IFwicGFnZVwiKSB7XHJcbiAgICAgIGxlZnQgLT0gcGFnZVNjcm9sbFgoKTtcclxuICAgICAgdG9wIC09IHBhZ2VTY3JvbGxZKCk7XHJcbiAgICB9IGVsc2UgaWYgKGNvbnRleHQgPT0gXCJsb2NhbFwiIHx8ICFjb250ZXh0KSB7XHJcbiAgICAgIHZhciBsb2NhbEJveCA9IGNtLmRpc3BsYXkuc2l6ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgIGxlZnQgKz0gbG9jYWxCb3gubGVmdDtcclxuICAgICAgdG9wICs9IGxvY2FsQm94LnRvcDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbGluZVNwYWNlQm94ID0gY20uZGlzcGxheS5saW5lU3BhY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICByZXR1cm4ge2xlZnQ6IGxlZnQgLSBsaW5lU3BhY2VCb3gubGVmdCwgdG9wOiB0b3AgLSBsaW5lU3BhY2VCb3gudG9wfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNoYXJDb29yZHMoY20sIHBvcywgY29udGV4dCwgbGluZU9iaiwgYmlhcykge1xyXG4gICAgaWYgKCFsaW5lT2JqKSBsaW5lT2JqID0gZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKTtcclxuICAgIHJldHVybiBpbnRvQ29vcmRTeXN0ZW0oY20sIGxpbmVPYmosIG1lYXN1cmVDaGFyKGNtLCBsaW5lT2JqLCBwb3MuY2gsIGJpYXMpLCBjb250ZXh0KTtcclxuICB9XHJcblxyXG4gIC8vIFJldHVybnMgYSBib3ggZm9yIGEgZ2l2ZW4gY3Vyc29yIHBvc2l0aW9uLCB3aGljaCBtYXkgaGF2ZSBhblxyXG4gIC8vICdvdGhlcicgcHJvcGVydHkgY29udGFpbmluZyB0aGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZGFyeSBjdXJzb3JcclxuICAvLyBvbiBhIGJpZGkgYm91bmRhcnkuXHJcbiAgZnVuY3Rpb24gY3Vyc29yQ29vcmRzKGNtLCBwb3MsIGNvbnRleHQsIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSwgdmFySGVpZ2h0KSB7XHJcbiAgICBsaW5lT2JqID0gbGluZU9iaiB8fCBnZXRMaW5lKGNtLmRvYywgcG9zLmxpbmUpO1xyXG4gICAgaWYgKCFwcmVwYXJlZE1lYXN1cmUpIHByZXBhcmVkTWVhc3VyZSA9IHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZU9iaik7XHJcbiAgICBmdW5jdGlvbiBnZXQoY2gsIHJpZ2h0KSB7XHJcbiAgICAgIHZhciBtID0gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWRNZWFzdXJlLCBjaCwgcmlnaHQgPyBcInJpZ2h0XCIgOiBcImxlZnRcIiwgdmFySGVpZ2h0KTtcclxuICAgICAgaWYgKHJpZ2h0KSBtLmxlZnQgPSBtLnJpZ2h0OyBlbHNlIG0ucmlnaHQgPSBtLmxlZnQ7XHJcbiAgICAgIHJldHVybiBpbnRvQ29vcmRTeXN0ZW0oY20sIGxpbmVPYmosIG0sIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0QmlkaShjaCwgcGFydFBvcykge1xyXG4gICAgICB2YXIgcGFydCA9IG9yZGVyW3BhcnRQb3NdLCByaWdodCA9IHBhcnQubGV2ZWwgJSAyO1xyXG4gICAgICBpZiAoY2ggPT0gYmlkaUxlZnQocGFydCkgJiYgcGFydFBvcyAmJiBwYXJ0LmxldmVsIDwgb3JkZXJbcGFydFBvcyAtIDFdLmxldmVsKSB7XHJcbiAgICAgICAgcGFydCA9IG9yZGVyWy0tcGFydFBvc107XHJcbiAgICAgICAgY2ggPSBiaWRpUmlnaHQocGFydCkgLSAocGFydC5sZXZlbCAlIDIgPyAwIDogMSk7XHJcbiAgICAgICAgcmlnaHQgPSB0cnVlO1xyXG4gICAgICB9IGVsc2UgaWYgKGNoID09IGJpZGlSaWdodChwYXJ0KSAmJiBwYXJ0UG9zIDwgb3JkZXIubGVuZ3RoIC0gMSAmJiBwYXJ0LmxldmVsIDwgb3JkZXJbcGFydFBvcyArIDFdLmxldmVsKSB7XHJcbiAgICAgICAgcGFydCA9IG9yZGVyWysrcGFydFBvc107XHJcbiAgICAgICAgY2ggPSBiaWRpTGVmdChwYXJ0KSAtIHBhcnQubGV2ZWwgJSAyO1xyXG4gICAgICAgIHJpZ2h0ID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJpZ2h0ICYmIGNoID09IHBhcnQudG8gJiYgY2ggPiBwYXJ0LmZyb20pIHJldHVybiBnZXQoY2ggLSAxKTtcclxuICAgICAgcmV0dXJuIGdldChjaCwgcmlnaHQpO1xyXG4gICAgfVxyXG4gICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZU9iaiksIGNoID0gcG9zLmNoO1xyXG4gICAgaWYgKCFvcmRlcikgcmV0dXJuIGdldChjaCk7XHJcbiAgICB2YXIgcGFydFBvcyA9IGdldEJpZGlQYXJ0QXQob3JkZXIsIGNoKTtcclxuICAgIHZhciB2YWwgPSBnZXRCaWRpKGNoLCBwYXJ0UG9zKTtcclxuICAgIGlmIChiaWRpT3RoZXIgIT0gbnVsbCkgdmFsLm90aGVyID0gZ2V0QmlkaShjaCwgYmlkaU90aGVyKTtcclxuICAgIHJldHVybiB2YWw7XHJcbiAgfVxyXG5cclxuICAvLyBVc2VkIHRvIGNoZWFwbHkgZXN0aW1hdGUgdGhlIGNvb3JkaW5hdGVzIGZvciBhIHBvc2l0aW9uLiBVc2VkIGZvclxyXG4gIC8vIGludGVybWVkaWF0ZSBzY3JvbGwgdXBkYXRlcy5cclxuICBmdW5jdGlvbiBlc3RpbWF0ZUNvb3JkcyhjbSwgcG9zKSB7XHJcbiAgICB2YXIgbGVmdCA9IDAsIHBvcyA9IGNsaXBQb3MoY20uZG9jLCBwb3MpO1xyXG4gICAgaWYgKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykgbGVmdCA9IGNoYXJXaWR0aChjbS5kaXNwbGF5KSAqIHBvcy5jaDtcclxuICAgIHZhciBsaW5lT2JqID0gZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKTtcclxuICAgIHZhciB0b3AgPSBoZWlnaHRBdExpbmUobGluZU9iaikgKyBwYWRkaW5nVG9wKGNtLmRpc3BsYXkpO1xyXG4gICAgcmV0dXJuIHtsZWZ0OiBsZWZ0LCByaWdodDogbGVmdCwgdG9wOiB0b3AsIGJvdHRvbTogdG9wICsgbGluZU9iai5oZWlnaHR9O1xyXG4gIH1cclxuXHJcbiAgLy8gUG9zaXRpb25zIHJldHVybmVkIGJ5IGNvb3Jkc0NoYXIgY29udGFpbiBzb21lIGV4dHJhIGluZm9ybWF0aW9uLlxyXG4gIC8vIHhSZWwgaXMgdGhlIHJlbGF0aXZlIHggcG9zaXRpb24gb2YgdGhlIGlucHV0IGNvb3JkaW5hdGVzIGNvbXBhcmVkXHJcbiAgLy8gdG8gdGhlIGZvdW5kIHBvc2l0aW9uIChzbyB4UmVsID4gMCBtZWFucyB0aGUgY29vcmRpbmF0ZXMgYXJlIHRvXHJcbiAgLy8gdGhlIHJpZ2h0IG9mIHRoZSBjaGFyYWN0ZXIgcG9zaXRpb24sIGZvciBleGFtcGxlKS4gV2hlbiBvdXRzaWRlXHJcbiAgLy8gaXMgdHJ1ZSwgdGhhdCBtZWFucyB0aGUgY29vcmRpbmF0ZXMgbGllIG91dHNpZGUgdGhlIGxpbmUnc1xyXG4gIC8vIHZlcnRpY2FsIHJhbmdlLlxyXG4gIGZ1bmN0aW9uIFBvc1dpdGhJbmZvKGxpbmUsIGNoLCBvdXRzaWRlLCB4UmVsKSB7XHJcbiAgICB2YXIgcG9zID0gUG9zKGxpbmUsIGNoKTtcclxuICAgIHBvcy54UmVsID0geFJlbDtcclxuICAgIGlmIChvdXRzaWRlKSBwb3Mub3V0c2lkZSA9IHRydWU7XHJcbiAgICByZXR1cm4gcG9zO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29tcHV0ZSB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uIGNsb3Nlc3QgdG8gdGhlIGdpdmVuIGNvb3JkaW5hdGVzLlxyXG4gIC8vIElucHV0IG11c3QgYmUgbGluZVNwYWNlLWxvY2FsIChcImRpdlwiIGNvb3JkaW5hdGUgc3lzdGVtKS5cclxuICBmdW5jdGlvbiBjb29yZHNDaGFyKGNtLCB4LCB5KSB7XHJcbiAgICB2YXIgZG9jID0gY20uZG9jO1xyXG4gICAgeSArPSBjbS5kaXNwbGF5LnZpZXdPZmZzZXQ7XHJcbiAgICBpZiAoeSA8IDApIHJldHVybiBQb3NXaXRoSW5mbyhkb2MuZmlyc3QsIDAsIHRydWUsIC0xKTtcclxuICAgIHZhciBsaW5lTiA9IGxpbmVBdEhlaWdodChkb2MsIHkpLCBsYXN0ID0gZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxO1xyXG4gICAgaWYgKGxpbmVOID4gbGFzdClcclxuICAgICAgcmV0dXJuIFBvc1dpdGhJbmZvKGRvYy5maXJzdCArIGRvYy5zaXplIC0gMSwgZ2V0TGluZShkb2MsIGxhc3QpLnRleHQubGVuZ3RoLCB0cnVlLCAxKTtcclxuICAgIGlmICh4IDwgMCkgeCA9IDA7XHJcblxyXG4gICAgdmFyIGxpbmVPYmogPSBnZXRMaW5lKGRvYywgbGluZU4pO1xyXG4gICAgZm9yICg7Oykge1xyXG4gICAgICB2YXIgZm91bmQgPSBjb29yZHNDaGFySW5uZXIoY20sIGxpbmVPYmosIGxpbmVOLCB4LCB5KTtcclxuICAgICAgdmFyIG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdEVuZChsaW5lT2JqKTtcclxuICAgICAgdmFyIG1lcmdlZFBvcyA9IG1lcmdlZCAmJiBtZXJnZWQuZmluZCgwLCB0cnVlKTtcclxuICAgICAgaWYgKG1lcmdlZCAmJiAoZm91bmQuY2ggPiBtZXJnZWRQb3MuZnJvbS5jaCB8fCBmb3VuZC5jaCA9PSBtZXJnZWRQb3MuZnJvbS5jaCAmJiBmb3VuZC54UmVsID4gMCkpXHJcbiAgICAgICAgbGluZU4gPSBsaW5lTm8obGluZU9iaiA9IG1lcmdlZFBvcy50by5saW5lKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBmb3VuZDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNvb3Jkc0NoYXJJbm5lcihjbSwgbGluZU9iaiwgbGluZU5vLCB4LCB5KSB7XHJcbiAgICB2YXIgaW5uZXJPZmYgPSB5IC0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopO1xyXG4gICAgdmFyIHdyb25nTGluZSA9IGZhbHNlLCBhZGp1c3QgPSAyICogY20uZGlzcGxheS53cmFwcGVyLmNsaWVudFdpZHRoO1xyXG4gICAgdmFyIHByZXBhcmVkTWVhc3VyZSA9IHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZU9iaik7XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0WChjaCkge1xyXG4gICAgICB2YXIgc3AgPSBjdXJzb3JDb29yZHMoY20sIFBvcyhsaW5lTm8sIGNoKSwgXCJsaW5lXCIsIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSk7XHJcbiAgICAgIHdyb25nTGluZSA9IHRydWU7XHJcbiAgICAgIGlmIChpbm5lck9mZiA+IHNwLmJvdHRvbSkgcmV0dXJuIHNwLmxlZnQgLSBhZGp1c3Q7XHJcbiAgICAgIGVsc2UgaWYgKGlubmVyT2ZmIDwgc3AudG9wKSByZXR1cm4gc3AubGVmdCArIGFkanVzdDtcclxuICAgICAgZWxzZSB3cm9uZ0xpbmUgPSBmYWxzZTtcclxuICAgICAgcmV0dXJuIHNwLmxlZnQ7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGJpZGkgPSBnZXRPcmRlcihsaW5lT2JqKSwgZGlzdCA9IGxpbmVPYmoudGV4dC5sZW5ndGg7XHJcbiAgICB2YXIgZnJvbSA9IGxpbmVMZWZ0KGxpbmVPYmopLCB0byA9IGxpbmVSaWdodChsaW5lT2JqKTtcclxuICAgIHZhciBmcm9tWCA9IGdldFgoZnJvbSksIGZyb21PdXRzaWRlID0gd3JvbmdMaW5lLCB0b1ggPSBnZXRYKHRvKSwgdG9PdXRzaWRlID0gd3JvbmdMaW5lO1xyXG5cclxuICAgIGlmICh4ID4gdG9YKSByZXR1cm4gUG9zV2l0aEluZm8obGluZU5vLCB0bywgdG9PdXRzaWRlLCAxKTtcclxuICAgIC8vIERvIGEgYmluYXJ5IHNlYXJjaCBiZXR3ZWVuIHRoZXNlIGJvdW5kcy5cclxuICAgIGZvciAoOzspIHtcclxuICAgICAgaWYgKGJpZGkgPyB0byA9PSBmcm9tIHx8IHRvID09IG1vdmVWaXN1YWxseShsaW5lT2JqLCBmcm9tLCAxKSA6IHRvIC0gZnJvbSA8PSAxKSB7XHJcbiAgICAgICAgdmFyIGNoID0geCA8IGZyb21YIHx8IHggLSBmcm9tWCA8PSB0b1ggLSB4ID8gZnJvbSA6IHRvO1xyXG4gICAgICAgIHZhciB4RGlmZiA9IHggLSAoY2ggPT0gZnJvbSA/IGZyb21YIDogdG9YKTtcclxuICAgICAgICB3aGlsZSAoaXNFeHRlbmRpbmdDaGFyKGxpbmVPYmoudGV4dC5jaGFyQXQoY2gpKSkgKytjaDtcclxuICAgICAgICB2YXIgcG9zID0gUG9zV2l0aEluZm8obGluZU5vLCBjaCwgY2ggPT0gZnJvbSA/IGZyb21PdXRzaWRlIDogdG9PdXRzaWRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4RGlmZiA8IC0xID8gLTEgOiB4RGlmZiA+IDEgPyAxIDogMCk7XHJcbiAgICAgICAgcmV0dXJuIHBvcztcclxuICAgICAgfVxyXG4gICAgICB2YXIgc3RlcCA9IE1hdGguY2VpbChkaXN0IC8gMiksIG1pZGRsZSA9IGZyb20gKyBzdGVwO1xyXG4gICAgICBpZiAoYmlkaSkge1xyXG4gICAgICAgIG1pZGRsZSA9IGZyb207XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGVwOyArK2kpIG1pZGRsZSA9IG1vdmVWaXN1YWxseShsaW5lT2JqLCBtaWRkbGUsIDEpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBtaWRkbGVYID0gZ2V0WChtaWRkbGUpO1xyXG4gICAgICBpZiAobWlkZGxlWCA+IHgpIHt0byA9IG1pZGRsZTsgdG9YID0gbWlkZGxlWDsgaWYgKHRvT3V0c2lkZSA9IHdyb25nTGluZSkgdG9YICs9IDEwMDA7IGRpc3QgPSBzdGVwO31cclxuICAgICAgZWxzZSB7ZnJvbSA9IG1pZGRsZTsgZnJvbVggPSBtaWRkbGVYOyBmcm9tT3V0c2lkZSA9IHdyb25nTGluZTsgZGlzdCAtPSBzdGVwO31cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBtZWFzdXJlVGV4dDtcclxuICAvLyBDb21wdXRlIHRoZSBkZWZhdWx0IHRleHQgaGVpZ2h0LlxyXG4gIGZ1bmN0aW9uIHRleHRIZWlnaHQoZGlzcGxheSkge1xyXG4gICAgaWYgKGRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodCAhPSBudWxsKSByZXR1cm4gZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0O1xyXG4gICAgaWYgKG1lYXN1cmVUZXh0ID09IG51bGwpIHtcclxuICAgICAgbWVhc3VyZVRleHQgPSBlbHQoXCJwcmVcIik7XHJcbiAgICAgIC8vIE1lYXN1cmUgYSBidW5jaCBvZiBsaW5lcywgZm9yIGJyb3dzZXJzIHRoYXQgY29tcHV0ZVxyXG4gICAgICAvLyBmcmFjdGlvbmFsIGhlaWdodHMuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDk7ICsraSkge1xyXG4gICAgICAgIG1lYXN1cmVUZXh0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwieFwiKSk7XHJcbiAgICAgICAgbWVhc3VyZVRleHQuYXBwZW5kQ2hpbGQoZWx0KFwiYnJcIikpO1xyXG4gICAgICB9XHJcbiAgICAgIG1lYXN1cmVUZXh0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwieFwiKSk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5Lm1lYXN1cmUsIG1lYXN1cmVUZXh0KTtcclxuICAgIHZhciBoZWlnaHQgPSBtZWFzdXJlVGV4dC5vZmZzZXRIZWlnaHQgLyA1MDtcclxuICAgIGlmIChoZWlnaHQgPiAzKSBkaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICByZW1vdmVDaGlsZHJlbihkaXNwbGF5Lm1lYXN1cmUpO1xyXG4gICAgcmV0dXJuIGhlaWdodCB8fCAxO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29tcHV0ZSB0aGUgZGVmYXVsdCBjaGFyYWN0ZXIgd2lkdGguXHJcbiAgZnVuY3Rpb24gY2hhcldpZHRoKGRpc3BsYXkpIHtcclxuICAgIGlmIChkaXNwbGF5LmNhY2hlZENoYXJXaWR0aCAhPSBudWxsKSByZXR1cm4gZGlzcGxheS5jYWNoZWRDaGFyV2lkdGg7XHJcbiAgICB2YXIgYW5jaG9yID0gZWx0KFwic3BhblwiLCBcInh4eHh4eHh4eHhcIik7XHJcbiAgICB2YXIgcHJlID0gZWx0KFwicHJlXCIsIFthbmNob3JdKTtcclxuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkubWVhc3VyZSwgcHJlKTtcclxuICAgIHZhciByZWN0ID0gYW5jaG9yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB3aWR0aCA9IChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSAvIDEwO1xyXG4gICAgaWYgKHdpZHRoID4gMikgZGlzcGxheS5jYWNoZWRDaGFyV2lkdGggPSB3aWR0aDtcclxuICAgIHJldHVybiB3aWR0aCB8fCAxMDtcclxuICB9XHJcblxyXG4gIC8vIE9QRVJBVElPTlNcclxuXHJcbiAgLy8gT3BlcmF0aW9ucyBhcmUgdXNlZCB0byB3cmFwIGEgc2VyaWVzIG9mIGNoYW5nZXMgdG8gdGhlIGVkaXRvclxyXG4gIC8vIHN0YXRlIGluIHN1Y2ggYSB3YXkgdGhhdCBlYWNoIGNoYW5nZSB3b24ndCBoYXZlIHRvIHVwZGF0ZSB0aGVcclxuICAvLyBjdXJzb3IgYW5kIGRpc3BsYXkgKHdoaWNoIHdvdWxkIGJlIGF3a3dhcmQsIHNsb3csIGFuZFxyXG4gIC8vIGVycm9yLXByb25lKS4gSW5zdGVhZCwgZGlzcGxheSB1cGRhdGVzIGFyZSBiYXRjaGVkIGFuZCB0aGVuIGFsbFxyXG4gIC8vIGNvbWJpbmVkIGFuZCBleGVjdXRlZCBhdCBvbmNlLlxyXG5cclxuICB2YXIgb3BlcmF0aW9uR3JvdXAgPSBudWxsO1xyXG5cclxuICB2YXIgbmV4dE9wSWQgPSAwO1xyXG4gIC8vIFN0YXJ0IGEgbmV3IG9wZXJhdGlvbi5cclxuICBmdW5jdGlvbiBzdGFydE9wZXJhdGlvbihjbSkge1xyXG4gICAgY20uY3VyT3AgPSB7XHJcbiAgICAgIGNtOiBjbSxcclxuICAgICAgdmlld0NoYW5nZWQ6IGZhbHNlLCAgICAgIC8vIEZsYWcgdGhhdCBpbmRpY2F0ZXMgdGhhdCBsaW5lcyBtaWdodCBuZWVkIHRvIGJlIHJlZHJhd25cclxuICAgICAgc3RhcnRIZWlnaHQ6IGNtLmRvYy5oZWlnaHQsIC8vIFVzZWQgdG8gZGV0ZWN0IG5lZWQgdG8gdXBkYXRlIHNjcm9sbGJhclxyXG4gICAgICBmb3JjZVVwZGF0ZTogZmFsc2UsICAgICAgLy8gVXNlZCB0byBmb3JjZSBhIHJlZHJhd1xyXG4gICAgICB1cGRhdGVJbnB1dDogbnVsbCwgICAgICAgLy8gV2hldGhlciB0byByZXNldCB0aGUgaW5wdXQgdGV4dGFyZWFcclxuICAgICAgdHlwaW5nOiBmYWxzZSwgICAgICAgICAgIC8vIFdoZXRoZXIgdGhpcyByZXNldCBzaG91bGQgYmUgY2FyZWZ1bCB0byBsZWF2ZSBleGlzdGluZyB0ZXh0IChmb3IgY29tcG9zaXRpbmcpXHJcbiAgICAgIGNoYW5nZU9ianM6IG51bGwsICAgICAgICAvLyBBY2N1bXVsYXRlZCBjaGFuZ2VzLCBmb3IgZmlyaW5nIGNoYW5nZSBldmVudHNcclxuICAgICAgY3Vyc29yQWN0aXZpdHlIYW5kbGVyczogbnVsbCwgLy8gU2V0IG9mIGhhbmRsZXJzIHRvIGZpcmUgY3Vyc29yQWN0aXZpdHkgb25cclxuICAgICAgY3Vyc29yQWN0aXZpdHlDYWxsZWQ6IDAsIC8vIFRyYWNrcyB3aGljaCBjdXJzb3JBY3Rpdml0eSBoYW5kbGVycyBoYXZlIGJlZW4gY2FsbGVkIGFscmVhZHlcclxuICAgICAgc2VsZWN0aW9uQ2hhbmdlZDogZmFsc2UsIC8vIFdoZXRoZXIgdGhlIHNlbGVjdGlvbiBuZWVkcyB0byBiZSByZWRyYXduXHJcbiAgICAgIHVwZGF0ZU1heExpbmU6IGZhbHNlLCAgICAvLyBTZXQgd2hlbiB0aGUgd2lkZXN0IGxpbmUgbmVlZHMgdG8gYmUgZGV0ZXJtaW5lZCBhbmV3XHJcbiAgICAgIHNjcm9sbExlZnQ6IG51bGwsIHNjcm9sbFRvcDogbnVsbCwgLy8gSW50ZXJtZWRpYXRlIHNjcm9sbCBwb3NpdGlvbiwgbm90IHB1c2hlZCB0byBET00geWV0XHJcbiAgICAgIHNjcm9sbFRvUG9zOiBudWxsLCAgICAgICAvLyBVc2VkIHRvIHNjcm9sbCB0byBhIHNwZWNpZmljIHBvc2l0aW9uXHJcbiAgICAgIGlkOiArK25leHRPcElkICAgICAgICAgICAvLyBVbmlxdWUgSURcclxuICAgIH07XHJcbiAgICBpZiAob3BlcmF0aW9uR3JvdXApIHtcclxuICAgICAgb3BlcmF0aW9uR3JvdXAub3BzLnB1c2goY20uY3VyT3ApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY20uY3VyT3Aub3duc0dyb3VwID0gb3BlcmF0aW9uR3JvdXAgPSB7XHJcbiAgICAgICAgb3BzOiBbY20uY3VyT3BdLFxyXG4gICAgICAgIGRlbGF5ZWRDYWxsYmFja3M6IFtdXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmaXJlQ2FsbGJhY2tzRm9yT3BzKGdyb3VwKSB7XHJcbiAgICAvLyBDYWxscyBkZWxheWVkIGNhbGxiYWNrcyBhbmQgY3Vyc29yQWN0aXZpdHkgaGFuZGxlcnMgdW50aWwgbm9cclxuICAgIC8vIG5ldyBvbmVzIGFwcGVhclxyXG4gICAgdmFyIGNhbGxiYWNrcyA9IGdyb3VwLmRlbGF5ZWRDYWxsYmFja3MsIGkgPSAwO1xyXG4gICAgZG8ge1xyXG4gICAgICBmb3IgKDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKylcclxuICAgICAgICBjYWxsYmFja3NbaV0oKTtcclxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBncm91cC5vcHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICB2YXIgb3AgPSBncm91cC5vcHNbal07XHJcbiAgICAgICAgaWYgKG9wLmN1cnNvckFjdGl2aXR5SGFuZGxlcnMpXHJcbiAgICAgICAgICB3aGlsZSAob3AuY3Vyc29yQWN0aXZpdHlDYWxsZWQgPCBvcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzLmxlbmd0aClcclxuICAgICAgICAgICAgb3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVyc1tvcC5jdXJzb3JBY3Rpdml0eUNhbGxlZCsrXShvcC5jbSk7XHJcbiAgICAgIH1cclxuICAgIH0gd2hpbGUgKGkgPCBjYWxsYmFja3MubGVuZ3RoKTtcclxuICB9XHJcblxyXG4gIC8vIEZpbmlzaCBhbiBvcGVyYXRpb24sIHVwZGF0aW5nIHRoZSBkaXNwbGF5IGFuZCBzaWduYWxsaW5nIGRlbGF5ZWQgZXZlbnRzXHJcbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uKGNtKSB7XHJcbiAgICB2YXIgb3AgPSBjbS5jdXJPcCwgZ3JvdXAgPSBvcC5vd25zR3JvdXA7XHJcbiAgICBpZiAoIWdyb3VwKSByZXR1cm47XHJcblxyXG4gICAgdHJ5IHsgZmlyZUNhbGxiYWNrc0Zvck9wcyhncm91cCk7IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICBvcGVyYXRpb25Hcm91cCA9IG51bGw7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAub3BzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGdyb3VwLm9wc1tpXS5jbS5jdXJPcCA9IG51bGw7XHJcbiAgICAgIGVuZE9wZXJhdGlvbnMoZ3JvdXApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gVGhlIERPTSB1cGRhdGVzIGRvbmUgd2hlbiBhbiBvcGVyYXRpb24gZmluaXNoZXMgYXJlIGJhdGNoZWQgc29cclxuICAvLyB0aGF0IHRoZSBtaW5pbXVtIG51bWJlciBvZiByZWxheW91dHMgYXJlIHJlcXVpcmVkLlxyXG4gIGZ1bmN0aW9uIGVuZE9wZXJhdGlvbnMoZ3JvdXApIHtcclxuICAgIHZhciBvcHMgPSBncm91cC5vcHM7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykgLy8gUmVhZCBET01cclxuICAgICAgZW5kT3BlcmF0aW9uX1IxKG9wc1tpXSk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykgLy8gV3JpdGUgRE9NIChtYXliZSlcclxuICAgICAgZW5kT3BlcmF0aW9uX1cxKG9wc1tpXSk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykgLy8gUmVhZCBET01cclxuICAgICAgZW5kT3BlcmF0aW9uX1IyKG9wc1tpXSk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykgLy8gV3JpdGUgRE9NIChtYXliZSlcclxuICAgICAgZW5kT3BlcmF0aW9uX1cyKG9wc1tpXSk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykgLy8gUmVhZCBET01cclxuICAgICAgZW5kT3BlcmF0aW9uX2ZpbmlzaChvcHNbaV0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uX1IxKG9wKSB7XHJcbiAgICB2YXIgY20gPSBvcC5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXk7XHJcbiAgICBtYXliZUNsaXBTY3JvbGxiYXJzKGNtKTtcclxuICAgIGlmIChvcC51cGRhdGVNYXhMaW5lKSBmaW5kTWF4TGluZShjbSk7XHJcblxyXG4gICAgb3AubXVzdFVwZGF0ZSA9IG9wLnZpZXdDaGFuZ2VkIHx8IG9wLmZvcmNlVXBkYXRlIHx8IG9wLnNjcm9sbFRvcCAhPSBudWxsIHx8XHJcbiAgICAgIG9wLnNjcm9sbFRvUG9zICYmIChvcC5zY3JvbGxUb1Bvcy5mcm9tLmxpbmUgPCBkaXNwbGF5LnZpZXdGcm9tIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBvcC5zY3JvbGxUb1Bvcy50by5saW5lID49IGRpc3BsYXkudmlld1RvKSB8fFxyXG4gICAgICBkaXNwbGF5Lm1heExpbmVDaGFuZ2VkICYmIGNtLm9wdGlvbnMubGluZVdyYXBwaW5nO1xyXG4gICAgb3AudXBkYXRlID0gb3AubXVzdFVwZGF0ZSAmJlxyXG4gICAgICBuZXcgRGlzcGxheVVwZGF0ZShjbSwgb3AubXVzdFVwZGF0ZSAmJiB7dG9wOiBvcC5zY3JvbGxUb3AsIGVuc3VyZTogb3Auc2Nyb2xsVG9Qb3N9LCBvcC5mb3JjZVVwZGF0ZSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBlbmRPcGVyYXRpb25fVzEob3ApIHtcclxuICAgIG9wLnVwZGF0ZWREaXNwbGF5ID0gb3AubXVzdFVwZGF0ZSAmJiB1cGRhdGVEaXNwbGF5SWZOZWVkZWQob3AuY20sIG9wLnVwZGF0ZSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBlbmRPcGVyYXRpb25fUjIob3ApIHtcclxuICAgIHZhciBjbSA9IG9wLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcclxuICAgIGlmIChvcC51cGRhdGVkRGlzcGxheSkgdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pO1xyXG5cclxuICAgIG9wLmJhck1lYXN1cmUgPSBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSk7XHJcblxyXG4gICAgLy8gSWYgdGhlIG1heCBsaW5lIGNoYW5nZWQgc2luY2UgaXQgd2FzIGxhc3QgbWVhc3VyZWQsIG1lYXN1cmUgaXQsXHJcbiAgICAvLyBhbmQgZW5zdXJlIHRoZSBkb2N1bWVudCdzIHdpZHRoIG1hdGNoZXMgaXQuXHJcbiAgICAvLyB1cGRhdGVEaXNwbGF5X1cyIHdpbGwgdXNlIHRoZXNlIHByb3BlcnRpZXMgdG8gZG8gdGhlIGFjdHVhbCByZXNpemluZ1xyXG4gICAgaWYgKGRpc3BsYXkubWF4TGluZUNoYW5nZWQgJiYgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XHJcbiAgICAgIG9wLmFkanVzdFdpZHRoVG8gPSBtZWFzdXJlQ2hhcihjbSwgZGlzcGxheS5tYXhMaW5lLCBkaXNwbGF5Lm1heExpbmUudGV4dC5sZW5ndGgpLmxlZnQgKyAzO1xyXG4gICAgICBjbS5kaXNwbGF5LnNpemVyV2lkdGggPSBvcC5hZGp1c3RXaWR0aFRvO1xyXG4gICAgICBvcC5iYXJNZWFzdXJlLnNjcm9sbFdpZHRoID1cclxuICAgICAgICBNYXRoLm1heChkaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoLCBkaXNwbGF5LnNpemVyLm9mZnNldExlZnQgKyBvcC5hZGp1c3RXaWR0aFRvICsgc2Nyb2xsR2FwKGNtKSArIGNtLmRpc3BsYXkuYmFyV2lkdGgpO1xyXG4gICAgICBvcC5tYXhTY3JvbGxMZWZ0ID0gTWF0aC5tYXgoMCwgZGlzcGxheS5zaXplci5vZmZzZXRMZWZ0ICsgb3AuYWRqdXN0V2lkdGhUbyAtIGRpc3BsYXlXaWR0aChjbSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvcC51cGRhdGVkRGlzcGxheSB8fCBvcC5zZWxlY3Rpb25DaGFuZ2VkKVxyXG4gICAgICBvcC5wcmVwYXJlZFNlbGVjdGlvbiA9IGRpc3BsYXkuaW5wdXQucHJlcGFyZVNlbGVjdGlvbigpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uX1cyKG9wKSB7XHJcbiAgICB2YXIgY20gPSBvcC5jbTtcclxuXHJcbiAgICBpZiAob3AuYWRqdXN0V2lkdGhUbyAhPSBudWxsKSB7XHJcbiAgICAgIGNtLmRpc3BsYXkuc2l6ZXIuc3R5bGUubWluV2lkdGggPSBvcC5hZGp1c3RXaWR0aFRvICsgXCJweFwiO1xyXG4gICAgICBpZiAob3AubWF4U2Nyb2xsTGVmdCA8IGNtLmRvYy5zY3JvbGxMZWZ0KVxyXG4gICAgICAgIHNldFNjcm9sbExlZnQoY20sIE1hdGgubWluKGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCwgb3AubWF4U2Nyb2xsTGVmdCksIHRydWUpO1xyXG4gICAgICBjbS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wLnByZXBhcmVkU2VsZWN0aW9uKVxyXG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnNob3dTZWxlY3Rpb24ob3AucHJlcGFyZWRTZWxlY3Rpb24pO1xyXG4gICAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5KVxyXG4gICAgICBzZXREb2N1bWVudEhlaWdodChjbSwgb3AuYmFyTWVhc3VyZSk7XHJcbiAgICBpZiAob3AudXBkYXRlZERpc3BsYXkgfHwgb3Auc3RhcnRIZWlnaHQgIT0gY20uZG9jLmhlaWdodClcclxuICAgICAgdXBkYXRlU2Nyb2xsYmFycyhjbSwgb3AuYmFyTWVhc3VyZSk7XHJcblxyXG4gICAgaWYgKG9wLnNlbGVjdGlvbkNoYW5nZWQpIHJlc3RhcnRCbGluayhjbSk7XHJcblxyXG4gICAgaWYgKGNtLnN0YXRlLmZvY3VzZWQgJiYgb3AudXBkYXRlSW5wdXQpXHJcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQucmVzZXQob3AudHlwaW5nKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9maW5pc2gob3ApIHtcclxuICAgIHZhciBjbSA9IG9wLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jO1xyXG5cclxuICAgIGlmIChvcC51cGRhdGVkRGlzcGxheSkgcG9zdFVwZGF0ZURpc3BsYXkoY20sIG9wLnVwZGF0ZSk7XHJcblxyXG4gICAgLy8gQWJvcnQgbW91c2Ugd2hlZWwgZGVsdGEgbWVhc3VyZW1lbnQsIHdoZW4gc2Nyb2xsaW5nIGV4cGxpY2l0bHlcclxuICAgIGlmIChkaXNwbGF5LndoZWVsU3RhcnRYICE9IG51bGwgJiYgKG9wLnNjcm9sbFRvcCAhPSBudWxsIHx8IG9wLnNjcm9sbExlZnQgIT0gbnVsbCB8fCBvcC5zY3JvbGxUb1BvcykpXHJcbiAgICAgIGRpc3BsYXkud2hlZWxTdGFydFggPSBkaXNwbGF5LndoZWVsU3RhcnRZID0gbnVsbDtcclxuXHJcbiAgICAvLyBQcm9wYWdhdGUgdGhlIHNjcm9sbCBwb3NpdGlvbiB0byB0aGUgYWN0dWFsIERPTSBzY3JvbGxlclxyXG4gICAgaWYgKG9wLnNjcm9sbFRvcCAhPSBudWxsICYmIChkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCAhPSBvcC5zY3JvbGxUb3AgfHwgb3AuZm9yY2VTY3JvbGwpKSB7XHJcbiAgICAgIGRvYy5zY3JvbGxUb3AgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbEhlaWdodCAtIGRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0LCBvcC5zY3JvbGxUb3ApKTtcclxuICAgICAgZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChkb2Muc2Nyb2xsVG9wKTtcclxuICAgICAgZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgPSBkb2Muc2Nyb2xsVG9wO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wLnNjcm9sbExlZnQgIT0gbnVsbCAmJiAoZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ICE9IG9wLnNjcm9sbExlZnQgfHwgb3AuZm9yY2VTY3JvbGwpKSB7XHJcbiAgICAgIGRvYy5zY3JvbGxMZWZ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGlzcGxheS5zY3JvbGxlci5zY3JvbGxXaWR0aCAtIGRpc3BsYXlXaWR0aChjbSksIG9wLnNjcm9sbExlZnQpKTtcclxuICAgICAgZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbExlZnQoZG9jLnNjcm9sbExlZnQpO1xyXG4gICAgICBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgPSBkb2Muc2Nyb2xsTGVmdDtcclxuICAgICAgYWxpZ25Ib3Jpem9udGFsbHkoY20pO1xyXG4gICAgfVxyXG4gICAgLy8gSWYgd2UgbmVlZCB0byBzY3JvbGwgYSBzcGVjaWZpYyBwb3NpdGlvbiBpbnRvIHZpZXcsIGRvIHNvLlxyXG4gICAgaWYgKG9wLnNjcm9sbFRvUG9zKSB7XHJcbiAgICAgIHZhciBjb29yZHMgPSBzY3JvbGxQb3NJbnRvVmlldyhjbSwgY2xpcFBvcyhkb2MsIG9wLnNjcm9sbFRvUG9zLmZyb20pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcFBvcyhkb2MsIG9wLnNjcm9sbFRvUG9zLnRvKSwgb3Auc2Nyb2xsVG9Qb3MubWFyZ2luKTtcclxuICAgICAgaWYgKG9wLnNjcm9sbFRvUG9zLmlzQ3Vyc29yICYmIGNtLnN0YXRlLmZvY3VzZWQpIG1heWJlU2Nyb2xsV2luZG93KGNtLCBjb29yZHMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZpcmUgZXZlbnRzIGZvciBtYXJrZXJzIHRoYXQgYXJlIGhpZGRlbi91bmlkZGVuIGJ5IGVkaXRpbmcgb3JcclxuICAgIC8vIHVuZG9pbmdcclxuICAgIHZhciBoaWRkZW4gPSBvcC5tYXliZUhpZGRlbk1hcmtlcnMsIHVuaGlkZGVuID0gb3AubWF5YmVVbmhpZGRlbk1hcmtlcnM7XHJcbiAgICBpZiAoaGlkZGVuKSBmb3IgKHZhciBpID0gMDsgaSA8IGhpZGRlbi5sZW5ndGg7ICsraSlcclxuICAgICAgaWYgKCFoaWRkZW5baV0ubGluZXMubGVuZ3RoKSBzaWduYWwoaGlkZGVuW2ldLCBcImhpZGVcIik7XHJcbiAgICBpZiAodW5oaWRkZW4pIGZvciAodmFyIGkgPSAwOyBpIDwgdW5oaWRkZW4ubGVuZ3RoOyArK2kpXHJcbiAgICAgIGlmICh1bmhpZGRlbltpXS5saW5lcy5sZW5ndGgpIHNpZ25hbCh1bmhpZGRlbltpXSwgXCJ1bmhpZGVcIik7XHJcblxyXG4gICAgaWYgKGRpc3BsYXkud3JhcHBlci5vZmZzZXRIZWlnaHQpXHJcbiAgICAgIGRvYy5zY3JvbGxUb3AgPSBjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcDtcclxuXHJcbiAgICAvLyBGaXJlIGNoYW5nZSBldmVudHMsIGFuZCBkZWxheWVkIGV2ZW50IGhhbmRsZXJzXHJcbiAgICBpZiAob3AuY2hhbmdlT2JqcylcclxuICAgICAgc2lnbmFsKGNtLCBcImNoYW5nZXNcIiwgY20sIG9wLmNoYW5nZU9ianMpO1xyXG4gICAgaWYgKG9wLnVwZGF0ZSlcclxuICAgICAgb3AudXBkYXRlLmZpbmlzaCgpO1xyXG4gIH1cclxuXHJcbiAgLy8gUnVuIHRoZSBnaXZlbiBmdW5jdGlvbiBpbiBhbiBvcGVyYXRpb25cclxuICBmdW5jdGlvbiBydW5Jbk9wKGNtLCBmKSB7XHJcbiAgICBpZiAoY20uY3VyT3ApIHJldHVybiBmKCk7XHJcbiAgICBzdGFydE9wZXJhdGlvbihjbSk7XHJcbiAgICB0cnkgeyByZXR1cm4gZigpOyB9XHJcbiAgICBmaW5hbGx5IHsgZW5kT3BlcmF0aW9uKGNtKTsgfVxyXG4gIH1cclxuICAvLyBXcmFwcyBhIGZ1bmN0aW9uIGluIGFuIG9wZXJhdGlvbi4gUmV0dXJucyB0aGUgd3JhcHBlZCBmdW5jdGlvbi5cclxuICBmdW5jdGlvbiBvcGVyYXRpb24oY20sIGYpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKGNtLmN1ck9wKSByZXR1cm4gZi5hcHBseShjbSwgYXJndW1lbnRzKTtcclxuICAgICAgc3RhcnRPcGVyYXRpb24oY20pO1xyXG4gICAgICB0cnkgeyByZXR1cm4gZi5hcHBseShjbSwgYXJndW1lbnRzKTsgfVxyXG4gICAgICBmaW5hbGx5IHsgZW5kT3BlcmF0aW9uKGNtKTsgfVxyXG4gICAgfTtcclxuICB9XHJcbiAgLy8gVXNlZCB0byBhZGQgbWV0aG9kcyB0byBlZGl0b3IgYW5kIGRvYyBpbnN0YW5jZXMsIHdyYXBwaW5nIHRoZW0gaW5cclxuICAvLyBvcGVyYXRpb25zLlxyXG4gIGZ1bmN0aW9uIG1ldGhvZE9wKGYpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKHRoaXMuY3VyT3ApIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIHN0YXJ0T3BlcmF0aW9uKHRoaXMpO1xyXG4gICAgICB0cnkgeyByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XHJcbiAgICAgIGZpbmFsbHkgeyBlbmRPcGVyYXRpb24odGhpcyk7IH1cclxuICAgIH07XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGRvY01ldGhvZE9wKGYpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGNtID0gdGhpcy5jbTtcclxuICAgICAgaWYgKCFjbSB8fCBjbS5jdXJPcCkgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgc3RhcnRPcGVyYXRpb24oY20pO1xyXG4gICAgICB0cnkgeyByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XHJcbiAgICAgIGZpbmFsbHkgeyBlbmRPcGVyYXRpb24oY20pOyB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gVklFVyBUUkFDS0lOR1xyXG5cclxuICAvLyBUaGVzZSBvYmplY3RzIGFyZSB1c2VkIHRvIHJlcHJlc2VudCB0aGUgdmlzaWJsZSAoY3VycmVudGx5IGRyYXduKVxyXG4gIC8vIHBhcnQgb2YgdGhlIGRvY3VtZW50LiBBIExpbmVWaWV3IG1heSBjb3JyZXNwb25kIHRvIG11bHRpcGxlXHJcbiAgLy8gbG9naWNhbCBsaW5lcywgaWYgdGhvc2UgYXJlIGNvbm5lY3RlZCBieSBjb2xsYXBzZWQgcmFuZ2VzLlxyXG4gIGZ1bmN0aW9uIExpbmVWaWV3KGRvYywgbGluZSwgbGluZU4pIHtcclxuICAgIC8vIFRoZSBzdGFydGluZyBsaW5lXHJcbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xyXG4gICAgLy8gQ29udGludWluZyBsaW5lcywgaWYgYW55XHJcbiAgICB0aGlzLnJlc3QgPSB2aXN1YWxMaW5lQ29udGludWVkKGxpbmUpO1xyXG4gICAgLy8gTnVtYmVyIG9mIGxvZ2ljYWwgbGluZXMgaW4gdGhpcyB2aXN1YWwgbGluZVxyXG4gICAgdGhpcy5zaXplID0gdGhpcy5yZXN0ID8gbGluZU5vKGxzdCh0aGlzLnJlc3QpKSAtIGxpbmVOICsgMSA6IDE7XHJcbiAgICB0aGlzLm5vZGUgPSB0aGlzLnRleHQgPSBudWxsO1xyXG4gICAgdGhpcy5oaWRkZW4gPSBsaW5lSXNIaWRkZW4oZG9jLCBsaW5lKTtcclxuICB9XHJcblxyXG4gIC8vIENyZWF0ZSBhIHJhbmdlIG9mIExpbmVWaWV3IG9iamVjdHMgZm9yIHRoZSBnaXZlbiBsaW5lcy5cclxuICBmdW5jdGlvbiBidWlsZFZpZXdBcnJheShjbSwgZnJvbSwgdG8pIHtcclxuICAgIHZhciBhcnJheSA9IFtdLCBuZXh0UG9zO1xyXG4gICAgZm9yICh2YXIgcG9zID0gZnJvbTsgcG9zIDwgdG87IHBvcyA9IG5leHRQb3MpIHtcclxuICAgICAgdmFyIHZpZXcgPSBuZXcgTGluZVZpZXcoY20uZG9jLCBnZXRMaW5lKGNtLmRvYywgcG9zKSwgcG9zKTtcclxuICAgICAgbmV4dFBvcyA9IHBvcyArIHZpZXcuc2l6ZTtcclxuICAgICAgYXJyYXkucHVzaCh2aWV3KTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcnJheTtcclxuICB9XHJcblxyXG4gIC8vIFVwZGF0ZXMgdGhlIGRpc3BsYXkudmlldyBkYXRhIHN0cnVjdHVyZSBmb3IgYSBnaXZlbiBjaGFuZ2UgdG8gdGhlXHJcbiAgLy8gZG9jdW1lbnQuIEZyb20gYW5kIHRvIGFyZSBpbiBwcmUtY2hhbmdlIGNvb3JkaW5hdGVzLiBMZW5kaWZmIGlzXHJcbiAgLy8gdGhlIGFtb3VudCBvZiBsaW5lcyBhZGRlZCBvciBzdWJ0cmFjdGVkIGJ5IHRoZSBjaGFuZ2UuIFRoaXMgaXNcclxuICAvLyB1c2VkIGZvciBjaGFuZ2VzIHRoYXQgc3BhbiBtdWx0aXBsZSBsaW5lcywgb3IgY2hhbmdlIHRoZSB3YXlcclxuICAvLyBsaW5lcyBhcmUgZGl2aWRlZCBpbnRvIHZpc3VhbCBsaW5lcy4gcmVnTGluZUNoYW5nZSAoYmVsb3cpXHJcbiAgLy8gcmVnaXN0ZXJzIHNpbmdsZS1saW5lIGNoYW5nZXMuXHJcbiAgZnVuY3Rpb24gcmVnQ2hhbmdlKGNtLCBmcm9tLCB0bywgbGVuZGlmZikge1xyXG4gICAgaWYgKGZyb20gPT0gbnVsbCkgZnJvbSA9IGNtLmRvYy5maXJzdDtcclxuICAgIGlmICh0byA9PSBudWxsKSB0byA9IGNtLmRvYy5maXJzdCArIGNtLmRvYy5zaXplO1xyXG4gICAgaWYgKCFsZW5kaWZmKSBsZW5kaWZmID0gMDtcclxuXHJcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XHJcbiAgICBpZiAobGVuZGlmZiAmJiB0byA8IGRpc3BsYXkudmlld1RvICYmXHJcbiAgICAgICAgKGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPT0gbnVsbCB8fCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID4gZnJvbSkpXHJcbiAgICAgIGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPSBmcm9tO1xyXG5cclxuICAgIGNtLmN1ck9wLnZpZXdDaGFuZ2VkID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAoZnJvbSA+PSBkaXNwbGF5LnZpZXdUbykgeyAvLyBDaGFuZ2UgYWZ0ZXJcclxuICAgICAgaWYgKHNhd0NvbGxhcHNlZFNwYW5zICYmIHZpc3VhbExpbmVObyhjbS5kb2MsIGZyb20pIDwgZGlzcGxheS52aWV3VG8pXHJcbiAgICAgICAgcmVzZXRWaWV3KGNtKTtcclxuICAgIH0gZWxzZSBpZiAodG8gPD0gZGlzcGxheS52aWV3RnJvbSkgeyAvLyBDaGFuZ2UgYmVmb3JlXHJcbiAgICAgIGlmIChzYXdDb2xsYXBzZWRTcGFucyAmJiB2aXN1YWxMaW5lRW5kTm8oY20uZG9jLCB0byArIGxlbmRpZmYpID4gZGlzcGxheS52aWV3RnJvbSkge1xyXG4gICAgICAgIHJlc2V0VmlldyhjbSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGlzcGxheS52aWV3RnJvbSArPSBsZW5kaWZmO1xyXG4gICAgICAgIGRpc3BsYXkudmlld1RvICs9IGxlbmRpZmY7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoZnJvbSA8PSBkaXNwbGF5LnZpZXdGcm9tICYmIHRvID49IGRpc3BsYXkudmlld1RvKSB7IC8vIEZ1bGwgb3ZlcmxhcFxyXG4gICAgICByZXNldFZpZXcoY20pO1xyXG4gICAgfSBlbHNlIGlmIChmcm9tIDw9IGRpc3BsYXkudmlld0Zyb20pIHsgLy8gVG9wIG92ZXJsYXBcclxuICAgICAgdmFyIGN1dCA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIHRvLCB0byArIGxlbmRpZmYsIDEpO1xyXG4gICAgICBpZiAoY3V0KSB7XHJcbiAgICAgICAgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKGN1dC5pbmRleCk7XHJcbiAgICAgICAgZGlzcGxheS52aWV3RnJvbSA9IGN1dC5saW5lTjtcclxuICAgICAgICBkaXNwbGF5LnZpZXdUbyArPSBsZW5kaWZmO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlc2V0VmlldyhjbSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodG8gPj0gZGlzcGxheS52aWV3VG8pIHsgLy8gQm90dG9tIG92ZXJsYXBcclxuICAgICAgdmFyIGN1dCA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIGZyb20sIGZyb20sIC0xKTtcclxuICAgICAgaWYgKGN1dCkge1xyXG4gICAgICAgIGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5zbGljZSgwLCBjdXQuaW5kZXgpO1xyXG4gICAgICAgIGRpc3BsYXkudmlld1RvID0gY3V0LmxpbmVOO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlc2V0VmlldyhjbSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7IC8vIEdhcCBpbiB0aGUgbWlkZGxlXHJcbiAgICAgIHZhciBjdXRUb3AgPSB2aWV3Q3V0dGluZ1BvaW50KGNtLCBmcm9tLCBmcm9tLCAtMSk7XHJcbiAgICAgIHZhciBjdXRCb3QgPSB2aWV3Q3V0dGluZ1BvaW50KGNtLCB0bywgdG8gKyBsZW5kaWZmLCAxKTtcclxuICAgICAgaWYgKGN1dFRvcCAmJiBjdXRCb3QpIHtcclxuICAgICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoMCwgY3V0VG9wLmluZGV4KVxyXG4gICAgICAgICAgLmNvbmNhdChidWlsZFZpZXdBcnJheShjbSwgY3V0VG9wLmxpbmVOLCBjdXRCb3QubGluZU4pKVxyXG4gICAgICAgICAgLmNvbmNhdChkaXNwbGF5LnZpZXcuc2xpY2UoY3V0Qm90LmluZGV4KSk7XHJcbiAgICAgICAgZGlzcGxheS52aWV3VG8gKz0gbGVuZGlmZjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXNldFZpZXcoY20pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGV4dCA9IGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtcclxuICAgIGlmIChleHQpIHtcclxuICAgICAgaWYgKHRvIDwgZXh0LmxpbmVOKVxyXG4gICAgICAgIGV4dC5saW5lTiArPSBsZW5kaWZmO1xyXG4gICAgICBlbHNlIGlmIChmcm9tIDwgZXh0LmxpbmVOICsgZXh0LnNpemUpXHJcbiAgICAgICAgZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFJlZ2lzdGVyIGEgY2hhbmdlIHRvIGEgc2luZ2xlIGxpbmUuIFR5cGUgbXVzdCBiZSBvbmUgb2YgXCJ0ZXh0XCIsXHJcbiAgLy8gXCJndXR0ZXJcIiwgXCJjbGFzc1wiLCBcIndpZGdldFwiXHJcbiAgZnVuY3Rpb24gcmVnTGluZUNoYW5nZShjbSwgbGluZSwgdHlwZSkge1xyXG4gICAgY20uY3VyT3Audmlld0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBleHQgPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ7XHJcbiAgICBpZiAoZXh0ICYmIGxpbmUgPj0gZXh0LmxpbmVOICYmIGxpbmUgPCBleHQubGluZU4gKyBleHQuc2l6ZSlcclxuICAgICAgZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkID0gbnVsbDtcclxuXHJcbiAgICBpZiAobGluZSA8IGRpc3BsYXkudmlld0Zyb20gfHwgbGluZSA+PSBkaXNwbGF5LnZpZXdUbykgcmV0dXJuO1xyXG4gICAgdmFyIGxpbmVWaWV3ID0gZGlzcGxheS52aWV3W2ZpbmRWaWV3SW5kZXgoY20sIGxpbmUpXTtcclxuICAgIGlmIChsaW5lVmlldy5ub2RlID09IG51bGwpIHJldHVybjtcclxuICAgIHZhciBhcnIgPSBsaW5lVmlldy5jaGFuZ2VzIHx8IChsaW5lVmlldy5jaGFuZ2VzID0gW10pO1xyXG4gICAgaWYgKGluZGV4T2YoYXJyLCB0eXBlKSA9PSAtMSkgYXJyLnB1c2godHlwZSk7XHJcbiAgfVxyXG5cclxuICAvLyBDbGVhciB0aGUgdmlldy5cclxuICBmdW5jdGlvbiByZXNldFZpZXcoY20pIHtcclxuICAgIGNtLmRpc3BsYXkudmlld0Zyb20gPSBjbS5kaXNwbGF5LnZpZXdUbyA9IGNtLmRvYy5maXJzdDtcclxuICAgIGNtLmRpc3BsYXkudmlldyA9IFtdO1xyXG4gICAgY20uZGlzcGxheS52aWV3T2Zmc2V0ID0gMDtcclxuICB9XHJcblxyXG4gIC8vIEZpbmQgdGhlIHZpZXcgZWxlbWVudCBjb3JyZXNwb25kaW5nIHRvIGEgZ2l2ZW4gbGluZS4gUmV0dXJuIG51bGxcclxuICAvLyB3aGVuIHRoZSBsaW5lIGlzbid0IHZpc2libGUuXHJcbiAgZnVuY3Rpb24gZmluZFZpZXdJbmRleChjbSwgbikge1xyXG4gICAgaWYgKG4gPj0gY20uZGlzcGxheS52aWV3VG8pIHJldHVybiBudWxsO1xyXG4gICAgbiAtPSBjbS5kaXNwbGF5LnZpZXdGcm9tO1xyXG4gICAgaWYgKG4gPCAwKSByZXR1cm4gbnVsbDtcclxuICAgIHZhciB2aWV3ID0gY20uZGlzcGxheS52aWV3O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIG4gLT0gdmlld1tpXS5zaXplO1xyXG4gICAgICBpZiAobiA8IDApIHJldHVybiBpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdmlld0N1dHRpbmdQb2ludChjbSwgb2xkTiwgbmV3TiwgZGlyKSB7XHJcbiAgICB2YXIgaW5kZXggPSBmaW5kVmlld0luZGV4KGNtLCBvbGROKSwgZGlmZiwgdmlldyA9IGNtLmRpc3BsYXkudmlldztcclxuICAgIGlmICghc2F3Q29sbGFwc2VkU3BhbnMgfHwgbmV3TiA9PSBjbS5kb2MuZmlyc3QgKyBjbS5kb2Muc2l6ZSlcclxuICAgICAgcmV0dXJuIHtpbmRleDogaW5kZXgsIGxpbmVOOiBuZXdOfTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gY20uZGlzcGxheS52aWV3RnJvbTsgaSA8IGluZGV4OyBpKyspXHJcbiAgICAgIG4gKz0gdmlld1tpXS5zaXplO1xyXG4gICAgaWYgKG4gIT0gb2xkTikge1xyXG4gICAgICBpZiAoZGlyID4gMCkge1xyXG4gICAgICAgIGlmIChpbmRleCA9PSB2aWV3Lmxlbmd0aCAtIDEpIHJldHVybiBudWxsO1xyXG4gICAgICAgIGRpZmYgPSAobiArIHZpZXdbaW5kZXhdLnNpemUpIC0gb2xkTjtcclxuICAgICAgICBpbmRleCsrO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRpZmYgPSBuIC0gb2xkTjtcclxuICAgICAgfVxyXG4gICAgICBvbGROICs9IGRpZmY7IG5ld04gKz0gZGlmZjtcclxuICAgIH1cclxuICAgIHdoaWxlICh2aXN1YWxMaW5lTm8oY20uZG9jLCBuZXdOKSAhPSBuZXdOKSB7XHJcbiAgICAgIGlmIChpbmRleCA9PSAoZGlyIDwgMCA/IDAgOiB2aWV3Lmxlbmd0aCAtIDEpKSByZXR1cm4gbnVsbDtcclxuICAgICAgbmV3TiArPSBkaXIgKiB2aWV3W2luZGV4IC0gKGRpciA8IDAgPyAxIDogMCldLnNpemU7XHJcbiAgICAgIGluZGV4ICs9IGRpcjtcclxuICAgIH1cclxuICAgIHJldHVybiB7aW5kZXg6IGluZGV4LCBsaW5lTjogbmV3Tn07XHJcbiAgfVxyXG5cclxuICAvLyBGb3JjZSB0aGUgdmlldyB0byBjb3ZlciBhIGdpdmVuIHJhbmdlLCBhZGRpbmcgZW1wdHkgdmlldyBlbGVtZW50XHJcbiAgLy8gb3IgY2xpcHBpbmcgb2ZmIGV4aXN0aW5nIG9uZXMgYXMgbmVlZGVkLlxyXG4gIGZ1bmN0aW9uIGFkanVzdFZpZXcoY20sIGZyb20sIHRvKSB7XHJcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHZpZXcgPSBkaXNwbGF5LnZpZXc7XHJcbiAgICBpZiAodmlldy5sZW5ndGggPT0gMCB8fCBmcm9tID49IGRpc3BsYXkudmlld1RvIHx8IHRvIDw9IGRpc3BsYXkudmlld0Zyb20pIHtcclxuICAgICAgZGlzcGxheS52aWV3ID0gYnVpbGRWaWV3QXJyYXkoY20sIGZyb20sIHRvKTtcclxuICAgICAgZGlzcGxheS52aWV3RnJvbSA9IGZyb207XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoZGlzcGxheS52aWV3RnJvbSA+IGZyb20pXHJcbiAgICAgICAgZGlzcGxheS52aWV3ID0gYnVpbGRWaWV3QXJyYXkoY20sIGZyb20sIGRpc3BsYXkudmlld0Zyb20pLmNvbmNhdChkaXNwbGF5LnZpZXcpO1xyXG4gICAgICBlbHNlIGlmIChkaXNwbGF5LnZpZXdGcm9tIDwgZnJvbSlcclxuICAgICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoZmluZFZpZXdJbmRleChjbSwgZnJvbSkpO1xyXG4gICAgICBkaXNwbGF5LnZpZXdGcm9tID0gZnJvbTtcclxuICAgICAgaWYgKGRpc3BsYXkudmlld1RvIDwgdG8pXHJcbiAgICAgICAgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LmNvbmNhdChidWlsZFZpZXdBcnJheShjbSwgZGlzcGxheS52aWV3VG8sIHRvKSk7XHJcbiAgICAgIGVsc2UgaWYgKGRpc3BsYXkudmlld1RvID4gdG8pXHJcbiAgICAgICAgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKDAsIGZpbmRWaWV3SW5kZXgoY20sIHRvKSk7XHJcbiAgICB9XHJcbiAgICBkaXNwbGF5LnZpZXdUbyA9IHRvO1xyXG4gIH1cclxuXHJcbiAgLy8gQ291bnQgdGhlIG51bWJlciBvZiBsaW5lcyBpbiB0aGUgdmlldyB3aG9zZSBET00gcmVwcmVzZW50YXRpb24gaXNcclxuICAvLyBvdXQgb2YgZGF0ZSAob3Igbm9uZXhpc3RlbnQpLlxyXG4gIGZ1bmN0aW9uIGNvdW50RGlydHlWaWV3KGNtKSB7XHJcbiAgICB2YXIgdmlldyA9IGNtLmRpc3BsYXkudmlldywgZGlydHkgPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBsaW5lVmlldyA9IHZpZXdbaV07XHJcbiAgICAgIGlmICghbGluZVZpZXcuaGlkZGVuICYmICghbGluZVZpZXcubm9kZSB8fCBsaW5lVmlldy5jaGFuZ2VzKSkgKytkaXJ0eTtcclxuICAgIH1cclxuICAgIHJldHVybiBkaXJ0eTtcclxuICB9XHJcblxyXG4gIC8vIEVWRU5UIEhBTkRMRVJTXHJcblxyXG4gIC8vIEF0dGFjaCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGhhbmRsZXJzIHdoZW4gaW5pdGlhbGl6aW5nIHRoZSBlZGl0b3JcclxuICBmdW5jdGlvbiByZWdpc3RlckV2ZW50SGFuZGxlcnMoY20pIHtcclxuICAgIHZhciBkID0gY20uZGlzcGxheTtcclxuICAgIG9uKGQuc2Nyb2xsZXIsIFwibW91c2Vkb3duXCIsIG9wZXJhdGlvbihjbSwgb25Nb3VzZURvd24pKTtcclxuICAgIC8vIE9sZGVyIElFJ3Mgd2lsbCBub3QgZmlyZSBhIHNlY29uZCBtb3VzZWRvd24gZm9yIGEgZG91YmxlIGNsaWNrXHJcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDExKVxyXG4gICAgICBvbihkLnNjcm9sbGVyLCBcImRibGNsaWNrXCIsIG9wZXJhdGlvbihjbSwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkpIHJldHVybjtcclxuICAgICAgICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlKTtcclxuICAgICAgICBpZiAoIXBvcyB8fCBjbGlja0luR3V0dGVyKGNtLCBlKSB8fCBldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksIGUpKSByZXR1cm47XHJcbiAgICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcclxuICAgICAgICB2YXIgd29yZCA9IGNtLmZpbmRXb3JkQXQocG9zKTtcclxuICAgICAgICBleHRlbmRTZWxlY3Rpb24oY20uZG9jLCB3b3JkLmFuY2hvciwgd29yZC5oZWFkKTtcclxuICAgICAgfSkpO1xyXG4gICAgZWxzZVxyXG4gICAgICBvbihkLnNjcm9sbGVyLCBcImRibGNsaWNrXCIsIGZ1bmN0aW9uKGUpIHsgc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGVfcHJldmVudERlZmF1bHQoZSk7IH0pO1xyXG4gICAgLy8gU29tZSBicm93c2VycyBmaXJlIGNvbnRleHRtZW51ICphZnRlciogb3BlbmluZyB0aGUgbWVudSwgYXRcclxuICAgIC8vIHdoaWNoIHBvaW50IHdlIGNhbid0IG1lc3Mgd2l0aCBpdCBhbnltb3JlLiBDb250ZXh0IG1lbnUgaXNcclxuICAgIC8vIGhhbmRsZWQgaW4gb25Nb3VzZURvd24gZm9yIHRoZXNlIGJyb3dzZXJzLlxyXG4gICAgaWYgKCFjYXB0dXJlUmlnaHRDbGljaykgb24oZC5zY3JvbGxlciwgXCJjb250ZXh0bWVudVwiLCBmdW5jdGlvbihlKSB7b25Db250ZXh0TWVudShjbSwgZSk7fSk7XHJcblxyXG4gICAgLy8gVXNlZCB0byBzdXBwcmVzcyBtb3VzZSBldmVudCBoYW5kbGluZyB3aGVuIGEgdG91Y2ggaGFwcGVuc1xyXG4gICAgdmFyIHRvdWNoRmluaXNoZWQsIHByZXZUb3VjaCA9IHtlbmQ6IDB9O1xyXG4gICAgZnVuY3Rpb24gZmluaXNoVG91Y2goKSB7XHJcbiAgICAgIGlmIChkLmFjdGl2ZVRvdWNoKSB7XHJcbiAgICAgICAgdG91Y2hGaW5pc2hlZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7ZC5hY3RpdmVUb3VjaCA9IG51bGw7fSwgMTAwMCk7XHJcbiAgICAgICAgcHJldlRvdWNoID0gZC5hY3RpdmVUb3VjaDtcclxuICAgICAgICBwcmV2VG91Y2guZW5kID0gK25ldyBEYXRlO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gaXNNb3VzZUxpa2VUb3VjaEV2ZW50KGUpIHtcclxuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggIT0gMSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB2YXIgdG91Y2ggPSBlLnRvdWNoZXNbMF07XHJcbiAgICAgIHJldHVybiB0b3VjaC5yYWRpdXNYIDw9IDEgJiYgdG91Y2gucmFkaXVzWSA8PSAxO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZmFyQXdheSh0b3VjaCwgb3RoZXIpIHtcclxuICAgICAgaWYgKG90aGVyLmxlZnQgPT0gbnVsbCkgcmV0dXJuIHRydWU7XHJcbiAgICAgIHZhciBkeCA9IG90aGVyLmxlZnQgLSB0b3VjaC5sZWZ0LCBkeSA9IG90aGVyLnRvcCAtIHRvdWNoLnRvcDtcclxuICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ID4gMjAgKiAyMDtcclxuICAgIH1cclxuICAgIG9uKGQuc2Nyb2xsZXIsIFwidG91Y2hzdGFydFwiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgIGlmICghaXNNb3VzZUxpa2VUb3VjaEV2ZW50KGUpKSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRvdWNoRmluaXNoZWQpO1xyXG4gICAgICAgIHZhciBub3cgPSArbmV3IERhdGU7XHJcbiAgICAgICAgZC5hY3RpdmVUb3VjaCA9IHtzdGFydDogbm93LCBtb3ZlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2OiBub3cgLSBwcmV2VG91Y2guZW5kIDw9IDMwMCA/IHByZXZUb3VjaCA6IG51bGx9O1xyXG4gICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09IDEpIHtcclxuICAgICAgICAgIGQuYWN0aXZlVG91Y2gubGVmdCA9IGUudG91Y2hlc1swXS5wYWdlWDtcclxuICAgICAgICAgIGQuYWN0aXZlVG91Y2gudG9wID0gZS50b3VjaGVzWzBdLnBhZ2VZO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBvbihkLnNjcm9sbGVyLCBcInRvdWNobW92ZVwiLCBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKGQuYWN0aXZlVG91Y2gpIGQuYWN0aXZlVG91Y2gubW92ZWQgPSB0cnVlO1xyXG4gICAgfSk7XHJcbiAgICBvbihkLnNjcm9sbGVyLCBcInRvdWNoZW5kXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgdmFyIHRvdWNoID0gZC5hY3RpdmVUb3VjaDtcclxuICAgICAgaWYgKHRvdWNoICYmICFldmVudEluV2lkZ2V0KGQsIGUpICYmIHRvdWNoLmxlZnQgIT0gbnVsbCAmJlxyXG4gICAgICAgICAgIXRvdWNoLm1vdmVkICYmIG5ldyBEYXRlIC0gdG91Y2guc3RhcnQgPCAzMDApIHtcclxuICAgICAgICB2YXIgcG9zID0gY20uY29vcmRzQ2hhcihkLmFjdGl2ZVRvdWNoLCBcInBhZ2VcIiksIHJhbmdlO1xyXG4gICAgICAgIGlmICghdG91Y2gucHJldiB8fCBmYXJBd2F5KHRvdWNoLCB0b3VjaC5wcmV2KSkgLy8gU2luZ2xlIHRhcFxyXG4gICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2UocG9zLCBwb3MpO1xyXG4gICAgICAgIGVsc2UgaWYgKCF0b3VjaC5wcmV2LnByZXYgfHwgZmFyQXdheSh0b3VjaCwgdG91Y2gucHJldi5wcmV2KSkgLy8gRG91YmxlIHRhcFxyXG4gICAgICAgICAgcmFuZ2UgPSBjbS5maW5kV29yZEF0KHBvcyk7XHJcbiAgICAgICAgZWxzZSAvLyBUcmlwbGUgdGFwXHJcbiAgICAgICAgICByYW5nZSA9IG5ldyBSYW5nZShQb3MocG9zLmxpbmUsIDApLCBjbGlwUG9zKGNtLmRvYywgUG9zKHBvcy5saW5lICsgMSwgMCkpKTtcclxuICAgICAgICBjbS5zZXRTZWxlY3Rpb24ocmFuZ2UuYW5jaG9yLCByYW5nZS5oZWFkKTtcclxuICAgICAgICBjbS5mb2N1cygpO1xyXG4gICAgICAgIGVfcHJldmVudERlZmF1bHQoZSk7XHJcbiAgICAgIH1cclxuICAgICAgZmluaXNoVG91Y2goKTtcclxuICAgIH0pO1xyXG4gICAgb24oZC5zY3JvbGxlciwgXCJ0b3VjaGNhbmNlbFwiLCBmaW5pc2hUb3VjaCk7XHJcblxyXG4gICAgLy8gU3luYyBzY3JvbGxpbmcgYmV0d2VlbiBmYWtlIHNjcm9sbGJhcnMgYW5kIHJlYWwgc2Nyb2xsYWJsZVxyXG4gICAgLy8gYXJlYSwgZW5zdXJlIHZpZXdwb3J0IGlzIHVwZGF0ZWQgd2hlbiBzY3JvbGxpbmcuXHJcbiAgICBvbihkLnNjcm9sbGVyLCBcInNjcm9sbFwiLCBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKGQuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgc2V0U2Nyb2xsVG9wKGNtLCBkLnNjcm9sbGVyLnNjcm9sbFRvcCk7XHJcbiAgICAgICAgc2V0U2Nyb2xsTGVmdChjbSwgZC5zY3JvbGxlci5zY3JvbGxMZWZ0LCB0cnVlKTtcclxuICAgICAgICBzaWduYWwoY20sIFwic2Nyb2xsXCIsIGNtKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gTGlzdGVuIHRvIHdoZWVsIGV2ZW50cyBpbiBvcmRlciB0byB0cnkgYW5kIHVwZGF0ZSB0aGUgdmlld3BvcnQgb24gdGltZS5cclxuICAgIG9uKGQuc2Nyb2xsZXIsIFwibW91c2V3aGVlbFwiLCBmdW5jdGlvbihlKXtvblNjcm9sbFdoZWVsKGNtLCBlKTt9KTtcclxuICAgIG9uKGQuc2Nyb2xsZXIsIFwiRE9NTW91c2VTY3JvbGxcIiwgZnVuY3Rpb24oZSl7b25TY3JvbGxXaGVlbChjbSwgZSk7fSk7XHJcblxyXG4gICAgLy8gUHJldmVudCB3cmFwcGVyIGZyb20gZXZlciBzY3JvbGxpbmdcclxuICAgIG9uKGQud3JhcHBlciwgXCJzY3JvbGxcIiwgZnVuY3Rpb24oKSB7IGQud3JhcHBlci5zY3JvbGxUb3AgPSBkLndyYXBwZXIuc2Nyb2xsTGVmdCA9IDA7IH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIGRyYWdfKGUpIHtcclxuICAgICAgaWYgKCFzaWduYWxET01FdmVudChjbSwgZSkpIGVfc3RvcChlKTtcclxuICAgIH1cclxuICAgIGlmIChjbS5vcHRpb25zLmRyYWdEcm9wKSB7XHJcbiAgICAgIG9uKGQuc2Nyb2xsZXIsIFwiZHJhZ3N0YXJ0XCIsIGZ1bmN0aW9uKGUpe29uRHJhZ1N0YXJ0KGNtLCBlKTt9KTtcclxuICAgICAgb24oZC5zY3JvbGxlciwgXCJkcmFnZW50ZXJcIiwgZHJhZ18pO1xyXG4gICAgICBvbihkLnNjcm9sbGVyLCBcImRyYWdvdmVyXCIsIGRyYWdfKTtcclxuICAgICAgb24oZC5zY3JvbGxlciwgXCJkcm9wXCIsIG9wZXJhdGlvbihjbSwgb25Ecm9wKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGlucCA9IGQuaW5wdXQuZ2V0RmllbGQoKTtcclxuICAgIG9uKGlucCwgXCJrZXl1cFwiLCBmdW5jdGlvbihlKSB7IG9uS2V5VXAuY2FsbChjbSwgZSk7IH0pO1xyXG4gICAgb24oaW5wLCBcImtleWRvd25cIiwgb3BlcmF0aW9uKGNtLCBvbktleURvd24pKTtcclxuICAgIG9uKGlucCwgXCJrZXlwcmVzc1wiLCBvcGVyYXRpb24oY20sIG9uS2V5UHJlc3MpKTtcclxuICAgIG9uKGlucCwgXCJmb2N1c1wiLCBiaW5kKG9uRm9jdXMsIGNtKSk7XHJcbiAgICBvbihpbnAsIFwiYmx1clwiLCBiaW5kKG9uQmx1ciwgY20pKTtcclxuICB9XHJcblxyXG4gIC8vIENhbGxlZCB3aGVuIHRoZSB3aW5kb3cgcmVzaXplc1xyXG4gIGZ1bmN0aW9uIG9uUmVzaXplKGNtKSB7XHJcbiAgICB2YXIgZCA9IGNtLmRpc3BsYXk7XHJcbiAgICBpZiAoZC5sYXN0V3JhcEhlaWdodCA9PSBkLndyYXBwZXIuY2xpZW50SGVpZ2h0ICYmIGQubGFzdFdyYXBXaWR0aCA9PSBkLndyYXBwZXIuY2xpZW50V2lkdGgpXHJcbiAgICAgIHJldHVybjtcclxuICAgIC8vIE1pZ2h0IGJlIGEgdGV4dCBzY2FsaW5nIG9wZXJhdGlvbiwgY2xlYXIgc2l6ZSBjYWNoZXMuXHJcbiAgICBkLmNhY2hlZENoYXJXaWR0aCA9IGQuY2FjaGVkVGV4dEhlaWdodCA9IGQuY2FjaGVkUGFkZGluZ0ggPSBudWxsO1xyXG4gICAgZC5zY3JvbGxiYXJzQ2xpcHBlZCA9IGZhbHNlO1xyXG4gICAgY20uc2V0U2l6ZSgpO1xyXG4gIH1cclxuXHJcbiAgLy8gTU9VU0UgRVZFTlRTXHJcblxyXG4gIC8vIFJldHVybiB0cnVlIHdoZW4gdGhlIGdpdmVuIG1vdXNlIGV2ZW50IGhhcHBlbmVkIGluIGEgd2lkZ2V0XHJcbiAgZnVuY3Rpb24gZXZlbnRJbldpZGdldChkaXNwbGF5LCBlKSB7XHJcbiAgICBmb3IgKHZhciBuID0gZV90YXJnZXQoZSk7IG4gIT0gZGlzcGxheS53cmFwcGVyOyBuID0gbi5wYXJlbnROb2RlKSB7XHJcbiAgICAgIGlmICghbiB8fCAobi5ub2RlVHlwZSA9PSAxICYmIG4uZ2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiKSA9PSBcInRydWVcIikgfHxcclxuICAgICAgICAgIChuLnBhcmVudE5vZGUgPT0gZGlzcGxheS5zaXplciAmJiBuICE9IGRpc3BsYXkubW92ZXIpKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gR2l2ZW4gYSBtb3VzZSBldmVudCwgZmluZCB0aGUgY29ycmVzcG9uZGluZyBwb3NpdGlvbi4gSWYgbGliZXJhbFxyXG4gIC8vIGlzIGZhbHNlLCBpdCBjaGVja3Mgd2hldGhlciBhIGd1dHRlciBvciBzY3JvbGxiYXIgd2FzIGNsaWNrZWQsXHJcbiAgLy8gYW5kIHJldHVybnMgbnVsbCBpZiBpdCB3YXMuIGZvclJlY3QgaXMgdXNlZCBieSByZWN0YW5ndWxhclxyXG4gIC8vIHNlbGVjdGlvbnMsIGFuZCB0cmllcyB0byBlc3RpbWF0ZSBhIGNoYXJhY3RlciBwb3NpdGlvbiBldmVuIGZvclxyXG4gIC8vIGNvb3JkaW5hdGVzIGJleW9uZCB0aGUgcmlnaHQgb2YgdGhlIHRleHQuXHJcbiAgZnVuY3Rpb24gcG9zRnJvbU1vdXNlKGNtLCBlLCBsaWJlcmFsLCBmb3JSZWN0KSB7XHJcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XHJcbiAgICBpZiAoIWxpYmVyYWwgJiYgZV90YXJnZXQoZSkuZ2V0QXR0cmlidXRlKFwiY20tbm90LWNvbnRlbnRcIikgPT0gXCJ0cnVlXCIpIHJldHVybiBudWxsO1xyXG5cclxuICAgIHZhciB4LCB5LCBzcGFjZSA9IGRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgLy8gRmFpbHMgdW5wcmVkaWN0YWJseSBvbiBJRVs2N10gd2hlbiBtb3VzZSBpcyBkcmFnZ2VkIGFyb3VuZCBxdWlja2x5LlxyXG4gICAgdHJ5IHsgeCA9IGUuY2xpZW50WCAtIHNwYWNlLmxlZnQ7IHkgPSBlLmNsaWVudFkgLSBzcGFjZS50b3A7IH1cclxuICAgIGNhdGNoIChlKSB7IHJldHVybiBudWxsOyB9XHJcbiAgICB2YXIgY29vcmRzID0gY29vcmRzQ2hhcihjbSwgeCwgeSksIGxpbmU7XHJcbiAgICBpZiAoZm9yUmVjdCAmJiBjb29yZHMueFJlbCA9PSAxICYmIChsaW5lID0gZ2V0TGluZShjbS5kb2MsIGNvb3Jkcy5saW5lKS50ZXh0KS5sZW5ndGggPT0gY29vcmRzLmNoKSB7XHJcbiAgICAgIHZhciBjb2xEaWZmID0gY291bnRDb2x1bW4obGluZSwgbGluZS5sZW5ndGgsIGNtLm9wdGlvbnMudGFiU2l6ZSkgLSBsaW5lLmxlbmd0aDtcclxuICAgICAgY29vcmRzID0gUG9zKGNvb3Jkcy5saW5lLCBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKCh4IC0gcGFkZGluZ0goY20uZGlzcGxheSkubGVmdCkgLyBjaGFyV2lkdGgoY20uZGlzcGxheSkpIC0gY29sRGlmZikpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvb3JkcztcclxuICB9XHJcblxyXG4gIC8vIEEgbW91c2UgZG93biBjYW4gYmUgYSBzaW5nbGUgY2xpY2ssIGRvdWJsZSBjbGljaywgdHJpcGxlIGNsaWNrLFxyXG4gIC8vIHN0YXJ0IG9mIHNlbGVjdGlvbiBkcmFnLCBzdGFydCBvZiB0ZXh0IGRyYWcsIG5ldyBjdXJzb3JcclxuICAvLyAoY3RybC1jbGljayksIHJlY3RhbmdsZSBkcmFnIChhbHQtZHJhZyksIG9yIHh3aW5cclxuICAvLyBtaWRkbGUtY2xpY2stcGFzdGUuIE9yIGl0IG1pZ2h0IGJlIGEgY2xpY2sgb24gc29tZXRoaW5nIHdlIHNob3VsZFxyXG4gIC8vIG5vdCBpbnRlcmZlcmUgd2l0aCwgc3VjaCBhcyBhIHNjcm9sbGJhciBvciB3aWRnZXQuXHJcbiAgZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xyXG4gICAgdmFyIGNtID0gdGhpcywgZGlzcGxheSA9IGNtLmRpc3BsYXk7XHJcbiAgICBpZiAoZGlzcGxheS5hY3RpdmVUb3VjaCAmJiBkaXNwbGF5LmlucHV0LnN1cHBvcnRzVG91Y2goKSB8fCBzaWduYWxET01FdmVudChjbSwgZSkpIHJldHVybjtcclxuICAgIGRpc3BsYXkuc2hpZnQgPSBlLnNoaWZ0S2V5O1xyXG5cclxuICAgIGlmIChldmVudEluV2lkZ2V0KGRpc3BsYXksIGUpKSB7XHJcbiAgICAgIGlmICghd2Via2l0KSB7XHJcbiAgICAgICAgLy8gQnJpZWZseSB0dXJuIG9mZiBkcmFnZ2FiaWxpdHksIHRvIGFsbG93IHdpZGdldHMgdG8gZG9cclxuICAgICAgICAvLyBub3JtYWwgZHJhZ2dpbmcgdGhpbmdzLlxyXG4gICAgICAgIGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe2Rpc3BsYXkuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gdHJ1ZTt9LCAxMDApO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChjbGlja0luR3V0dGVyKGNtLCBlKSkgcmV0dXJuO1xyXG4gICAgdmFyIHN0YXJ0ID0gcG9zRnJvbU1vdXNlKGNtLCBlKTtcclxuICAgIHdpbmRvdy5mb2N1cygpO1xyXG5cclxuICAgIHN3aXRjaCAoZV9idXR0b24oZSkpIHtcclxuICAgIGNhc2UgMTpcclxuICAgICAgaWYgKHN0YXJ0KVxyXG4gICAgICAgIGxlZnRCdXR0b25Eb3duKGNtLCBlLCBzdGFydCk7XHJcbiAgICAgIGVsc2UgaWYgKGVfdGFyZ2V0KGUpID09IGRpc3BsYXkuc2Nyb2xsZXIpXHJcbiAgICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDI6XHJcbiAgICAgIGlmICh3ZWJraXQpIGNtLnN0YXRlLmxhc3RNaWRkbGVEb3duID0gK25ldyBEYXRlO1xyXG4gICAgICBpZiAoc3RhcnQpIGV4dGVuZFNlbGVjdGlvbihjbS5kb2MsIHN0YXJ0KTtcclxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtkaXNwbGF5LmlucHV0LmZvY3VzKCk7fSwgMjApO1xyXG4gICAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMzpcclxuICAgICAgaWYgKGNhcHR1cmVSaWdodENsaWNrKSBvbkNvbnRleHRNZW51KGNtLCBlKTtcclxuICAgICAgZWxzZSBkZWxheUJsdXJFdmVudChjbSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIGxhc3RDbGljaywgbGFzdERvdWJsZUNsaWNrO1xyXG4gIGZ1bmN0aW9uIGxlZnRCdXR0b25Eb3duKGNtLCBlLCBzdGFydCkge1xyXG4gICAgaWYgKGllKSBzZXRUaW1lb3V0KGJpbmQoZW5zdXJlRm9jdXMsIGNtKSwgMCk7XHJcbiAgICBlbHNlIGVuc3VyZUZvY3VzKGNtKTtcclxuXHJcbiAgICB2YXIgbm93ID0gK25ldyBEYXRlLCB0eXBlO1xyXG4gICAgaWYgKGxhc3REb3VibGVDbGljayAmJiBsYXN0RG91YmxlQ2xpY2sudGltZSA+IG5vdyAtIDQwMCAmJiBjbXAobGFzdERvdWJsZUNsaWNrLnBvcywgc3RhcnQpID09IDApIHtcclxuICAgICAgdHlwZSA9IFwidHJpcGxlXCI7XHJcbiAgICB9IGVsc2UgaWYgKGxhc3RDbGljayAmJiBsYXN0Q2xpY2sudGltZSA+IG5vdyAtIDQwMCAmJiBjbXAobGFzdENsaWNrLnBvcywgc3RhcnQpID09IDApIHtcclxuICAgICAgdHlwZSA9IFwiZG91YmxlXCI7XHJcbiAgICAgIGxhc3REb3VibGVDbGljayA9IHt0aW1lOiBub3csIHBvczogc3RhcnR9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdHlwZSA9IFwic2luZ2xlXCI7XHJcbiAgICAgIGxhc3RDbGljayA9IHt0aW1lOiBub3csIHBvczogc3RhcnR9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzZWwgPSBjbS5kb2Muc2VsLCBtb2RpZmllciA9IG1hYyA/IGUubWV0YUtleSA6IGUuY3RybEtleSwgY29udGFpbmVkO1xyXG4gICAgaWYgKGNtLm9wdGlvbnMuZHJhZ0Ryb3AgJiYgZHJhZ0FuZERyb3AgJiYgIWlzUmVhZE9ubHkoY20pICYmXHJcbiAgICAgICAgdHlwZSA9PSBcInNpbmdsZVwiICYmIChjb250YWluZWQgPSBzZWwuY29udGFpbnMoc3RhcnQpKSA+IC0xICYmXHJcbiAgICAgICAgIXNlbC5yYW5nZXNbY29udGFpbmVkXS5lbXB0eSgpKVxyXG4gICAgICBsZWZ0QnV0dG9uU3RhcnREcmFnKGNtLCBlLCBzdGFydCwgbW9kaWZpZXIpO1xyXG4gICAgZWxzZVxyXG4gICAgICBsZWZ0QnV0dG9uU2VsZWN0KGNtLCBlLCBzdGFydCwgdHlwZSwgbW9kaWZpZXIpO1xyXG4gIH1cclxuXHJcbiAgLy8gU3RhcnQgYSB0ZXh0IGRyYWcuIFdoZW4gaXQgZW5kcywgc2VlIGlmIGFueSBkcmFnZ2luZyBhY3R1YWxseVxyXG4gIC8vIGhhcHBlbiwgYW5kIHRyZWF0IGFzIGEgY2xpY2sgaWYgaXQgZGlkbid0LlxyXG4gIGZ1bmN0aW9uIGxlZnRCdXR0b25TdGFydERyYWcoY20sIGUsIHN0YXJ0LCBtb2RpZmllcikge1xyXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xyXG4gICAgdmFyIGRyYWdFbmQgPSBvcGVyYXRpb24oY20sIGZ1bmN0aW9uKGUyKSB7XHJcbiAgICAgIGlmICh3ZWJraXQpIGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gZmFsc2U7XHJcbiAgICAgIGNtLnN0YXRlLmRyYWdnaW5nVGV4dCA9IGZhbHNlO1xyXG4gICAgICBvZmYoZG9jdW1lbnQsIFwibW91c2V1cFwiLCBkcmFnRW5kKTtcclxuICAgICAgb2ZmKGRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJvcFwiLCBkcmFnRW5kKTtcclxuICAgICAgaWYgKE1hdGguYWJzKGUuY2xpZW50WCAtIGUyLmNsaWVudFgpICsgTWF0aC5hYnMoZS5jbGllbnRZIC0gZTIuY2xpZW50WSkgPCAxMCkge1xyXG4gICAgICAgIGVfcHJldmVudERlZmF1bHQoZTIpO1xyXG4gICAgICAgIGlmICghbW9kaWZpZXIpXHJcbiAgICAgICAgICBleHRlbmRTZWxlY3Rpb24oY20uZG9jLCBzdGFydCk7XHJcbiAgICAgICAgLy8gV29yayBhcm91bmQgdW5leHBsYWluYWJsZSBmb2N1cyBwcm9ibGVtIGluIElFOSAoIzIxMjcpIGFuZCBDaHJvbWUgKCMzMDgxKVxyXG4gICAgICAgIGlmICh3ZWJraXQgfHwgaWUgJiYgaWVfdmVyc2lvbiA9PSA5KVxyXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtkb2N1bWVudC5ib2R5LmZvY3VzKCk7IGRpc3BsYXkuaW5wdXQuZm9jdXMoKTt9LCAyMCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgZGlzcGxheS5pbnB1dC5mb2N1cygpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIC8vIExldCB0aGUgZHJhZyBoYW5kbGVyIGhhbmRsZSB0aGlzLlxyXG4gICAgaWYgKHdlYmtpdCkgZGlzcGxheS5zY3JvbGxlci5kcmFnZ2FibGUgPSB0cnVlO1xyXG4gICAgY20uc3RhdGUuZHJhZ2dpbmdUZXh0ID0gZHJhZ0VuZDtcclxuICAgIC8vIElFJ3MgYXBwcm9hY2ggdG8gZHJhZ2dhYmxlXHJcbiAgICBpZiAoZGlzcGxheS5zY3JvbGxlci5kcmFnRHJvcCkgZGlzcGxheS5zY3JvbGxlci5kcmFnRHJvcCgpO1xyXG4gICAgb24oZG9jdW1lbnQsIFwibW91c2V1cFwiLCBkcmFnRW5kKTtcclxuICAgIG9uKGRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJvcFwiLCBkcmFnRW5kKTtcclxuICB9XHJcblxyXG4gIC8vIE5vcm1hbCBzZWxlY3Rpb24sIGFzIG9wcG9zZWQgdG8gdGV4dCBkcmFnZ2luZy5cclxuICBmdW5jdGlvbiBsZWZ0QnV0dG9uU2VsZWN0KGNtLCBlLCBzdGFydCwgdHlwZSwgYWRkTmV3KSB7XHJcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcclxuICAgIGVfcHJldmVudERlZmF1bHQoZSk7XHJcblxyXG4gICAgdmFyIG91clJhbmdlLCBvdXJJbmRleCwgc3RhcnRTZWwgPSBkb2Muc2VsLCByYW5nZXMgPSBzdGFydFNlbC5yYW5nZXM7XHJcbiAgICBpZiAoYWRkTmV3ICYmICFlLnNoaWZ0S2V5KSB7XHJcbiAgICAgIG91ckluZGV4ID0gZG9jLnNlbC5jb250YWlucyhzdGFydCk7XHJcbiAgICAgIGlmIChvdXJJbmRleCA+IC0xKVxyXG4gICAgICAgIG91clJhbmdlID0gcmFuZ2VzW291ckluZGV4XTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIG91clJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0LCBzdGFydCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBvdXJSYW5nZSA9IGRvYy5zZWwucHJpbWFyeSgpO1xyXG4gICAgICBvdXJJbmRleCA9IGRvYy5zZWwucHJpbUluZGV4O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChlLmFsdEtleSkge1xyXG4gICAgICB0eXBlID0gXCJyZWN0XCI7XHJcbiAgICAgIGlmICghYWRkTmV3KSBvdXJSYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgc3RhcnQpO1xyXG4gICAgICBzdGFydCA9IHBvc0Zyb21Nb3VzZShjbSwgZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgIG91ckluZGV4ID0gLTE7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJkb3VibGVcIikge1xyXG4gICAgICB2YXIgd29yZCA9IGNtLmZpbmRXb3JkQXQoc3RhcnQpO1xyXG4gICAgICBpZiAoY20uZGlzcGxheS5zaGlmdCB8fCBkb2MuZXh0ZW5kKVxyXG4gICAgICAgIG91clJhbmdlID0gZXh0ZW5kUmFuZ2UoZG9jLCBvdXJSYW5nZSwgd29yZC5hbmNob3IsIHdvcmQuaGVhZCk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBvdXJSYW5nZSA9IHdvcmQ7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJ0cmlwbGVcIikge1xyXG4gICAgICB2YXIgbGluZSA9IG5ldyBSYW5nZShQb3Moc3RhcnQubGluZSwgMCksIGNsaXBQb3MoZG9jLCBQb3Moc3RhcnQubGluZSArIDEsIDApKSk7XHJcbiAgICAgIGlmIChjbS5kaXNwbGF5LnNoaWZ0IHx8IGRvYy5leHRlbmQpXHJcbiAgICAgICAgb3VyUmFuZ2UgPSBleHRlbmRSYW5nZShkb2MsIG91clJhbmdlLCBsaW5lLmFuY2hvciwgbGluZS5oZWFkKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIG91clJhbmdlID0gbGluZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG91clJhbmdlID0gZXh0ZW5kUmFuZ2UoZG9jLCBvdXJSYW5nZSwgc3RhcnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghYWRkTmV3KSB7XHJcbiAgICAgIG91ckluZGV4ID0gMDtcclxuICAgICAgc2V0U2VsZWN0aW9uKGRvYywgbmV3IFNlbGVjdGlvbihbb3VyUmFuZ2VdLCAwKSwgc2VsX21vdXNlKTtcclxuICAgICAgc3RhcnRTZWwgPSBkb2Muc2VsO1xyXG4gICAgfSBlbHNlIGlmIChvdXJJbmRleCA9PSAtMSkge1xyXG4gICAgICBvdXJJbmRleCA9IHJhbmdlcy5sZW5ndGg7XHJcbiAgICAgIHNldFNlbGVjdGlvbihkb2MsIG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMuY29uY2F0KFtvdXJSYW5nZV0pLCBvdXJJbmRleCksXHJcbiAgICAgICAgICAgICAgICAgICB7c2Nyb2xsOiBmYWxzZSwgb3JpZ2luOiBcIiptb3VzZVwifSk7XHJcbiAgICB9IGVsc2UgaWYgKHJhbmdlcy5sZW5ndGggPiAxICYmIHJhbmdlc1tvdXJJbmRleF0uZW1wdHkoKSAmJiB0eXBlID09IFwic2luZ2xlXCIgJiYgIWUuc2hpZnRLZXkpIHtcclxuICAgICAgc2V0U2VsZWN0aW9uKGRvYywgbm9ybWFsaXplU2VsZWN0aW9uKHJhbmdlcy5zbGljZSgwLCBvdXJJbmRleCkuY29uY2F0KHJhbmdlcy5zbGljZShvdXJJbmRleCArIDEpKSwgMCkpO1xyXG4gICAgICBzdGFydFNlbCA9IGRvYy5zZWw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXBsYWNlT25lU2VsZWN0aW9uKGRvYywgb3VySW5kZXgsIG91clJhbmdlLCBzZWxfbW91c2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBsYXN0UG9zID0gc3RhcnQ7XHJcbiAgICBmdW5jdGlvbiBleHRlbmRUbyhwb3MpIHtcclxuICAgICAgaWYgKGNtcChsYXN0UG9zLCBwb3MpID09IDApIHJldHVybjtcclxuICAgICAgbGFzdFBvcyA9IHBvcztcclxuXHJcbiAgICAgIGlmICh0eXBlID09IFwicmVjdFwiKSB7XHJcbiAgICAgICAgdmFyIHJhbmdlcyA9IFtdLCB0YWJTaXplID0gY20ub3B0aW9ucy50YWJTaXplO1xyXG4gICAgICAgIHZhciBzdGFydENvbCA9IGNvdW50Q29sdW1uKGdldExpbmUoZG9jLCBzdGFydC5saW5lKS50ZXh0LCBzdGFydC5jaCwgdGFiU2l6ZSk7XHJcbiAgICAgICAgdmFyIHBvc0NvbCA9IGNvdW50Q29sdW1uKGdldExpbmUoZG9jLCBwb3MubGluZSkudGV4dCwgcG9zLmNoLCB0YWJTaXplKTtcclxuICAgICAgICB2YXIgbGVmdCA9IE1hdGgubWluKHN0YXJ0Q29sLCBwb3NDb2wpLCByaWdodCA9IE1hdGgubWF4KHN0YXJ0Q29sLCBwb3NDb2wpO1xyXG4gICAgICAgIGZvciAodmFyIGxpbmUgPSBNYXRoLm1pbihzdGFydC5saW5lLCBwb3MubGluZSksIGVuZCA9IE1hdGgubWluKGNtLmxhc3RMaW5lKCksIE1hdGgubWF4KHN0YXJ0LmxpbmUsIHBvcy5saW5lKSk7XHJcbiAgICAgICAgICAgICBsaW5lIDw9IGVuZDsgbGluZSsrKSB7XHJcbiAgICAgICAgICB2YXIgdGV4dCA9IGdldExpbmUoZG9jLCBsaW5lKS50ZXh0LCBsZWZ0UG9zID0gZmluZENvbHVtbih0ZXh0LCBsZWZ0LCB0YWJTaXplKTtcclxuICAgICAgICAgIGlmIChsZWZ0ID09IHJpZ2h0KVxyXG4gICAgICAgICAgICByYW5nZXMucHVzaChuZXcgUmFuZ2UoUG9zKGxpbmUsIGxlZnRQb3MpLCBQb3MobGluZSwgbGVmdFBvcykpKTtcclxuICAgICAgICAgIGVsc2UgaWYgKHRleHQubGVuZ3RoID4gbGVmdFBvcylcclxuICAgICAgICAgICAgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKFBvcyhsaW5lLCBsZWZ0UG9zKSwgUG9zKGxpbmUsIGZpbmRDb2x1bW4odGV4dCwgcmlnaHQsIHRhYlNpemUpKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXJhbmdlcy5sZW5ndGgpIHJhbmdlcy5wdXNoKG5ldyBSYW5nZShzdGFydCwgc3RhcnQpKTtcclxuICAgICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oc3RhcnRTZWwucmFuZ2VzLnNsaWNlKDAsIG91ckluZGV4KS5jb25jYXQocmFuZ2VzKSwgb3VySW5kZXgpLFxyXG4gICAgICAgICAgICAgICAgICAgICB7b3JpZ2luOiBcIiptb3VzZVwiLCBzY3JvbGw6IGZhbHNlfSk7XHJcbiAgICAgICAgY20uc2Nyb2xsSW50b1ZpZXcocG9zKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgb2xkUmFuZ2UgPSBvdXJSYW5nZTtcclxuICAgICAgICB2YXIgYW5jaG9yID0gb2xkUmFuZ2UuYW5jaG9yLCBoZWFkID0gcG9zO1xyXG4gICAgICAgIGlmICh0eXBlICE9IFwic2luZ2xlXCIpIHtcclxuICAgICAgICAgIGlmICh0eXBlID09IFwiZG91YmxlXCIpXHJcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGNtLmZpbmRXb3JkQXQocG9zKTtcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdmFyIHJhbmdlID0gbmV3IFJhbmdlKFBvcyhwb3MubGluZSwgMCksIGNsaXBQb3MoZG9jLCBQb3MocG9zLmxpbmUgKyAxLCAwKSkpO1xyXG4gICAgICAgICAgaWYgKGNtcChyYW5nZS5hbmNob3IsIGFuY2hvcikgPiAwKSB7XHJcbiAgICAgICAgICAgIGhlYWQgPSByYW5nZS5oZWFkO1xyXG4gICAgICAgICAgICBhbmNob3IgPSBtaW5Qb3Mob2xkUmFuZ2UuZnJvbSgpLCByYW5nZS5hbmNob3IpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaGVhZCA9IHJhbmdlLmFuY2hvcjtcclxuICAgICAgICAgICAgYW5jaG9yID0gbWF4UG9zKG9sZFJhbmdlLnRvKCksIHJhbmdlLmhlYWQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmFuZ2VzID0gc3RhcnRTZWwucmFuZ2VzLnNsaWNlKDApO1xyXG4gICAgICAgIHJhbmdlc1tvdXJJbmRleF0gPSBuZXcgUmFuZ2UoY2xpcFBvcyhkb2MsIGFuY2hvciksIGhlYWQpO1xyXG4gICAgICAgIHNldFNlbGVjdGlvbihkb2MsIG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMsIG91ckluZGV4KSwgc2VsX21vdXNlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBlZGl0b3JTaXplID0gZGlzcGxheS53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgLy8gVXNlZCB0byBlbnN1cmUgdGltZW91dCByZS10cmllcyBkb24ndCBmaXJlIHdoZW4gYW5vdGhlciBleHRlbmRcclxuICAgIC8vIGhhcHBlbmVkIGluIHRoZSBtZWFudGltZSAoY2xlYXJUaW1lb3V0IGlzbid0IHJlbGlhYmxlIC0tIGF0XHJcbiAgICAvLyBsZWFzdCBvbiBDaHJvbWUsIHRoZSB0aW1lb3V0cyBzdGlsbCBoYXBwZW4gZXZlbiB3aGVuIGNsZWFyZWQsXHJcbiAgICAvLyBpZiB0aGUgY2xlYXIgaGFwcGVucyBhZnRlciB0aGVpciBzY2hlZHVsZWQgZmlyaW5nIHRpbWUpLlxyXG4gICAgdmFyIGNvdW50ZXIgPSAwO1xyXG5cclxuICAgIGZ1bmN0aW9uIGV4dGVuZChlKSB7XHJcbiAgICAgIHZhciBjdXJDb3VudCA9ICsrY291bnRlcjtcclxuICAgICAgdmFyIGN1ciA9IHBvc0Zyb21Nb3VzZShjbSwgZSwgdHJ1ZSwgdHlwZSA9PSBcInJlY3RcIik7XHJcbiAgICAgIGlmICghY3VyKSByZXR1cm47XHJcbiAgICAgIGlmIChjbXAoY3VyLCBsYXN0UG9zKSAhPSAwKSB7XHJcbiAgICAgICAgZW5zdXJlRm9jdXMoY20pO1xyXG4gICAgICAgIGV4dGVuZFRvKGN1cik7XHJcbiAgICAgICAgdmFyIHZpc2libGUgPSB2aXNpYmxlTGluZXMoZGlzcGxheSwgZG9jKTtcclxuICAgICAgICBpZiAoY3VyLmxpbmUgPj0gdmlzaWJsZS50byB8fCBjdXIubGluZSA8IHZpc2libGUuZnJvbSlcclxuICAgICAgICAgIHNldFRpbWVvdXQob3BlcmF0aW9uKGNtLCBmdW5jdGlvbigpe2lmIChjb3VudGVyID09IGN1ckNvdW50KSBleHRlbmQoZSk7fSksIDE1MCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIG91dHNpZGUgPSBlLmNsaWVudFkgPCBlZGl0b3JTaXplLnRvcCA/IC0yMCA6IGUuY2xpZW50WSA+IGVkaXRvclNpemUuYm90dG9tID8gMjAgOiAwO1xyXG4gICAgICAgIGlmIChvdXRzaWRlKSBzZXRUaW1lb3V0KG9wZXJhdGlvbihjbSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBpZiAoY291bnRlciAhPSBjdXJDb3VudCkgcmV0dXJuO1xyXG4gICAgICAgICAgZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgKz0gb3V0c2lkZTtcclxuICAgICAgICAgIGV4dGVuZChlKTtcclxuICAgICAgICB9KSwgNTApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZG9uZShlKSB7XHJcbiAgICAgIGNvdW50ZXIgPSBJbmZpbml0eTtcclxuICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcclxuICAgICAgZGlzcGxheS5pbnB1dC5mb2N1cygpO1xyXG4gICAgICBvZmYoZG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIG1vdmUpO1xyXG4gICAgICBvZmYoZG9jdW1lbnQsIFwibW91c2V1cFwiLCB1cCk7XHJcbiAgICAgIGRvYy5oaXN0b3J5Lmxhc3RTZWxPcmlnaW4gPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBtb3ZlID0gb3BlcmF0aW9uKGNtLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgIGlmICghZV9idXR0b24oZSkpIGRvbmUoZSk7XHJcbiAgICAgIGVsc2UgZXh0ZW5kKGUpO1xyXG4gICAgfSk7XHJcbiAgICB2YXIgdXAgPSBvcGVyYXRpb24oY20sIGRvbmUpO1xyXG4gICAgb24oZG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIG1vdmUpO1xyXG4gICAgb24oZG9jdW1lbnQsIFwibW91c2V1cFwiLCB1cCk7XHJcbiAgfVxyXG5cclxuICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gZXZlbnQgaGFwcGVuZWQgaW4gdGhlIGd1dHRlciwgYW5kIGZpcmVzIHRoZVxyXG4gIC8vIGhhbmRsZXJzIGZvciB0aGUgY29ycmVzcG9uZGluZyBldmVudC5cclxuICBmdW5jdGlvbiBndXR0ZXJFdmVudChjbSwgZSwgdHlwZSwgcHJldmVudCwgc2lnbmFsZm4pIHtcclxuICAgIHRyeSB7IHZhciBtWCA9IGUuY2xpZW50WCwgbVkgPSBlLmNsaWVudFk7IH1cclxuICAgIGNhdGNoKGUpIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICBpZiAobVggPj0gTWF0aC5mbG9vcihjbS5kaXNwbGF5Lmd1dHRlcnMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQpKSByZXR1cm4gZmFsc2U7XHJcbiAgICBpZiAocHJldmVudCkgZV9wcmV2ZW50RGVmYXVsdChlKTtcclxuXHJcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XHJcbiAgICB2YXIgbGluZUJveCA9IGRpc3BsYXkubGluZURpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcbiAgICBpZiAobVkgPiBsaW5lQm94LmJvdHRvbSB8fCAhaGFzSGFuZGxlcihjbSwgdHlwZSkpIHJldHVybiBlX2RlZmF1bHRQcmV2ZW50ZWQoZSk7XHJcbiAgICBtWSAtPSBsaW5lQm94LnRvcCAtIGRpc3BsYXkudmlld09mZnNldDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNtLm9wdGlvbnMuZ3V0dGVycy5sZW5ndGg7ICsraSkge1xyXG4gICAgICB2YXIgZyA9IGRpc3BsYXkuZ3V0dGVycy5jaGlsZE5vZGVzW2ldO1xyXG4gICAgICBpZiAoZyAmJiBnLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0ID49IG1YKSB7XHJcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lQXRIZWlnaHQoY20uZG9jLCBtWSk7XHJcbiAgICAgICAgdmFyIGd1dHRlciA9IGNtLm9wdGlvbnMuZ3V0dGVyc1tpXTtcclxuICAgICAgICBzaWduYWxmbihjbSwgdHlwZSwgY20sIGxpbmUsIGd1dHRlciwgZSk7XHJcbiAgICAgICAgcmV0dXJuIGVfZGVmYXVsdFByZXZlbnRlZChlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2xpY2tJbkd1dHRlcihjbSwgZSkge1xyXG4gICAgcmV0dXJuIGd1dHRlckV2ZW50KGNtLCBlLCBcImd1dHRlckNsaWNrXCIsIHRydWUsIHNpZ25hbExhdGVyKTtcclxuICB9XHJcblxyXG4gIC8vIEtsdWRnZSB0byB3b3JrIGFyb3VuZCBzdHJhbmdlIElFIGJlaGF2aW9yIHdoZXJlIGl0J2xsIHNvbWV0aW1lc1xyXG4gIC8vIHJlLWZpcmUgYSBzZXJpZXMgb2YgZHJhZy1yZWxhdGVkIGV2ZW50cyByaWdodCBhZnRlciB0aGUgZHJvcCAoIzE1NTEpXHJcbiAgdmFyIGxhc3REcm9wID0gMDtcclxuXHJcbiAgZnVuY3Rpb24gb25Ecm9wKGUpIHtcclxuICAgIHZhciBjbSA9IHRoaXM7XHJcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkpXHJcbiAgICAgIHJldHVybjtcclxuICAgIGVfcHJldmVudERlZmF1bHQoZSk7XHJcbiAgICBpZiAoaWUpIGxhc3REcm9wID0gK25ldyBEYXRlO1xyXG4gICAgdmFyIHBvcyA9IHBvc0Zyb21Nb3VzZShjbSwgZSwgdHJ1ZSksIGZpbGVzID0gZS5kYXRhVHJhbnNmZXIuZmlsZXM7XHJcbiAgICBpZiAoIXBvcyB8fCBpc1JlYWRPbmx5KGNtKSkgcmV0dXJuO1xyXG4gICAgLy8gTWlnaHQgYmUgYSBmaWxlIGRyb3AsIGluIHdoaWNoIGNhc2Ugd2Ugc2ltcGx5IGV4dHJhY3QgdGhlIHRleHRcclxuICAgIC8vIGFuZCBpbnNlcnQgaXQuXHJcbiAgICBpZiAoZmlsZXMgJiYgZmlsZXMubGVuZ3RoICYmIHdpbmRvdy5GaWxlUmVhZGVyICYmIHdpbmRvdy5GaWxlKSB7XHJcbiAgICAgIHZhciBuID0gZmlsZXMubGVuZ3RoLCB0ZXh0ID0gQXJyYXkobiksIHJlYWQgPSAwO1xyXG4gICAgICB2YXIgbG9hZEZpbGUgPSBmdW5jdGlvbihmaWxlLCBpKSB7XHJcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyO1xyXG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSBvcGVyYXRpb24oY20sIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdGV4dFtpXSA9IHJlYWRlci5yZXN1bHQ7XHJcbiAgICAgICAgICBpZiAoKytyZWFkID09IG4pIHtcclxuICAgICAgICAgICAgcG9zID0gY2xpcFBvcyhjbS5kb2MsIHBvcyk7XHJcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSB7ZnJvbTogcG9zLCB0bzogcG9zLCB0ZXh0OiBzcGxpdExpbmVzKHRleHQuam9pbihcIlxcblwiKSksIG9yaWdpbjogXCJwYXN0ZVwifTtcclxuICAgICAgICAgICAgbWFrZUNoYW5nZShjbS5kb2MsIGNoYW5nZSk7XHJcbiAgICAgICAgICAgIHNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5KGNtLmRvYywgc2ltcGxlU2VsZWN0aW9uKHBvcywgY2hhbmdlRW5kKGNoYW5nZSkpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcclxuICAgICAgfTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIGxvYWRGaWxlKGZpbGVzW2ldLCBpKTtcclxuICAgIH0gZWxzZSB7IC8vIE5vcm1hbCBkcm9wXHJcbiAgICAgIC8vIERvbid0IGRvIGEgcmVwbGFjZSBpZiB0aGUgZHJvcCBoYXBwZW5lZCBpbnNpZGUgb2YgdGhlIHNlbGVjdGVkIHRleHQuXHJcbiAgICAgIGlmIChjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgJiYgY20uZG9jLnNlbC5jb250YWlucyhwb3MpID4gLTEpIHtcclxuICAgICAgICBjbS5zdGF0ZS5kcmFnZ2luZ1RleHQoZSk7XHJcbiAgICAgICAgLy8gRW5zdXJlIHRoZSBlZGl0b3IgaXMgcmUtZm9jdXNlZFxyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7Y20uZGlzcGxheS5pbnB1dC5mb2N1cygpO30sIDIwKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdHJ5IHtcclxuICAgICAgICB2YXIgdGV4dCA9IGUuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJUZXh0XCIpO1xyXG4gICAgICAgIGlmICh0ZXh0KSB7XHJcbiAgICAgICAgICBpZiAoY20uc3RhdGUuZHJhZ2dpbmdUZXh0ICYmICEobWFjID8gZS5tZXRhS2V5IDogZS5jdHJsS2V5KSlcclxuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcclxuICAgICAgICAgIHNldFNlbGVjdGlvbk5vVW5kbyhjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihwb3MsIHBvcykpO1xyXG4gICAgICAgICAgaWYgKHNlbGVjdGVkKSBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICByZXBsYWNlUmFuZ2UoY20uZG9jLCBcIlwiLCBzZWxlY3RlZFtpXS5hbmNob3IsIHNlbGVjdGVkW2ldLmhlYWQsIFwiZHJhZ1wiKTtcclxuICAgICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb24odGV4dCwgXCJhcm91bmRcIiwgXCJwYXN0ZVwiKTtcclxuICAgICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgY2F0Y2goZSl7fVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gb25EcmFnU3RhcnQoY20sIGUpIHtcclxuICAgIGlmIChpZSAmJiAoIWNtLnN0YXRlLmRyYWdnaW5nVGV4dCB8fCArbmV3IERhdGUgLSBsYXN0RHJvcCA8IDEwMCkpIHsgZV9zdG9wKGUpOyByZXR1cm47IH1cclxuICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkgfHwgZXZlbnRJbldpZGdldChjbS5kaXNwbGF5LCBlKSkgcmV0dXJuO1xyXG5cclxuICAgIGUuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJUZXh0XCIsIGNtLmdldFNlbGVjdGlvbigpKTtcclxuXHJcbiAgICAvLyBVc2UgZHVtbXkgaW1hZ2UgaW5zdGVhZCBvZiBkZWZhdWx0IGJyb3dzZXJzIGltYWdlLlxyXG4gICAgLy8gUmVjZW50IFNhZmFyaSAofjYuMC4yKSBoYXZlIGEgdGVuZGVuY3kgdG8gc2VnZmF1bHQgd2hlbiB0aGlzIGhhcHBlbnMsIHNvIHdlIGRvbid0IGRvIGl0IHRoZXJlLlxyXG4gICAgaWYgKGUuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZSAmJiAhc2FmYXJpKSB7XHJcbiAgICAgIHZhciBpbWcgPSBlbHQoXCJpbWdcIiwgbnVsbCwgbnVsbCwgXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IDA7IHRvcDogMDtcIik7XHJcbiAgICAgIGltZy5zcmMgPSBcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUFBQUNINUJBRUtBQUVBTEFBQUFBQUJBQUVBQUFJQ1RBRUFPdz09XCI7XHJcbiAgICAgIGlmIChwcmVzdG8pIHtcclxuICAgICAgICBpbWcud2lkdGggPSBpbWcuaGVpZ2h0ID0gMTtcclxuICAgICAgICBjbS5kaXNwbGF5LndyYXBwZXIuYXBwZW5kQ2hpbGQoaW1nKTtcclxuICAgICAgICAvLyBGb3JjZSBhIHJlbGF5b3V0LCBvciBPcGVyYSB3b24ndCB1c2Ugb3VyIGltYWdlIGZvciBzb21lIG9ic2N1cmUgcmVhc29uXHJcbiAgICAgICAgaW1nLl90b3AgPSBpbWcub2Zmc2V0VG9wO1xyXG4gICAgICB9XHJcbiAgICAgIGUuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShpbWcsIDAsIDApO1xyXG4gICAgICBpZiAocHJlc3RvKSBpbWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpbWcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gU0NST0xMIEVWRU5UU1xyXG5cclxuICAvLyBTeW5jIHRoZSBzY3JvbGxhYmxlIGFyZWEgYW5kIHNjcm9sbGJhcnMsIGVuc3VyZSB0aGUgdmlld3BvcnRcclxuICAvLyBjb3ZlcnMgdGhlIHZpc2libGUgYXJlYS5cclxuICBmdW5jdGlvbiBzZXRTY3JvbGxUb3AoY20sIHZhbCkge1xyXG4gICAgaWYgKE1hdGguYWJzKGNtLmRvYy5zY3JvbGxUb3AgLSB2YWwpIDwgMikgcmV0dXJuO1xyXG4gICAgY20uZG9jLnNjcm9sbFRvcCA9IHZhbDtcclxuICAgIGlmICghZ2Vja28pIHVwZGF0ZURpc3BsYXlTaW1wbGUoY20sIHt0b3A6IHZhbH0pO1xyXG4gICAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wICE9IHZhbCkgY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgPSB2YWw7XHJcbiAgICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsVG9wKHZhbCk7XHJcbiAgICBpZiAoZ2Vja28pIHVwZGF0ZURpc3BsYXlTaW1wbGUoY20pO1xyXG4gICAgc3RhcnRXb3JrZXIoY20sIDEwMCk7XHJcbiAgfVxyXG4gIC8vIFN5bmMgc2Nyb2xsZXIgYW5kIHNjcm9sbGJhciwgZW5zdXJlIHRoZSBndXR0ZXIgZWxlbWVudHMgYXJlXHJcbiAgLy8gYWxpZ25lZC5cclxuICBmdW5jdGlvbiBzZXRTY3JvbGxMZWZ0KGNtLCB2YWwsIGlzU2Nyb2xsZXIpIHtcclxuICAgIGlmIChpc1Njcm9sbGVyID8gdmFsID09IGNtLmRvYy5zY3JvbGxMZWZ0IDogTWF0aC5hYnMoY20uZG9jLnNjcm9sbExlZnQgLSB2YWwpIDwgMikgcmV0dXJuO1xyXG4gICAgdmFsID0gTWF0aC5taW4odmFsLCBjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFdpZHRoIC0gY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCk7XHJcbiAgICBjbS5kb2Muc2Nyb2xsTGVmdCA9IHZhbDtcclxuICAgIGFsaWduSG9yaXpvbnRhbGx5KGNtKTtcclxuICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgIT0gdmFsKSBjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgPSB2YWw7XHJcbiAgICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsTGVmdCh2YWwpO1xyXG4gIH1cclxuXHJcbiAgLy8gU2luY2UgdGhlIGRlbHRhIHZhbHVlcyByZXBvcnRlZCBvbiBtb3VzZSB3aGVlbCBldmVudHMgYXJlXHJcbiAgLy8gdW5zdGFuZGFyZGl6ZWQgYmV0d2VlbiBicm93c2VycyBhbmQgZXZlbiBicm93c2VyIHZlcnNpb25zLCBhbmRcclxuICAvLyBnZW5lcmFsbHkgaG9ycmlibHkgdW5wcmVkaWN0YWJsZSwgdGhpcyBjb2RlIHN0YXJ0cyBieSBtZWFzdXJpbmdcclxuICAvLyB0aGUgc2Nyb2xsIGVmZmVjdCB0aGF0IHRoZSBmaXJzdCBmZXcgbW91c2Ugd2hlZWwgZXZlbnRzIGhhdmUsXHJcbiAgLy8gYW5kLCBmcm9tIHRoYXQsIGRldGVjdHMgdGhlIHdheSBpdCBjYW4gY29udmVydCBkZWx0YXMgdG8gcGl4ZWxcclxuICAvLyBvZmZzZXRzIGFmdGVyd2FyZHMuXHJcbiAgLy9cclxuICAvLyBUaGUgcmVhc29uIHdlIHdhbnQgdG8ga25vdyB0aGUgYW1vdW50IGEgd2hlZWwgZXZlbnQgd2lsbCBzY3JvbGxcclxuICAvLyBpcyB0aGF0IGl0IGdpdmVzIHVzIGEgY2hhbmNlIHRvIHVwZGF0ZSB0aGUgZGlzcGxheSBiZWZvcmUgdGhlXHJcbiAgLy8gYWN0dWFsIHNjcm9sbGluZyBoYXBwZW5zLCByZWR1Y2luZyBmbGlja2VyaW5nLlxyXG5cclxuICB2YXIgd2hlZWxTYW1wbGVzID0gMCwgd2hlZWxQaXhlbHNQZXJVbml0ID0gbnVsbDtcclxuICAvLyBGaWxsIGluIGEgYnJvd3Nlci1kZXRlY3RlZCBzdGFydGluZyB2YWx1ZSBvbiBicm93c2VycyB3aGVyZSB3ZVxyXG4gIC8vIGtub3cgb25lLiBUaGVzZSBkb24ndCBoYXZlIHRvIGJlIGFjY3VyYXRlIC0tIHRoZSByZXN1bHQgb2YgdGhlbVxyXG4gIC8vIGJlaW5nIHdyb25nIHdvdWxkIGp1c3QgYmUgYSBzbGlnaHQgZmxpY2tlciBvbiB0aGUgZmlyc3Qgd2hlZWxcclxuICAvLyBzY3JvbGwgKGlmIGl0IGlzIGxhcmdlIGVub3VnaCkuXHJcbiAgaWYgKGllKSB3aGVlbFBpeGVsc1BlclVuaXQgPSAtLjUzO1xyXG4gIGVsc2UgaWYgKGdlY2tvKSB3aGVlbFBpeGVsc1BlclVuaXQgPSAxNTtcclxuICBlbHNlIGlmIChjaHJvbWUpIHdoZWVsUGl4ZWxzUGVyVW5pdCA9IC0uNztcclxuICBlbHNlIGlmIChzYWZhcmkpIHdoZWVsUGl4ZWxzUGVyVW5pdCA9IC0xLzM7XHJcblxyXG4gIHZhciB3aGVlbEV2ZW50RGVsdGEgPSBmdW5jdGlvbihlKSB7XHJcbiAgICB2YXIgZHggPSBlLndoZWVsRGVsdGFYLCBkeSA9IGUud2hlZWxEZWx0YVk7XHJcbiAgICBpZiAoZHggPT0gbnVsbCAmJiBlLmRldGFpbCAmJiBlLmF4aXMgPT0gZS5IT1JJWk9OVEFMX0FYSVMpIGR4ID0gZS5kZXRhaWw7XHJcbiAgICBpZiAoZHkgPT0gbnVsbCAmJiBlLmRldGFpbCAmJiBlLmF4aXMgPT0gZS5WRVJUSUNBTF9BWElTKSBkeSA9IGUuZGV0YWlsO1xyXG4gICAgZWxzZSBpZiAoZHkgPT0gbnVsbCkgZHkgPSBlLndoZWVsRGVsdGE7XHJcbiAgICByZXR1cm4ge3g6IGR4LCB5OiBkeX07XHJcbiAgfTtcclxuICBDb2RlTWlycm9yLndoZWVsRXZlbnRQaXhlbHMgPSBmdW5jdGlvbihlKSB7XHJcbiAgICB2YXIgZGVsdGEgPSB3aGVlbEV2ZW50RGVsdGEoZSk7XHJcbiAgICBkZWx0YS54ICo9IHdoZWVsUGl4ZWxzUGVyVW5pdDtcclxuICAgIGRlbHRhLnkgKj0gd2hlZWxQaXhlbHNQZXJVbml0O1xyXG4gICAgcmV0dXJuIGRlbHRhO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIG9uU2Nyb2xsV2hlZWwoY20sIGUpIHtcclxuICAgIHZhciBkZWx0YSA9IHdoZWVsRXZlbnREZWx0YShlKSwgZHggPSBkZWx0YS54LCBkeSA9IGRlbHRhLnk7XHJcblxyXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBzY3JvbGwgPSBkaXNwbGF5LnNjcm9sbGVyO1xyXG4gICAgLy8gUXVpdCBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2Nyb2xsIGhlcmVcclxuICAgIGlmICghKGR4ICYmIHNjcm9sbC5zY3JvbGxXaWR0aCA+IHNjcm9sbC5jbGllbnRXaWR0aCB8fFxyXG4gICAgICAgICAgZHkgJiYgc2Nyb2xsLnNjcm9sbEhlaWdodCA+IHNjcm9sbC5jbGllbnRIZWlnaHQpKSByZXR1cm47XHJcblxyXG4gICAgLy8gV2Via2l0IGJyb3dzZXJzIG9uIE9TIFggYWJvcnQgbW9tZW50dW0gc2Nyb2xscyB3aGVuIHRoZSB0YXJnZXRcclxuICAgIC8vIG9mIHRoZSBzY3JvbGwgZXZlbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBzY3JvbGxhYmxlIGVsZW1lbnQuXHJcbiAgICAvLyBUaGlzIGhhY2sgKHNlZSByZWxhdGVkIGNvZGUgaW4gcGF0Y2hEaXNwbGF5KSBtYWtlcyBzdXJlIHRoZVxyXG4gICAgLy8gZWxlbWVudCBpcyBrZXB0IGFyb3VuZC5cclxuICAgIGlmIChkeSAmJiBtYWMgJiYgd2Via2l0KSB7XHJcbiAgICAgIG91dGVyOiBmb3IgKHZhciBjdXIgPSBlLnRhcmdldCwgdmlldyA9IGRpc3BsYXkudmlldzsgY3VyICE9IHNjcm9sbDsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGlmICh2aWV3W2ldLm5vZGUgPT0gY3VyKSB7XHJcbiAgICAgICAgICAgIGNtLmRpc3BsYXkuY3VycmVudFdoZWVsVGFyZ2V0ID0gY3VyO1xyXG4gICAgICAgICAgICBicmVhayBvdXRlcjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBPbiBzb21lIGJyb3dzZXJzLCBob3Jpem9udGFsIHNjcm9sbGluZyB3aWxsIGNhdXNlIHJlZHJhd3MgdG9cclxuICAgIC8vIGhhcHBlbiBiZWZvcmUgdGhlIGd1dHRlciBoYXMgYmVlbiByZWFsaWduZWQsIGNhdXNpbmcgaXQgdG9cclxuICAgIC8vIHdyaWdnbGUgYXJvdW5kIGluIGEgbW9zdCB1bnNlZW1seSB3YXkuIFdoZW4gd2UgaGF2ZSBhblxyXG4gICAgLy8gZXN0aW1hdGVkIHBpeGVscy9kZWx0YSB2YWx1ZSwgd2UganVzdCBoYW5kbGUgaG9yaXpvbnRhbFxyXG4gICAgLy8gc2Nyb2xsaW5nIGVudGlyZWx5IGhlcmUuIEl0J2xsIGJlIHNsaWdodGx5IG9mZiBmcm9tIG5hdGl2ZSwgYnV0XHJcbiAgICAvLyBiZXR0ZXIgdGhhbiBnbGl0Y2hpbmcgb3V0LlxyXG4gICAgaWYgKGR4ICYmICFnZWNrbyAmJiAhcHJlc3RvICYmIHdoZWVsUGl4ZWxzUGVyVW5pdCAhPSBudWxsKSB7XHJcbiAgICAgIGlmIChkeSlcclxuICAgICAgICBzZXRTY3JvbGxUb3AoY20sIE1hdGgubWF4KDAsIE1hdGgubWluKHNjcm9sbC5zY3JvbGxUb3AgKyBkeSAqIHdoZWVsUGl4ZWxzUGVyVW5pdCwgc2Nyb2xsLnNjcm9sbEhlaWdodCAtIHNjcm9sbC5jbGllbnRIZWlnaHQpKSk7XHJcbiAgICAgIHNldFNjcm9sbExlZnQoY20sIE1hdGgubWF4KDAsIE1hdGgubWluKHNjcm9sbC5zY3JvbGxMZWZ0ICsgZHggKiB3aGVlbFBpeGVsc1BlclVuaXQsIHNjcm9sbC5zY3JvbGxXaWR0aCAtIHNjcm9sbC5jbGllbnRXaWR0aCkpKTtcclxuICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcclxuICAgICAgZGlzcGxheS53aGVlbFN0YXJ0WCA9IG51bGw7IC8vIEFib3J0IG1lYXN1cmVtZW50LCBpZiBpbiBwcm9ncmVzc1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gJ1Byb2plY3QnIHRoZSB2aXNpYmxlIHZpZXdwb3J0IHRvIGNvdmVyIHRoZSBhcmVhIHRoYXQgaXMgYmVpbmdcclxuICAgIC8vIHNjcm9sbGVkIGludG8gdmlldyAoaWYgd2Uga25vdyBlbm91Z2ggdG8gZXN0aW1hdGUgaXQpLlxyXG4gICAgaWYgKGR5ICYmIHdoZWVsUGl4ZWxzUGVyVW5pdCAhPSBudWxsKSB7XHJcbiAgICAgIHZhciBwaXhlbHMgPSBkeSAqIHdoZWVsUGl4ZWxzUGVyVW5pdDtcclxuICAgICAgdmFyIHRvcCA9IGNtLmRvYy5zY3JvbGxUb3AsIGJvdCA9IHRvcCArIGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQ7XHJcbiAgICAgIGlmIChwaXhlbHMgPCAwKSB0b3AgPSBNYXRoLm1heCgwLCB0b3AgKyBwaXhlbHMgLSA1MCk7XHJcbiAgICAgIGVsc2UgYm90ID0gTWF0aC5taW4oY20uZG9jLmhlaWdodCwgYm90ICsgcGl4ZWxzICsgNTApO1xyXG4gICAgICB1cGRhdGVEaXNwbGF5U2ltcGxlKGNtLCB7dG9wOiB0b3AsIGJvdHRvbTogYm90fSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHdoZWVsU2FtcGxlcyA8IDIwKSB7XHJcbiAgICAgIGlmIChkaXNwbGF5LndoZWVsU3RhcnRYID09IG51bGwpIHtcclxuICAgICAgICBkaXNwbGF5LndoZWVsU3RhcnRYID0gc2Nyb2xsLnNjcm9sbExlZnQ7IGRpc3BsYXkud2hlZWxTdGFydFkgPSBzY3JvbGwuc2Nyb2xsVG9wO1xyXG4gICAgICAgIGRpc3BsYXkud2hlZWxEWCA9IGR4OyBkaXNwbGF5LndoZWVsRFkgPSBkeTtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgaWYgKGRpc3BsYXkud2hlZWxTdGFydFggPT0gbnVsbCkgcmV0dXJuO1xyXG4gICAgICAgICAgdmFyIG1vdmVkWCA9IHNjcm9sbC5zY3JvbGxMZWZ0IC0gZGlzcGxheS53aGVlbFN0YXJ0WDtcclxuICAgICAgICAgIHZhciBtb3ZlZFkgPSBzY3JvbGwuc2Nyb2xsVG9wIC0gZGlzcGxheS53aGVlbFN0YXJ0WTtcclxuICAgICAgICAgIHZhciBzYW1wbGUgPSAobW92ZWRZICYmIGRpc3BsYXkud2hlZWxEWSAmJiBtb3ZlZFkgLyBkaXNwbGF5LndoZWVsRFkpIHx8XHJcbiAgICAgICAgICAgIChtb3ZlZFggJiYgZGlzcGxheS53aGVlbERYICYmIG1vdmVkWCAvIGRpc3BsYXkud2hlZWxEWCk7XHJcbiAgICAgICAgICBkaXNwbGF5LndoZWVsU3RhcnRYID0gZGlzcGxheS53aGVlbFN0YXJ0WSA9IG51bGw7XHJcbiAgICAgICAgICBpZiAoIXNhbXBsZSkgcmV0dXJuO1xyXG4gICAgICAgICAgd2hlZWxQaXhlbHNQZXJVbml0ID0gKHdoZWVsUGl4ZWxzUGVyVW5pdCAqIHdoZWVsU2FtcGxlcyArIHNhbXBsZSkgLyAod2hlZWxTYW1wbGVzICsgMSk7XHJcbiAgICAgICAgICArK3doZWVsU2FtcGxlcztcclxuICAgICAgICB9LCAyMDApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRpc3BsYXkud2hlZWxEWCArPSBkeDsgZGlzcGxheS53aGVlbERZICs9IGR5O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBLRVkgRVZFTlRTXHJcblxyXG4gIC8vIFJ1biBhIGhhbmRsZXIgdGhhdCB3YXMgYm91bmQgdG8gYSBrZXkuXHJcbiAgZnVuY3Rpb24gZG9IYW5kbGVCaW5kaW5nKGNtLCBib3VuZCwgZHJvcFNoaWZ0KSB7XHJcbiAgICBpZiAodHlwZW9mIGJvdW5kID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgYm91bmQgPSBjb21tYW5kc1tib3VuZF07XHJcbiAgICAgIGlmICghYm91bmQpIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIEVuc3VyZSBwcmV2aW91cyBpbnB1dCBoYXMgYmVlbiByZWFkLCBzbyB0aGF0IHRoZSBoYW5kbGVyIHNlZXMgYVxyXG4gICAgLy8gY29uc2lzdGVudCB2aWV3IG9mIHRoZSBkb2N1bWVudFxyXG4gICAgY20uZGlzcGxheS5pbnB1dC5lbnN1cmVQb2xsZWQoKTtcclxuICAgIHZhciBwcmV2U2hpZnQgPSBjbS5kaXNwbGF5LnNoaWZ0LCBkb25lID0gZmFsc2U7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoaXNSZWFkT25seShjbSkpIGNtLnN0YXRlLnN1cHByZXNzRWRpdHMgPSB0cnVlO1xyXG4gICAgICBpZiAoZHJvcFNoaWZ0KSBjbS5kaXNwbGF5LnNoaWZ0ID0gZmFsc2U7XHJcbiAgICAgIGRvbmUgPSBib3VuZChjbSkgIT0gUGFzcztcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIGNtLmRpc3BsYXkuc2hpZnQgPSBwcmV2U2hpZnQ7XHJcbiAgICAgIGNtLnN0YXRlLnN1cHByZXNzRWRpdHMgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBkb25lO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbG9va3VwS2V5Rm9yRWRpdG9yKGNtLCBuYW1lLCBoYW5kbGUpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY20uc3RhdGUua2V5TWFwcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgcmVzdWx0ID0gbG9va3VwS2V5KG5hbWUsIGNtLnN0YXRlLmtleU1hcHNbaV0sIGhhbmRsZSwgY20pO1xyXG4gICAgICBpZiAocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChjbS5vcHRpb25zLmV4dHJhS2V5cyAmJiBsb29rdXBLZXkobmFtZSwgY20ub3B0aW9ucy5leHRyYUtleXMsIGhhbmRsZSwgY20pKVxyXG4gICAgICB8fCBsb29rdXBLZXkobmFtZSwgY20ub3B0aW9ucy5rZXlNYXAsIGhhbmRsZSwgY20pO1xyXG4gIH1cclxuXHJcbiAgdmFyIHN0b3BTZXEgPSBuZXcgRGVsYXllZDtcclxuICBmdW5jdGlvbiBkaXNwYXRjaEtleShjbSwgbmFtZSwgZSwgaGFuZGxlKSB7XHJcbiAgICB2YXIgc2VxID0gY20uc3RhdGUua2V5U2VxO1xyXG4gICAgaWYgKHNlcSkge1xyXG4gICAgICBpZiAoaXNNb2RpZmllcktleShuYW1lKSkgcmV0dXJuIFwiaGFuZGxlZFwiO1xyXG4gICAgICBzdG9wU2VxLnNldCg1MCwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKGNtLnN0YXRlLmtleVNlcSA9PSBzZXEpIHtcclxuICAgICAgICAgIGNtLnN0YXRlLmtleVNlcSA9IG51bGw7XHJcbiAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgbmFtZSA9IHNlcSArIFwiIFwiICsgbmFtZTtcclxuICAgIH1cclxuICAgIHZhciByZXN1bHQgPSBsb29rdXBLZXlGb3JFZGl0b3IoY20sIG5hbWUsIGhhbmRsZSk7XHJcblxyXG4gICAgaWYgKHJlc3VsdCA9PSBcIm11bHRpXCIpXHJcbiAgICAgIGNtLnN0YXRlLmtleVNlcSA9IG5hbWU7XHJcbiAgICBpZiAocmVzdWx0ID09IFwiaGFuZGxlZFwiKVxyXG4gICAgICBzaWduYWxMYXRlcihjbSwgXCJrZXlIYW5kbGVkXCIsIGNtLCBuYW1lLCBlKTtcclxuXHJcbiAgICBpZiAocmVzdWx0ID09IFwiaGFuZGxlZFwiIHx8IHJlc3VsdCA9PSBcIm11bHRpXCIpIHtcclxuICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcclxuICAgICAgcmVzdGFydEJsaW5rKGNtKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2VxICYmICFyZXN1bHQgJiYgL1xcJyQvLnRlc3QobmFtZSkpIHtcclxuICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gISFyZXN1bHQ7XHJcbiAgfVxyXG5cclxuICAvLyBIYW5kbGUgYSBrZXkgZnJvbSB0aGUga2V5ZG93biBldmVudC5cclxuICBmdW5jdGlvbiBoYW5kbGVLZXlCaW5kaW5nKGNtLCBlKSB7XHJcbiAgICB2YXIgbmFtZSA9IGtleU5hbWUoZSwgdHJ1ZSk7XHJcbiAgICBpZiAoIW5hbWUpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICBpZiAoZS5zaGlmdEtleSAmJiAhY20uc3RhdGUua2V5U2VxKSB7XHJcbiAgICAgIC8vIEZpcnN0IHRyeSB0byByZXNvbHZlIGZ1bGwgbmFtZSAoaW5jbHVkaW5nICdTaGlmdC0nKS4gRmFpbGluZ1xyXG4gICAgICAvLyB0aGF0LCBzZWUgaWYgdGhlcmUgaXMgYSBjdXJzb3ItbW90aW9uIGNvbW1hbmQgKHN0YXJ0aW5nIHdpdGhcclxuICAgICAgLy8gJ2dvJykgYm91bmQgdG8gdGhlIGtleW5hbWUgd2l0aG91dCAnU2hpZnQtJy5cclxuICAgICAgcmV0dXJuIGRpc3BhdGNoS2V5KGNtLCBcIlNoaWZ0LVwiICsgbmFtZSwgZSwgZnVuY3Rpb24oYikge3JldHVybiBkb0hhbmRsZUJpbmRpbmcoY20sIGIsIHRydWUpO30pXHJcbiAgICAgICAgICB8fCBkaXNwYXRjaEtleShjbSwgbmFtZSwgZSwgZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICAgICBpZiAodHlwZW9mIGIgPT0gXCJzdHJpbmdcIiA/IC9eZ29bQS1aXS8udGVzdChiKSA6IGIubW90aW9uKVxyXG4gICAgICAgICAgICAgICAgIHJldHVybiBkb0hhbmRsZUJpbmRpbmcoY20sIGIpO1xyXG4gICAgICAgICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZGlzcGF0Y2hLZXkoY20sIG5hbWUsIGUsIGZ1bmN0aW9uKGIpIHsgcmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYik7IH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSGFuZGxlIGEga2V5IGZyb20gdGhlIGtleXByZXNzIGV2ZW50XHJcbiAgZnVuY3Rpb24gaGFuZGxlQ2hhckJpbmRpbmcoY20sIGUsIGNoKSB7XHJcbiAgICByZXR1cm4gZGlzcGF0Y2hLZXkoY20sIFwiJ1wiICsgY2ggKyBcIidcIiwgZSxcclxuICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihiKSB7IHJldHVybiBkb0hhbmRsZUJpbmRpbmcoY20sIGIsIHRydWUpOyB9KTtcclxuICB9XHJcblxyXG4gIHZhciBsYXN0U3RvcHBlZEtleSA9IG51bGw7XHJcbiAgZnVuY3Rpb24gb25LZXlEb3duKGUpIHtcclxuICAgIHZhciBjbSA9IHRoaXM7XHJcbiAgICBlbnN1cmVGb2N1cyhjbSk7XHJcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpKSByZXR1cm47XHJcbiAgICAvLyBJRSBkb2VzIHN0cmFuZ2UgdGhpbmdzIHdpdGggZXNjYXBlLlxyXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCAxMSAmJiBlLmtleUNvZGUgPT0gMjcpIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuICAgIHZhciBjb2RlID0gZS5rZXlDb2RlO1xyXG4gICAgY20uZGlzcGxheS5zaGlmdCA9IGNvZGUgPT0gMTYgfHwgZS5zaGlmdEtleTtcclxuICAgIHZhciBoYW5kbGVkID0gaGFuZGxlS2V5QmluZGluZyhjbSwgZSk7XHJcbiAgICBpZiAocHJlc3RvKSB7XHJcbiAgICAgIGxhc3RTdG9wcGVkS2V5ID0gaGFuZGxlZCA/IGNvZGUgOiBudWxsO1xyXG4gICAgICAvLyBPcGVyYSBoYXMgbm8gY3V0IGV2ZW50Li4uIHdlIHRyeSB0byBhdCBsZWFzdCBjYXRjaCB0aGUga2V5IGNvbWJvXHJcbiAgICAgIGlmICghaGFuZGxlZCAmJiBjb2RlID09IDg4ICYmICFoYXNDb3B5RXZlbnQgJiYgKG1hYyA/IGUubWV0YUtleSA6IGUuY3RybEtleSkpXHJcbiAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbihcIlwiLCBudWxsLCBcImN1dFwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUdXJuIG1vdXNlIGludG8gY3Jvc3NoYWlyIHdoZW4gQWx0IGlzIGhlbGQgb24gTWFjLlxyXG4gICAgaWYgKGNvZGUgPT0gMTggJiYgIS9cXGJDb2RlTWlycm9yLWNyb3NzaGFpclxcYi8udGVzdChjbS5kaXNwbGF5LmxpbmVEaXYuY2xhc3NOYW1lKSlcclxuICAgICAgc2hvd0Nyb3NzSGFpcihjbSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzaG93Q3Jvc3NIYWlyKGNtKSB7XHJcbiAgICB2YXIgbGluZURpdiA9IGNtLmRpc3BsYXkubGluZURpdjtcclxuICAgIGFkZENsYXNzKGxpbmVEaXYsIFwiQ29kZU1pcnJvci1jcm9zc2hhaXJcIik7XHJcblxyXG4gICAgZnVuY3Rpb24gdXAoZSkge1xyXG4gICAgICBpZiAoZS5rZXlDb2RlID09IDE4IHx8ICFlLmFsdEtleSkge1xyXG4gICAgICAgIHJtQ2xhc3MobGluZURpdiwgXCJDb2RlTWlycm9yLWNyb3NzaGFpclwiKTtcclxuICAgICAgICBvZmYoZG9jdW1lbnQsIFwia2V5dXBcIiwgdXApO1xyXG4gICAgICAgIG9mZihkb2N1bWVudCwgXCJtb3VzZW92ZXJcIiwgdXApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBvbihkb2N1bWVudCwgXCJrZXl1cFwiLCB1cCk7XHJcbiAgICBvbihkb2N1bWVudCwgXCJtb3VzZW92ZXJcIiwgdXApO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gb25LZXlVcChlKSB7XHJcbiAgICBpZiAoZS5rZXlDb2RlID09IDE2KSB0aGlzLmRvYy5zZWwuc2hpZnQgPSBmYWxzZTtcclxuICAgIHNpZ25hbERPTUV2ZW50KHRoaXMsIGUpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gb25LZXlQcmVzcyhlKSB7XHJcbiAgICB2YXIgY20gPSB0aGlzO1xyXG4gICAgaWYgKGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkgfHwgc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGUuY3RybEtleSAmJiAhZS5hbHRLZXkgfHwgbWFjICYmIGUubWV0YUtleSkgcmV0dXJuO1xyXG4gICAgdmFyIGtleUNvZGUgPSBlLmtleUNvZGUsIGNoYXJDb2RlID0gZS5jaGFyQ29kZTtcclxuICAgIGlmIChwcmVzdG8gJiYga2V5Q29kZSA9PSBsYXN0U3RvcHBlZEtleSkge2xhc3RTdG9wcGVkS2V5ID0gbnVsbDsgZV9wcmV2ZW50RGVmYXVsdChlKTsgcmV0dXJuO31cclxuICAgIGlmICgocHJlc3RvICYmICghZS53aGljaCB8fCBlLndoaWNoIDwgMTApKSAmJiBoYW5kbGVLZXlCaW5kaW5nKGNtLCBlKSkgcmV0dXJuO1xyXG4gICAgdmFyIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSA9PSBudWxsID8ga2V5Q29kZSA6IGNoYXJDb2RlKTtcclxuICAgIGlmIChoYW5kbGVDaGFyQmluZGluZyhjbSwgZSwgY2gpKSByZXR1cm47XHJcbiAgICBjbS5kaXNwbGF5LmlucHV0Lm9uS2V5UHJlc3MoZSk7XHJcbiAgfVxyXG5cclxuICAvLyBGT0NVUy9CTFVSIEVWRU5UU1xyXG5cclxuICBmdW5jdGlvbiBkZWxheUJsdXJFdmVudChjbSkge1xyXG4gICAgY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSB0cnVlO1xyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50KSB7XHJcbiAgICAgICAgY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSBmYWxzZTtcclxuICAgICAgICBvbkJsdXIoY20pO1xyXG4gICAgICB9XHJcbiAgICB9LCAxMDApO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gb25Gb2N1cyhjbSkge1xyXG4gICAgaWYgKGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50KSBjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCA9IGZhbHNlO1xyXG5cclxuICAgIGlmIChjbS5vcHRpb25zLnJlYWRPbmx5ID09IFwibm9jdXJzb3JcIikgcmV0dXJuO1xyXG4gICAgaWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSB7XHJcbiAgICAgIHNpZ25hbChjbSwgXCJmb2N1c1wiLCBjbSk7XHJcbiAgICAgIGNtLnN0YXRlLmZvY3VzZWQgPSB0cnVlO1xyXG4gICAgICBhZGRDbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIFwiQ29kZU1pcnJvci1mb2N1c2VkXCIpO1xyXG4gICAgICAvLyBUaGlzIHRlc3QgcHJldmVudHMgdGhpcyBmcm9tIGZpcmluZyB3aGVuIGEgY29udGV4dFxyXG4gICAgICAvLyBtZW51IGlzIGNsb3NlZCAoc2luY2UgdGhlIGlucHV0IHJlc2V0IHdvdWxkIGtpbGwgdGhlXHJcbiAgICAgIC8vIHNlbGVjdC1hbGwgZGV0ZWN0aW9uIGhhY2spXHJcbiAgICAgIGlmICghY20uY3VyT3AgJiYgY20uZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSAhPSBjbS5kb2Muc2VsKSB7XHJcbiAgICAgICAgY20uZGlzcGxheS5pbnB1dC5yZXNldCgpO1xyXG4gICAgICAgIGlmICh3ZWJraXQpIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNtLmRpc3BsYXkuaW5wdXQucmVzZXQodHJ1ZSk7IH0sIDIwKTsgLy8gSXNzdWUgIzE3MzBcclxuICAgICAgfVxyXG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnJlY2VpdmVkRm9jdXMoKTtcclxuICAgIH1cclxuICAgIHJlc3RhcnRCbGluayhjbSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIG9uQmx1cihjbSkge1xyXG4gICAgaWYgKGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50KSByZXR1cm47XHJcblxyXG4gICAgaWYgKGNtLnN0YXRlLmZvY3VzZWQpIHtcclxuICAgICAgc2lnbmFsKGNtLCBcImJsdXJcIiwgY20pO1xyXG4gICAgICBjbS5zdGF0ZS5mb2N1c2VkID0gZmFsc2U7XHJcbiAgICAgIHJtQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBcIkNvZGVNaXJyb3ItZm9jdXNlZFwiKTtcclxuICAgIH1cclxuICAgIGNsZWFySW50ZXJ2YWwoY20uZGlzcGxheS5ibGlua2VyKTtcclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7aWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSBjbS5kaXNwbGF5LnNoaWZ0ID0gZmFsc2U7fSwgMTUwKTtcclxuICB9XHJcblxyXG4gIC8vIENPTlRFWFQgTUVOVSBIQU5ETElOR1xyXG5cclxuICAvLyBUbyBtYWtlIHRoZSBjb250ZXh0IG1lbnUgd29yaywgd2UgbmVlZCB0byBicmllZmx5IHVuaGlkZSB0aGVcclxuICAvLyB0ZXh0YXJlYSAobWFraW5nIGl0IGFzIHVub2J0cnVzaXZlIGFzIHBvc3NpYmxlKSB0byBsZXQgdGhlXHJcbiAgLy8gcmlnaHQtY2xpY2sgdGFrZSBlZmZlY3Qgb24gaXQuXHJcbiAgZnVuY3Rpb24gb25Db250ZXh0TWVudShjbSwgZSkge1xyXG4gICAgaWYgKGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkgfHwgY29udGV4dE1lbnVJbkd1dHRlcihjbSwgZSkpIHJldHVybjtcclxuICAgIGNtLmRpc3BsYXkuaW5wdXQub25Db250ZXh0TWVudShlKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNvbnRleHRNZW51SW5HdXR0ZXIoY20sIGUpIHtcclxuICAgIGlmICghaGFzSGFuZGxlcihjbSwgXCJndXR0ZXJDb250ZXh0TWVudVwiKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIGd1dHRlckV2ZW50KGNtLCBlLCBcImd1dHRlckNvbnRleHRNZW51XCIsIGZhbHNlLCBzaWduYWwpO1xyXG4gIH1cclxuXHJcbiAgLy8gVVBEQVRJTkdcclxuXHJcbiAgLy8gQ29tcHV0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGVuZCBvZiBhIGNoYW5nZSAoaXRzICd0bycgcHJvcGVydHlcclxuICAvLyByZWZlcnMgdG8gdGhlIHByZS1jaGFuZ2UgZW5kKS5cclxuICB2YXIgY2hhbmdlRW5kID0gQ29kZU1pcnJvci5jaGFuZ2VFbmQgPSBmdW5jdGlvbihjaGFuZ2UpIHtcclxuICAgIGlmICghY2hhbmdlLnRleHQpIHJldHVybiBjaGFuZ2UudG87XHJcbiAgICByZXR1cm4gUG9zKGNoYW5nZS5mcm9tLmxpbmUgKyBjaGFuZ2UudGV4dC5sZW5ndGggLSAxLFxyXG4gICAgICAgICAgICAgICBsc3QoY2hhbmdlLnRleHQpLmxlbmd0aCArIChjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSA/IGNoYW5nZS5mcm9tLmNoIDogMCkpO1xyXG4gIH07XHJcblxyXG4gIC8vIEFkanVzdCBhIHBvc2l0aW9uIHRvIHJlZmVyIHRvIHRoZSBwb3N0LWNoYW5nZSBwb3NpdGlvbiBvZiB0aGVcclxuICAvLyBzYW1lIHRleHQsIG9yIHRoZSBlbmQgb2YgdGhlIGNoYW5nZSBpZiB0aGUgY2hhbmdlIGNvdmVycyBpdC5cclxuICBmdW5jdGlvbiBhZGp1c3RGb3JDaGFuZ2UocG9zLCBjaGFuZ2UpIHtcclxuICAgIGlmIChjbXAocG9zLCBjaGFuZ2UuZnJvbSkgPCAwKSByZXR1cm4gcG9zO1xyXG4gICAgaWYgKGNtcChwb3MsIGNoYW5nZS50bykgPD0gMCkgcmV0dXJuIGNoYW5nZUVuZChjaGFuZ2UpO1xyXG5cclxuICAgIHZhciBsaW5lID0gcG9zLmxpbmUgKyBjaGFuZ2UudGV4dC5sZW5ndGggLSAoY2hhbmdlLnRvLmxpbmUgLSBjaGFuZ2UuZnJvbS5saW5lKSAtIDEsIGNoID0gcG9zLmNoO1xyXG4gICAgaWYgKHBvcy5saW5lID09IGNoYW5nZS50by5saW5lKSBjaCArPSBjaGFuZ2VFbmQoY2hhbmdlKS5jaCAtIGNoYW5nZS50by5jaDtcclxuICAgIHJldHVybiBQb3MobGluZSwgY2gpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYywgY2hhbmdlKSB7XHJcbiAgICB2YXIgb3V0ID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciByYW5nZSA9IGRvYy5zZWwucmFuZ2VzW2ldO1xyXG4gICAgICBvdXQucHVzaChuZXcgUmFuZ2UoYWRqdXN0Rm9yQ2hhbmdlKHJhbmdlLmFuY2hvciwgY2hhbmdlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdEZvckNoYW5nZShyYW5nZS5oZWFkLCBjaGFuZ2UpKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9ybWFsaXplU2VsZWN0aW9uKG91dCwgZG9jLnNlbC5wcmltSW5kZXgpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gb2Zmc2V0UG9zKHBvcywgb2xkLCBudykge1xyXG4gICAgaWYgKHBvcy5saW5lID09IG9sZC5saW5lKVxyXG4gICAgICByZXR1cm4gUG9zKG53LmxpbmUsIHBvcy5jaCAtIG9sZC5jaCArIG53LmNoKTtcclxuICAgIGVsc2VcclxuICAgICAgcmV0dXJuIFBvcyhudy5saW5lICsgKHBvcy5saW5lIC0gb2xkLmxpbmUpLCBwb3MuY2gpO1xyXG4gIH1cclxuXHJcbiAgLy8gVXNlZCBieSByZXBsYWNlU2VsZWN0aW9ucyB0byBhbGxvdyBtb3ZpbmcgdGhlIHNlbGVjdGlvbiB0byB0aGVcclxuICAvLyBzdGFydCBvciBhcm91bmQgdGhlIHJlcGxhY2VkIHRlc3QuIEhpbnQgbWF5IGJlIFwic3RhcnRcIiBvciBcImFyb3VuZFwiLlxyXG4gIGZ1bmN0aW9uIGNvbXB1dGVSZXBsYWNlZFNlbChkb2MsIGNoYW5nZXMsIGhpbnQpIHtcclxuICAgIHZhciBvdXQgPSBbXTtcclxuICAgIHZhciBvbGRQcmV2ID0gUG9zKGRvYy5maXJzdCwgMCksIG5ld1ByZXYgPSBvbGRQcmV2O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xyXG4gICAgICB2YXIgZnJvbSA9IG9mZnNldFBvcyhjaGFuZ2UuZnJvbSwgb2xkUHJldiwgbmV3UHJldik7XHJcbiAgICAgIHZhciB0byA9IG9mZnNldFBvcyhjaGFuZ2VFbmQoY2hhbmdlKSwgb2xkUHJldiwgbmV3UHJldik7XHJcbiAgICAgIG9sZFByZXYgPSBjaGFuZ2UudG87XHJcbiAgICAgIG5ld1ByZXYgPSB0bztcclxuICAgICAgaWYgKGhpbnQgPT0gXCJhcm91bmRcIikge1xyXG4gICAgICAgIHZhciByYW5nZSA9IGRvYy5zZWwucmFuZ2VzW2ldLCBpbnYgPSBjbXAocmFuZ2UuaGVhZCwgcmFuZ2UuYW5jaG9yKSA8IDA7XHJcbiAgICAgICAgb3V0W2ldID0gbmV3IFJhbmdlKGludiA/IHRvIDogZnJvbSwgaW52ID8gZnJvbSA6IHRvKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBvdXRbaV0gPSBuZXcgUmFuZ2UoZnJvbSwgZnJvbSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKG91dCwgZG9jLnNlbC5wcmltSW5kZXgpO1xyXG4gIH1cclxuXHJcbiAgLy8gQWxsb3cgXCJiZWZvcmVDaGFuZ2VcIiBldmVudCBoYW5kbGVycyB0byBpbmZsdWVuY2UgYSBjaGFuZ2VcclxuICBmdW5jdGlvbiBmaWx0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UsIHVwZGF0ZSkge1xyXG4gICAgdmFyIG9iaiA9IHtcclxuICAgICAgY2FuY2VsZWQ6IGZhbHNlLFxyXG4gICAgICBmcm9tOiBjaGFuZ2UuZnJvbSxcclxuICAgICAgdG86IGNoYW5nZS50byxcclxuICAgICAgdGV4dDogY2hhbmdlLnRleHQsXHJcbiAgICAgIG9yaWdpbjogY2hhbmdlLm9yaWdpbixcclxuICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHsgdGhpcy5jYW5jZWxlZCA9IHRydWU7IH1cclxuICAgIH07XHJcbiAgICBpZiAodXBkYXRlKSBvYmoudXBkYXRlID0gZnVuY3Rpb24oZnJvbSwgdG8sIHRleHQsIG9yaWdpbikge1xyXG4gICAgICBpZiAoZnJvbSkgdGhpcy5mcm9tID0gY2xpcFBvcyhkb2MsIGZyb20pO1xyXG4gICAgICBpZiAodG8pIHRoaXMudG8gPSBjbGlwUG9zKGRvYywgdG8pO1xyXG4gICAgICBpZiAodGV4dCkgdGhpcy50ZXh0ID0gdGV4dDtcclxuICAgICAgaWYgKG9yaWdpbiAhPT0gdW5kZWZpbmVkKSB0aGlzLm9yaWdpbiA9IG9yaWdpbjtcclxuICAgIH07XHJcbiAgICBzaWduYWwoZG9jLCBcImJlZm9yZUNoYW5nZVwiLCBkb2MsIG9iaik7XHJcbiAgICBpZiAoZG9jLmNtKSBzaWduYWwoZG9jLmNtLCBcImJlZm9yZUNoYW5nZVwiLCBkb2MuY20sIG9iaik7XHJcblxyXG4gICAgaWYgKG9iai5jYW5jZWxlZCkgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4ge2Zyb206IG9iai5mcm9tLCB0bzogb2JqLnRvLCB0ZXh0OiBvYmoudGV4dCwgb3JpZ2luOiBvYmoub3JpZ2lufTtcclxuICB9XHJcblxyXG4gIC8vIEFwcGx5IGEgY2hhbmdlIHRvIGEgZG9jdW1lbnQsIGFuZCBhZGQgaXQgdG8gdGhlIGRvY3VtZW50J3NcclxuICAvLyBoaXN0b3J5LCBhbmQgcHJvcGFnYXRpbmcgaXQgdG8gYWxsIGxpbmtlZCBkb2N1bWVudHMuXHJcbiAgZnVuY3Rpb24gbWFrZUNoYW5nZShkb2MsIGNoYW5nZSwgaWdub3JlUmVhZE9ubHkpIHtcclxuICAgIGlmIChkb2MuY20pIHtcclxuICAgICAgaWYgKCFkb2MuY20uY3VyT3ApIHJldHVybiBvcGVyYXRpb24oZG9jLmNtLCBtYWtlQ2hhbmdlKShkb2MsIGNoYW5nZSwgaWdub3JlUmVhZE9ubHkpO1xyXG4gICAgICBpZiAoZG9jLmNtLnN0YXRlLnN1cHByZXNzRWRpdHMpIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaGFzSGFuZGxlcihkb2MsIFwiYmVmb3JlQ2hhbmdlXCIpIHx8IGRvYy5jbSAmJiBoYXNIYW5kbGVyKGRvYy5jbSwgXCJiZWZvcmVDaGFuZ2VcIikpIHtcclxuICAgICAgY2hhbmdlID0gZmlsdGVyQ2hhbmdlKGRvYywgY2hhbmdlLCB0cnVlKTtcclxuICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQb3NzaWJseSBzcGxpdCBvciBzdXBwcmVzcyB0aGUgdXBkYXRlIGJhc2VkIG9uIHRoZSBwcmVzZW5jZVxyXG4gICAgLy8gb2YgcmVhZC1vbmx5IHNwYW5zIGluIGl0cyByYW5nZS5cclxuICAgIHZhciBzcGxpdCA9IHNhd1JlYWRPbmx5U3BhbnMgJiYgIWlnbm9yZVJlYWRPbmx5ICYmIHJlbW92ZVJlYWRPbmx5UmFuZ2VzKGRvYywgY2hhbmdlLmZyb20sIGNoYW5nZS50byk7XHJcbiAgICBpZiAoc3BsaXQpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IHNwbGl0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKVxyXG4gICAgICAgIG1ha2VDaGFuZ2VJbm5lcihkb2MsIHtmcm9tOiBzcGxpdFtpXS5mcm9tLCB0bzogc3BsaXRbaV0udG8sIHRleHQ6IGkgPyBbXCJcIl0gOiBjaGFuZ2UudGV4dH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbWFrZUNoYW5nZUlubmVyKGRvYywgY2hhbmdlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG1ha2VDaGFuZ2VJbm5lcihkb2MsIGNoYW5nZSkge1xyXG4gICAgaWYgKGNoYW5nZS50ZXh0Lmxlbmd0aCA9PSAxICYmIGNoYW5nZS50ZXh0WzBdID09IFwiXCIgJiYgY21wKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pID09IDApIHJldHVybjtcclxuICAgIHZhciBzZWxBZnRlciA9IGNvbXB1dGVTZWxBZnRlckNoYW5nZShkb2MsIGNoYW5nZSk7XHJcbiAgICBhZGRDaGFuZ2VUb0hpc3RvcnkoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBkb2MuY20gPyBkb2MuY20uY3VyT3AuaWQgOiBOYU4pO1xyXG5cclxuICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBzdHJldGNoU3BhbnNPdmVyQ2hhbmdlKGRvYywgY2hhbmdlKSk7XHJcbiAgICB2YXIgcmViYXNlZCA9IFtdO1xyXG5cclxuICAgIGxpbmtlZERvY3MoZG9jLCBmdW5jdGlvbihkb2MsIHNoYXJlZEhpc3QpIHtcclxuICAgICAgaWYgKCFzaGFyZWRIaXN0ICYmIGluZGV4T2YocmViYXNlZCwgZG9jLmhpc3RvcnkpID09IC0xKSB7XHJcbiAgICAgICAgcmViYXNlSGlzdChkb2MuaGlzdG9yeSwgY2hhbmdlKTtcclxuICAgICAgICByZWJhc2VkLnB1c2goZG9jLmhpc3RvcnkpO1xyXG4gICAgICB9XHJcbiAgICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIG51bGwsIHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gUmV2ZXJ0IGEgY2hhbmdlIHN0b3JlZCBpbiBhIGRvY3VtZW50J3MgaGlzdG9yeS5cclxuICBmdW5jdGlvbiBtYWtlQ2hhbmdlRnJvbUhpc3RvcnkoZG9jLCB0eXBlLCBhbGxvd1NlbGVjdGlvbk9ubHkpIHtcclxuICAgIGlmIChkb2MuY20gJiYgZG9jLmNtLnN0YXRlLnN1cHByZXNzRWRpdHMpIHJldHVybjtcclxuXHJcbiAgICB2YXIgaGlzdCA9IGRvYy5oaXN0b3J5LCBldmVudCwgc2VsQWZ0ZXIgPSBkb2Muc2VsO1xyXG4gICAgdmFyIHNvdXJjZSA9IHR5cGUgPT0gXCJ1bmRvXCIgPyBoaXN0LmRvbmUgOiBoaXN0LnVuZG9uZSwgZGVzdCA9IHR5cGUgPT0gXCJ1bmRvXCIgPyBoaXN0LnVuZG9uZSA6IGhpc3QuZG9uZTtcclxuXHJcbiAgICAvLyBWZXJpZnkgdGhhdCB0aGVyZSBpcyBhIHVzZWFibGUgZXZlbnQgKHNvIHRoYXQgY3RybC16IHdvbid0XHJcbiAgICAvLyBuZWVkbGVzc2x5IGNsZWFyIHNlbGVjdGlvbiBldmVudHMpXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBldmVudCA9IHNvdXJjZVtpXTtcclxuICAgICAgaWYgKGFsbG93U2VsZWN0aW9uT25seSA/IGV2ZW50LnJhbmdlcyAmJiAhZXZlbnQuZXF1YWxzKGRvYy5zZWwpIDogIWV2ZW50LnJhbmdlcylcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGlmIChpID09IHNvdXJjZS5sZW5ndGgpIHJldHVybjtcclxuICAgIGhpc3QubGFzdE9yaWdpbiA9IGhpc3QubGFzdFNlbE9yaWdpbiA9IG51bGw7XHJcblxyXG4gICAgZm9yICg7Oykge1xyXG4gICAgICBldmVudCA9IHNvdXJjZS5wb3AoKTtcclxuICAgICAgaWYgKGV2ZW50LnJhbmdlcykge1xyXG4gICAgICAgIHB1c2hTZWxlY3Rpb25Ub0hpc3RvcnkoZXZlbnQsIGRlc3QpO1xyXG4gICAgICAgIGlmIChhbGxvd1NlbGVjdGlvbk9ubHkgJiYgIWV2ZW50LmVxdWFscyhkb2Muc2VsKSkge1xyXG4gICAgICAgICAgc2V0U2VsZWN0aW9uKGRvYywgZXZlbnQsIHtjbGVhclJlZG86IGZhbHNlfSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlbEFmdGVyID0gZXZlbnQ7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICAvLyBCdWlsZCB1cCBhIHJldmVyc2UgY2hhbmdlIG9iamVjdCB0byBhZGQgdG8gdGhlIG9wcG9zaXRlIGhpc3RvcnlcclxuICAgIC8vIHN0YWNrIChyZWRvIHdoZW4gdW5kb2luZywgYW5kIHZpY2UgdmVyc2EpLlxyXG4gICAgdmFyIGFudGlDaGFuZ2VzID0gW107XHJcbiAgICBwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KHNlbEFmdGVyLCBkZXN0KTtcclxuICAgIGRlc3QucHVzaCh7Y2hhbmdlczogYW50aUNoYW5nZXMsIGdlbmVyYXRpb246IGhpc3QuZ2VuZXJhdGlvbn0pO1xyXG4gICAgaGlzdC5nZW5lcmF0aW9uID0gZXZlbnQuZ2VuZXJhdGlvbiB8fCArK2hpc3QubWF4R2VuZXJhdGlvbjtcclxuXHJcbiAgICB2YXIgZmlsdGVyID0gaGFzSGFuZGxlcihkb2MsIFwiYmVmb3JlQ2hhbmdlXCIpIHx8IGRvYy5jbSAmJiBoYXNIYW5kbGVyKGRvYy5jbSwgXCJiZWZvcmVDaGFuZ2VcIik7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IGV2ZW50LmNoYW5nZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgdmFyIGNoYW5nZSA9IGV2ZW50LmNoYW5nZXNbaV07XHJcbiAgICAgIGNoYW5nZS5vcmlnaW4gPSB0eXBlO1xyXG4gICAgICBpZiAoZmlsdGVyICYmICFmaWx0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UsIGZhbHNlKSkge1xyXG4gICAgICAgIHNvdXJjZS5sZW5ndGggPSAwO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgYW50aUNoYW5nZXMucHVzaChoaXN0b3J5Q2hhbmdlRnJvbUNoYW5nZShkb2MsIGNoYW5nZSkpO1xyXG5cclxuICAgICAgdmFyIGFmdGVyID0gaSA/IGNvbXB1dGVTZWxBZnRlckNoYW5nZShkb2MsIGNoYW5nZSkgOiBsc3Qoc291cmNlKTtcclxuICAgICAgbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgYWZ0ZXIsIG1lcmdlT2xkU3BhbnMoZG9jLCBjaGFuZ2UpKTtcclxuICAgICAgaWYgKCFpICYmIGRvYy5jbSkgZG9jLmNtLnNjcm9sbEludG9WaWV3KHtmcm9tOiBjaGFuZ2UuZnJvbSwgdG86IGNoYW5nZUVuZChjaGFuZ2UpfSk7XHJcbiAgICAgIHZhciByZWJhc2VkID0gW107XHJcblxyXG4gICAgICAvLyBQcm9wYWdhdGUgdG8gdGhlIGxpbmtlZCBkb2N1bWVudHNcclxuICAgICAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uKGRvYywgc2hhcmVkSGlzdCkge1xyXG4gICAgICAgIGlmICghc2hhcmVkSGlzdCAmJiBpbmRleE9mKHJlYmFzZWQsIGRvYy5oaXN0b3J5KSA9PSAtMSkge1xyXG4gICAgICAgICAgcmViYXNlSGlzdChkb2MuaGlzdG9yeSwgY2hhbmdlKTtcclxuICAgICAgICAgIHJlYmFzZWQucHVzaChkb2MuaGlzdG9yeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIG51bGwsIG1lcmdlT2xkU3BhbnMoZG9jLCBjaGFuZ2UpKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTdWItdmlld3MgbmVlZCB0aGVpciBsaW5lIG51bWJlcnMgc2hpZnRlZCB3aGVuIHRleHQgaXMgYWRkZWRcclxuICAvLyBhYm92ZSBvciBiZWxvdyB0aGVtIGluIHRoZSBwYXJlbnQgZG9jdW1lbnQuXHJcbiAgZnVuY3Rpb24gc2hpZnREb2MoZG9jLCBkaXN0YW5jZSkge1xyXG4gICAgaWYgKGRpc3RhbmNlID09IDApIHJldHVybjtcclxuICAgIGRvYy5maXJzdCArPSBkaXN0YW5jZTtcclxuICAgIGRvYy5zZWwgPSBuZXcgU2VsZWN0aW9uKG1hcChkb2Muc2VsLnJhbmdlcywgZnVuY3Rpb24ocmFuZ2UpIHtcclxuICAgICAgcmV0dXJuIG5ldyBSYW5nZShQb3MocmFuZ2UuYW5jaG9yLmxpbmUgKyBkaXN0YW5jZSwgcmFuZ2UuYW5jaG9yLmNoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICBQb3MocmFuZ2UuaGVhZC5saW5lICsgZGlzdGFuY2UsIHJhbmdlLmhlYWQuY2gpKTtcclxuICAgIH0pLCBkb2Muc2VsLnByaW1JbmRleCk7XHJcbiAgICBpZiAoZG9jLmNtKSB7XHJcbiAgICAgIHJlZ0NoYW5nZShkb2MuY20sIGRvYy5maXJzdCwgZG9jLmZpcnN0IC0gZGlzdGFuY2UsIGRpc3RhbmNlKTtcclxuICAgICAgZm9yICh2YXIgZCA9IGRvYy5jbS5kaXNwbGF5LCBsID0gZC52aWV3RnJvbTsgbCA8IGQudmlld1RvOyBsKyspXHJcbiAgICAgICAgcmVnTGluZUNoYW5nZShkb2MuY20sIGwsIFwiZ3V0dGVyXCIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTW9yZSBsb3dlci1sZXZlbCBjaGFuZ2UgZnVuY3Rpb24sIGhhbmRsaW5nIG9ubHkgYSBzaW5nbGUgZG9jdW1lbnRcclxuICAvLyAobm90IGxpbmtlZCBvbmVzKS5cclxuICBmdW5jdGlvbiBtYWtlQ2hhbmdlU2luZ2xlRG9jKGRvYywgY2hhbmdlLCBzZWxBZnRlciwgc3BhbnMpIHtcclxuICAgIGlmIChkb2MuY20gJiYgIWRvYy5jbS5jdXJPcClcclxuICAgICAgcmV0dXJuIG9wZXJhdGlvbihkb2MuY20sIG1ha2VDaGFuZ2VTaW5nbGVEb2MpKGRvYywgY2hhbmdlLCBzZWxBZnRlciwgc3BhbnMpO1xyXG5cclxuICAgIGlmIChjaGFuZ2UudG8ubGluZSA8IGRvYy5maXJzdCkge1xyXG4gICAgICBzaGlmdERvYyhkb2MsIGNoYW5nZS50ZXh0Lmxlbmd0aCAtIDEgLSAoY2hhbmdlLnRvLmxpbmUgLSBjaGFuZ2UuZnJvbS5saW5lKSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChjaGFuZ2UuZnJvbS5saW5lID4gZG9jLmxhc3RMaW5lKCkpIHJldHVybjtcclxuXHJcbiAgICAvLyBDbGlwIHRoZSBjaGFuZ2UgdG8gdGhlIHNpemUgb2YgdGhpcyBkb2NcclxuICAgIGlmIChjaGFuZ2UuZnJvbS5saW5lIDwgZG9jLmZpcnN0KSB7XHJcbiAgICAgIHZhciBzaGlmdCA9IGNoYW5nZS50ZXh0Lmxlbmd0aCAtIDEgLSAoZG9jLmZpcnN0IC0gY2hhbmdlLmZyb20ubGluZSk7XHJcbiAgICAgIHNoaWZ0RG9jKGRvYywgc2hpZnQpO1xyXG4gICAgICBjaGFuZ2UgPSB7ZnJvbTogUG9zKGRvYy5maXJzdCwgMCksIHRvOiBQb3MoY2hhbmdlLnRvLmxpbmUgKyBzaGlmdCwgY2hhbmdlLnRvLmNoKSxcclxuICAgICAgICAgICAgICAgIHRleHQ6IFtsc3QoY2hhbmdlLnRleHQpXSwgb3JpZ2luOiBjaGFuZ2Uub3JpZ2lufTtcclxuICAgIH1cclxuICAgIHZhciBsYXN0ID0gZG9jLmxhc3RMaW5lKCk7XHJcbiAgICBpZiAoY2hhbmdlLnRvLmxpbmUgPiBsYXN0KSB7XHJcbiAgICAgIGNoYW5nZSA9IHtmcm9tOiBjaGFuZ2UuZnJvbSwgdG86IFBvcyhsYXN0LCBnZXRMaW5lKGRvYywgbGFzdCkudGV4dC5sZW5ndGgpLFxyXG4gICAgICAgICAgICAgICAgdGV4dDogW2NoYW5nZS50ZXh0WzBdXSwgb3JpZ2luOiBjaGFuZ2Uub3JpZ2lufTtcclxuICAgIH1cclxuXHJcbiAgICBjaGFuZ2UucmVtb3ZlZCA9IGdldEJldHdlZW4oZG9jLCBjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKTtcclxuXHJcbiAgICBpZiAoIXNlbEFmdGVyKSBzZWxBZnRlciA9IGNvbXB1dGVTZWxBZnRlckNoYW5nZShkb2MsIGNoYW5nZSk7XHJcbiAgICBpZiAoZG9jLmNtKSBtYWtlQ2hhbmdlU2luZ2xlRG9jSW5FZGl0b3IoZG9jLmNtLCBjaGFuZ2UsIHNwYW5zKTtcclxuICAgIGVsc2UgdXBkYXRlRG9jKGRvYywgY2hhbmdlLCBzcGFucyk7XHJcbiAgICBzZXRTZWxlY3Rpb25Ob1VuZG8oZG9jLCBzZWxBZnRlciwgc2VsX2RvbnRTY3JvbGwpO1xyXG4gIH1cclxuXHJcbiAgLy8gSGFuZGxlIHRoZSBpbnRlcmFjdGlvbiBvZiBhIGNoYW5nZSB0byBhIGRvY3VtZW50IHdpdGggdGhlIGVkaXRvclxyXG4gIC8vIHRoYXQgdGhpcyBkb2N1bWVudCBpcyBwYXJ0IG9mLlxyXG4gIGZ1bmN0aW9uIG1ha2VDaGFuZ2VTaW5nbGVEb2NJbkVkaXRvcihjbSwgY2hhbmdlLCBzcGFucykge1xyXG4gICAgdmFyIGRvYyA9IGNtLmRvYywgZGlzcGxheSA9IGNtLmRpc3BsYXksIGZyb20gPSBjaGFuZ2UuZnJvbSwgdG8gPSBjaGFuZ2UudG87XHJcblxyXG4gICAgdmFyIHJlY29tcHV0ZU1heExlbmd0aCA9IGZhbHNlLCBjaGVja1dpZHRoU3RhcnQgPSBmcm9tLmxpbmU7XHJcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XHJcbiAgICAgIGNoZWNrV2lkdGhTdGFydCA9IGxpbmVObyh2aXN1YWxMaW5lKGdldExpbmUoZG9jLCBmcm9tLmxpbmUpKSk7XHJcbiAgICAgIGRvYy5pdGVyKGNoZWNrV2lkdGhTdGFydCwgdG8ubGluZSArIDEsIGZ1bmN0aW9uKGxpbmUpIHtcclxuICAgICAgICBpZiAobGluZSA9PSBkaXNwbGF5Lm1heExpbmUpIHtcclxuICAgICAgICAgIHJlY29tcHV0ZU1heExlbmd0aCA9IHRydWU7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkb2Muc2VsLmNvbnRhaW5zKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pID4gLTEpXHJcbiAgICAgIHNpZ25hbEN1cnNvckFjdGl2aXR5KGNtKTtcclxuXHJcbiAgICB1cGRhdGVEb2MoZG9jLCBjaGFuZ2UsIHNwYW5zLCBlc3RpbWF0ZUhlaWdodChjbSkpO1xyXG5cclxuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcclxuICAgICAgZG9jLml0ZXIoY2hlY2tXaWR0aFN0YXJ0LCBmcm9tLmxpbmUgKyBjaGFuZ2UudGV4dC5sZW5ndGgsIGZ1bmN0aW9uKGxpbmUpIHtcclxuICAgICAgICB2YXIgbGVuID0gbGluZUxlbmd0aChsaW5lKTtcclxuICAgICAgICBpZiAobGVuID4gZGlzcGxheS5tYXhMaW5lTGVuZ3RoKSB7XHJcbiAgICAgICAgICBkaXNwbGF5Lm1heExpbmUgPSBsaW5lO1xyXG4gICAgICAgICAgZGlzcGxheS5tYXhMaW5lTGVuZ3RoID0gbGVuO1xyXG4gICAgICAgICAgZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICByZWNvbXB1dGVNYXhMZW5ndGggPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAocmVjb21wdXRlTWF4TGVuZ3RoKSBjbS5jdXJPcC51cGRhdGVNYXhMaW5lID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGp1c3QgZnJvbnRpZXIsIHNjaGVkdWxlIHdvcmtlclxyXG4gICAgZG9jLmZyb250aWVyID0gTWF0aC5taW4oZG9jLmZyb250aWVyLCBmcm9tLmxpbmUpO1xyXG4gICAgc3RhcnRXb3JrZXIoY20sIDQwMCk7XHJcblxyXG4gICAgdmFyIGxlbmRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAodG8ubGluZSAtIGZyb20ubGluZSkgLSAxO1xyXG4gICAgLy8gUmVtZW1iZXIgdGhhdCB0aGVzZSBsaW5lcyBjaGFuZ2VkLCBmb3IgdXBkYXRpbmcgdGhlIGRpc3BsYXlcclxuICAgIGlmIChjaGFuZ2UuZnVsbClcclxuICAgICAgcmVnQ2hhbmdlKGNtKTtcclxuICAgIGVsc2UgaWYgKGZyb20ubGluZSA9PSB0by5saW5lICYmIGNoYW5nZS50ZXh0Lmxlbmd0aCA9PSAxICYmICFpc1dob2xlTGluZVVwZGF0ZShjbS5kb2MsIGNoYW5nZSkpXHJcbiAgICAgIHJlZ0xpbmVDaGFuZ2UoY20sIGZyb20ubGluZSwgXCJ0ZXh0XCIpO1xyXG4gICAgZWxzZVxyXG4gICAgICByZWdDaGFuZ2UoY20sIGZyb20ubGluZSwgdG8ubGluZSArIDEsIGxlbmRpZmYpO1xyXG5cclxuICAgIHZhciBjaGFuZ2VzSGFuZGxlciA9IGhhc0hhbmRsZXIoY20sIFwiY2hhbmdlc1wiKSwgY2hhbmdlSGFuZGxlciA9IGhhc0hhbmRsZXIoY20sIFwiY2hhbmdlXCIpO1xyXG4gICAgaWYgKGNoYW5nZUhhbmRsZXIgfHwgY2hhbmdlc0hhbmRsZXIpIHtcclxuICAgICAgdmFyIG9iaiA9IHtcclxuICAgICAgICBmcm9tOiBmcm9tLCB0bzogdG8sXHJcbiAgICAgICAgdGV4dDogY2hhbmdlLnRleHQsXHJcbiAgICAgICAgcmVtb3ZlZDogY2hhbmdlLnJlbW92ZWQsXHJcbiAgICAgICAgb3JpZ2luOiBjaGFuZ2Uub3JpZ2luXHJcbiAgICAgIH07XHJcbiAgICAgIGlmIChjaGFuZ2VIYW5kbGVyKSBzaWduYWxMYXRlcihjbSwgXCJjaGFuZ2VcIiwgY20sIG9iaik7XHJcbiAgICAgIGlmIChjaGFuZ2VzSGFuZGxlcikgKGNtLmN1ck9wLmNoYW5nZU9ianMgfHwgKGNtLmN1ck9wLmNoYW5nZU9ianMgPSBbXSkpLnB1c2gob2JqKTtcclxuICAgIH1cclxuICAgIGNtLmRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVwbGFjZVJhbmdlKGRvYywgY29kZSwgZnJvbSwgdG8sIG9yaWdpbikge1xyXG4gICAgaWYgKCF0bykgdG8gPSBmcm9tO1xyXG4gICAgaWYgKGNtcCh0bywgZnJvbSkgPCAwKSB7IHZhciB0bXAgPSB0bzsgdG8gPSBmcm9tOyBmcm9tID0gdG1wOyB9XHJcbiAgICBpZiAodHlwZW9mIGNvZGUgPT0gXCJzdHJpbmdcIikgY29kZSA9IHNwbGl0TGluZXMoY29kZSk7XHJcbiAgICBtYWtlQ2hhbmdlKGRvYywge2Zyb206IGZyb20sIHRvOiB0bywgdGV4dDogY29kZSwgb3JpZ2luOiBvcmlnaW59KTtcclxuICB9XHJcblxyXG4gIC8vIFNDUk9MTElORyBUSElOR1MgSU5UTyBWSUVXXHJcblxyXG4gIC8vIElmIGFuIGVkaXRvciBzaXRzIG9uIHRoZSB0b3Agb3IgYm90dG9tIG9mIHRoZSB3aW5kb3csIHBhcnRpYWxseVxyXG4gIC8vIHNjcm9sbGVkIG91dCBvZiB2aWV3LCB0aGlzIGVuc3VyZXMgdGhhdCB0aGUgY3Vyc29yIGlzIHZpc2libGUuXHJcbiAgZnVuY3Rpb24gbWF5YmVTY3JvbGxXaW5kb3coY20sIGNvb3Jkcykge1xyXG4gICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBcInNjcm9sbEN1cnNvckludG9WaWV3XCIpKSByZXR1cm47XHJcblxyXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBib3ggPSBkaXNwbGF5LnNpemVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBkb1Njcm9sbCA9IG51bGw7XHJcbiAgICBpZiAoY29vcmRzLnRvcCArIGJveC50b3AgPCAwKSBkb1Njcm9sbCA9IHRydWU7XHJcbiAgICBlbHNlIGlmIChjb29yZHMuYm90dG9tICsgYm94LnRvcCA+ICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkpIGRvU2Nyb2xsID0gZmFsc2U7XHJcbiAgICBpZiAoZG9TY3JvbGwgIT0gbnVsbCAmJiAhcGhhbnRvbSkge1xyXG4gICAgICB2YXIgc2Nyb2xsTm9kZSA9IGVsdChcImRpdlwiLCBcIlxcdTIwMGJcIiwgbnVsbCwgXCJwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoY29vcmRzLnRvcCAtIGRpc3BsYXkudmlld09mZnNldCAtIHBhZGRpbmdUb3AoY20uZGlzcGxheSkpICsgXCJweDsgaGVpZ2h0OiBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb29yZHMuYm90dG9tIC0gY29vcmRzLnRvcCArIHNjcm9sbEdhcChjbSkgKyBkaXNwbGF5LmJhckhlaWdodCkgKyBcInB4OyBsZWZ0OiBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3Jkcy5sZWZ0ICsgXCJweDsgd2lkdGg6IDJweDtcIik7XHJcbiAgICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLmFwcGVuZENoaWxkKHNjcm9sbE5vZGUpO1xyXG4gICAgICBzY3JvbGxOb2RlLnNjcm9sbEludG9WaWV3KGRvU2Nyb2xsKTtcclxuICAgICAgY20uZGlzcGxheS5saW5lU3BhY2UucmVtb3ZlQ2hpbGQoc2Nyb2xsTm9kZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTY3JvbGwgYSBnaXZlbiBwb3NpdGlvbiBpbnRvIHZpZXcgKGltbWVkaWF0ZWx5KSwgdmVyaWZ5aW5nIHRoYXRcclxuICAvLyBpdCBhY3R1YWxseSBiZWNhbWUgdmlzaWJsZSAoYXMgbGluZSBoZWlnaHRzIGFyZSBhY2N1cmF0ZWx5XHJcbiAgLy8gbWVhc3VyZWQsIHRoZSBwb3NpdGlvbiBvZiBzb21ldGhpbmcgbWF5ICdkcmlmdCcgZHVyaW5nIGRyYXdpbmcpLlxyXG4gIGZ1bmN0aW9uIHNjcm9sbFBvc0ludG9WaWV3KGNtLCBwb3MsIGVuZCwgbWFyZ2luKSB7XHJcbiAgICBpZiAobWFyZ2luID09IG51bGwpIG1hcmdpbiA9IDA7XHJcbiAgICBmb3IgKHZhciBsaW1pdCA9IDA7IGxpbWl0IDwgNTsgbGltaXQrKykge1xyXG4gICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlLCBjb29yZHMgPSBjdXJzb3JDb29yZHMoY20sIHBvcyk7XHJcbiAgICAgIHZhciBlbmRDb29yZHMgPSAhZW5kIHx8IGVuZCA9PSBwb3MgPyBjb29yZHMgOiBjdXJzb3JDb29yZHMoY20sIGVuZCk7XHJcbiAgICAgIHZhciBzY3JvbGxQb3MgPSBjYWxjdWxhdGVTY3JvbGxQb3MoY20sIE1hdGgubWluKGNvb3Jkcy5sZWZ0LCBlbmRDb29yZHMubGVmdCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oY29vcmRzLnRvcCwgZW5kQ29vcmRzLnRvcCkgLSBtYXJnaW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoY29vcmRzLmxlZnQsIGVuZENvb3Jkcy5sZWZ0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChjb29yZHMuYm90dG9tLCBlbmRDb29yZHMuYm90dG9tKSArIG1hcmdpbik7XHJcbiAgICAgIHZhciBzdGFydFRvcCA9IGNtLmRvYy5zY3JvbGxUb3AsIHN0YXJ0TGVmdCA9IGNtLmRvYy5zY3JvbGxMZWZ0O1xyXG4gICAgICBpZiAoc2Nyb2xsUG9zLnNjcm9sbFRvcCAhPSBudWxsKSB7XHJcbiAgICAgICAgc2V0U2Nyb2xsVG9wKGNtLCBzY3JvbGxQb3Muc2Nyb2xsVG9wKTtcclxuICAgICAgICBpZiAoTWF0aC5hYnMoY20uZG9jLnNjcm9sbFRvcCAtIHN0YXJ0VG9wKSA+IDEpIGNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzY3JvbGxQb3Muc2Nyb2xsTGVmdCAhPSBudWxsKSB7XHJcbiAgICAgICAgc2V0U2Nyb2xsTGVmdChjbSwgc2Nyb2xsUG9zLnNjcm9sbExlZnQpO1xyXG4gICAgICAgIGlmIChNYXRoLmFicyhjbS5kb2Muc2Nyb2xsTGVmdCAtIHN0YXJ0TGVmdCkgPiAxKSBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWNoYW5nZWQpIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvb3JkcztcclxuICB9XHJcblxyXG4gIC8vIFNjcm9sbCBhIGdpdmVuIHNldCBvZiBjb29yZGluYXRlcyBpbnRvIHZpZXcgKGltbWVkaWF0ZWx5KS5cclxuICBmdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhjbSwgeDEsIHkxLCB4MiwgeTIpIHtcclxuICAgIHZhciBzY3JvbGxQb3MgPSBjYWxjdWxhdGVTY3JvbGxQb3MoY20sIHgxLCB5MSwgeDIsIHkyKTtcclxuICAgIGlmIChzY3JvbGxQb3Muc2Nyb2xsVG9wICE9IG51bGwpIHNldFNjcm9sbFRvcChjbSwgc2Nyb2xsUG9zLnNjcm9sbFRvcCk7XHJcbiAgICBpZiAoc2Nyb2xsUG9zLnNjcm9sbExlZnQgIT0gbnVsbCkgc2V0U2Nyb2xsTGVmdChjbSwgc2Nyb2xsUG9zLnNjcm9sbExlZnQpO1xyXG4gIH1cclxuXHJcbiAgLy8gQ2FsY3VsYXRlIGEgbmV3IHNjcm9sbCBwb3NpdGlvbiBuZWVkZWQgdG8gc2Nyb2xsIHRoZSBnaXZlblxyXG4gIC8vIHJlY3RhbmdsZSBpbnRvIHZpZXcuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggc2Nyb2xsVG9wIGFuZFxyXG4gIC8vIHNjcm9sbExlZnQgcHJvcGVydGllcy4gV2hlbiB0aGVzZSBhcmUgdW5kZWZpbmVkLCB0aGVcclxuICAvLyB2ZXJ0aWNhbC9ob3Jpem9udGFsIHBvc2l0aW9uIGRvZXMgbm90IG5lZWQgdG8gYmUgYWRqdXN0ZWQuXHJcbiAgZnVuY3Rpb24gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLCB4MSwgeTEsIHgyLCB5Mikge1xyXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBzbmFwTWFyZ2luID0gdGV4dEhlaWdodChjbS5kaXNwbGF5KTtcclxuICAgIGlmICh5MSA8IDApIHkxID0gMDtcclxuICAgIHZhciBzY3JlZW50b3AgPSBjbS5jdXJPcCAmJiBjbS5jdXJPcC5zY3JvbGxUb3AgIT0gbnVsbCA/IGNtLmN1ck9wLnNjcm9sbFRvcCA6IGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wO1xyXG4gICAgdmFyIHNjcmVlbiA9IGRpc3BsYXlIZWlnaHQoY20pLCByZXN1bHQgPSB7fTtcclxuICAgIGlmICh5MiAtIHkxID4gc2NyZWVuKSB5MiA9IHkxICsgc2NyZWVuO1xyXG4gICAgdmFyIGRvY0JvdHRvbSA9IGNtLmRvYy5oZWlnaHQgKyBwYWRkaW5nVmVydChkaXNwbGF5KTtcclxuICAgIHZhciBhdFRvcCA9IHkxIDwgc25hcE1hcmdpbiwgYXRCb3R0b20gPSB5MiA+IGRvY0JvdHRvbSAtIHNuYXBNYXJnaW47XHJcbiAgICBpZiAoeTEgPCBzY3JlZW50b3ApIHtcclxuICAgICAgcmVzdWx0LnNjcm9sbFRvcCA9IGF0VG9wID8gMCA6IHkxO1xyXG4gICAgfSBlbHNlIGlmICh5MiA+IHNjcmVlbnRvcCArIHNjcmVlbikge1xyXG4gICAgICB2YXIgbmV3VG9wID0gTWF0aC5taW4oeTEsIChhdEJvdHRvbSA/IGRvY0JvdHRvbSA6IHkyKSAtIHNjcmVlbik7XHJcbiAgICAgIGlmIChuZXdUb3AgIT0gc2NyZWVudG9wKSByZXN1bHQuc2Nyb2xsVG9wID0gbmV3VG9wO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzY3JlZW5sZWZ0ID0gY20uY3VyT3AgJiYgY20uY3VyT3Auc2Nyb2xsTGVmdCAhPSBudWxsID8gY20uY3VyT3Auc2Nyb2xsTGVmdCA6IGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdDtcclxuICAgIHZhciBzY3JlZW53ID0gZGlzcGxheVdpZHRoKGNtKSAtIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoIDogMCk7XHJcbiAgICB2YXIgdG9vV2lkZSA9IHgyIC0geDEgPiBzY3JlZW53O1xyXG4gICAgaWYgKHRvb1dpZGUpIHgyID0geDEgKyBzY3JlZW53O1xyXG4gICAgaWYgKHgxIDwgMTApXHJcbiAgICAgIHJlc3VsdC5zY3JvbGxMZWZ0ID0gMDtcclxuICAgIGVsc2UgaWYgKHgxIDwgc2NyZWVubGVmdClcclxuICAgICAgcmVzdWx0LnNjcm9sbExlZnQgPSBNYXRoLm1heCgwLCB4MSAtICh0b29XaWRlID8gMCA6IDEwKSk7XHJcbiAgICBlbHNlIGlmICh4MiA+IHNjcmVlbncgKyBzY3JlZW5sZWZ0IC0gMylcclxuICAgICAgcmVzdWx0LnNjcm9sbExlZnQgPSB4MiArICh0b29XaWRlID8gMCA6IDEwKSAtIHNjcmVlbnc7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgLy8gU3RvcmUgYSByZWxhdGl2ZSBhZGp1c3RtZW50IHRvIHRoZSBzY3JvbGwgcG9zaXRpb24gaW4gdGhlIGN1cnJlbnRcclxuICAvLyBvcGVyYXRpb24gKHRvIGJlIGFwcGxpZWQgd2hlbiB0aGUgb3BlcmF0aW9uIGZpbmlzaGVzKS5cclxuICBmdW5jdGlvbiBhZGRUb1Njcm9sbFBvcyhjbSwgbGVmdCwgdG9wKSB7XHJcbiAgICBpZiAobGVmdCAhPSBudWxsIHx8IHRvcCAhPSBudWxsKSByZXNvbHZlU2Nyb2xsVG9Qb3MoY20pO1xyXG4gICAgaWYgKGxlZnQgIT0gbnVsbClcclxuICAgICAgY20uY3VyT3Auc2Nyb2xsTGVmdCA9IChjbS5jdXJPcC5zY3JvbGxMZWZ0ID09IG51bGwgPyBjbS5kb2Muc2Nyb2xsTGVmdCA6IGNtLmN1ck9wLnNjcm9sbExlZnQpICsgbGVmdDtcclxuICAgIGlmICh0b3AgIT0gbnVsbClcclxuICAgICAgY20uY3VyT3Auc2Nyb2xsVG9wID0gKGNtLmN1ck9wLnNjcm9sbFRvcCA9PSBudWxsID8gY20uZG9jLnNjcm9sbFRvcCA6IGNtLmN1ck9wLnNjcm9sbFRvcCkgKyB0b3A7XHJcbiAgfVxyXG5cclxuICAvLyBNYWtlIHN1cmUgdGhhdCBhdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb24gdGhlIGN1cnJlbnQgY3Vyc29yIGlzXHJcbiAgLy8gc2hvd24uXHJcbiAgZnVuY3Rpb24gZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSkge1xyXG4gICAgcmVzb2x2ZVNjcm9sbFRvUG9zKGNtKTtcclxuICAgIHZhciBjdXIgPSBjbS5nZXRDdXJzb3IoKSwgZnJvbSA9IGN1ciwgdG8gPSBjdXI7XHJcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XHJcbiAgICAgIGZyb20gPSBjdXIuY2ggPyBQb3MoY3VyLmxpbmUsIGN1ci5jaCAtIDEpIDogY3VyO1xyXG4gICAgICB0byA9IFBvcyhjdXIubGluZSwgY3VyLmNoICsgMSk7XHJcbiAgICB9XHJcbiAgICBjbS5jdXJPcC5zY3JvbGxUb1BvcyA9IHtmcm9tOiBmcm9tLCB0bzogdG8sIG1hcmdpbjogY20ub3B0aW9ucy5jdXJzb3JTY3JvbGxNYXJnaW4sIGlzQ3Vyc29yOiB0cnVlfTtcclxuICB9XHJcblxyXG4gIC8vIFdoZW4gYW4gb3BlcmF0aW9uIGhhcyBpdHMgc2Nyb2xsVG9Qb3MgcHJvcGVydHkgc2V0LCBhbmQgYW5vdGhlclxyXG4gIC8vIHNjcm9sbCBhY3Rpb24gaXMgYXBwbGllZCBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uLCB0aGlzXHJcbiAgLy8gJ3NpbXVsYXRlcycgc2Nyb2xsaW5nIHRoYXQgcG9zaXRpb24gaW50byB2aWV3IGluIGEgY2hlYXAgd2F5LCBzb1xyXG4gIC8vIHRoYXQgdGhlIGVmZmVjdCBvZiBpbnRlcm1lZGlhdGUgc2Nyb2xsIGNvbW1hbmRzIGlzIG5vdCBpZ25vcmVkLlxyXG4gIGZ1bmN0aW9uIHJlc29sdmVTY3JvbGxUb1BvcyhjbSkge1xyXG4gICAgdmFyIHJhbmdlID0gY20uY3VyT3Auc2Nyb2xsVG9Qb3M7XHJcbiAgICBpZiAocmFuZ2UpIHtcclxuICAgICAgY20uY3VyT3Auc2Nyb2xsVG9Qb3MgPSBudWxsO1xyXG4gICAgICB2YXIgZnJvbSA9IGVzdGltYXRlQ29vcmRzKGNtLCByYW5nZS5mcm9tKSwgdG8gPSBlc3RpbWF0ZUNvb3JkcyhjbSwgcmFuZ2UudG8pO1xyXG4gICAgICB2YXIgc1BvcyA9IGNhbGN1bGF0ZVNjcm9sbFBvcyhjbSwgTWF0aC5taW4oZnJvbS5sZWZ0LCB0by5sZWZ0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oZnJvbS50b3AsIHRvLnRvcCkgLSByYW5nZS5tYXJnaW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGZyb20ucmlnaHQsIHRvLnJpZ2h0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoZnJvbS5ib3R0b20sIHRvLmJvdHRvbSkgKyByYW5nZS5tYXJnaW4pO1xyXG4gICAgICBjbS5zY3JvbGxUbyhzUG9zLnNjcm9sbExlZnQsIHNQb3Muc2Nyb2xsVG9wKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFQSSBVVElMSVRJRVNcclxuXHJcbiAgLy8gSW5kZW50IHRoZSBnaXZlbiBsaW5lLiBUaGUgaG93IHBhcmFtZXRlciBjYW4gYmUgXCJzbWFydFwiLFxyXG4gIC8vIFwiYWRkXCIvbnVsbCwgXCJzdWJ0cmFjdFwiLCBvciBcInByZXZcIi4gV2hlbiBhZ2dyZXNzaXZlIGlzIGZhbHNlXHJcbiAgLy8gKHR5cGljYWxseSBzZXQgdG8gdHJ1ZSBmb3IgZm9yY2VkIHNpbmdsZS1saW5lIGluZGVudHMpLCBlbXB0eVxyXG4gIC8vIGxpbmVzIGFyZSBub3QgaW5kZW50ZWQsIGFuZCBwbGFjZXMgd2hlcmUgdGhlIG1vZGUgcmV0dXJucyBQYXNzXHJcbiAgLy8gYXJlIGxlZnQgYWxvbmUuXHJcbiAgZnVuY3Rpb24gaW5kZW50TGluZShjbSwgbiwgaG93LCBhZ2dyZXNzaXZlKSB7XHJcbiAgICB2YXIgZG9jID0gY20uZG9jLCBzdGF0ZTtcclxuICAgIGlmIChob3cgPT0gbnVsbCkgaG93ID0gXCJhZGRcIjtcclxuICAgIGlmIChob3cgPT0gXCJzbWFydFwiKSB7XHJcbiAgICAgIC8vIEZhbGwgYmFjayB0byBcInByZXZcIiB3aGVuIHRoZSBtb2RlIGRvZXNuJ3QgaGF2ZSBhbiBpbmRlbnRhdGlvblxyXG4gICAgICAvLyBtZXRob2QuXHJcbiAgICAgIGlmICghZG9jLm1vZGUuaW5kZW50KSBob3cgPSBcInByZXZcIjtcclxuICAgICAgZWxzZSBzdGF0ZSA9IGdldFN0YXRlQmVmb3JlKGNtLCBuKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdGFiU2l6ZSA9IGNtLm9wdGlvbnMudGFiU2l6ZTtcclxuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIG4pLCBjdXJTcGFjZSA9IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgbnVsbCwgdGFiU2l6ZSk7XHJcbiAgICBpZiAobGluZS5zdGF0ZUFmdGVyKSBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsO1xyXG4gICAgdmFyIGN1clNwYWNlU3RyaW5nID0gbGluZS50ZXh0Lm1hdGNoKC9eXFxzKi8pWzBdLCBpbmRlbnRhdGlvbjtcclxuICAgIGlmICghYWdncmVzc2l2ZSAmJiAhL1xcUy8udGVzdChsaW5lLnRleHQpKSB7XHJcbiAgICAgIGluZGVudGF0aW9uID0gMDtcclxuICAgICAgaG93ID0gXCJub3RcIjtcclxuICAgIH0gZWxzZSBpZiAoaG93ID09IFwic21hcnRcIikge1xyXG4gICAgICBpbmRlbnRhdGlvbiA9IGRvYy5tb2RlLmluZGVudChzdGF0ZSwgbGluZS50ZXh0LnNsaWNlKGN1clNwYWNlU3RyaW5nLmxlbmd0aCksIGxpbmUudGV4dCk7XHJcbiAgICAgIGlmIChpbmRlbnRhdGlvbiA9PSBQYXNzIHx8IGluZGVudGF0aW9uID4gMTUwKSB7XHJcbiAgICAgICAgaWYgKCFhZ2dyZXNzaXZlKSByZXR1cm47XHJcbiAgICAgICAgaG93ID0gXCJwcmV2XCI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChob3cgPT0gXCJwcmV2XCIpIHtcclxuICAgICAgaWYgKG4gPiBkb2MuZmlyc3QpIGluZGVudGF0aW9uID0gY291bnRDb2x1bW4oZ2V0TGluZShkb2MsIG4tMSkudGV4dCwgbnVsbCwgdGFiU2l6ZSk7XHJcbiAgICAgIGVsc2UgaW5kZW50YXRpb24gPSAwO1xyXG4gICAgfSBlbHNlIGlmIChob3cgPT0gXCJhZGRcIikge1xyXG4gICAgICBpbmRlbnRhdGlvbiA9IGN1clNwYWNlICsgY20ub3B0aW9ucy5pbmRlbnRVbml0O1xyXG4gICAgfSBlbHNlIGlmIChob3cgPT0gXCJzdWJ0cmFjdFwiKSB7XHJcbiAgICAgIGluZGVudGF0aW9uID0gY3VyU3BhY2UgLSBjbS5vcHRpb25zLmluZGVudFVuaXQ7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBob3cgPT0gXCJudW1iZXJcIikge1xyXG4gICAgICBpbmRlbnRhdGlvbiA9IGN1clNwYWNlICsgaG93O1xyXG4gICAgfVxyXG4gICAgaW5kZW50YXRpb24gPSBNYXRoLm1heCgwLCBpbmRlbnRhdGlvbik7XHJcblxyXG4gICAgdmFyIGluZGVudFN0cmluZyA9IFwiXCIsIHBvcyA9IDA7XHJcbiAgICBpZiAoY20ub3B0aW9ucy5pbmRlbnRXaXRoVGFicylcclxuICAgICAgZm9yICh2YXIgaSA9IE1hdGguZmxvb3IoaW5kZW50YXRpb24gLyB0YWJTaXplKTsgaTsgLS1pKSB7cG9zICs9IHRhYlNpemU7IGluZGVudFN0cmluZyArPSBcIlxcdFwiO31cclxuICAgIGlmIChwb3MgPCBpbmRlbnRhdGlvbikgaW5kZW50U3RyaW5nICs9IHNwYWNlU3RyKGluZGVudGF0aW9uIC0gcG9zKTtcclxuXHJcbiAgICBpZiAoaW5kZW50U3RyaW5nICE9IGN1clNwYWNlU3RyaW5nKSB7XHJcbiAgICAgIHJlcGxhY2VSYW5nZShkb2MsIGluZGVudFN0cmluZywgUG9zKG4sIDApLCBQb3MobiwgY3VyU3BhY2VTdHJpbmcubGVuZ3RoKSwgXCIraW5wdXRcIik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBFbnN1cmUgdGhhdCwgaWYgdGhlIGN1cnNvciB3YXMgaW4gdGhlIHdoaXRlc3BhY2UgYXQgdGhlIHN0YXJ0XHJcbiAgICAgIC8vIG9mIHRoZSBsaW5lLCBpdCBpcyBtb3ZlZCB0byB0aGUgZW5kIG9mIHRoYXQgc3BhY2UuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnJhbmdlc1tpXTtcclxuICAgICAgICBpZiAocmFuZ2UuaGVhZC5saW5lID09IG4gJiYgcmFuZ2UuaGVhZC5jaCA8IGN1clNwYWNlU3RyaW5nLmxlbmd0aCkge1xyXG4gICAgICAgICAgdmFyIHBvcyA9IFBvcyhuLCBjdXJTcGFjZVN0cmluZy5sZW5ndGgpO1xyXG4gICAgICAgICAgcmVwbGFjZU9uZVNlbGVjdGlvbihkb2MsIGksIG5ldyBSYW5nZShwb3MsIHBvcykpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLy8gVXRpbGl0eSBmb3IgYXBwbHlpbmcgYSBjaGFuZ2UgdG8gYSBsaW5lIGJ5IGhhbmRsZSBvciBudW1iZXIsXHJcbiAgLy8gcmV0dXJuaW5nIHRoZSBudW1iZXIgYW5kIG9wdGlvbmFsbHkgcmVnaXN0ZXJpbmcgdGhlIGxpbmUgYXNcclxuICAvLyBjaGFuZ2VkLlxyXG4gIGZ1bmN0aW9uIGNoYW5nZUxpbmUoZG9jLCBoYW5kbGUsIGNoYW5nZVR5cGUsIG9wKSB7XHJcbiAgICB2YXIgbm8gPSBoYW5kbGUsIGxpbmUgPSBoYW5kbGU7XHJcbiAgICBpZiAodHlwZW9mIGhhbmRsZSA9PSBcIm51bWJlclwiKSBsaW5lID0gZ2V0TGluZShkb2MsIGNsaXBMaW5lKGRvYywgaGFuZGxlKSk7XHJcbiAgICBlbHNlIG5vID0gbGluZU5vKGhhbmRsZSk7XHJcbiAgICBpZiAobm8gPT0gbnVsbCkgcmV0dXJuIG51bGw7XHJcbiAgICBpZiAob3AobGluZSwgbm8pICYmIGRvYy5jbSkgcmVnTGluZUNoYW5nZShkb2MuY20sIG5vLCBjaGFuZ2VUeXBlKTtcclxuICAgIHJldHVybiBsaW5lO1xyXG4gIH1cclxuXHJcbiAgLy8gSGVscGVyIGZvciBkZWxldGluZyB0ZXh0IG5lYXIgdGhlIHNlbGVjdGlvbihzKSwgdXNlZCB0byBpbXBsZW1lbnRcclxuICAvLyBiYWNrc3BhY2UsIGRlbGV0ZSwgYW5kIHNpbWlsYXIgZnVuY3Rpb25hbGl0eS5cclxuICBmdW5jdGlvbiBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBjb21wdXRlKSB7XHJcbiAgICB2YXIgcmFuZ2VzID0gY20uZG9jLnNlbC5yYW5nZXMsIGtpbGwgPSBbXTtcclxuICAgIC8vIEJ1aWxkIHVwIGEgc2V0IG9mIHJhbmdlcyB0byBraWxsIGZpcnN0LCBtZXJnaW5nIG92ZXJsYXBwaW5nXHJcbiAgICAvLyByYW5nZXMuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgdG9LaWxsID0gY29tcHV0ZShyYW5nZXNbaV0pO1xyXG4gICAgICB3aGlsZSAoa2lsbC5sZW5ndGggJiYgY21wKHRvS2lsbC5mcm9tLCBsc3Qoa2lsbCkudG8pIDw9IDApIHtcclxuICAgICAgICB2YXIgcmVwbGFjZWQgPSBraWxsLnBvcCgpO1xyXG4gICAgICAgIGlmIChjbXAocmVwbGFjZWQuZnJvbSwgdG9LaWxsLmZyb20pIDwgMCkge1xyXG4gICAgICAgICAgdG9LaWxsLmZyb20gPSByZXBsYWNlZC5mcm9tO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGtpbGwucHVzaCh0b0tpbGwpO1xyXG4gICAgfVxyXG4gICAgLy8gTmV4dCwgcmVtb3ZlIHRob3NlIGFjdHVhbCByYW5nZXMuXHJcbiAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbigpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IGtpbGwubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICAgICAgcmVwbGFjZVJhbmdlKGNtLmRvYywgXCJcIiwga2lsbFtpXS5mcm9tLCBraWxsW2ldLnRvLCBcIitkZWxldGVcIik7XHJcbiAgICAgIGVuc3VyZUN1cnNvclZpc2libGUoY20pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBVc2VkIGZvciBob3Jpem9udGFsIHJlbGF0aXZlIG1vdGlvbi4gRGlyIGlzIC0xIG9yIDEgKGxlZnQgb3JcclxuICAvLyByaWdodCksIHVuaXQgY2FuIGJlIFwiY2hhclwiLCBcImNvbHVtblwiIChsaWtlIGNoYXIsIGJ1dCBkb2Vzbid0XHJcbiAgLy8gY3Jvc3MgbGluZSBib3VuZGFyaWVzKSwgXCJ3b3JkXCIgKGFjcm9zcyBuZXh0IHdvcmQpLCBvciBcImdyb3VwXCIgKHRvXHJcbiAgLy8gdGhlIHN0YXJ0IG9mIG5leHQgZ3JvdXAgb2Ygd29yZCBvciBub24td29yZC1ub24td2hpdGVzcGFjZVxyXG4gIC8vIGNoYXJzKS4gVGhlIHZpc3VhbGx5IHBhcmFtIGNvbnRyb2xzIHdoZXRoZXIsIGluIHJpZ2h0LXRvLWxlZnRcclxuICAvLyB0ZXh0LCBkaXJlY3Rpb24gMSBtZWFucyB0byBtb3ZlIHRvd2FyZHMgdGhlIG5leHQgaW5kZXggaW4gdGhlXHJcbiAgLy8gc3RyaW5nLCBvciB0b3dhcmRzIHRoZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjdXJyZW50XHJcbiAgLy8gcG9zaXRpb24uIFRoZSByZXN1bHRpbmcgcG9zaXRpb24gd2lsbCBoYXZlIGEgaGl0U2lkZT10cnVlXHJcbiAgLy8gcHJvcGVydHkgaWYgaXQgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cclxuICBmdW5jdGlvbiBmaW5kUG9zSChkb2MsIHBvcywgZGlyLCB1bml0LCB2aXN1YWxseSkge1xyXG4gICAgdmFyIGxpbmUgPSBwb3MubGluZSwgY2ggPSBwb3MuY2gsIG9yaWdEaXIgPSBkaXI7XHJcbiAgICB2YXIgbGluZU9iaiA9IGdldExpbmUoZG9jLCBsaW5lKTtcclxuICAgIHZhciBwb3NzaWJsZSA9IHRydWU7XHJcbiAgICBmdW5jdGlvbiBmaW5kTmV4dExpbmUoKSB7XHJcbiAgICAgIHZhciBsID0gbGluZSArIGRpcjtcclxuICAgICAgaWYgKGwgPCBkb2MuZmlyc3QgfHwgbCA+PSBkb2MuZmlyc3QgKyBkb2Muc2l6ZSkgcmV0dXJuIChwb3NzaWJsZSA9IGZhbHNlKTtcclxuICAgICAgbGluZSA9IGw7XHJcbiAgICAgIHJldHVybiBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGwpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbW92ZU9uY2UoYm91bmRUb0xpbmUpIHtcclxuICAgICAgdmFyIG5leHQgPSAodmlzdWFsbHkgPyBtb3ZlVmlzdWFsbHkgOiBtb3ZlTG9naWNhbGx5KShsaW5lT2JqLCBjaCwgZGlyLCB0cnVlKTtcclxuICAgICAgaWYgKG5leHQgPT0gbnVsbCkge1xyXG4gICAgICAgIGlmICghYm91bmRUb0xpbmUgJiYgZmluZE5leHRMaW5lKCkpIHtcclxuICAgICAgICAgIGlmICh2aXN1YWxseSkgY2ggPSAoZGlyIDwgMCA/IGxpbmVSaWdodCA6IGxpbmVMZWZ0KShsaW5lT2JqKTtcclxuICAgICAgICAgIGVsc2UgY2ggPSBkaXIgPCAwID8gbGluZU9iai50ZXh0Lmxlbmd0aCA6IDA7XHJcbiAgICAgICAgfSBlbHNlIHJldHVybiAocG9zc2libGUgPSBmYWxzZSk7XHJcbiAgICAgIH0gZWxzZSBjaCA9IG5leHQ7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh1bml0ID09IFwiY2hhclwiKSBtb3ZlT25jZSgpO1xyXG4gICAgZWxzZSBpZiAodW5pdCA9PSBcImNvbHVtblwiKSBtb3ZlT25jZSh0cnVlKTtcclxuICAgIGVsc2UgaWYgKHVuaXQgPT0gXCJ3b3JkXCIgfHwgdW5pdCA9PSBcImdyb3VwXCIpIHtcclxuICAgICAgdmFyIHNhd1R5cGUgPSBudWxsLCBncm91cCA9IHVuaXQgPT0gXCJncm91cFwiO1xyXG4gICAgICB2YXIgaGVscGVyID0gZG9jLmNtICYmIGRvYy5jbS5nZXRIZWxwZXIocG9zLCBcIndvcmRDaGFyc1wiKTtcclxuICAgICAgZm9yICh2YXIgZmlyc3QgPSB0cnVlOzsgZmlyc3QgPSBmYWxzZSkge1xyXG4gICAgICAgIGlmIChkaXIgPCAwICYmICFtb3ZlT25jZSghZmlyc3QpKSBicmVhaztcclxuICAgICAgICB2YXIgY3VyID0gbGluZU9iai50ZXh0LmNoYXJBdChjaCkgfHwgXCJcXG5cIjtcclxuICAgICAgICB2YXIgdHlwZSA9IGlzV29yZENoYXIoY3VyLCBoZWxwZXIpID8gXCJ3XCJcclxuICAgICAgICAgIDogZ3JvdXAgJiYgY3VyID09IFwiXFxuXCIgPyBcIm5cIlxyXG4gICAgICAgICAgOiAhZ3JvdXAgfHwgL1xccy8udGVzdChjdXIpID8gbnVsbFxyXG4gICAgICAgICAgOiBcInBcIjtcclxuICAgICAgICBpZiAoZ3JvdXAgJiYgIWZpcnN0ICYmICF0eXBlKSB0eXBlID0gXCJzXCI7XHJcbiAgICAgICAgaWYgKHNhd1R5cGUgJiYgc2F3VHlwZSAhPSB0eXBlKSB7XHJcbiAgICAgICAgICBpZiAoZGlyIDwgMCkge2RpciA9IDE7IG1vdmVPbmNlKCk7fVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZSkgc2F3VHlwZSA9IHR5cGU7XHJcbiAgICAgICAgaWYgKGRpciA+IDAgJiYgIW1vdmVPbmNlKCFmaXJzdCkpIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgcmVzdWx0ID0gc2tpcEF0b21pYyhkb2MsIFBvcyhsaW5lLCBjaCksIG9yaWdEaXIsIHRydWUpO1xyXG4gICAgaWYgKCFwb3NzaWJsZSkgcmVzdWx0LmhpdFNpZGUgPSB0cnVlO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIC8vIEZvciByZWxhdGl2ZSB2ZXJ0aWNhbCBtb3ZlbWVudC4gRGlyIG1heSBiZSAtMSBvciAxLiBVbml0IGNhbiBiZVxyXG4gIC8vIFwicGFnZVwiIG9yIFwibGluZVwiLiBUaGUgcmVzdWx0aW5nIHBvc2l0aW9uIHdpbGwgaGF2ZSBhIGhpdFNpZGU9dHJ1ZVxyXG4gIC8vIHByb3BlcnR5IGlmIGl0IHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXHJcbiAgZnVuY3Rpb24gZmluZFBvc1YoY20sIHBvcywgZGlyLCB1bml0KSB7XHJcbiAgICB2YXIgZG9jID0gY20uZG9jLCB4ID0gcG9zLmxlZnQsIHk7XHJcbiAgICBpZiAodW5pdCA9PSBcInBhZ2VcIikge1xyXG4gICAgICB2YXIgcGFnZVNpemUgPSBNYXRoLm1pbihjbS5kaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCk7XHJcbiAgICAgIHkgPSBwb3MudG9wICsgZGlyICogKHBhZ2VTaXplIC0gKGRpciA8IDAgPyAxLjUgOiAuNSkgKiB0ZXh0SGVpZ2h0KGNtLmRpc3BsYXkpKTtcclxuICAgIH0gZWxzZSBpZiAodW5pdCA9PSBcImxpbmVcIikge1xyXG4gICAgICB5ID0gZGlyID4gMCA/IHBvcy5ib3R0b20gKyAzIDogcG9zLnRvcCAtIDM7XHJcbiAgICB9XHJcbiAgICBmb3IgKDs7KSB7XHJcbiAgICAgIHZhciB0YXJnZXQgPSBjb29yZHNDaGFyKGNtLCB4LCB5KTtcclxuICAgICAgaWYgKCF0YXJnZXQub3V0c2lkZSkgYnJlYWs7XHJcbiAgICAgIGlmIChkaXIgPCAwID8geSA8PSAwIDogeSA+PSBkb2MuaGVpZ2h0KSB7IHRhcmdldC5oaXRTaWRlID0gdHJ1ZTsgYnJlYWs7IH1cclxuICAgICAgeSArPSBkaXIgKiA1O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxuICB9XHJcblxyXG4gIC8vIEVESVRPUiBNRVRIT0RTXHJcblxyXG4gIC8vIFRoZSBwdWJsaWNseSB2aXNpYmxlIEFQSS4gTm90ZSB0aGF0IG1ldGhvZE9wKGYpIG1lYW5zXHJcbiAgLy8gJ3dyYXAgZiBpbiBhbiBvcGVyYXRpb24sIHBlcmZvcm1lZCBvbiBpdHMgYHRoaXNgIHBhcmFtZXRlcicuXHJcblxyXG4gIC8vIFRoaXMgaXMgbm90IHRoZSBjb21wbGV0ZSBzZXQgb2YgZWRpdG9yIG1ldGhvZHMuIE1vc3Qgb2YgdGhlXHJcbiAgLy8gbWV0aG9kcyBkZWZpbmVkIG9uIHRoZSBEb2MgdHlwZSBhcmUgYWxzbyBpbmplY3RlZCBpbnRvXHJcbiAgLy8gQ29kZU1pcnJvci5wcm90b3R5cGUsIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBhbmRcclxuICAvLyBjb252ZW5pZW5jZS5cclxuXHJcbiAgQ29kZU1pcnJvci5wcm90b3R5cGUgPSB7XHJcbiAgICBjb25zdHJ1Y3RvcjogQ29kZU1pcnJvcixcclxuICAgIGZvY3VzOiBmdW5jdGlvbigpe3dpbmRvdy5mb2N1cygpOyB0aGlzLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTt9LFxyXG5cclxuICAgIHNldE9wdGlvbjogZnVuY3Rpb24ob3B0aW9uLCB2YWx1ZSkge1xyXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucywgb2xkID0gb3B0aW9uc1tvcHRpb25dO1xyXG4gICAgICBpZiAob3B0aW9uc1tvcHRpb25dID09IHZhbHVlICYmIG9wdGlvbiAhPSBcIm1vZGVcIikgcmV0dXJuO1xyXG4gICAgICBvcHRpb25zW29wdGlvbl0gPSB2YWx1ZTtcclxuICAgICAgaWYgKG9wdGlvbkhhbmRsZXJzLmhhc093blByb3BlcnR5KG9wdGlvbikpXHJcbiAgICAgICAgb3BlcmF0aW9uKHRoaXMsIG9wdGlvbkhhbmRsZXJzW29wdGlvbl0pKHRoaXMsIHZhbHVlLCBvbGQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRPcHRpb246IGZ1bmN0aW9uKG9wdGlvbikge3JldHVybiB0aGlzLm9wdGlvbnNbb3B0aW9uXTt9LFxyXG4gICAgZ2V0RG9jOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5kb2M7fSxcclxuXHJcbiAgICBhZGRLZXlNYXA6IGZ1bmN0aW9uKG1hcCwgYm90dG9tKSB7XHJcbiAgICAgIHRoaXMuc3RhdGUua2V5TWFwc1tib3R0b20gPyBcInB1c2hcIiA6IFwidW5zaGlmdFwiXShnZXRLZXlNYXAobWFwKSk7XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlS2V5TWFwOiBmdW5jdGlvbihtYXApIHtcclxuICAgICAgdmFyIG1hcHMgPSB0aGlzLnN0YXRlLmtleU1hcHM7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwcy5sZW5ndGg7ICsraSlcclxuICAgICAgICBpZiAobWFwc1tpXSA9PSBtYXAgfHwgbWFwc1tpXS5uYW1lID09IG1hcCkge1xyXG4gICAgICAgICAgbWFwcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGFkZE92ZXJsYXk6IG1ldGhvZE9wKGZ1bmN0aW9uKHNwZWMsIG9wdGlvbnMpIHtcclxuICAgICAgdmFyIG1vZGUgPSBzcGVjLnRva2VuID8gc3BlYyA6IENvZGVNaXJyb3IuZ2V0TW9kZSh0aGlzLm9wdGlvbnMsIHNwZWMpO1xyXG4gICAgICBpZiAobW9kZS5zdGFydFN0YXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJPdmVybGF5cyBtYXkgbm90IGJlIHN0YXRlZnVsLlwiKTtcclxuICAgICAgdGhpcy5zdGF0ZS5vdmVybGF5cy5wdXNoKHttb2RlOiBtb2RlLCBtb2RlU3BlYzogc3BlYywgb3BhcXVlOiBvcHRpb25zICYmIG9wdGlvbnMub3BhcXVlfSk7XHJcbiAgICAgIHRoaXMuc3RhdGUubW9kZUdlbisrO1xyXG4gICAgICByZWdDaGFuZ2UodGhpcyk7XHJcbiAgICB9KSxcclxuICAgIHJlbW92ZU92ZXJsYXk6IG1ldGhvZE9wKGZ1bmN0aW9uKHNwZWMpIHtcclxuICAgICAgdmFyIG92ZXJsYXlzID0gdGhpcy5zdGF0ZS5vdmVybGF5cztcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdmVybGF5cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHZhciBjdXIgPSBvdmVybGF5c1tpXS5tb2RlU3BlYztcclxuICAgICAgICBpZiAoY3VyID09IHNwZWMgfHwgdHlwZW9mIHNwZWMgPT0gXCJzdHJpbmdcIiAmJiBjdXIubmFtZSA9PSBzcGVjKSB7XHJcbiAgICAgICAgICBvdmVybGF5cy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICB0aGlzLnN0YXRlLm1vZGVHZW4rKztcclxuICAgICAgICAgIHJlZ0NoYW5nZSh0aGlzKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pLFxyXG5cclxuICAgIGluZGVudExpbmU6IG1ldGhvZE9wKGZ1bmN0aW9uKG4sIGRpciwgYWdncmVzc2l2ZSkge1xyXG4gICAgICBpZiAodHlwZW9mIGRpciAhPSBcInN0cmluZ1wiICYmIHR5cGVvZiBkaXIgIT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgIGlmIChkaXIgPT0gbnVsbCkgZGlyID0gdGhpcy5vcHRpb25zLnNtYXJ0SW5kZW50ID8gXCJzbWFydFwiIDogXCJwcmV2XCI7XHJcbiAgICAgICAgZWxzZSBkaXIgPSBkaXIgPyBcImFkZFwiIDogXCJzdWJ0cmFjdFwiO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc0xpbmUodGhpcy5kb2MsIG4pKSBpbmRlbnRMaW5lKHRoaXMsIG4sIGRpciwgYWdncmVzc2l2ZSk7XHJcbiAgICB9KSxcclxuICAgIGluZGVudFNlbGVjdGlvbjogbWV0aG9kT3AoZnVuY3Rpb24oaG93KSB7XHJcbiAgICAgIHZhciByYW5nZXMgPSB0aGlzLmRvYy5zZWwucmFuZ2VzLCBlbmQgPSAtMTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XHJcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSgpKSB7XHJcbiAgICAgICAgICB2YXIgZnJvbSA9IHJhbmdlLmZyb20oKSwgdG8gPSByYW5nZS50bygpO1xyXG4gICAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoZW5kLCBmcm9tLmxpbmUpO1xyXG4gICAgICAgICAgZW5kID0gTWF0aC5taW4odGhpcy5sYXN0TGluZSgpLCB0by5saW5lIC0gKHRvLmNoID8gMCA6IDEpKSArIDE7XHJcbiAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnQ7IGogPCBlbmQ7ICsrailcclxuICAgICAgICAgICAgaW5kZW50TGluZSh0aGlzLCBqLCBob3cpO1xyXG4gICAgICAgICAgdmFyIG5ld1JhbmdlcyA9IHRoaXMuZG9jLnNlbC5yYW5nZXM7XHJcbiAgICAgICAgICBpZiAoZnJvbS5jaCA9PSAwICYmIHJhbmdlcy5sZW5ndGggPT0gbmV3UmFuZ2VzLmxlbmd0aCAmJiBuZXdSYW5nZXNbaV0uZnJvbSgpLmNoID4gMClcclxuICAgICAgICAgICAgcmVwbGFjZU9uZVNlbGVjdGlvbih0aGlzLmRvYywgaSwgbmV3IFJhbmdlKGZyb20sIG5ld1Jhbmdlc1tpXS50bygpKSwgc2VsX2RvbnRTY3JvbGwpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocmFuZ2UuaGVhZC5saW5lID4gZW5kKSB7XHJcbiAgICAgICAgICBpbmRlbnRMaW5lKHRoaXMsIHJhbmdlLmhlYWQubGluZSwgaG93LCB0cnVlKTtcclxuICAgICAgICAgIGVuZCA9IHJhbmdlLmhlYWQubGluZTtcclxuICAgICAgICAgIGlmIChpID09IHRoaXMuZG9jLnNlbC5wcmltSW5kZXgpIGVuc3VyZUN1cnNvclZpc2libGUodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KSxcclxuXHJcbiAgICAvLyBGZXRjaCB0aGUgcGFyc2VyIHRva2VuIGZvciBhIGdpdmVuIGNoYXJhY3Rlci4gVXNlZnVsIGZvciBoYWNrc1xyXG4gICAgLy8gdGhhdCB3YW50IHRvIGluc3BlY3QgdGhlIG1vZGUgc3RhdGUgKHNheSwgZm9yIGNvbXBsZXRpb24pLlxyXG4gICAgZ2V0VG9rZW5BdDogZnVuY3Rpb24ocG9zLCBwcmVjaXNlKSB7XHJcbiAgICAgIHJldHVybiB0YWtlVG9rZW4odGhpcywgcG9zLCBwcmVjaXNlKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0TGluZVRva2VuczogZnVuY3Rpb24obGluZSwgcHJlY2lzZSkge1xyXG4gICAgICByZXR1cm4gdGFrZVRva2VuKHRoaXMsIFBvcyhsaW5lKSwgcHJlY2lzZSwgdHJ1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFRva2VuVHlwZUF0OiBmdW5jdGlvbihwb3MpIHtcclxuICAgICAgcG9zID0gY2xpcFBvcyh0aGlzLmRvYywgcG9zKTtcclxuICAgICAgdmFyIHN0eWxlcyA9IGdldExpbmVTdHlsZXModGhpcywgZ2V0TGluZSh0aGlzLmRvYywgcG9zLmxpbmUpKTtcclxuICAgICAgdmFyIGJlZm9yZSA9IDAsIGFmdGVyID0gKHN0eWxlcy5sZW5ndGggLSAxKSAvIDIsIGNoID0gcG9zLmNoO1xyXG4gICAgICB2YXIgdHlwZTtcclxuICAgICAgaWYgKGNoID09IDApIHR5cGUgPSBzdHlsZXNbMl07XHJcbiAgICAgIGVsc2UgZm9yICg7Oykge1xyXG4gICAgICAgIHZhciBtaWQgPSAoYmVmb3JlICsgYWZ0ZXIpID4+IDE7XHJcbiAgICAgICAgaWYgKChtaWQgPyBzdHlsZXNbbWlkICogMiAtIDFdIDogMCkgPj0gY2gpIGFmdGVyID0gbWlkO1xyXG4gICAgICAgIGVsc2UgaWYgKHN0eWxlc1ttaWQgKiAyICsgMV0gPCBjaCkgYmVmb3JlID0gbWlkICsgMTtcclxuICAgICAgICBlbHNlIHsgdHlwZSA9IHN0eWxlc1ttaWQgKiAyICsgMl07IGJyZWFrOyB9XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGN1dCA9IHR5cGUgPyB0eXBlLmluZGV4T2YoXCJjbS1vdmVybGF5IFwiKSA6IC0xO1xyXG4gICAgICByZXR1cm4gY3V0IDwgMCA/IHR5cGUgOiBjdXQgPT0gMCA/IG51bGwgOiB0eXBlLnNsaWNlKDAsIGN1dCAtIDEpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRNb2RlQXQ6IGZ1bmN0aW9uKHBvcykge1xyXG4gICAgICB2YXIgbW9kZSA9IHRoaXMuZG9jLm1vZGU7XHJcbiAgICAgIGlmICghbW9kZS5pbm5lck1vZGUpIHJldHVybiBtb2RlO1xyXG4gICAgICByZXR1cm4gQ29kZU1pcnJvci5pbm5lck1vZGUobW9kZSwgdGhpcy5nZXRUb2tlbkF0KHBvcykuc3RhdGUpLm1vZGU7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldEhlbHBlcjogZnVuY3Rpb24ocG9zLCB0eXBlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldEhlbHBlcnMocG9zLCB0eXBlKVswXTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0SGVscGVyczogZnVuY3Rpb24ocG9zLCB0eXBlKSB7XHJcbiAgICAgIHZhciBmb3VuZCA9IFtdO1xyXG4gICAgICBpZiAoIWhlbHBlcnMuaGFzT3duUHJvcGVydHkodHlwZSkpIHJldHVybiBmb3VuZDtcclxuICAgICAgdmFyIGhlbHAgPSBoZWxwZXJzW3R5cGVdLCBtb2RlID0gdGhpcy5nZXRNb2RlQXQocG9zKTtcclxuICAgICAgaWYgKHR5cGVvZiBtb2RlW3R5cGVdID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBpZiAoaGVscFttb2RlW3R5cGVdXSkgZm91bmQucHVzaChoZWxwW21vZGVbdHlwZV1dKTtcclxuICAgICAgfSBlbHNlIGlmIChtb2RlW3R5cGVdKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb2RlW3R5cGVdLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICB2YXIgdmFsID0gaGVscFttb2RlW3R5cGVdW2ldXTtcclxuICAgICAgICAgIGlmICh2YWwpIGZvdW5kLnB1c2godmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAobW9kZS5oZWxwZXJUeXBlICYmIGhlbHBbbW9kZS5oZWxwZXJUeXBlXSkge1xyXG4gICAgICAgIGZvdW5kLnB1c2goaGVscFttb2RlLmhlbHBlclR5cGVdKTtcclxuICAgICAgfSBlbHNlIGlmIChoZWxwW21vZGUubmFtZV0pIHtcclxuICAgICAgICBmb3VuZC5wdXNoKGhlbHBbbW9kZS5uYW1lXSk7XHJcbiAgICAgIH1cclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWxwLl9nbG9iYWwubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgY3VyID0gaGVscC5fZ2xvYmFsW2ldO1xyXG4gICAgICAgIGlmIChjdXIucHJlZChtb2RlLCB0aGlzKSAmJiBpbmRleE9mKGZvdW5kLCBjdXIudmFsKSA9PSAtMSlcclxuICAgICAgICAgIGZvdW5kLnB1c2goY3VyLnZhbCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZvdW5kO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRTdGF0ZUFmdGVyOiBmdW5jdGlvbihsaW5lLCBwcmVjaXNlKSB7XHJcbiAgICAgIHZhciBkb2MgPSB0aGlzLmRvYztcclxuICAgICAgbGluZSA9IGNsaXBMaW5lKGRvYywgbGluZSA9PSBudWxsID8gZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxOiBsaW5lKTtcclxuICAgICAgcmV0dXJuIGdldFN0YXRlQmVmb3JlKHRoaXMsIGxpbmUgKyAxLCBwcmVjaXNlKTtcclxuICAgIH0sXHJcblxyXG4gICAgY3Vyc29yQ29vcmRzOiBmdW5jdGlvbihzdGFydCwgbW9kZSkge1xyXG4gICAgICB2YXIgcG9zLCByYW5nZSA9IHRoaXMuZG9jLnNlbC5wcmltYXJ5KCk7XHJcbiAgICAgIGlmIChzdGFydCA9PSBudWxsKSBwb3MgPSByYW5nZS5oZWFkO1xyXG4gICAgICBlbHNlIGlmICh0eXBlb2Ygc3RhcnQgPT0gXCJvYmplY3RcIikgcG9zID0gY2xpcFBvcyh0aGlzLmRvYywgc3RhcnQpO1xyXG4gICAgICBlbHNlIHBvcyA9IHN0YXJ0ID8gcmFuZ2UuZnJvbSgpIDogcmFuZ2UudG8oKTtcclxuICAgICAgcmV0dXJuIGN1cnNvckNvb3Jkcyh0aGlzLCBwb3MsIG1vZGUgfHwgXCJwYWdlXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjaGFyQ29vcmRzOiBmdW5jdGlvbihwb3MsIG1vZGUpIHtcclxuICAgICAgcmV0dXJuIGNoYXJDb29yZHModGhpcywgY2xpcFBvcyh0aGlzLmRvYywgcG9zKSwgbW9kZSB8fCBcInBhZ2VcIik7XHJcbiAgICB9LFxyXG5cclxuICAgIGNvb3Jkc0NoYXI6IGZ1bmN0aW9uKGNvb3JkcywgbW9kZSkge1xyXG4gICAgICBjb29yZHMgPSBmcm9tQ29vcmRTeXN0ZW0odGhpcywgY29vcmRzLCBtb2RlIHx8IFwicGFnZVwiKTtcclxuICAgICAgcmV0dXJuIGNvb3Jkc0NoYXIodGhpcywgY29vcmRzLmxlZnQsIGNvb3Jkcy50b3ApO1xyXG4gICAgfSxcclxuXHJcbiAgICBsaW5lQXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCwgbW9kZSkge1xyXG4gICAgICBoZWlnaHQgPSBmcm9tQ29vcmRTeXN0ZW0odGhpcywge3RvcDogaGVpZ2h0LCBsZWZ0OiAwfSwgbW9kZSB8fCBcInBhZ2VcIikudG9wO1xyXG4gICAgICByZXR1cm4gbGluZUF0SGVpZ2h0KHRoaXMuZG9jLCBoZWlnaHQgKyB0aGlzLmRpc3BsYXkudmlld09mZnNldCk7XHJcbiAgICB9LFxyXG4gICAgaGVpZ2h0QXRMaW5lOiBmdW5jdGlvbihsaW5lLCBtb2RlKSB7XHJcbiAgICAgIHZhciBlbmQgPSBmYWxzZSwgbGFzdCA9IHRoaXMuZG9jLmZpcnN0ICsgdGhpcy5kb2Muc2l6ZSAtIDE7XHJcbiAgICAgIGlmIChsaW5lIDwgdGhpcy5kb2MuZmlyc3QpIGxpbmUgPSB0aGlzLmRvYy5maXJzdDtcclxuICAgICAgZWxzZSBpZiAobGluZSA+IGxhc3QpIHsgbGluZSA9IGxhc3Q7IGVuZCA9IHRydWU7IH1cclxuICAgICAgdmFyIGxpbmVPYmogPSBnZXRMaW5lKHRoaXMuZG9jLCBsaW5lKTtcclxuICAgICAgcmV0dXJuIGludG9Db29yZFN5c3RlbSh0aGlzLCBsaW5lT2JqLCB7dG9wOiAwLCBsZWZ0OiAwfSwgbW9kZSB8fCBcInBhZ2VcIikudG9wICtcclxuICAgICAgICAoZW5kID8gdGhpcy5kb2MuaGVpZ2h0IC0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopIDogMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlZmF1bHRUZXh0SGVpZ2h0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRleHRIZWlnaHQodGhpcy5kaXNwbGF5KTsgfSxcclxuICAgIGRlZmF1bHRDaGFyV2lkdGg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gY2hhcldpZHRoKHRoaXMuZGlzcGxheSk7IH0sXHJcblxyXG4gICAgc2V0R3V0dGVyTWFya2VyOiBtZXRob2RPcChmdW5jdGlvbihsaW5lLCBndXR0ZXJJRCwgdmFsdWUpIHtcclxuICAgICAgcmV0dXJuIGNoYW5nZUxpbmUodGhpcy5kb2MsIGxpbmUsIFwiZ3V0dGVyXCIsIGZ1bmN0aW9uKGxpbmUpIHtcclxuICAgICAgICB2YXIgbWFya2VycyA9IGxpbmUuZ3V0dGVyTWFya2VycyB8fCAobGluZS5ndXR0ZXJNYXJrZXJzID0ge30pO1xyXG4gICAgICAgIG1hcmtlcnNbZ3V0dGVySURdID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSAmJiBpc0VtcHR5KG1hcmtlcnMpKSBsaW5lLmd1dHRlck1hcmtlcnMgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9KTtcclxuICAgIH0pLFxyXG5cclxuICAgIGNsZWFyR3V0dGVyOiBtZXRob2RPcChmdW5jdGlvbihndXR0ZXJJRCkge1xyXG4gICAgICB2YXIgY20gPSB0aGlzLCBkb2MgPSBjbS5kb2MsIGkgPSBkb2MuZmlyc3Q7XHJcbiAgICAgIGRvYy5pdGVyKGZ1bmN0aW9uKGxpbmUpIHtcclxuICAgICAgICBpZiAobGluZS5ndXR0ZXJNYXJrZXJzICYmIGxpbmUuZ3V0dGVyTWFya2Vyc1tndXR0ZXJJRF0pIHtcclxuICAgICAgICAgIGxpbmUuZ3V0dGVyTWFya2Vyc1tndXR0ZXJJRF0gPSBudWxsO1xyXG4gICAgICAgICAgcmVnTGluZUNoYW5nZShjbSwgaSwgXCJndXR0ZXJcIik7XHJcbiAgICAgICAgICBpZiAoaXNFbXB0eShsaW5lLmd1dHRlck1hcmtlcnMpKSBsaW5lLmd1dHRlck1hcmtlcnMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICArK2k7XHJcbiAgICAgIH0pO1xyXG4gICAgfSksXHJcblxyXG4gICAgbGluZUluZm86IGZ1bmN0aW9uKGxpbmUpIHtcclxuICAgICAgaWYgKHR5cGVvZiBsaW5lID09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICBpZiAoIWlzTGluZSh0aGlzLmRvYywgbGluZSkpIHJldHVybiBudWxsO1xyXG4gICAgICAgIHZhciBuID0gbGluZTtcclxuICAgICAgICBsaW5lID0gZ2V0TGluZSh0aGlzLmRvYywgbGluZSk7XHJcbiAgICAgICAgaWYgKCFsaW5lKSByZXR1cm4gbnVsbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgbiA9IGxpbmVObyhsaW5lKTtcclxuICAgICAgICBpZiAobiA9PSBudWxsKSByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4ge2xpbmU6IG4sIGhhbmRsZTogbGluZSwgdGV4dDogbGluZS50ZXh0LCBndXR0ZXJNYXJrZXJzOiBsaW5lLmd1dHRlck1hcmtlcnMsXHJcbiAgICAgICAgICAgICAgdGV4dENsYXNzOiBsaW5lLnRleHRDbGFzcywgYmdDbGFzczogbGluZS5iZ0NsYXNzLCB3cmFwQ2xhc3M6IGxpbmUud3JhcENsYXNzLFxyXG4gICAgICAgICAgICAgIHdpZGdldHM6IGxpbmUud2lkZ2V0c307XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFZpZXdwb3J0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHtmcm9tOiB0aGlzLmRpc3BsYXkudmlld0Zyb20sIHRvOiB0aGlzLmRpc3BsYXkudmlld1RvfTt9LFxyXG5cclxuICAgIGFkZFdpZGdldDogZnVuY3Rpb24ocG9zLCBub2RlLCBzY3JvbGwsIHZlcnQsIGhvcml6KSB7XHJcbiAgICAgIHZhciBkaXNwbGF5ID0gdGhpcy5kaXNwbGF5O1xyXG4gICAgICBwb3MgPSBjdXJzb3JDb29yZHModGhpcywgY2xpcFBvcyh0aGlzLmRvYywgcG9zKSk7XHJcbiAgICAgIHZhciB0b3AgPSBwb3MuYm90dG9tLCBsZWZ0ID0gcG9zLmxlZnQ7XHJcbiAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XHJcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiLCBcInRydWVcIik7XHJcbiAgICAgIHRoaXMuZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKG5vZGUpO1xyXG4gICAgICBkaXNwbGF5LnNpemVyLmFwcGVuZENoaWxkKG5vZGUpO1xyXG4gICAgICBpZiAodmVydCA9PSBcIm92ZXJcIikge1xyXG4gICAgICAgIHRvcCA9IHBvcy50b3A7XHJcbiAgICAgIH0gZWxzZSBpZiAodmVydCA9PSBcImFib3ZlXCIgfHwgdmVydCA9PSBcIm5lYXJcIikge1xyXG4gICAgICAgIHZhciB2c3BhY2UgPSBNYXRoLm1heChkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0LCB0aGlzLmRvYy5oZWlnaHQpLFxyXG4gICAgICAgIGhzcGFjZSA9IE1hdGgubWF4KGRpc3BsYXkuc2l6ZXIuY2xpZW50V2lkdGgsIGRpc3BsYXkubGluZVNwYWNlLmNsaWVudFdpZHRoKTtcclxuICAgICAgICAvLyBEZWZhdWx0IHRvIHBvc2l0aW9uaW5nIGFib3ZlIChpZiBzcGVjaWZpZWQgYW5kIHBvc3NpYmxlKTsgb3RoZXJ3aXNlIGRlZmF1bHQgdG8gcG9zaXRpb25pbmcgYmVsb3dcclxuICAgICAgICBpZiAoKHZlcnQgPT0gJ2Fib3ZlJyB8fCBwb3MuYm90dG9tICsgbm9kZS5vZmZzZXRIZWlnaHQgPiB2c3BhY2UpICYmIHBvcy50b3AgPiBub2RlLm9mZnNldEhlaWdodClcclxuICAgICAgICAgIHRvcCA9IHBvcy50b3AgLSBub2RlLm9mZnNldEhlaWdodDtcclxuICAgICAgICBlbHNlIGlmIChwb3MuYm90dG9tICsgbm9kZS5vZmZzZXRIZWlnaHQgPD0gdnNwYWNlKVxyXG4gICAgICAgICAgdG9wID0gcG9zLmJvdHRvbTtcclxuICAgICAgICBpZiAobGVmdCArIG5vZGUub2Zmc2V0V2lkdGggPiBoc3BhY2UpXHJcbiAgICAgICAgICBsZWZ0ID0gaHNwYWNlIC0gbm9kZS5vZmZzZXRXaWR0aDtcclxuICAgICAgfVxyXG4gICAgICBub2RlLnN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjtcclxuICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gbm9kZS5zdHlsZS5yaWdodCA9IFwiXCI7XHJcbiAgICAgIGlmIChob3JpeiA9PSBcInJpZ2h0XCIpIHtcclxuICAgICAgICBsZWZ0ID0gZGlzcGxheS5zaXplci5jbGllbnRXaWR0aCAtIG5vZGUub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgbm9kZS5zdHlsZS5yaWdodCA9IFwiMHB4XCI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGhvcml6ID09IFwibGVmdFwiKSBsZWZ0ID0gMDtcclxuICAgICAgICBlbHNlIGlmIChob3JpeiA9PSBcIm1pZGRsZVwiKSBsZWZ0ID0gKGRpc3BsYXkuc2l6ZXIuY2xpZW50V2lkdGggLSBub2RlLm9mZnNldFdpZHRoKSAvIDI7XHJcbiAgICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2Nyb2xsKVxyXG4gICAgICAgIHNjcm9sbEludG9WaWV3KHRoaXMsIGxlZnQsIHRvcCwgbGVmdCArIG5vZGUub2Zmc2V0V2lkdGgsIHRvcCArIG5vZGUub2Zmc2V0SGVpZ2h0KTtcclxuICAgIH0sXHJcblxyXG4gICAgdHJpZ2dlck9uS2V5RG93bjogbWV0aG9kT3Aob25LZXlEb3duKSxcclxuICAgIHRyaWdnZXJPbktleVByZXNzOiBtZXRob2RPcChvbktleVByZXNzKSxcclxuICAgIHRyaWdnZXJPbktleVVwOiBvbktleVVwLFxyXG5cclxuICAgIGV4ZWNDb21tYW5kOiBmdW5jdGlvbihjbWQpIHtcclxuICAgICAgaWYgKGNvbW1hbmRzLmhhc093blByb3BlcnR5KGNtZCkpXHJcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzW2NtZF0odGhpcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZpbmRQb3NIOiBmdW5jdGlvbihmcm9tLCBhbW91bnQsIHVuaXQsIHZpc3VhbGx5KSB7XHJcbiAgICAgIHZhciBkaXIgPSAxO1xyXG4gICAgICBpZiAoYW1vdW50IDwgMCkgeyBkaXIgPSAtMTsgYW1vdW50ID0gLWFtb3VudDsgfVxyXG4gICAgICBmb3IgKHZhciBpID0gMCwgY3VyID0gY2xpcFBvcyh0aGlzLmRvYywgZnJvbSk7IGkgPCBhbW91bnQ7ICsraSkge1xyXG4gICAgICAgIGN1ciA9IGZpbmRQb3NIKHRoaXMuZG9jLCBjdXIsIGRpciwgdW5pdCwgdmlzdWFsbHkpO1xyXG4gICAgICAgIGlmIChjdXIuaGl0U2lkZSkgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGN1cjtcclxuICAgIH0sXHJcblxyXG4gICAgbW92ZUg6IG1ldGhvZE9wKGZ1bmN0aW9uKGRpciwgdW5pdCkge1xyXG4gICAgICB2YXIgY20gPSB0aGlzO1xyXG4gICAgICBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24ocmFuZ2UpIHtcclxuICAgICAgICBpZiAoY20uZGlzcGxheS5zaGlmdCB8fCBjbS5kb2MuZXh0ZW5kIHx8IHJhbmdlLmVtcHR5KCkpXHJcbiAgICAgICAgICByZXR1cm4gZmluZFBvc0goY20uZG9jLCByYW5nZS5oZWFkLCBkaXIsIHVuaXQsIGNtLm9wdGlvbnMucnRsTW92ZVZpc3VhbGx5KTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICByZXR1cm4gZGlyIDwgMCA/IHJhbmdlLmZyb20oKSA6IHJhbmdlLnRvKCk7XHJcbiAgICAgIH0sIHNlbF9tb3ZlKTtcclxuICAgIH0pLFxyXG5cclxuICAgIGRlbGV0ZUg6IG1ldGhvZE9wKGZ1bmN0aW9uKGRpciwgdW5pdCkge1xyXG4gICAgICB2YXIgc2VsID0gdGhpcy5kb2Muc2VsLCBkb2MgPSB0aGlzLmRvYztcclxuICAgICAgaWYgKHNlbC5zb21ldGhpbmdTZWxlY3RlZCgpKVxyXG4gICAgICAgIGRvYy5yZXBsYWNlU2VsZWN0aW9uKFwiXCIsIG51bGwsIFwiK2RlbGV0ZVwiKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIGRlbGV0ZU5lYXJTZWxlY3Rpb24odGhpcywgZnVuY3Rpb24ocmFuZ2UpIHtcclxuICAgICAgICAgIHZhciBvdGhlciA9IGZpbmRQb3NIKGRvYywgcmFuZ2UuaGVhZCwgZGlyLCB1bml0LCBmYWxzZSk7XHJcbiAgICAgICAgICByZXR1cm4gZGlyIDwgMCA/IHtmcm9tOiBvdGhlciwgdG86IHJhbmdlLmhlYWR9IDoge2Zyb206IHJhbmdlLmhlYWQsIHRvOiBvdGhlcn07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KSxcclxuXHJcbiAgICBmaW5kUG9zVjogZnVuY3Rpb24oZnJvbSwgYW1vdW50LCB1bml0LCBnb2FsQ29sdW1uKSB7XHJcbiAgICAgIHZhciBkaXIgPSAxLCB4ID0gZ29hbENvbHVtbjtcclxuICAgICAgaWYgKGFtb3VudCA8IDApIHsgZGlyID0gLTE7IGFtb3VudCA9IC1hbW91bnQ7IH1cclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGN1ciA9IGNsaXBQb3ModGhpcy5kb2MsIGZyb20pOyBpIDwgYW1vdW50OyArK2kpIHtcclxuICAgICAgICB2YXIgY29vcmRzID0gY3Vyc29yQ29vcmRzKHRoaXMsIGN1ciwgXCJkaXZcIik7XHJcbiAgICAgICAgaWYgKHggPT0gbnVsbCkgeCA9IGNvb3Jkcy5sZWZ0O1xyXG4gICAgICAgIGVsc2UgY29vcmRzLmxlZnQgPSB4O1xyXG4gICAgICAgIGN1ciA9IGZpbmRQb3NWKHRoaXMsIGNvb3JkcywgZGlyLCB1bml0KTtcclxuICAgICAgICBpZiAoY3VyLmhpdFNpZGUpIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjdXI7XHJcbiAgICB9LFxyXG5cclxuICAgIG1vdmVWOiBtZXRob2RPcChmdW5jdGlvbihkaXIsIHVuaXQpIHtcclxuICAgICAgdmFyIGNtID0gdGhpcywgZG9jID0gdGhpcy5kb2MsIGdvYWxzID0gW107XHJcbiAgICAgIHZhciBjb2xsYXBzZSA9ICFjbS5kaXNwbGF5LnNoaWZ0ICYmICFkb2MuZXh0ZW5kICYmIGRvYy5zZWwuc29tZXRoaW5nU2VsZWN0ZWQoKTtcclxuICAgICAgZG9jLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbihyYW5nZSkge1xyXG4gICAgICAgIGlmIChjb2xsYXBzZSlcclxuICAgICAgICAgIHJldHVybiBkaXIgPCAwID8gcmFuZ2UuZnJvbSgpIDogcmFuZ2UudG8oKTtcclxuICAgICAgICB2YXIgaGVhZFBvcyA9IGN1cnNvckNvb3JkcyhjbSwgcmFuZ2UuaGVhZCwgXCJkaXZcIik7XHJcbiAgICAgICAgaWYgKHJhbmdlLmdvYWxDb2x1bW4gIT0gbnVsbCkgaGVhZFBvcy5sZWZ0ID0gcmFuZ2UuZ29hbENvbHVtbjtcclxuICAgICAgICBnb2Fscy5wdXNoKGhlYWRQb3MubGVmdCk7XHJcbiAgICAgICAgdmFyIHBvcyA9IGZpbmRQb3NWKGNtLCBoZWFkUG9zLCBkaXIsIHVuaXQpO1xyXG4gICAgICAgIGlmICh1bml0ID09IFwicGFnZVwiICYmIHJhbmdlID09IGRvYy5zZWwucHJpbWFyeSgpKVxyXG4gICAgICAgICAgYWRkVG9TY3JvbGxQb3MoY20sIG51bGwsIGNoYXJDb29yZHMoY20sIHBvcywgXCJkaXZcIikudG9wIC0gaGVhZFBvcy50b3ApO1xyXG4gICAgICAgIHJldHVybiBwb3M7XHJcbiAgICAgIH0sIHNlbF9tb3ZlKTtcclxuICAgICAgaWYgKGdvYWxzLmxlbmd0aCkgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKylcclxuICAgICAgICBkb2Muc2VsLnJhbmdlc1tpXS5nb2FsQ29sdW1uID0gZ29hbHNbaV07XHJcbiAgICB9KSxcclxuXHJcbiAgICAvLyBGaW5kIHRoZSB3b3JkIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiAoYXMgcmV0dXJuZWQgYnkgY29vcmRzQ2hhcikuXHJcbiAgICBmaW5kV29yZEF0OiBmdW5jdGlvbihwb3MpIHtcclxuICAgICAgdmFyIGRvYyA9IHRoaXMuZG9jLCBsaW5lID0gZ2V0TGluZShkb2MsIHBvcy5saW5lKS50ZXh0O1xyXG4gICAgICB2YXIgc3RhcnQgPSBwb3MuY2gsIGVuZCA9IHBvcy5jaDtcclxuICAgICAgaWYgKGxpbmUpIHtcclxuICAgICAgICB2YXIgaGVscGVyID0gdGhpcy5nZXRIZWxwZXIocG9zLCBcIndvcmRDaGFyc1wiKTtcclxuICAgICAgICBpZiAoKHBvcy54UmVsIDwgMCB8fCBlbmQgPT0gbGluZS5sZW5ndGgpICYmIHN0YXJ0KSAtLXN0YXJ0OyBlbHNlICsrZW5kO1xyXG4gICAgICAgIHZhciBzdGFydENoYXIgPSBsaW5lLmNoYXJBdChzdGFydCk7XHJcbiAgICAgICAgdmFyIGNoZWNrID0gaXNXb3JkQ2hhcihzdGFydENoYXIsIGhlbHBlcilcclxuICAgICAgICAgID8gZnVuY3Rpb24oY2gpIHsgcmV0dXJuIGlzV29yZENoYXIoY2gsIGhlbHBlcik7IH1cclxuICAgICAgICAgIDogL1xccy8udGVzdChzdGFydENoYXIpID8gZnVuY3Rpb24oY2gpIHtyZXR1cm4gL1xccy8udGVzdChjaCk7fVxyXG4gICAgICAgICAgOiBmdW5jdGlvbihjaCkge3JldHVybiAhL1xccy8udGVzdChjaCkgJiYgIWlzV29yZENoYXIoY2gpO307XHJcbiAgICAgICAgd2hpbGUgKHN0YXJ0ID4gMCAmJiBjaGVjayhsaW5lLmNoYXJBdChzdGFydCAtIDEpKSkgLS1zdGFydDtcclxuICAgICAgICB3aGlsZSAoZW5kIDwgbGluZS5sZW5ndGggJiYgY2hlY2sobGluZS5jaGFyQXQoZW5kKSkpICsrZW5kO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuZXcgUmFuZ2UoUG9zKHBvcy5saW5lLCBzdGFydCksIFBvcyhwb3MubGluZSwgZW5kKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHRvZ2dsZU92ZXJ3cml0ZTogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgPT0gdGhpcy5zdGF0ZS5vdmVyd3JpdGUpIHJldHVybjtcclxuICAgICAgaWYgKHRoaXMuc3RhdGUub3ZlcndyaXRlID0gIXRoaXMuc3RhdGUub3ZlcndyaXRlKVxyXG4gICAgICAgIGFkZENsYXNzKHRoaXMuZGlzcGxheS5jdXJzb3JEaXYsIFwiQ29kZU1pcnJvci1vdmVyd3JpdGVcIik7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBybUNsYXNzKHRoaXMuZGlzcGxheS5jdXJzb3JEaXYsIFwiQ29kZU1pcnJvci1vdmVyd3JpdGVcIik7XHJcblxyXG4gICAgICBzaWduYWwodGhpcywgXCJvdmVyd3JpdGVUb2dnbGVcIiwgdGhpcywgdGhpcy5zdGF0ZS5vdmVyd3JpdGUpO1xyXG4gICAgfSxcclxuICAgIGhhc0ZvY3VzOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpID09IGFjdGl2ZUVsdCgpOyB9LFxyXG5cclxuICAgIHNjcm9sbFRvOiBtZXRob2RPcChmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgIGlmICh4ICE9IG51bGwgfHwgeSAhPSBudWxsKSByZXNvbHZlU2Nyb2xsVG9Qb3ModGhpcyk7XHJcbiAgICAgIGlmICh4ICE9IG51bGwpIHRoaXMuY3VyT3Auc2Nyb2xsTGVmdCA9IHg7XHJcbiAgICAgIGlmICh5ICE9IG51bGwpIHRoaXMuY3VyT3Auc2Nyb2xsVG9wID0geTtcclxuICAgIH0pLFxyXG4gICAgZ2V0U2Nyb2xsSW5mbzogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBzY3JvbGxlciA9IHRoaXMuZGlzcGxheS5zY3JvbGxlcjtcclxuICAgICAgcmV0dXJuIHtsZWZ0OiBzY3JvbGxlci5zY3JvbGxMZWZ0LCB0b3A6IHNjcm9sbGVyLnNjcm9sbFRvcCxcclxuICAgICAgICAgICAgICBoZWlnaHQ6IHNjcm9sbGVyLnNjcm9sbEhlaWdodCAtIHNjcm9sbEdhcCh0aGlzKSAtIHRoaXMuZGlzcGxheS5iYXJIZWlnaHQsXHJcbiAgICAgICAgICAgICAgd2lkdGg6IHNjcm9sbGVyLnNjcm9sbFdpZHRoIC0gc2Nyb2xsR2FwKHRoaXMpIC0gdGhpcy5kaXNwbGF5LmJhcldpZHRoLFxyXG4gICAgICAgICAgICAgIGNsaWVudEhlaWdodDogZGlzcGxheUhlaWdodCh0aGlzKSwgY2xpZW50V2lkdGg6IGRpc3BsYXlXaWR0aCh0aGlzKX07XHJcbiAgICB9LFxyXG5cclxuICAgIHNjcm9sbEludG9WaWV3OiBtZXRob2RPcChmdW5jdGlvbihyYW5nZSwgbWFyZ2luKSB7XHJcbiAgICAgIGlmIChyYW5nZSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmFuZ2UgPSB7ZnJvbTogdGhpcy5kb2Muc2VsLnByaW1hcnkoKS5oZWFkLCB0bzogbnVsbH07XHJcbiAgICAgICAgaWYgKG1hcmdpbiA9PSBudWxsKSBtYXJnaW4gPSB0aGlzLm9wdGlvbnMuY3Vyc29yU2Nyb2xsTWFyZ2luO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiByYW5nZSA9PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgcmFuZ2UgPSB7ZnJvbTogUG9zKHJhbmdlLCAwKSwgdG86IG51bGx9O1xyXG4gICAgICB9IGVsc2UgaWYgKHJhbmdlLmZyb20gPT0gbnVsbCkge1xyXG4gICAgICAgIHJhbmdlID0ge2Zyb206IHJhbmdlLCB0bzogbnVsbH07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFyYW5nZS50bykgcmFuZ2UudG8gPSByYW5nZS5mcm9tO1xyXG4gICAgICByYW5nZS5tYXJnaW4gPSBtYXJnaW4gfHwgMDtcclxuXHJcbiAgICAgIGlmIChyYW5nZS5mcm9tLmxpbmUgIT0gbnVsbCkge1xyXG4gICAgICAgIHJlc29sdmVTY3JvbGxUb1Bvcyh0aGlzKTtcclxuICAgICAgICB0aGlzLmN1ck9wLnNjcm9sbFRvUG9zID0gcmFuZ2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIHNQb3MgPSBjYWxjdWxhdGVTY3JvbGxQb3ModGhpcywgTWF0aC5taW4ocmFuZ2UuZnJvbS5sZWZ0LCByYW5nZS50by5sZWZ0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihyYW5nZS5mcm9tLnRvcCwgcmFuZ2UudG8udG9wKSAtIHJhbmdlLm1hcmdpbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChyYW5nZS5mcm9tLnJpZ2h0LCByYW5nZS50by5yaWdodCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgocmFuZ2UuZnJvbS5ib3R0b20sIHJhbmdlLnRvLmJvdHRvbSkgKyByYW5nZS5tYXJnaW4pO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsVG8oc1Bvcy5zY3JvbGxMZWZ0LCBzUG9zLnNjcm9sbFRvcCk7XHJcbiAgICAgIH1cclxuICAgIH0pLFxyXG5cclxuICAgIHNldFNpemU6IG1ldGhvZE9wKGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgdmFyIGNtID0gdGhpcztcclxuICAgICAgZnVuY3Rpb24gaW50ZXJwcmV0KHZhbCkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09IFwibnVtYmVyXCIgfHwgL15cXGQrJC8udGVzdChTdHJpbmcodmFsKSkgPyB2YWwgKyBcInB4XCIgOiB2YWw7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHdpZHRoICE9IG51bGwpIGNtLmRpc3BsYXkud3JhcHBlci5zdHlsZS53aWR0aCA9IGludGVycHJldCh3aWR0aCk7XHJcbiAgICAgIGlmIChoZWlnaHQgIT0gbnVsbCkgY20uZGlzcGxheS53cmFwcGVyLnN0eWxlLmhlaWdodCA9IGludGVycHJldChoZWlnaHQpO1xyXG4gICAgICBpZiAoY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGUodGhpcyk7XHJcbiAgICAgIHZhciBsaW5lTm8gPSBjbS5kaXNwbGF5LnZpZXdGcm9tO1xyXG4gICAgICBjbS5kb2MuaXRlcihsaW5lTm8sIGNtLmRpc3BsYXkudmlld1RvLCBmdW5jdGlvbihsaW5lKSB7XHJcbiAgICAgICAgaWYgKGxpbmUud2lkZ2V0cykgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLndpZGdldHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICBpZiAobGluZS53aWRnZXRzW2ldLm5vSFNjcm9sbCkgeyByZWdMaW5lQ2hhbmdlKGNtLCBsaW5lTm8sIFwid2lkZ2V0XCIpOyBicmVhazsgfVxyXG4gICAgICAgICsrbGluZU5vO1xyXG4gICAgICB9KTtcclxuICAgICAgY20uY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xyXG4gICAgICBzaWduYWwoY20sIFwicmVmcmVzaFwiLCB0aGlzKTtcclxuICAgIH0pLFxyXG5cclxuICAgIG9wZXJhdGlvbjogZnVuY3Rpb24oZil7cmV0dXJuIHJ1bkluT3AodGhpcywgZik7fSxcclxuXHJcbiAgICByZWZyZXNoOiBtZXRob2RPcChmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIG9sZEhlaWdodCA9IHRoaXMuZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0O1xyXG4gICAgICByZWdDaGFuZ2UodGhpcyk7XHJcbiAgICAgIHRoaXMuY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xyXG4gICAgICBjbGVhckNhY2hlcyh0aGlzKTtcclxuICAgICAgdGhpcy5zY3JvbGxUbyh0aGlzLmRvYy5zY3JvbGxMZWZ0LCB0aGlzLmRvYy5zY3JvbGxUb3ApO1xyXG4gICAgICB1cGRhdGVHdXR0ZXJTcGFjZSh0aGlzKTtcclxuICAgICAgaWYgKG9sZEhlaWdodCA9PSBudWxsIHx8IE1hdGguYWJzKG9sZEhlaWdodCAtIHRleHRIZWlnaHQodGhpcy5kaXNwbGF5KSkgPiAuNSlcclxuICAgICAgICBlc3RpbWF0ZUxpbmVIZWlnaHRzKHRoaXMpO1xyXG4gICAgICBzaWduYWwodGhpcywgXCJyZWZyZXNoXCIsIHRoaXMpO1xyXG4gICAgfSksXHJcblxyXG4gICAgc3dhcERvYzogbWV0aG9kT3AoZnVuY3Rpb24oZG9jKSB7XHJcbiAgICAgIHZhciBvbGQgPSB0aGlzLmRvYztcclxuICAgICAgb2xkLmNtID0gbnVsbDtcclxuICAgICAgYXR0YWNoRG9jKHRoaXMsIGRvYyk7XHJcbiAgICAgIGNsZWFyQ2FjaGVzKHRoaXMpO1xyXG4gICAgICB0aGlzLmRpc3BsYXkuaW5wdXQucmVzZXQoKTtcclxuICAgICAgdGhpcy5zY3JvbGxUbyhkb2Muc2Nyb2xsTGVmdCwgZG9jLnNjcm9sbFRvcCk7XHJcbiAgICAgIHRoaXMuY3VyT3AuZm9yY2VTY3JvbGwgPSB0cnVlO1xyXG4gICAgICBzaWduYWxMYXRlcih0aGlzLCBcInN3YXBEb2NcIiwgdGhpcywgb2xkKTtcclxuICAgICAgcmV0dXJuIG9sZDtcclxuICAgIH0pLFxyXG5cclxuICAgIGdldElucHV0RmllbGQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpO30sXHJcbiAgICBnZXRXcmFwcGVyRWxlbWVudDogZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5LndyYXBwZXI7fSxcclxuICAgIGdldFNjcm9sbGVyRWxlbWVudDogZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5LnNjcm9sbGVyO30sXHJcbiAgICBnZXRHdXR0ZXJFbGVtZW50OiBmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkuZ3V0dGVyczt9XHJcbiAgfTtcclxuICBldmVudE1peGluKENvZGVNaXJyb3IpO1xyXG5cclxuICAvLyBPUFRJT04gREVGQVVMVFNcclxuXHJcbiAgLy8gVGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBvcHRpb25zLlxyXG4gIHZhciBkZWZhdWx0cyA9IENvZGVNaXJyb3IuZGVmYXVsdHMgPSB7fTtcclxuICAvLyBGdW5jdGlvbnMgdG8gcnVuIHdoZW4gb3B0aW9ucyBhcmUgY2hhbmdlZC5cclxuICB2YXIgb3B0aW9uSGFuZGxlcnMgPSBDb2RlTWlycm9yLm9wdGlvbkhhbmRsZXJzID0ge307XHJcblxyXG4gIGZ1bmN0aW9uIG9wdGlvbihuYW1lLCBkZWZsdCwgaGFuZGxlLCBub3RPbkluaXQpIHtcclxuICAgIENvZGVNaXJyb3IuZGVmYXVsdHNbbmFtZV0gPSBkZWZsdDtcclxuICAgIGlmIChoYW5kbGUpIG9wdGlvbkhhbmRsZXJzW25hbWVdID1cclxuICAgICAgbm90T25Jbml0ID8gZnVuY3Rpb24oY20sIHZhbCwgb2xkKSB7aWYgKG9sZCAhPSBJbml0KSBoYW5kbGUoY20sIHZhbCwgb2xkKTt9IDogaGFuZGxlO1xyXG4gIH1cclxuXHJcbiAgLy8gUGFzc2VkIHRvIG9wdGlvbiBoYW5kbGVycyB3aGVuIHRoZXJlIGlzIG5vIG9sZCB2YWx1ZS5cclxuICB2YXIgSW5pdCA9IENvZGVNaXJyb3IuSW5pdCA9IHt0b1N0cmluZzogZnVuY3Rpb24oKXtyZXR1cm4gXCJDb2RlTWlycm9yLkluaXRcIjt9fTtcclxuXHJcbiAgLy8gVGhlc2UgdHdvIGFyZSwgb24gaW5pdCwgY2FsbGVkIGZyb20gdGhlIGNvbnN0cnVjdG9yIGJlY2F1c2UgdGhleVxyXG4gIC8vIGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQgYmVmb3JlIHRoZSBlZGl0b3IgY2FuIHN0YXJ0IGF0IGFsbC5cclxuICBvcHRpb24oXCJ2YWx1ZVwiLCBcIlwiLCBmdW5jdGlvbihjbSwgdmFsKSB7XHJcbiAgICBjbS5zZXRWYWx1ZSh2YWwpO1xyXG4gIH0sIHRydWUpO1xyXG4gIG9wdGlvbihcIm1vZGVcIiwgbnVsbCwgZnVuY3Rpb24oY20sIHZhbCkge1xyXG4gICAgY20uZG9jLm1vZGVPcHRpb24gPSB2YWw7XHJcbiAgICBsb2FkTW9kZShjbSk7XHJcbiAgfSwgdHJ1ZSk7XHJcblxyXG4gIG9wdGlvbihcImluZGVudFVuaXRcIiwgMiwgbG9hZE1vZGUsIHRydWUpO1xyXG4gIG9wdGlvbihcImluZGVudFdpdGhUYWJzXCIsIGZhbHNlKTtcclxuICBvcHRpb24oXCJzbWFydEluZGVudFwiLCB0cnVlKTtcclxuICBvcHRpb24oXCJ0YWJTaXplXCIsIDQsIGZ1bmN0aW9uKGNtKSB7XHJcbiAgICByZXNldE1vZGVTdGF0ZShjbSk7XHJcbiAgICBjbGVhckNhY2hlcyhjbSk7XHJcbiAgICByZWdDaGFuZ2UoY20pO1xyXG4gIH0sIHRydWUpO1xyXG4gIG9wdGlvbihcInNwZWNpYWxDaGFyc1wiLCAvW1xcdFxcdTAwMDAtXFx1MDAxOVxcdTAwYWRcXHUyMDBiLVxcdTIwMGZcXHUyMDI4XFx1MjAyOVxcdWZlZmZdL2csIGZ1bmN0aW9uKGNtLCB2YWwsIG9sZCkge1xyXG4gICAgY20uc3RhdGUuc3BlY2lhbENoYXJzID0gbmV3IFJlZ0V4cCh2YWwuc291cmNlICsgKHZhbC50ZXN0KFwiXFx0XCIpID8gXCJcIiA6IFwifFxcdFwiKSwgXCJnXCIpO1xyXG4gICAgaWYgKG9sZCAhPSBDb2RlTWlycm9yLkluaXQpIGNtLnJlZnJlc2goKTtcclxuICB9KTtcclxuICBvcHRpb24oXCJzcGVjaWFsQ2hhclBsYWNlaG9sZGVyXCIsIGRlZmF1bHRTcGVjaWFsQ2hhclBsYWNlaG9sZGVyLCBmdW5jdGlvbihjbSkge2NtLnJlZnJlc2goKTt9LCB0cnVlKTtcclxuICBvcHRpb24oXCJlbGVjdHJpY0NoYXJzXCIsIHRydWUpO1xyXG4gIG9wdGlvbihcImlucHV0U3R5bGVcIiwgbW9iaWxlID8gXCJjb250ZW50ZWRpdGFibGVcIiA6IFwidGV4dGFyZWFcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dFN0eWxlIGNhbiBub3QgKHlldCkgYmUgY2hhbmdlZCBpbiBhIHJ1bm5pbmcgZWRpdG9yXCIpOyAvLyBGSVhNRVxyXG4gIH0sIHRydWUpO1xyXG4gIG9wdGlvbihcInJ0bE1vdmVWaXN1YWxseVwiLCAhd2luZG93cyk7XHJcbiAgb3B0aW9uKFwid2hvbGVMaW5lVXBkYXRlQmVmb3JlXCIsIHRydWUpO1xyXG5cclxuICBvcHRpb24oXCJ0aGVtZVwiLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oY20pIHtcclxuICAgIHRoZW1lQ2hhbmdlZChjbSk7XHJcbiAgICBndXR0ZXJzQ2hhbmdlZChjbSk7XHJcbiAgfSwgdHJ1ZSk7XHJcbiAgb3B0aW9uKFwia2V5TWFwXCIsIFwiZGVmYXVsdFwiLCBmdW5jdGlvbihjbSwgdmFsLCBvbGQpIHtcclxuICAgIHZhciBuZXh0ID0gZ2V0S2V5TWFwKHZhbCk7XHJcbiAgICB2YXIgcHJldiA9IG9sZCAhPSBDb2RlTWlycm9yLkluaXQgJiYgZ2V0S2V5TWFwKG9sZCk7XHJcbiAgICBpZiAocHJldiAmJiBwcmV2LmRldGFjaCkgcHJldi5kZXRhY2goY20sIG5leHQpO1xyXG4gICAgaWYgKG5leHQuYXR0YWNoKSBuZXh0LmF0dGFjaChjbSwgcHJldiB8fCBudWxsKTtcclxuICB9KTtcclxuICBvcHRpb24oXCJleHRyYUtleXNcIiwgbnVsbCk7XHJcblxyXG4gIG9wdGlvbihcImxpbmVXcmFwcGluZ1wiLCBmYWxzZSwgd3JhcHBpbmdDaGFuZ2VkLCB0cnVlKTtcclxuICBvcHRpb24oXCJndXR0ZXJzXCIsIFtdLCBmdW5jdGlvbihjbSkge1xyXG4gICAgc2V0R3V0dGVyc0ZvckxpbmVOdW1iZXJzKGNtLm9wdGlvbnMpO1xyXG4gICAgZ3V0dGVyc0NoYW5nZWQoY20pO1xyXG4gIH0sIHRydWUpO1xyXG4gIG9wdGlvbihcImZpeGVkR3V0dGVyXCIsIHRydWUsIGZ1bmN0aW9uKGNtLCB2YWwpIHtcclxuICAgIGNtLmRpc3BsYXkuZ3V0dGVycy5zdHlsZS5sZWZ0ID0gdmFsID8gY29tcGVuc2F0ZUZvckhTY3JvbGwoY20uZGlzcGxheSkgKyBcInB4XCIgOiBcIjBcIjtcclxuICAgIGNtLnJlZnJlc2goKTtcclxuICB9LCB0cnVlKTtcclxuICBvcHRpb24oXCJjb3Zlckd1dHRlck5leHRUb1Njcm9sbGJhclwiLCBmYWxzZSwgZnVuY3Rpb24oY20pIHt1cGRhdGVTY3JvbGxiYXJzKGNtKTt9LCB0cnVlKTtcclxuICBvcHRpb24oXCJzY3JvbGxiYXJTdHlsZVwiLCBcIm5hdGl2ZVwiLCBmdW5jdGlvbihjbSkge1xyXG4gICAgaW5pdFNjcm9sbGJhcnMoY20pO1xyXG4gICAgdXBkYXRlU2Nyb2xsYmFycyhjbSk7XHJcbiAgICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsVG9wKGNtLmRvYy5zY3JvbGxUb3ApO1xyXG4gICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbExlZnQoY20uZG9jLnNjcm9sbExlZnQpO1xyXG4gIH0sIHRydWUpO1xyXG4gIG9wdGlvbihcImxpbmVOdW1iZXJzXCIsIGZhbHNlLCBmdW5jdGlvbihjbSkge1xyXG4gICAgc2V0R3V0dGVyc0ZvckxpbmVOdW1iZXJzKGNtLm9wdGlvbnMpO1xyXG4gICAgZ3V0dGVyc0NoYW5nZWQoY20pO1xyXG4gIH0sIHRydWUpO1xyXG4gIG9wdGlvbihcImZpcnN0TGluZU51bWJlclwiLCAxLCBndXR0ZXJzQ2hhbmdlZCwgdHJ1ZSk7XHJcbiAgb3B0aW9uKFwibGluZU51bWJlckZvcm1hdHRlclwiLCBmdW5jdGlvbihpbnRlZ2VyKSB7cmV0dXJuIGludGVnZXI7fSwgZ3V0dGVyc0NoYW5nZWQsIHRydWUpO1xyXG4gIG9wdGlvbihcInNob3dDdXJzb3JXaGVuU2VsZWN0aW5nXCIsIGZhbHNlLCB1cGRhdGVTZWxlY3Rpb24sIHRydWUpO1xyXG5cclxuICBvcHRpb24oXCJyZXNldFNlbGVjdGlvbk9uQ29udGV4dE1lbnVcIiwgdHJ1ZSk7XHJcblxyXG4gIG9wdGlvbihcInJlYWRPbmx5XCIsIGZhbHNlLCBmdW5jdGlvbihjbSwgdmFsKSB7XHJcbiAgICBpZiAodmFsID09IFwibm9jdXJzb3JcIikge1xyXG4gICAgICBvbkJsdXIoY20pO1xyXG4gICAgICBjbS5kaXNwbGF5LmlucHV0LmJsdXIoKTtcclxuICAgICAgY20uZGlzcGxheS5kaXNhYmxlZCA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjbS5kaXNwbGF5LmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgIGlmICghdmFsKSBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgb3B0aW9uKFwiZGlzYWJsZUlucHV0XCIsIGZhbHNlLCBmdW5jdGlvbihjbSwgdmFsKSB7aWYgKCF2YWwpIGNtLmRpc3BsYXkuaW5wdXQucmVzZXQoKTt9LCB0cnVlKTtcclxuICBvcHRpb24oXCJkcmFnRHJvcFwiLCB0cnVlKTtcclxuXHJcbiAgb3B0aW9uKFwiY3Vyc29yQmxpbmtSYXRlXCIsIDUzMCk7XHJcbiAgb3B0aW9uKFwiY3Vyc29yU2Nyb2xsTWFyZ2luXCIsIDApO1xyXG4gIG9wdGlvbihcImN1cnNvckhlaWdodFwiLCAxLCB1cGRhdGVTZWxlY3Rpb24sIHRydWUpO1xyXG4gIG9wdGlvbihcInNpbmdsZUN1cnNvckhlaWdodFBlckxpbmVcIiwgdHJ1ZSwgdXBkYXRlU2VsZWN0aW9uLCB0cnVlKTtcclxuICBvcHRpb24oXCJ3b3JrVGltZVwiLCAxMDApO1xyXG4gIG9wdGlvbihcIndvcmtEZWxheVwiLCAxMDApO1xyXG4gIG9wdGlvbihcImZsYXR0ZW5TcGFuc1wiLCB0cnVlLCByZXNldE1vZGVTdGF0ZSwgdHJ1ZSk7XHJcbiAgb3B0aW9uKFwiYWRkTW9kZUNsYXNzXCIsIGZhbHNlLCByZXNldE1vZGVTdGF0ZSwgdHJ1ZSk7XHJcbiAgb3B0aW9uKFwicG9sbEludGVydmFsXCIsIDEwMCk7XHJcbiAgb3B0aW9uKFwidW5kb0RlcHRoXCIsIDIwMCwgZnVuY3Rpb24oY20sIHZhbCl7Y20uZG9jLmhpc3RvcnkudW5kb0RlcHRoID0gdmFsO30pO1xyXG4gIG9wdGlvbihcImhpc3RvcnlFdmVudERlbGF5XCIsIDEyNTApO1xyXG4gIG9wdGlvbihcInZpZXdwb3J0TWFyZ2luXCIsIDEwLCBmdW5jdGlvbihjbSl7Y20ucmVmcmVzaCgpO30sIHRydWUpO1xyXG4gIG9wdGlvbihcIm1heEhpZ2hsaWdodExlbmd0aFwiLCAxMDAwMCwgcmVzZXRNb2RlU3RhdGUsIHRydWUpO1xyXG4gIG9wdGlvbihcIm1vdmVJbnB1dFdpdGhDdXJzb3JcIiwgdHJ1ZSwgZnVuY3Rpb24oY20sIHZhbCkge1xyXG4gICAgaWYgKCF2YWwpIGNtLmRpc3BsYXkuaW5wdXQucmVzZXRQb3NpdGlvbigpO1xyXG4gIH0pO1xyXG5cclxuICBvcHRpb24oXCJ0YWJpbmRleFwiLCBudWxsLCBmdW5jdGlvbihjbSwgdmFsKSB7XHJcbiAgICBjbS5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCkudGFiSW5kZXggPSB2YWwgfHwgXCJcIjtcclxuICB9KTtcclxuICBvcHRpb24oXCJhdXRvZm9jdXNcIiwgbnVsbCk7XHJcblxyXG4gIC8vIE1PREUgREVGSU5JVElPTiBBTkQgUVVFUllJTkdcclxuXHJcbiAgLy8gS25vd24gbW9kZXMsIGJ5IG5hbWUgYW5kIGJ5IE1JTUVcclxuICB2YXIgbW9kZXMgPSBDb2RlTWlycm9yLm1vZGVzID0ge30sIG1pbWVNb2RlcyA9IENvZGVNaXJyb3IubWltZU1vZGVzID0ge307XHJcblxyXG4gIC8vIEV4dHJhIGFyZ3VtZW50cyBhcmUgc3RvcmVkIGFzIHRoZSBtb2RlJ3MgZGVwZW5kZW5jaWVzLCB3aGljaCBpc1xyXG4gIC8vIHVzZWQgYnkgKGxlZ2FjeSkgbWVjaGFuaXNtcyBsaWtlIGxvYWRtb2RlLmpzIHRvIGF1dG9tYXRpY2FsbHlcclxuICAvLyBsb2FkIGEgbW9kZS4gKFByZWZlcnJlZCBtZWNoYW5pc20gaXMgdGhlIHJlcXVpcmUvZGVmaW5lIGNhbGxzLilcclxuICBDb2RlTWlycm9yLmRlZmluZU1vZGUgPSBmdW5jdGlvbihuYW1lLCBtb2RlKSB7XHJcbiAgICBpZiAoIUNvZGVNaXJyb3IuZGVmYXVsdHMubW9kZSAmJiBuYW1lICE9IFwibnVsbFwiKSBDb2RlTWlycm9yLmRlZmF1bHRzLm1vZGUgPSBuYW1lO1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKVxyXG4gICAgICBtb2RlLmRlcGVuZGVuY2llcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcbiAgICBtb2Rlc1tuYW1lXSA9IG1vZGU7XHJcbiAgfTtcclxuXHJcbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FID0gZnVuY3Rpb24obWltZSwgc3BlYykge1xyXG4gICAgbWltZU1vZGVzW21pbWVdID0gc3BlYztcclxuICB9O1xyXG5cclxuICAvLyBHaXZlbiBhIE1JTUUgdHlwZSwgYSB7bmFtZSwgLi4ub3B0aW9uc30gY29uZmlnIG9iamVjdCwgb3IgYSBuYW1lXHJcbiAgLy8gc3RyaW5nLCByZXR1cm4gYSBtb2RlIGNvbmZpZyBvYmplY3QuXHJcbiAgQ29kZU1pcnJvci5yZXNvbHZlTW9kZSA9IGZ1bmN0aW9uKHNwZWMpIHtcclxuICAgIGlmICh0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiICYmIG1pbWVNb2Rlcy5oYXNPd25Qcm9wZXJ0eShzcGVjKSkge1xyXG4gICAgICBzcGVjID0gbWltZU1vZGVzW3NwZWNdO1xyXG4gICAgfSBlbHNlIGlmIChzcGVjICYmIHR5cGVvZiBzcGVjLm5hbWUgPT0gXCJzdHJpbmdcIiAmJiBtaW1lTW9kZXMuaGFzT3duUHJvcGVydHkoc3BlYy5uYW1lKSkge1xyXG4gICAgICB2YXIgZm91bmQgPSBtaW1lTW9kZXNbc3BlYy5uYW1lXTtcclxuICAgICAgaWYgKHR5cGVvZiBmb3VuZCA9PSBcInN0cmluZ1wiKSBmb3VuZCA9IHtuYW1lOiBmb3VuZH07XHJcbiAgICAgIHNwZWMgPSBjcmVhdGVPYmooZm91bmQsIHNwZWMpO1xyXG4gICAgICBzcGVjLm5hbWUgPSBmb3VuZC5uYW1lO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiICYmIC9eW1xcd1xcLV0rXFwvW1xcd1xcLV0rXFwreG1sJC8udGVzdChzcGVjKSkge1xyXG4gICAgICByZXR1cm4gQ29kZU1pcnJvci5yZXNvbHZlTW9kZShcImFwcGxpY2F0aW9uL3htbFwiKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiKSByZXR1cm4ge25hbWU6IHNwZWN9O1xyXG4gICAgZWxzZSByZXR1cm4gc3BlYyB8fCB7bmFtZTogXCJudWxsXCJ9O1xyXG4gIH07XHJcblxyXG4gIC8vIEdpdmVuIGEgbW9kZSBzcGVjIChhbnl0aGluZyB0aGF0IHJlc29sdmVNb2RlIGFjY2VwdHMpLCBmaW5kIGFuZFxyXG4gIC8vIGluaXRpYWxpemUgYW4gYWN0dWFsIG1vZGUgb2JqZWN0LlxyXG4gIENvZGVNaXJyb3IuZ2V0TW9kZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIHNwZWMpIHtcclxuICAgIHZhciBzcGVjID0gQ29kZU1pcnJvci5yZXNvbHZlTW9kZShzcGVjKTtcclxuICAgIHZhciBtZmFjdG9yeSA9IG1vZGVzW3NwZWMubmFtZV07XHJcbiAgICBpZiAoIW1mYWN0b3J5KSByZXR1cm4gQ29kZU1pcnJvci5nZXRNb2RlKG9wdGlvbnMsIFwidGV4dC9wbGFpblwiKTtcclxuICAgIHZhciBtb2RlT2JqID0gbWZhY3Rvcnkob3B0aW9ucywgc3BlYyk7XHJcbiAgICBpZiAobW9kZUV4dGVuc2lvbnMuaGFzT3duUHJvcGVydHkoc3BlYy5uYW1lKSkge1xyXG4gICAgICB2YXIgZXh0cyA9IG1vZGVFeHRlbnNpb25zW3NwZWMubmFtZV07XHJcbiAgICAgIGZvciAodmFyIHByb3AgaW4gZXh0cykge1xyXG4gICAgICAgIGlmICghZXh0cy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgY29udGludWU7XHJcbiAgICAgICAgaWYgKG1vZGVPYmouaGFzT3duUHJvcGVydHkocHJvcCkpIG1vZGVPYmpbXCJfXCIgKyBwcm9wXSA9IG1vZGVPYmpbcHJvcF07XHJcbiAgICAgICAgbW9kZU9ialtwcm9wXSA9IGV4dHNbcHJvcF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIG1vZGVPYmoubmFtZSA9IHNwZWMubmFtZTtcclxuICAgIGlmIChzcGVjLmhlbHBlclR5cGUpIG1vZGVPYmouaGVscGVyVHlwZSA9IHNwZWMuaGVscGVyVHlwZTtcclxuICAgIGlmIChzcGVjLm1vZGVQcm9wcykgZm9yICh2YXIgcHJvcCBpbiBzcGVjLm1vZGVQcm9wcylcclxuICAgICAgbW9kZU9ialtwcm9wXSA9IHNwZWMubW9kZVByb3BzW3Byb3BdO1xyXG5cclxuICAgIHJldHVybiBtb2RlT2JqO1xyXG4gIH07XHJcblxyXG4gIC8vIE1pbmltYWwgZGVmYXVsdCBtb2RlLlxyXG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZShcIm51bGxcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge3Rva2VuOiBmdW5jdGlvbihzdHJlYW0pIHtzdHJlYW0uc2tpcFRvRW5kKCk7fX07XHJcbiAgfSk7XHJcbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC9wbGFpblwiLCBcIm51bGxcIik7XHJcblxyXG4gIC8vIFRoaXMgY2FuIGJlIHVzZWQgdG8gYXR0YWNoIHByb3BlcnRpZXMgdG8gbW9kZSBvYmplY3RzIGZyb21cclxuICAvLyBvdXRzaWRlIHRoZSBhY3R1YWwgbW9kZSBkZWZpbml0aW9uLlxyXG4gIHZhciBtb2RlRXh0ZW5zaW9ucyA9IENvZGVNaXJyb3IubW9kZUV4dGVuc2lvbnMgPSB7fTtcclxuICBDb2RlTWlycm9yLmV4dGVuZE1vZGUgPSBmdW5jdGlvbihtb2RlLCBwcm9wZXJ0aWVzKSB7XHJcbiAgICB2YXIgZXh0cyA9IG1vZGVFeHRlbnNpb25zLmhhc093blByb3BlcnR5KG1vZGUpID8gbW9kZUV4dGVuc2lvbnNbbW9kZV0gOiAobW9kZUV4dGVuc2lvbnNbbW9kZV0gPSB7fSk7XHJcbiAgICBjb3B5T2JqKHByb3BlcnRpZXMsIGV4dHMpO1xyXG4gIH07XHJcblxyXG4gIC8vIEVYVEVOU0lPTlNcclxuXHJcbiAgQ29kZU1pcnJvci5kZWZpbmVFeHRlbnNpb24gPSBmdW5jdGlvbihuYW1lLCBmdW5jKSB7XHJcbiAgICBDb2RlTWlycm9yLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmM7XHJcbiAgfTtcclxuICBDb2RlTWlycm9yLmRlZmluZURvY0V4dGVuc2lvbiA9IGZ1bmN0aW9uKG5hbWUsIGZ1bmMpIHtcclxuICAgIERvYy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jO1xyXG4gIH07XHJcbiAgQ29kZU1pcnJvci5kZWZpbmVPcHRpb24gPSBvcHRpb247XHJcblxyXG4gIHZhciBpbml0SG9va3MgPSBbXTtcclxuICBDb2RlTWlycm9yLmRlZmluZUluaXRIb29rID0gZnVuY3Rpb24oZikge2luaXRIb29rcy5wdXNoKGYpO307XHJcblxyXG4gIHZhciBoZWxwZXJzID0gQ29kZU1pcnJvci5oZWxwZXJzID0ge307XHJcbiAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlciA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHZhbHVlKSB7XHJcbiAgICBpZiAoIWhlbHBlcnMuaGFzT3duUHJvcGVydHkodHlwZSkpIGhlbHBlcnNbdHlwZV0gPSBDb2RlTWlycm9yW3R5cGVdID0ge19nbG9iYWw6IFtdfTtcclxuICAgIGhlbHBlcnNbdHlwZV1bbmFtZV0gPSB2YWx1ZTtcclxuICB9O1xyXG4gIENvZGVNaXJyb3IucmVnaXN0ZXJHbG9iYWxIZWxwZXIgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBwcmVkaWNhdGUsIHZhbHVlKSB7XHJcbiAgICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyKHR5cGUsIG5hbWUsIHZhbHVlKTtcclxuICAgIGhlbHBlcnNbdHlwZV0uX2dsb2JhbC5wdXNoKHtwcmVkOiBwcmVkaWNhdGUsIHZhbDogdmFsdWV9KTtcclxuICB9O1xyXG5cclxuICAvLyBNT0RFIFNUQVRFIEhBTkRMSU5HXHJcblxyXG4gIC8vIFV0aWxpdHkgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggc3RhdGUuIEV4cG9ydGVkIGJlY2F1c2UgbmVzdGVkXHJcbiAgLy8gbW9kZXMgbmVlZCB0byBkbyB0aGlzIGZvciB0aGVpciBpbm5lciBtb2Rlcy5cclxuXHJcbiAgdmFyIGNvcHlTdGF0ZSA9IENvZGVNaXJyb3IuY29weVN0YXRlID0gZnVuY3Rpb24obW9kZSwgc3RhdGUpIHtcclxuICAgIGlmIChzdGF0ZSA9PT0gdHJ1ZSkgcmV0dXJuIHN0YXRlO1xyXG4gICAgaWYgKG1vZGUuY29weVN0YXRlKSByZXR1cm4gbW9kZS5jb3B5U3RhdGUoc3RhdGUpO1xyXG4gICAgdmFyIG5zdGF0ZSA9IHt9O1xyXG4gICAgZm9yICh2YXIgbiBpbiBzdGF0ZSkge1xyXG4gICAgICB2YXIgdmFsID0gc3RhdGVbbl07XHJcbiAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheSkgdmFsID0gdmFsLmNvbmNhdChbXSk7XHJcbiAgICAgIG5zdGF0ZVtuXSA9IHZhbDtcclxuICAgIH1cclxuICAgIHJldHVybiBuc3RhdGU7XHJcbiAgfTtcclxuXHJcbiAgdmFyIHN0YXJ0U3RhdGUgPSBDb2RlTWlycm9yLnN0YXJ0U3RhdGUgPSBmdW5jdGlvbihtb2RlLCBhMSwgYTIpIHtcclxuICAgIHJldHVybiBtb2RlLnN0YXJ0U3RhdGUgPyBtb2RlLnN0YXJ0U3RhdGUoYTEsIGEyKSA6IHRydWU7XHJcbiAgfTtcclxuXHJcbiAgLy8gR2l2ZW4gYSBtb2RlIGFuZCBhIHN0YXRlIChmb3IgdGhhdCBtb2RlKSwgZmluZCB0aGUgaW5uZXIgbW9kZSBhbmRcclxuICAvLyBzdGF0ZSBhdCB0aGUgcG9zaXRpb24gdGhhdCB0aGUgc3RhdGUgcmVmZXJzIHRvLlxyXG4gIENvZGVNaXJyb3IuaW5uZXJNb2RlID0gZnVuY3Rpb24obW9kZSwgc3RhdGUpIHtcclxuICAgIHdoaWxlIChtb2RlLmlubmVyTW9kZSkge1xyXG4gICAgICB2YXIgaW5mbyA9IG1vZGUuaW5uZXJNb2RlKHN0YXRlKTtcclxuICAgICAgaWYgKCFpbmZvIHx8IGluZm8ubW9kZSA9PSBtb2RlKSBicmVhaztcclxuICAgICAgc3RhdGUgPSBpbmZvLnN0YXRlO1xyXG4gICAgICBtb2RlID0gaW5mby5tb2RlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGluZm8gfHwge21vZGU6IG1vZGUsIHN0YXRlOiBzdGF0ZX07XHJcbiAgfTtcclxuXHJcbiAgLy8gU1RBTkRBUkQgQ09NTUFORFNcclxuXHJcbiAgLy8gQ29tbWFuZHMgYXJlIHBhcmFtZXRlci1sZXNzIGFjdGlvbnMgdGhhdCBjYW4gYmUgcGVyZm9ybWVkIG9uIGFuXHJcbiAgLy8gZWRpdG9yLCBtb3N0bHkgdXNlZCBmb3Iga2V5YmluZGluZ3MuXHJcbiAgdmFyIGNvbW1hbmRzID0gQ29kZU1pcnJvci5jb21tYW5kcyA9IHtcclxuICAgIHNlbGVjdEFsbDogZnVuY3Rpb24oY20pIHtjbS5zZXRTZWxlY3Rpb24oUG9zKGNtLmZpcnN0TGluZSgpLCAwKSwgUG9zKGNtLmxhc3RMaW5lKCkpLCBzZWxfZG9udFNjcm9sbCk7fSxcclxuICAgIHNpbmdsZVNlbGVjdGlvbjogZnVuY3Rpb24oY20pIHtcclxuICAgICAgY20uc2V0U2VsZWN0aW9uKGNtLmdldEN1cnNvcihcImFuY2hvclwiKSwgY20uZ2V0Q3Vyc29yKFwiaGVhZFwiKSwgc2VsX2RvbnRTY3JvbGwpO1xyXG4gICAgfSxcclxuICAgIGtpbGxMaW5lOiBmdW5jdGlvbihjbSkge1xyXG4gICAgICBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbihyYW5nZSkge1xyXG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSgpKSB7XHJcbiAgICAgICAgICB2YXIgbGVuID0gZ2V0TGluZShjbS5kb2MsIHJhbmdlLmhlYWQubGluZSkudGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICBpZiAocmFuZ2UuaGVhZC5jaCA9PSBsZW4gJiYgcmFuZ2UuaGVhZC5saW5lIDwgY20ubGFzdExpbmUoKSlcclxuICAgICAgICAgICAgcmV0dXJuIHtmcm9tOiByYW5nZS5oZWFkLCB0bzogUG9zKHJhbmdlLmhlYWQubGluZSArIDEsIDApfTtcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIHtmcm9tOiByYW5nZS5oZWFkLCB0bzogUG9zKHJhbmdlLmhlYWQubGluZSwgbGVuKX07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiB7ZnJvbTogcmFuZ2UuZnJvbSgpLCB0bzogcmFuZ2UudG8oKX07XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBkZWxldGVMaW5lOiBmdW5jdGlvbihjbSkge1xyXG4gICAgICBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbihyYW5nZSkge1xyXG4gICAgICAgIHJldHVybiB7ZnJvbTogUG9zKHJhbmdlLmZyb20oKS5saW5lLCAwKSxcclxuICAgICAgICAgICAgICAgIHRvOiBjbGlwUG9zKGNtLmRvYywgUG9zKHJhbmdlLnRvKCkubGluZSArIDEsIDApKX07XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGRlbExpbmVMZWZ0OiBmdW5jdGlvbihjbSkge1xyXG4gICAgICBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbihyYW5nZSkge1xyXG4gICAgICAgIHJldHVybiB7ZnJvbTogUG9zKHJhbmdlLmZyb20oKS5saW5lLCAwKSwgdG86IHJhbmdlLmZyb20oKX07XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGRlbFdyYXBwZWRMaW5lTGVmdDogZnVuY3Rpb24oY20pIHtcclxuICAgICAgZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24ocmFuZ2UpIHtcclxuICAgICAgICB2YXIgdG9wID0gY20uY2hhckNvb3JkcyhyYW5nZS5oZWFkLCBcImRpdlwiKS50b3AgKyA1O1xyXG4gICAgICAgIHZhciBsZWZ0UG9zID0gY20uY29vcmRzQ2hhcih7bGVmdDogMCwgdG9wOiB0b3B9LCBcImRpdlwiKTtcclxuICAgICAgICByZXR1cm4ge2Zyb206IGxlZnRQb3MsIHRvOiByYW5nZS5mcm9tKCl9O1xyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBkZWxXcmFwcGVkTGluZVJpZ2h0OiBmdW5jdGlvbihjbSkge1xyXG4gICAgICBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbihyYW5nZSkge1xyXG4gICAgICAgIHZhciB0b3AgPSBjbS5jaGFyQ29vcmRzKHJhbmdlLmhlYWQsIFwiZGl2XCIpLnRvcCArIDU7XHJcbiAgICAgICAgdmFyIHJpZ2h0UG9zID0gY20uY29vcmRzQ2hhcih7bGVmdDogY20uZGlzcGxheS5saW5lRGl2Lm9mZnNldFdpZHRoICsgMTAwLCB0b3A6IHRvcH0sIFwiZGl2XCIpO1xyXG4gICAgICAgIHJldHVybiB7ZnJvbTogcmFuZ2UuZnJvbSgpLCB0bzogcmlnaHRQb3MgfTtcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgdW5kbzogZnVuY3Rpb24oY20pIHtjbS51bmRvKCk7fSxcclxuICAgIHJlZG86IGZ1bmN0aW9uKGNtKSB7Y20ucmVkbygpO30sXHJcbiAgICB1bmRvU2VsZWN0aW9uOiBmdW5jdGlvbihjbSkge2NtLnVuZG9TZWxlY3Rpb24oKTt9LFxyXG4gICAgcmVkb1NlbGVjdGlvbjogZnVuY3Rpb24oY20pIHtjbS5yZWRvU2VsZWN0aW9uKCk7fSxcclxuICAgIGdvRG9jU3RhcnQ6IGZ1bmN0aW9uKGNtKSB7Y20uZXh0ZW5kU2VsZWN0aW9uKFBvcyhjbS5maXJzdExpbmUoKSwgMCkpO30sXHJcbiAgICBnb0RvY0VuZDogZnVuY3Rpb24oY20pIHtjbS5leHRlbmRTZWxlY3Rpb24oUG9zKGNtLmxhc3RMaW5lKCkpKTt9LFxyXG4gICAgZ29MaW5lU3RhcnQ6IGZ1bmN0aW9uKGNtKSB7XHJcbiAgICAgIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbihyYW5nZSkgeyByZXR1cm4gbGluZVN0YXJ0KGNtLCByYW5nZS5oZWFkLmxpbmUpOyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge29yaWdpbjogXCIrbW92ZVwiLCBiaWFzOiAxfSk7XHJcbiAgICB9LFxyXG4gICAgZ29MaW5lU3RhcnRTbWFydDogZnVuY3Rpb24oY20pIHtcclxuICAgICAgY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKHJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIGxpbmVTdGFydFNtYXJ0KGNtLCByYW5nZS5oZWFkKTtcclxuICAgICAgfSwge29yaWdpbjogXCIrbW92ZVwiLCBiaWFzOiAxfSk7XHJcbiAgICB9LFxyXG4gICAgZ29MaW5lRW5kOiBmdW5jdGlvbihjbSkge1xyXG4gICAgICBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24ocmFuZ2UpIHsgcmV0dXJuIGxpbmVFbmQoY20sIHJhbmdlLmhlYWQubGluZSk7IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7b3JpZ2luOiBcIittb3ZlXCIsIGJpYXM6IC0xfSk7XHJcbiAgICB9LFxyXG4gICAgZ29MaW5lUmlnaHQ6IGZ1bmN0aW9uKGNtKSB7XHJcbiAgICAgIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbihyYW5nZSkge1xyXG4gICAgICAgIHZhciB0b3AgPSBjbS5jaGFyQ29vcmRzKHJhbmdlLmhlYWQsIFwiZGl2XCIpLnRvcCArIDU7XHJcbiAgICAgICAgcmV0dXJuIGNtLmNvb3Jkc0NoYXIoe2xlZnQ6IGNtLmRpc3BsYXkubGluZURpdi5vZmZzZXRXaWR0aCArIDEwMCwgdG9wOiB0b3B9LCBcImRpdlwiKTtcclxuICAgICAgfSwgc2VsX21vdmUpO1xyXG4gICAgfSxcclxuICAgIGdvTGluZUxlZnQ6IGZ1bmN0aW9uKGNtKSB7XHJcbiAgICAgIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbihyYW5nZSkge1xyXG4gICAgICAgIHZhciB0b3AgPSBjbS5jaGFyQ29vcmRzKHJhbmdlLmhlYWQsIFwiZGl2XCIpLnRvcCArIDU7XHJcbiAgICAgICAgcmV0dXJuIGNtLmNvb3Jkc0NoYXIoe2xlZnQ6IDAsIHRvcDogdG9wfSwgXCJkaXZcIik7XHJcbiAgICAgIH0sIHNlbF9tb3ZlKTtcclxuICAgIH0sXHJcbiAgICBnb0xpbmVMZWZ0U21hcnQ6IGZ1bmN0aW9uKGNtKSB7XHJcbiAgICAgIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbihyYW5nZSkge1xyXG4gICAgICAgIHZhciB0b3AgPSBjbS5jaGFyQ29vcmRzKHJhbmdlLmhlYWQsIFwiZGl2XCIpLnRvcCArIDU7XHJcbiAgICAgICAgdmFyIHBvcyA9IGNtLmNvb3Jkc0NoYXIoe2xlZnQ6IDAsIHRvcDogdG9wfSwgXCJkaXZcIik7XHJcbiAgICAgICAgaWYgKHBvcy5jaCA8IGNtLmdldExpbmUocG9zLmxpbmUpLnNlYXJjaCgvXFxTLykpIHJldHVybiBsaW5lU3RhcnRTbWFydChjbSwgcmFuZ2UuaGVhZCk7XHJcbiAgICAgICAgcmV0dXJuIHBvcztcclxuICAgICAgfSwgc2VsX21vdmUpO1xyXG4gICAgfSxcclxuICAgIGdvTGluZVVwOiBmdW5jdGlvbihjbSkge2NtLm1vdmVWKC0xLCBcImxpbmVcIik7fSxcclxuICAgIGdvTGluZURvd246IGZ1bmN0aW9uKGNtKSB7Y20ubW92ZVYoMSwgXCJsaW5lXCIpO30sXHJcbiAgICBnb1BhZ2VVcDogZnVuY3Rpb24oY20pIHtjbS5tb3ZlVigtMSwgXCJwYWdlXCIpO30sXHJcbiAgICBnb1BhZ2VEb3duOiBmdW5jdGlvbihjbSkge2NtLm1vdmVWKDEsIFwicGFnZVwiKTt9LFxyXG4gICAgZ29DaGFyTGVmdDogZnVuY3Rpb24oY20pIHtjbS5tb3ZlSCgtMSwgXCJjaGFyXCIpO30sXHJcbiAgICBnb0NoYXJSaWdodDogZnVuY3Rpb24oY20pIHtjbS5tb3ZlSCgxLCBcImNoYXJcIik7fSxcclxuICAgIGdvQ29sdW1uTGVmdDogZnVuY3Rpb24oY20pIHtjbS5tb3ZlSCgtMSwgXCJjb2x1bW5cIik7fSxcclxuICAgIGdvQ29sdW1uUmlnaHQ6IGZ1bmN0aW9uKGNtKSB7Y20ubW92ZUgoMSwgXCJjb2x1bW5cIik7fSxcclxuICAgIGdvV29yZExlZnQ6IGZ1bmN0aW9uKGNtKSB7Y20ubW92ZUgoLTEsIFwid29yZFwiKTt9LFxyXG4gICAgZ29Hcm91cFJpZ2h0OiBmdW5jdGlvbihjbSkge2NtLm1vdmVIKDEsIFwiZ3JvdXBcIik7fSxcclxuICAgIGdvR3JvdXBMZWZ0OiBmdW5jdGlvbihjbSkge2NtLm1vdmVIKC0xLCBcImdyb3VwXCIpO30sXHJcbiAgICBnb1dvcmRSaWdodDogZnVuY3Rpb24oY20pIHtjbS5tb3ZlSCgxLCBcIndvcmRcIik7fSxcclxuICAgIGRlbENoYXJCZWZvcmU6IGZ1bmN0aW9uKGNtKSB7Y20uZGVsZXRlSCgtMSwgXCJjaGFyXCIpO30sXHJcbiAgICBkZWxDaGFyQWZ0ZXI6IGZ1bmN0aW9uKGNtKSB7Y20uZGVsZXRlSCgxLCBcImNoYXJcIik7fSxcclxuICAgIGRlbFdvcmRCZWZvcmU6IGZ1bmN0aW9uKGNtKSB7Y20uZGVsZXRlSCgtMSwgXCJ3b3JkXCIpO30sXHJcbiAgICBkZWxXb3JkQWZ0ZXI6IGZ1bmN0aW9uKGNtKSB7Y20uZGVsZXRlSCgxLCBcIndvcmRcIik7fSxcclxuICAgIGRlbEdyb3VwQmVmb3JlOiBmdW5jdGlvbihjbSkge2NtLmRlbGV0ZUgoLTEsIFwiZ3JvdXBcIik7fSxcclxuICAgIGRlbEdyb3VwQWZ0ZXI6IGZ1bmN0aW9uKGNtKSB7Y20uZGVsZXRlSCgxLCBcImdyb3VwXCIpO30sXHJcbiAgICBpbmRlbnRBdXRvOiBmdW5jdGlvbihjbSkge2NtLmluZGVudFNlbGVjdGlvbihcInNtYXJ0XCIpO30sXHJcbiAgICBpbmRlbnRNb3JlOiBmdW5jdGlvbihjbSkge2NtLmluZGVudFNlbGVjdGlvbihcImFkZFwiKTt9LFxyXG4gICAgaW5kZW50TGVzczogZnVuY3Rpb24oY20pIHtjbS5pbmRlbnRTZWxlY3Rpb24oXCJzdWJ0cmFjdFwiKTt9LFxyXG4gICAgaW5zZXJ0VGFiOiBmdW5jdGlvbihjbSkge2NtLnJlcGxhY2VTZWxlY3Rpb24oXCJcXHRcIik7fSxcclxuICAgIGluc2VydFNvZnRUYWI6IGZ1bmN0aW9uKGNtKSB7XHJcbiAgICAgIHZhciBzcGFjZXMgPSBbXSwgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKSwgdGFiU2l6ZSA9IGNtLm9wdGlvbnMudGFiU2l6ZTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgcG9zID0gcmFuZ2VzW2ldLmZyb20oKTtcclxuICAgICAgICB2YXIgY29sID0gY291bnRDb2x1bW4oY20uZ2V0TGluZShwb3MubGluZSksIHBvcy5jaCwgdGFiU2l6ZSk7XHJcbiAgICAgICAgc3BhY2VzLnB1c2gobmV3IEFycmF5KHRhYlNpemUgLSBjb2wgJSB0YWJTaXplICsgMSkuam9pbihcIiBcIikpO1xyXG4gICAgICB9XHJcbiAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb25zKHNwYWNlcyk7XHJcbiAgICB9LFxyXG4gICAgZGVmYXVsdFRhYjogZnVuY3Rpb24oY20pIHtcclxuICAgICAgaWYgKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIGNtLmluZGVudFNlbGVjdGlvbihcImFkZFwiKTtcclxuICAgICAgZWxzZSBjbS5leGVjQ29tbWFuZChcImluc2VydFRhYlwiKTtcclxuICAgIH0sXHJcbiAgICB0cmFuc3Bvc2VDaGFyczogZnVuY3Rpb24oY20pIHtcclxuICAgICAgcnVuSW5PcChjbSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCksIG5ld1NlbCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICB2YXIgY3VyID0gcmFuZ2VzW2ldLmhlYWQsIGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgY3VyLmxpbmUpLnRleHQ7XHJcbiAgICAgICAgICBpZiAobGluZSkge1xyXG4gICAgICAgICAgICBpZiAoY3VyLmNoID09IGxpbmUubGVuZ3RoKSBjdXIgPSBuZXcgUG9zKGN1ci5saW5lLCBjdXIuY2ggLSAxKTtcclxuICAgICAgICAgICAgaWYgKGN1ci5jaCA+IDApIHtcclxuICAgICAgICAgICAgICBjdXIgPSBuZXcgUG9zKGN1ci5saW5lLCBjdXIuY2ggKyAxKTtcclxuICAgICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UobGluZS5jaGFyQXQoY3VyLmNoIC0gMSkgKyBsaW5lLmNoYXJBdChjdXIuY2ggLSAyKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9zKGN1ci5saW5lLCBjdXIuY2ggLSAyKSwgY3VyLCBcIit0cmFuc3Bvc2VcIik7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyLmxpbmUgPiBjbS5kb2MuZmlyc3QpIHtcclxuICAgICAgICAgICAgICB2YXIgcHJldiA9IGdldExpbmUoY20uZG9jLCBjdXIubGluZSAtIDEpLnRleHQ7XHJcbiAgICAgICAgICAgICAgaWYgKHByZXYpXHJcbiAgICAgICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UobGluZS5jaGFyQXQoMCkgKyBcIlxcblwiICsgcHJldi5jaGFyQXQocHJldi5sZW5ndGggLSAxKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb3MoY3VyLmxpbmUgLSAxLCBwcmV2Lmxlbmd0aCAtIDEpLCBQb3MoY3VyLmxpbmUsIDEpLCBcIit0cmFuc3Bvc2VcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG5ld1NlbC5wdXNoKG5ldyBSYW5nZShjdXIsIGN1cikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbS5zZXRTZWxlY3Rpb25zKG5ld1NlbCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIG5ld2xpbmVBbmRJbmRlbnQ6IGZ1bmN0aW9uKGNtKSB7XHJcbiAgICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBsZW4gPSBjbS5saXN0U2VsZWN0aW9ucygpLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBjbS5saXN0U2VsZWN0aW9ucygpW2ldO1xyXG4gICAgICAgICAgY20ucmVwbGFjZVJhbmdlKFwiXFxuXCIsIHJhbmdlLmFuY2hvciwgcmFuZ2UuaGVhZCwgXCIraW5wdXRcIik7XHJcbiAgICAgICAgICBjbS5pbmRlbnRMaW5lKHJhbmdlLmZyb20oKS5saW5lICsgMSwgbnVsbCwgdHJ1ZSk7XHJcbiAgICAgICAgICBlbnN1cmVDdXJzb3JWaXNpYmxlKGNtKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIHRvZ2dsZU92ZXJ3cml0ZTogZnVuY3Rpb24oY20pIHtjbS50b2dnbGVPdmVyd3JpdGUoKTt9XHJcbiAgfTtcclxuXHJcblxyXG4gIC8vIFNUQU5EQVJEIEtFWU1BUFNcclxuXHJcbiAgdmFyIGtleU1hcCA9IENvZGVNaXJyb3Iua2V5TWFwID0ge307XHJcblxyXG4gIGtleU1hcC5iYXNpYyA9IHtcclxuICAgIFwiTGVmdFwiOiBcImdvQ2hhckxlZnRcIiwgXCJSaWdodFwiOiBcImdvQ2hhclJpZ2h0XCIsIFwiVXBcIjogXCJnb0xpbmVVcFwiLCBcIkRvd25cIjogXCJnb0xpbmVEb3duXCIsXHJcbiAgICBcIkVuZFwiOiBcImdvTGluZUVuZFwiLCBcIkhvbWVcIjogXCJnb0xpbmVTdGFydFNtYXJ0XCIsIFwiUGFnZVVwXCI6IFwiZ29QYWdlVXBcIiwgXCJQYWdlRG93blwiOiBcImdvUGFnZURvd25cIixcclxuICAgIFwiRGVsZXRlXCI6IFwiZGVsQ2hhckFmdGVyXCIsIFwiQmFja3NwYWNlXCI6IFwiZGVsQ2hhckJlZm9yZVwiLCBcIlNoaWZ0LUJhY2tzcGFjZVwiOiBcImRlbENoYXJCZWZvcmVcIixcclxuICAgIFwiVGFiXCI6IFwiZGVmYXVsdFRhYlwiLCBcIlNoaWZ0LVRhYlwiOiBcImluZGVudEF1dG9cIixcclxuICAgIFwiRW50ZXJcIjogXCJuZXdsaW5lQW5kSW5kZW50XCIsIFwiSW5zZXJ0XCI6IFwidG9nZ2xlT3ZlcndyaXRlXCIsXHJcbiAgICBcIkVzY1wiOiBcInNpbmdsZVNlbGVjdGlvblwiXHJcbiAgfTtcclxuICAvLyBOb3RlIHRoYXQgdGhlIHNhdmUgYW5kIGZpbmQtcmVsYXRlZCBjb21tYW5kcyBhcmVuJ3QgZGVmaW5lZCBieVxyXG4gIC8vIGRlZmF1bHQuIFVzZXIgY29kZSBvciBhZGRvbnMgY2FuIGRlZmluZSB0aGVtLiBVbmtub3duIGNvbW1hbmRzXHJcbiAgLy8gYXJlIHNpbXBseSBpZ25vcmVkLlxyXG4gIGtleU1hcC5wY0RlZmF1bHQgPSB7XHJcbiAgICBcIkN0cmwtQVwiOiBcInNlbGVjdEFsbFwiLCBcIkN0cmwtRFwiOiBcImRlbGV0ZUxpbmVcIiwgXCJDdHJsLVpcIjogXCJ1bmRvXCIsIFwiU2hpZnQtQ3RybC1aXCI6IFwicmVkb1wiLCBcIkN0cmwtWVwiOiBcInJlZG9cIixcclxuICAgIFwiQ3RybC1Ib21lXCI6IFwiZ29Eb2NTdGFydFwiLCBcIkN0cmwtRW5kXCI6IFwiZ29Eb2NFbmRcIiwgXCJDdHJsLVVwXCI6IFwiZ29MaW5lVXBcIiwgXCJDdHJsLURvd25cIjogXCJnb0xpbmVEb3duXCIsXHJcbiAgICBcIkN0cmwtTGVmdFwiOiBcImdvR3JvdXBMZWZ0XCIsIFwiQ3RybC1SaWdodFwiOiBcImdvR3JvdXBSaWdodFwiLCBcIkFsdC1MZWZ0XCI6IFwiZ29MaW5lU3RhcnRcIiwgXCJBbHQtUmlnaHRcIjogXCJnb0xpbmVFbmRcIixcclxuICAgIFwiQ3RybC1CYWNrc3BhY2VcIjogXCJkZWxHcm91cEJlZm9yZVwiLCBcIkN0cmwtRGVsZXRlXCI6IFwiZGVsR3JvdXBBZnRlclwiLCBcIkN0cmwtU1wiOiBcInNhdmVcIiwgXCJDdHJsLUZcIjogXCJmaW5kXCIsXHJcbiAgICBcIkN0cmwtR1wiOiBcImZpbmROZXh0XCIsIFwiU2hpZnQtQ3RybC1HXCI6IFwiZmluZFByZXZcIiwgXCJTaGlmdC1DdHJsLUZcIjogXCJyZXBsYWNlXCIsIFwiU2hpZnQtQ3RybC1SXCI6IFwicmVwbGFjZUFsbFwiLFxyXG4gICAgXCJDdHJsLVtcIjogXCJpbmRlbnRMZXNzXCIsIFwiQ3RybC1dXCI6IFwiaW5kZW50TW9yZVwiLFxyXG4gICAgXCJDdHJsLVVcIjogXCJ1bmRvU2VsZWN0aW9uXCIsIFwiU2hpZnQtQ3RybC1VXCI6IFwicmVkb1NlbGVjdGlvblwiLCBcIkFsdC1VXCI6IFwicmVkb1NlbGVjdGlvblwiLFxyXG4gICAgZmFsbHRocm91Z2g6IFwiYmFzaWNcIlxyXG4gIH07XHJcbiAgLy8gVmVyeSBiYXNpYyByZWFkbGluZS9lbWFjcy1zdHlsZSBiaW5kaW5ncywgd2hpY2ggYXJlIHN0YW5kYXJkIG9uIE1hYy5cclxuICBrZXlNYXAuZW1hY3N5ID0ge1xyXG4gICAgXCJDdHJsLUZcIjogXCJnb0NoYXJSaWdodFwiLCBcIkN0cmwtQlwiOiBcImdvQ2hhckxlZnRcIiwgXCJDdHJsLVBcIjogXCJnb0xpbmVVcFwiLCBcIkN0cmwtTlwiOiBcImdvTGluZURvd25cIixcclxuICAgIFwiQWx0LUZcIjogXCJnb1dvcmRSaWdodFwiLCBcIkFsdC1CXCI6IFwiZ29Xb3JkTGVmdFwiLCBcIkN0cmwtQVwiOiBcImdvTGluZVN0YXJ0XCIsIFwiQ3RybC1FXCI6IFwiZ29MaW5lRW5kXCIsXHJcbiAgICBcIkN0cmwtVlwiOiBcImdvUGFnZURvd25cIiwgXCJTaGlmdC1DdHJsLVZcIjogXCJnb1BhZ2VVcFwiLCBcIkN0cmwtRFwiOiBcImRlbENoYXJBZnRlclwiLCBcIkN0cmwtSFwiOiBcImRlbENoYXJCZWZvcmVcIixcclxuICAgIFwiQWx0LURcIjogXCJkZWxXb3JkQWZ0ZXJcIiwgXCJBbHQtQmFja3NwYWNlXCI6IFwiZGVsV29yZEJlZm9yZVwiLCBcIkN0cmwtS1wiOiBcImtpbGxMaW5lXCIsIFwiQ3RybC1UXCI6IFwidHJhbnNwb3NlQ2hhcnNcIlxyXG4gIH07XHJcbiAga2V5TWFwLm1hY0RlZmF1bHQgPSB7XHJcbiAgICBcIkNtZC1BXCI6IFwic2VsZWN0QWxsXCIsIFwiQ21kLURcIjogXCJkZWxldGVMaW5lXCIsIFwiQ21kLVpcIjogXCJ1bmRvXCIsIFwiU2hpZnQtQ21kLVpcIjogXCJyZWRvXCIsIFwiQ21kLVlcIjogXCJyZWRvXCIsXHJcbiAgICBcIkNtZC1Ib21lXCI6IFwiZ29Eb2NTdGFydFwiLCBcIkNtZC1VcFwiOiBcImdvRG9jU3RhcnRcIiwgXCJDbWQtRW5kXCI6IFwiZ29Eb2NFbmRcIiwgXCJDbWQtRG93blwiOiBcImdvRG9jRW5kXCIsIFwiQWx0LUxlZnRcIjogXCJnb0dyb3VwTGVmdFwiLFxyXG4gICAgXCJBbHQtUmlnaHRcIjogXCJnb0dyb3VwUmlnaHRcIiwgXCJDbWQtTGVmdFwiOiBcImdvTGluZUxlZnRcIiwgXCJDbWQtUmlnaHRcIjogXCJnb0xpbmVSaWdodFwiLCBcIkFsdC1CYWNrc3BhY2VcIjogXCJkZWxHcm91cEJlZm9yZVwiLFxyXG4gICAgXCJDdHJsLUFsdC1CYWNrc3BhY2VcIjogXCJkZWxHcm91cEFmdGVyXCIsIFwiQWx0LURlbGV0ZVwiOiBcImRlbEdyb3VwQWZ0ZXJcIiwgXCJDbWQtU1wiOiBcInNhdmVcIiwgXCJDbWQtRlwiOiBcImZpbmRcIixcclxuICAgIFwiQ21kLUdcIjogXCJmaW5kTmV4dFwiLCBcIlNoaWZ0LUNtZC1HXCI6IFwiZmluZFByZXZcIiwgXCJDbWQtQWx0LUZcIjogXCJyZXBsYWNlXCIsIFwiU2hpZnQtQ21kLUFsdC1GXCI6IFwicmVwbGFjZUFsbFwiLFxyXG4gICAgXCJDbWQtW1wiOiBcImluZGVudExlc3NcIiwgXCJDbWQtXVwiOiBcImluZGVudE1vcmVcIiwgXCJDbWQtQmFja3NwYWNlXCI6IFwiZGVsV3JhcHBlZExpbmVMZWZ0XCIsIFwiQ21kLURlbGV0ZVwiOiBcImRlbFdyYXBwZWRMaW5lUmlnaHRcIixcclxuICAgIFwiQ21kLVVcIjogXCJ1bmRvU2VsZWN0aW9uXCIsIFwiU2hpZnQtQ21kLVVcIjogXCJyZWRvU2VsZWN0aW9uXCIsIFwiQ3RybC1VcFwiOiBcImdvRG9jU3RhcnRcIiwgXCJDdHJsLURvd25cIjogXCJnb0RvY0VuZFwiLFxyXG4gICAgZmFsbHRocm91Z2g6IFtcImJhc2ljXCIsIFwiZW1hY3N5XCJdXHJcbiAgfTtcclxuICBrZXlNYXBbXCJkZWZhdWx0XCJdID0gbWFjID8ga2V5TWFwLm1hY0RlZmF1bHQgOiBrZXlNYXAucGNEZWZhdWx0O1xyXG5cclxuICAvLyBLRVlNQVAgRElTUEFUQ0hcclxuXHJcbiAgZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lKSB7XHJcbiAgICB2YXIgcGFydHMgPSBuYW1lLnNwbGl0KC8tKD8hJCkvKSwgbmFtZSA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgdmFyIGFsdCwgY3RybCwgc2hpZnQsIGNtZDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgIHZhciBtb2QgPSBwYXJ0c1tpXTtcclxuICAgICAgaWYgKC9eKGNtZHxtZXRhfG0pJC9pLnRlc3QobW9kKSkgY21kID0gdHJ1ZTtcclxuICAgICAgZWxzZSBpZiAoL15hKGx0KT8kL2kudGVzdChtb2QpKSBhbHQgPSB0cnVlO1xyXG4gICAgICBlbHNlIGlmICgvXihjfGN0cmx8Y29udHJvbCkkL2kudGVzdChtb2QpKSBjdHJsID0gdHJ1ZTtcclxuICAgICAgZWxzZSBpZiAoL15zKGhpZnQpJC9pLnRlc3QobW9kKSkgc2hpZnQgPSB0cnVlO1xyXG4gICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiBcIiArIG1vZCk7XHJcbiAgICB9XHJcbiAgICBpZiAoYWx0KSBuYW1lID0gXCJBbHQtXCIgKyBuYW1lO1xyXG4gICAgaWYgKGN0cmwpIG5hbWUgPSBcIkN0cmwtXCIgKyBuYW1lO1xyXG4gICAgaWYgKGNtZCkgbmFtZSA9IFwiQ21kLVwiICsgbmFtZTtcclxuICAgIGlmIChzaGlmdCkgbmFtZSA9IFwiU2hpZnQtXCIgKyBuYW1lO1xyXG4gICAgcmV0dXJuIG5hbWU7XHJcbiAgfVxyXG5cclxuICAvLyBUaGlzIGlzIGEga2x1ZGdlIHRvIGtlZXAga2V5bWFwcyBtb3N0bHkgd29ya2luZyBhcyByYXcgb2JqZWN0c1xyXG4gIC8vIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSkgd2hpbGUgYXQgdGhlIHNhbWUgdGltZSBzdXBwb3J0IGZlYXR1cmVzXHJcbiAgLy8gbGlrZSBub3JtYWxpemF0aW9uIGFuZCBtdWx0aS1zdHJva2Uga2V5IGJpbmRpbmdzLiBJdCBjb21waWxlcyBhXHJcbiAgLy8gbmV3IG5vcm1hbGl6ZWQga2V5bWFwLCBhbmQgdGhlbiB1cGRhdGVzIHRoZSBvbGQgb2JqZWN0IHRvIHJlZmxlY3RcclxuICAvLyB0aGlzLlxyXG4gIENvZGVNaXJyb3Iubm9ybWFsaXplS2V5TWFwID0gZnVuY3Rpb24oa2V5bWFwKSB7XHJcbiAgICB2YXIgY29weSA9IHt9O1xyXG4gICAgZm9yICh2YXIga2V5bmFtZSBpbiBrZXltYXApIGlmIChrZXltYXAuaGFzT3duUHJvcGVydHkoa2V5bmFtZSkpIHtcclxuICAgICAgdmFyIHZhbHVlID0ga2V5bWFwW2tleW5hbWVdO1xyXG4gICAgICBpZiAoL14obmFtZXxmYWxsdGhyb3VnaHwoZGV8YXQpdGFjaCkkLy50ZXN0KGtleW5hbWUpKSBjb250aW51ZTtcclxuICAgICAgaWYgKHZhbHVlID09IFwiLi4uXCIpIHsgZGVsZXRlIGtleW1hcFtrZXluYW1lXTsgY29udGludWU7IH1cclxuXHJcbiAgICAgIHZhciBrZXlzID0gbWFwKGtleW5hbWUuc3BsaXQoXCIgXCIpLCBub3JtYWxpemVLZXlOYW1lKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHZhbCwgbmFtZTtcclxuICAgICAgICBpZiAoaSA9PSBrZXlzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgIG5hbWUgPSBrZXluYW1lO1xyXG4gICAgICAgICAgdmFsID0gdmFsdWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5hbWUgPSBrZXlzLnNsaWNlKDAsIGkgKyAxKS5qb2luKFwiIFwiKTtcclxuICAgICAgICAgIHZhbCA9IFwiLi4uXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwcmV2ID0gY29weVtuYW1lXTtcclxuICAgICAgICBpZiAoIXByZXYpIGNvcHlbbmFtZV0gPSB2YWw7XHJcbiAgICAgICAgZWxzZSBpZiAocHJldiAhPSB2YWwpIHRocm93IG5ldyBFcnJvcihcIkluY29uc2lzdGVudCBiaW5kaW5ncyBmb3IgXCIgKyBuYW1lKTtcclxuICAgICAgfVxyXG4gICAgICBkZWxldGUga2V5bWFwW2tleW5hbWVdO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgcHJvcCBpbiBjb3B5KSBrZXltYXBbcHJvcF0gPSBjb3B5W3Byb3BdO1xyXG4gICAgcmV0dXJuIGtleW1hcDtcclxuICB9O1xyXG5cclxuICB2YXIgbG9va3VwS2V5ID0gQ29kZU1pcnJvci5sb29rdXBLZXkgPSBmdW5jdGlvbihrZXksIG1hcCwgaGFuZGxlLCBjb250ZXh0KSB7XHJcbiAgICBtYXAgPSBnZXRLZXlNYXAobWFwKTtcclxuICAgIHZhciBmb3VuZCA9IG1hcC5jYWxsID8gbWFwLmNhbGwoa2V5LCBjb250ZXh0KSA6IG1hcFtrZXldO1xyXG4gICAgaWYgKGZvdW5kID09PSBmYWxzZSkgcmV0dXJuIFwibm90aGluZ1wiO1xyXG4gICAgaWYgKGZvdW5kID09PSBcIi4uLlwiKSByZXR1cm4gXCJtdWx0aVwiO1xyXG4gICAgaWYgKGZvdW5kICE9IG51bGwgJiYgaGFuZGxlKGZvdW5kKSkgcmV0dXJuIFwiaGFuZGxlZFwiO1xyXG5cclxuICAgIGlmIChtYXAuZmFsbHRocm91Z2gpIHtcclxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtYXAuZmFsbHRocm91Z2gpICE9IFwiW29iamVjdCBBcnJheV1cIilcclxuICAgICAgICByZXR1cm4gbG9va3VwS2V5KGtleSwgbWFwLmZhbGx0aHJvdWdoLCBoYW5kbGUsIGNvbnRleHQpO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcC5mYWxsdGhyb3VnaC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBsb29rdXBLZXkoa2V5LCBtYXAuZmFsbHRocm91Z2hbaV0sIGhhbmRsZSwgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIE1vZGlmaWVyIGtleSBwcmVzc2VzIGRvbid0IGNvdW50IGFzICdyZWFsJyBrZXkgcHJlc3NlcyBmb3IgdGhlXHJcbiAgLy8gcHVycG9zZSBvZiBrZXltYXAgZmFsbHRocm91Z2guXHJcbiAgdmFyIGlzTW9kaWZpZXJLZXkgPSBDb2RlTWlycm9yLmlzTW9kaWZpZXJLZXkgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgdmFyIG5hbWUgPSB0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIiA/IHZhbHVlIDoga2V5TmFtZXNbdmFsdWUua2V5Q29kZV07XHJcbiAgICByZXR1cm4gbmFtZSA9PSBcIkN0cmxcIiB8fCBuYW1lID09IFwiQWx0XCIgfHwgbmFtZSA9PSBcIlNoaWZ0XCIgfHwgbmFtZSA9PSBcIk1vZFwiO1xyXG4gIH07XHJcblxyXG4gIC8vIExvb2sgdXAgdGhlIG5hbWUgb2YgYSBrZXkgYXMgaW5kaWNhdGVkIGJ5IGFuIGV2ZW50IG9iamVjdC5cclxuICB2YXIga2V5TmFtZSA9IENvZGVNaXJyb3Iua2V5TmFtZSA9IGZ1bmN0aW9uKGV2ZW50LCBub1NoaWZ0KSB7XHJcbiAgICBpZiAocHJlc3RvICYmIGV2ZW50LmtleUNvZGUgPT0gMzQgJiYgZXZlbnRbXCJjaGFyXCJdKSByZXR1cm4gZmFsc2U7XHJcbiAgICB2YXIgYmFzZSA9IGtleU5hbWVzW2V2ZW50LmtleUNvZGVdLCBuYW1lID0gYmFzZTtcclxuICAgIGlmIChuYW1lID09IG51bGwgfHwgZXZlbnQuYWx0R3JhcGhLZXkpIHJldHVybiBmYWxzZTtcclxuICAgIGlmIChldmVudC5hbHRLZXkgJiYgYmFzZSAhPSBcIkFsdFwiKSBuYW1lID0gXCJBbHQtXCIgKyBuYW1lO1xyXG4gICAgaWYgKChmbGlwQ3RybENtZCA/IGV2ZW50Lm1ldGFLZXkgOiBldmVudC5jdHJsS2V5KSAmJiBiYXNlICE9IFwiQ3RybFwiKSBuYW1lID0gXCJDdHJsLVwiICsgbmFtZTtcclxuICAgIGlmICgoZmxpcEN0cmxDbWQgPyBldmVudC5jdHJsS2V5IDogZXZlbnQubWV0YUtleSkgJiYgYmFzZSAhPSBcIkNtZFwiKSBuYW1lID0gXCJDbWQtXCIgKyBuYW1lO1xyXG4gICAgaWYgKCFub1NoaWZ0ICYmIGV2ZW50LnNoaWZ0S2V5ICYmIGJhc2UgIT0gXCJTaGlmdFwiKSBuYW1lID0gXCJTaGlmdC1cIiArIG5hbWU7XHJcbiAgICByZXR1cm4gbmFtZTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBnZXRLZXlNYXAodmFsKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PSBcInN0cmluZ1wiID8ga2V5TWFwW3ZhbF0gOiB2YWw7XHJcbiAgfVxyXG5cclxuICAvLyBGUk9NVEVYVEFSRUFcclxuXHJcbiAgQ29kZU1pcnJvci5mcm9tVGV4dEFyZWEgPSBmdW5jdGlvbih0ZXh0YXJlYSwgb3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBjb3B5T2JqKG9wdGlvbnMpIDoge307XHJcbiAgICBvcHRpb25zLnZhbHVlID0gdGV4dGFyZWEudmFsdWU7XHJcbiAgICBpZiAoIW9wdGlvbnMudGFiaW5kZXggJiYgdGV4dGFyZWEudGFiSW5kZXgpXHJcbiAgICAgIG9wdGlvbnMudGFiaW5kZXggPSB0ZXh0YXJlYS50YWJJbmRleDtcclxuICAgIGlmICghb3B0aW9ucy5wbGFjZWhvbGRlciAmJiB0ZXh0YXJlYS5wbGFjZWhvbGRlcilcclxuICAgICAgb3B0aW9ucy5wbGFjZWhvbGRlciA9IHRleHRhcmVhLnBsYWNlaG9sZGVyO1xyXG4gICAgLy8gU2V0IGF1dG9mb2N1cyB0byB0cnVlIGlmIHRoaXMgdGV4dGFyZWEgaXMgZm9jdXNlZCwgb3IgaWYgaXQgaGFzXHJcbiAgICAvLyBhdXRvZm9jdXMgYW5kIG5vIG90aGVyIGVsZW1lbnQgaXMgZm9jdXNlZC5cclxuICAgIGlmIChvcHRpb25zLmF1dG9mb2N1cyA9PSBudWxsKSB7XHJcbiAgICAgIHZhciBoYXNGb2N1cyA9IGFjdGl2ZUVsdCgpO1xyXG4gICAgICBvcHRpb25zLmF1dG9mb2N1cyA9IGhhc0ZvY3VzID09IHRleHRhcmVhIHx8XHJcbiAgICAgICAgdGV4dGFyZWEuZ2V0QXR0cmlidXRlKFwiYXV0b2ZvY3VzXCIpICE9IG51bGwgJiYgaGFzRm9jdXMgPT0gZG9jdW1lbnQuYm9keTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzYXZlKCkge3RleHRhcmVhLnZhbHVlID0gY20uZ2V0VmFsdWUoKTt9XHJcbiAgICBpZiAodGV4dGFyZWEuZm9ybSkge1xyXG4gICAgICBvbih0ZXh0YXJlYS5mb3JtLCBcInN1Ym1pdFwiLCBzYXZlKTtcclxuICAgICAgLy8gRGVwbG9yYWJsZSBoYWNrIHRvIG1ha2UgdGhlIHN1Ym1pdCBtZXRob2QgZG8gdGhlIHJpZ2h0IHRoaW5nLlxyXG4gICAgICBpZiAoIW9wdGlvbnMubGVhdmVTdWJtaXRNZXRob2RBbG9uZSkge1xyXG4gICAgICAgIHZhciBmb3JtID0gdGV4dGFyZWEuZm9ybSwgcmVhbFN1Ym1pdCA9IGZvcm0uc3VibWl0O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB2YXIgd3JhcHBlZFN1Ym1pdCA9IGZvcm0uc3VibWl0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHNhdmUoKTtcclxuICAgICAgICAgICAgZm9ybS5zdWJtaXQgPSByZWFsU3VibWl0O1xyXG4gICAgICAgICAgICBmb3JtLnN1Ym1pdCgpO1xyXG4gICAgICAgICAgICBmb3JtLnN1Ym1pdCA9IHdyYXBwZWRTdWJtaXQ7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0gY2F0Y2goZSkge31cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9wdGlvbnMuZmluaXNoSW5pdCA9IGZ1bmN0aW9uKGNtKSB7XHJcbiAgICAgIGNtLnNhdmUgPSBzYXZlO1xyXG4gICAgICBjbS5nZXRUZXh0QXJlYSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGV4dGFyZWE7IH07XHJcbiAgICAgIGNtLnRvVGV4dEFyZWEgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBjbS50b1RleHRBcmVhID0gaXNOYU47IC8vIFByZXZlbnQgdGhpcyBmcm9tIGJlaW5nIHJhbiB0d2ljZVxyXG4gICAgICAgIHNhdmUoKTtcclxuICAgICAgICB0ZXh0YXJlYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNtLmdldFdyYXBwZXJFbGVtZW50KCkpO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xyXG4gICAgICAgIGlmICh0ZXh0YXJlYS5mb3JtKSB7XHJcbiAgICAgICAgICBvZmYodGV4dGFyZWEuZm9ybSwgXCJzdWJtaXRcIiwgc2F2ZSk7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIHRleHRhcmVhLmZvcm0uc3VibWl0ID09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgdGV4dGFyZWEuZm9ybS5zdWJtaXQgPSByZWFsU3VibWl0O1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgdGV4dGFyZWEuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgdmFyIGNtID0gQ29kZU1pcnJvcihmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgIHRleHRhcmVhLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIHRleHRhcmVhLm5leHRTaWJsaW5nKTtcclxuICAgIH0sIG9wdGlvbnMpO1xyXG4gICAgcmV0dXJuIGNtO1xyXG4gIH07XHJcblxyXG4gIC8vIFNUUklORyBTVFJFQU1cclxuXHJcbiAgLy8gRmVkIHRvIHRoZSBtb2RlIHBhcnNlcnMsIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gbWFrZVxyXG4gIC8vIHBhcnNlcnMgbW9yZSBzdWNjaW5jdC5cclxuXHJcbiAgdmFyIFN0cmluZ1N0cmVhbSA9IENvZGVNaXJyb3IuU3RyaW5nU3RyZWFtID0gZnVuY3Rpb24oc3RyaW5nLCB0YWJTaXplKSB7XHJcbiAgICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQgPSAwO1xyXG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XHJcbiAgICB0aGlzLnRhYlNpemUgPSB0YWJTaXplIHx8IDg7XHJcbiAgICB0aGlzLmxhc3RDb2x1bW5Qb3MgPSB0aGlzLmxhc3RDb2x1bW5WYWx1ZSA9IDA7XHJcbiAgICB0aGlzLmxpbmVTdGFydCA9IDA7XHJcbiAgfTtcclxuXHJcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZSA9IHtcclxuICAgIGVvbDogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMucG9zID49IHRoaXMuc3RyaW5nLmxlbmd0aDt9LFxyXG4gICAgc29sOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5wb3MgPT0gdGhpcy5saW5lU3RhcnQ7fSxcclxuICAgIHBlZWs6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpIHx8IHVuZGVmaW5lZDt9LFxyXG4gICAgbmV4dDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICh0aGlzLnBvcyA8IHRoaXMuc3RyaW5nLmxlbmd0aClcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKyspO1xyXG4gICAgfSxcclxuICAgIGVhdDogZnVuY3Rpb24obWF0Y2gpIHtcclxuICAgICAgdmFyIGNoID0gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKTtcclxuICAgICAgaWYgKHR5cGVvZiBtYXRjaCA9PSBcInN0cmluZ1wiKSB2YXIgb2sgPSBjaCA9PSBtYXRjaDtcclxuICAgICAgZWxzZSB2YXIgb2sgPSBjaCAmJiAobWF0Y2gudGVzdCA/IG1hdGNoLnRlc3QoY2gpIDogbWF0Y2goY2gpKTtcclxuICAgICAgaWYgKG9rKSB7Kyt0aGlzLnBvczsgcmV0dXJuIGNoO31cclxuICAgIH0sXHJcbiAgICBlYXRXaGlsZTogZnVuY3Rpb24obWF0Y2gpIHtcclxuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XHJcbiAgICAgIHdoaWxlICh0aGlzLmVhdChtYXRjaCkpe31cclxuICAgICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnQ7XHJcbiAgICB9LFxyXG4gICAgZWF0U3BhY2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcclxuICAgICAgd2hpbGUgKC9bXFxzXFx1MDBhMF0vLnRlc3QodGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSkpICsrdGhpcy5wb3M7XHJcbiAgICAgIHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0O1xyXG4gICAgfSxcclxuICAgIHNraXBUb0VuZDogZnVuY3Rpb24oKSB7dGhpcy5wb3MgPSB0aGlzLnN0cmluZy5sZW5ndGg7fSxcclxuICAgIHNraXBUbzogZnVuY3Rpb24oY2gpIHtcclxuICAgICAgdmFyIGZvdW5kID0gdGhpcy5zdHJpbmcuaW5kZXhPZihjaCwgdGhpcy5wb3MpO1xyXG4gICAgICBpZiAoZm91bmQgPiAtMSkge3RoaXMucG9zID0gZm91bmQ7IHJldHVybiB0cnVlO31cclxuICAgIH0sXHJcbiAgICBiYWNrVXA6IGZ1bmN0aW9uKG4pIHt0aGlzLnBvcyAtPSBuO30sXHJcbiAgICBjb2x1bW46IGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAodGhpcy5sYXN0Q29sdW1uUG9zIDwgdGhpcy5zdGFydCkge1xyXG4gICAgICAgIHRoaXMubGFzdENvbHVtblZhbHVlID0gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIHRoaXMuc3RhcnQsIHRoaXMudGFiU2l6ZSwgdGhpcy5sYXN0Q29sdW1uUG9zLCB0aGlzLmxhc3RDb2x1bW5WYWx1ZSk7XHJcbiAgICAgICAgdGhpcy5sYXN0Q29sdW1uUG9zID0gdGhpcy5zdGFydDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5sYXN0Q29sdW1uVmFsdWUgLSAodGhpcy5saW5lU3RhcnQgPyBjb3VudENvbHVtbih0aGlzLnN0cmluZywgdGhpcy5saW5lU3RhcnQsIHRoaXMudGFiU2l6ZSkgOiAwKTtcclxuICAgIH0sXHJcbiAgICBpbmRlbnRhdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBjb3VudENvbHVtbih0aGlzLnN0cmluZywgbnVsbCwgdGhpcy50YWJTaXplKSAtXHJcbiAgICAgICAgKHRoaXMubGluZVN0YXJ0ID8gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIHRoaXMubGluZVN0YXJ0LCB0aGlzLnRhYlNpemUpIDogMCk7XHJcbiAgICB9LFxyXG4gICAgbWF0Y2g6IGZ1bmN0aW9uKHBhdHRlcm4sIGNvbnN1bWUsIGNhc2VJbnNlbnNpdGl2ZSkge1xyXG4gICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHZhciBjYXNlZCA9IGZ1bmN0aW9uKHN0cikge3JldHVybiBjYXNlSW5zZW5zaXRpdmUgPyBzdHIudG9Mb3dlckNhc2UoKSA6IHN0cjt9O1xyXG4gICAgICAgIHZhciBzdWJzdHIgPSB0aGlzLnN0cmluZy5zdWJzdHIodGhpcy5wb3MsIHBhdHRlcm4ubGVuZ3RoKTtcclxuICAgICAgICBpZiAoY2FzZWQoc3Vic3RyKSA9PSBjYXNlZChwYXR0ZXJuKSkge1xyXG4gICAgICAgICAgaWYgKGNvbnN1bWUgIT09IGZhbHNlKSB0aGlzLnBvcyArPSBwYXR0ZXJuLmxlbmd0aDtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgbWF0Y2ggPSB0aGlzLnN0cmluZy5zbGljZSh0aGlzLnBvcykubWF0Y2gocGF0dGVybik7XHJcbiAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmluZGV4ID4gMCkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgaWYgKG1hdGNoICYmIGNvbnN1bWUgIT09IGZhbHNlKSB0aGlzLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgY3VycmVudDogZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5wb3MpO30sXHJcbiAgICBoaWRlRmlyc3RDaGFyczogZnVuY3Rpb24obiwgaW5uZXIpIHtcclxuICAgICAgdGhpcy5saW5lU3RhcnQgKz0gbjtcclxuICAgICAgdHJ5IHsgcmV0dXJuIGlubmVyKCk7IH1cclxuICAgICAgZmluYWxseSB7IHRoaXMubGluZVN0YXJ0IC09IG47IH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBURVhUTUFSS0VSU1xyXG5cclxuICAvLyBDcmVhdGVkIHdpdGggbWFya1RleHQgYW5kIHNldEJvb2ttYXJrIG1ldGhvZHMuIEEgVGV4dE1hcmtlciBpcyBhXHJcbiAgLy8gaGFuZGxlIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2xlYXIgb3IgZmluZCBhIG1hcmtlZCBwb3NpdGlvbiBpbiB0aGVcclxuICAvLyBkb2N1bWVudC4gTGluZSBvYmplY3RzIGhvbGQgYXJyYXlzIChtYXJrZWRTcGFucykgY29udGFpbmluZ1xyXG4gIC8vIHtmcm9tLCB0bywgbWFya2VyfSBvYmplY3QgcG9pbnRpbmcgdG8gc3VjaCBtYXJrZXIgb2JqZWN0cywgYW5kXHJcbiAgLy8gaW5kaWNhdGluZyB0aGF0IHN1Y2ggYSBtYXJrZXIgaXMgcHJlc2VudCBvbiB0aGF0IGxpbmUuIE11bHRpcGxlXHJcbiAgLy8gbGluZXMgbWF5IHBvaW50IHRvIHRoZSBzYW1lIG1hcmtlciB3aGVuIGl0IHNwYW5zIGFjcm9zcyBsaW5lcy5cclxuICAvLyBUaGUgc3BhbnMgd2lsbCBoYXZlIG51bGwgZm9yIHRoZWlyIGZyb20vdG8gcHJvcGVydGllcyB3aGVuIHRoZVxyXG4gIC8vIG1hcmtlciBjb250aW51ZXMgYmV5b25kIHRoZSBzdGFydC9lbmQgb2YgdGhlIGxpbmUuIE1hcmtlcnMgaGF2ZVxyXG4gIC8vIGxpbmtzIGJhY2sgdG8gdGhlIGxpbmVzIHRoZXkgY3VycmVudGx5IHRvdWNoLlxyXG5cclxuICB2YXIgbmV4dE1hcmtlcklkID0gMDtcclxuXHJcbiAgdmFyIFRleHRNYXJrZXIgPSBDb2RlTWlycm9yLlRleHRNYXJrZXIgPSBmdW5jdGlvbihkb2MsIHR5cGUpIHtcclxuICAgIHRoaXMubGluZXMgPSBbXTtcclxuICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICB0aGlzLmRvYyA9IGRvYztcclxuICAgIHRoaXMuaWQgPSArK25leHRNYXJrZXJJZDtcclxuICB9O1xyXG4gIGV2ZW50TWl4aW4oVGV4dE1hcmtlcik7XHJcblxyXG4gIC8vIENsZWFyIHRoZSBtYXJrZXIuXHJcbiAgVGV4dE1hcmtlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmICh0aGlzLmV4cGxpY2l0bHlDbGVhcmVkKSByZXR1cm47XHJcbiAgICB2YXIgY20gPSB0aGlzLmRvYy5jbSwgd2l0aE9wID0gY20gJiYgIWNtLmN1ck9wO1xyXG4gICAgaWYgKHdpdGhPcCkgc3RhcnRPcGVyYXRpb24oY20pO1xyXG4gICAgaWYgKGhhc0hhbmRsZXIodGhpcywgXCJjbGVhclwiKSkge1xyXG4gICAgICB2YXIgZm91bmQgPSB0aGlzLmZpbmQoKTtcclxuICAgICAgaWYgKGZvdW5kKSBzaWduYWxMYXRlcih0aGlzLCBcImNsZWFyXCIsIGZvdW5kLmZyb20sIGZvdW5kLnRvKTtcclxuICAgIH1cclxuICAgIHZhciBtaW4gPSBudWxsLCBtYXggPSBudWxsO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIHZhciBsaW5lID0gdGhpcy5saW5lc1tpXTtcclxuICAgICAgdmFyIHNwYW4gPSBnZXRNYXJrZWRTcGFuRm9yKGxpbmUubWFya2VkU3BhbnMsIHRoaXMpO1xyXG4gICAgICBpZiAoY20gJiYgIXRoaXMuY29sbGFwc2VkKSByZWdMaW5lQ2hhbmdlKGNtLCBsaW5lTm8obGluZSksIFwidGV4dFwiKTtcclxuICAgICAgZWxzZSBpZiAoY20pIHtcclxuICAgICAgICBpZiAoc3Bhbi50byAhPSBudWxsKSBtYXggPSBsaW5lTm8obGluZSk7XHJcbiAgICAgICAgaWYgKHNwYW4uZnJvbSAhPSBudWxsKSBtaW4gPSBsaW5lTm8obGluZSk7XHJcbiAgICAgIH1cclxuICAgICAgbGluZS5tYXJrZWRTcGFucyA9IHJlbW92ZU1hcmtlZFNwYW4obGluZS5tYXJrZWRTcGFucywgc3Bhbik7XHJcbiAgICAgIGlmIChzcGFuLmZyb20gPT0gbnVsbCAmJiB0aGlzLmNvbGxhcHNlZCAmJiAhbGluZUlzSGlkZGVuKHRoaXMuZG9jLCBsaW5lKSAmJiBjbSlcclxuICAgICAgICB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIHRleHRIZWlnaHQoY20uZGlzcGxheSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGNtICYmIHRoaXMuY29sbGFwc2VkICYmICFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIHZhciB2aXN1YWwgPSB2aXN1YWxMaW5lKHRoaXMubGluZXNbaV0pLCBsZW4gPSBsaW5lTGVuZ3RoKHZpc3VhbCk7XHJcbiAgICAgIGlmIChsZW4gPiBjbS5kaXNwbGF5Lm1heExpbmVMZW5ndGgpIHtcclxuICAgICAgICBjbS5kaXNwbGF5Lm1heExpbmUgPSB2aXN1YWw7XHJcbiAgICAgICAgY20uZGlzcGxheS5tYXhMaW5lTGVuZ3RoID0gbGVuO1xyXG4gICAgICAgIGNtLmRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1pbiAhPSBudWxsICYmIGNtICYmIHRoaXMuY29sbGFwc2VkKSByZWdDaGFuZ2UoY20sIG1pbiwgbWF4ICsgMSk7XHJcbiAgICB0aGlzLmxpbmVzLmxlbmd0aCA9IDA7XHJcbiAgICB0aGlzLmV4cGxpY2l0bHlDbGVhcmVkID0gdHJ1ZTtcclxuICAgIGlmICh0aGlzLmF0b21pYyAmJiB0aGlzLmRvYy5jYW50RWRpdCkge1xyXG4gICAgICB0aGlzLmRvYy5jYW50RWRpdCA9IGZhbHNlO1xyXG4gICAgICBpZiAoY20pIHJlQ2hlY2tTZWxlY3Rpb24oY20uZG9jKTtcclxuICAgIH1cclxuICAgIGlmIChjbSkgc2lnbmFsTGF0ZXIoY20sIFwibWFya2VyQ2xlYXJlZFwiLCBjbSwgdGhpcyk7XHJcbiAgICBpZiAod2l0aE9wKSBlbmRPcGVyYXRpb24oY20pO1xyXG4gICAgaWYgKHRoaXMucGFyZW50KSB0aGlzLnBhcmVudC5jbGVhcigpO1xyXG4gIH07XHJcblxyXG4gIC8vIEZpbmQgdGhlIHBvc2l0aW9uIG9mIHRoZSBtYXJrZXIgaW4gdGhlIGRvY3VtZW50LiBSZXR1cm5zIGEge2Zyb20sXHJcbiAgLy8gdG99IG9iamVjdCBieSBkZWZhdWx0LiBTaWRlIGNhbiBiZSBwYXNzZWQgdG8gZ2V0IGEgc3BlY2lmaWMgc2lkZVxyXG4gIC8vIC0tIDAgKGJvdGgpLCAtMSAobGVmdCksIG9yIDEgKHJpZ2h0KS4gV2hlbiBsaW5lT2JqIGlzIHRydWUsIHRoZVxyXG4gIC8vIFBvcyBvYmplY3RzIHJldHVybmVkIGNvbnRhaW4gYSBsaW5lIG9iamVjdCwgcmF0aGVyIHRoYW4gYSBsaW5lXHJcbiAgLy8gbnVtYmVyICh1c2VkIHRvIHByZXZlbnQgbG9va2luZyB1cCB0aGUgc2FtZSBsaW5lIHR3aWNlKS5cclxuICBUZXh0TWFya2VyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oc2lkZSwgbGluZU9iaikge1xyXG4gICAgaWYgKHNpZGUgPT0gbnVsbCAmJiB0aGlzLnR5cGUgPT0gXCJib29rbWFya1wiKSBzaWRlID0gMTtcclxuICAgIHZhciBmcm9tLCB0bztcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNbaV07XHJcbiAgICAgIHZhciBzcGFuID0gZ2V0TWFya2VkU3BhbkZvcihsaW5lLm1hcmtlZFNwYW5zLCB0aGlzKTtcclxuICAgICAgaWYgKHNwYW4uZnJvbSAhPSBudWxsKSB7XHJcbiAgICAgICAgZnJvbSA9IFBvcyhsaW5lT2JqID8gbGluZSA6IGxpbmVObyhsaW5lKSwgc3Bhbi5mcm9tKTtcclxuICAgICAgICBpZiAoc2lkZSA9PSAtMSkgcmV0dXJuIGZyb207XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNwYW4udG8gIT0gbnVsbCkge1xyXG4gICAgICAgIHRvID0gUG9zKGxpbmVPYmogPyBsaW5lIDogbGluZU5vKGxpbmUpLCBzcGFuLnRvKTtcclxuICAgICAgICBpZiAoc2lkZSA9PSAxKSByZXR1cm4gdG87XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmcm9tICYmIHtmcm9tOiBmcm9tLCB0bzogdG99O1xyXG4gIH07XHJcblxyXG4gIC8vIFNpZ25hbHMgdGhhdCB0aGUgbWFya2VyJ3Mgd2lkZ2V0IGNoYW5nZWQsIGFuZCBzdXJyb3VuZGluZyBsYXlvdXRcclxuICAvLyBzaG91bGQgYmUgcmVjb21wdXRlZC5cclxuICBUZXh0TWFya2VyLnByb3RvdHlwZS5jaGFuZ2VkID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcG9zID0gdGhpcy5maW5kKC0xLCB0cnVlKSwgd2lkZ2V0ID0gdGhpcywgY20gPSB0aGlzLmRvYy5jbTtcclxuICAgIGlmICghcG9zIHx8ICFjbSkgcmV0dXJuO1xyXG4gICAgcnVuSW5PcChjbSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBsaW5lID0gcG9zLmxpbmUsIGxpbmVOID0gbGluZU5vKHBvcy5saW5lKTtcclxuICAgICAgdmFyIHZpZXcgPSBmaW5kVmlld0ZvckxpbmUoY20sIGxpbmVOKTtcclxuICAgICAgaWYgKHZpZXcpIHtcclxuICAgICAgICBjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlRm9yKHZpZXcpO1xyXG4gICAgICAgIGNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQgPSBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgY20uY3VyT3AudXBkYXRlTWF4TGluZSA9IHRydWU7XHJcbiAgICAgIGlmICghbGluZUlzSGlkZGVuKHdpZGdldC5kb2MsIGxpbmUpICYmIHdpZGdldC5oZWlnaHQgIT0gbnVsbCkge1xyXG4gICAgICAgIHZhciBvbGRIZWlnaHQgPSB3aWRnZXQuaGVpZ2h0O1xyXG4gICAgICAgIHdpZGdldC5oZWlnaHQgPSBudWxsO1xyXG4gICAgICAgIHZhciBkSGVpZ2h0ID0gd2lkZ2V0SGVpZ2h0KHdpZGdldCkgLSBvbGRIZWlnaHQ7XHJcbiAgICAgICAgaWYgKGRIZWlnaHQpXHJcbiAgICAgICAgICB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGxpbmUuaGVpZ2h0ICsgZEhlaWdodCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIFRleHRNYXJrZXIucHJvdG90eXBlLmF0dGFjaExpbmUgPSBmdW5jdGlvbihsaW5lKSB7XHJcbiAgICBpZiAoIXRoaXMubGluZXMubGVuZ3RoICYmIHRoaXMuZG9jLmNtKSB7XHJcbiAgICAgIHZhciBvcCA9IHRoaXMuZG9jLmNtLmN1ck9wO1xyXG4gICAgICBpZiAoIW9wLm1heWJlSGlkZGVuTWFya2VycyB8fCBpbmRleE9mKG9wLm1heWJlSGlkZGVuTWFya2VycywgdGhpcykgPT0gLTEpXHJcbiAgICAgICAgKG9wLm1heWJlVW5oaWRkZW5NYXJrZXJzIHx8IChvcC5tYXliZVVuaGlkZGVuTWFya2VycyA9IFtdKSkucHVzaCh0aGlzKTtcclxuICAgIH1cclxuICAgIHRoaXMubGluZXMucHVzaChsaW5lKTtcclxuICB9O1xyXG4gIFRleHRNYXJrZXIucHJvdG90eXBlLmRldGFjaExpbmUgPSBmdW5jdGlvbihsaW5lKSB7XHJcbiAgICB0aGlzLmxpbmVzLnNwbGljZShpbmRleE9mKHRoaXMubGluZXMsIGxpbmUpLCAxKTtcclxuICAgIGlmICghdGhpcy5saW5lcy5sZW5ndGggJiYgdGhpcy5kb2MuY20pIHtcclxuICAgICAgdmFyIG9wID0gdGhpcy5kb2MuY20uY3VyT3A7XHJcbiAgICAgIChvcC5tYXliZUhpZGRlbk1hcmtlcnMgfHwgKG9wLm1heWJlSGlkZGVuTWFya2VycyA9IFtdKSkucHVzaCh0aGlzKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBDb2xsYXBzZWQgbWFya2VycyBoYXZlIHVuaXF1ZSBpZHMsIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gb3JkZXJcclxuICAvLyB0aGVtLCB3aGljaCBpcyBuZWVkZWQgZm9yIHVuaXF1ZWx5IGRldGVybWluaW5nIGFuIG91dGVyIG1hcmtlclxyXG4gIC8vIHdoZW4gdGhleSBvdmVybGFwICh0aGV5IG1heSBuZXN0LCBidXQgbm90IHBhcnRpYWxseSBvdmVybGFwKS5cclxuICB2YXIgbmV4dE1hcmtlcklkID0gMDtcclxuXHJcbiAgLy8gQ3JlYXRlIGEgbWFya2VyLCB3aXJlIGl0IHVwIHRvIHRoZSByaWdodCBsaW5lcywgYW5kXHJcbiAgZnVuY3Rpb24gbWFya1RleHQoZG9jLCBmcm9tLCB0bywgb3B0aW9ucywgdHlwZSkge1xyXG4gICAgLy8gU2hhcmVkIG1hcmtlcnMgKGFjcm9zcyBsaW5rZWQgZG9jdW1lbnRzKSBhcmUgaGFuZGxlZCBzZXBhcmF0ZWx5XHJcbiAgICAvLyAobWFya1RleHRTaGFyZWQgd2lsbCBjYWxsIG91dCB0byB0aGlzIGFnYWluLCBvbmNlIHBlclxyXG4gICAgLy8gZG9jdW1lbnQpLlxyXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zaGFyZWQpIHJldHVybiBtYXJrVGV4dFNoYXJlZChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKTtcclxuICAgIC8vIEVuc3VyZSB3ZSBhcmUgaW4gYW4gb3BlcmF0aW9uLlxyXG4gICAgaWYgKGRvYy5jbSAmJiAhZG9jLmNtLmN1ck9wKSByZXR1cm4gb3BlcmF0aW9uKGRvYy5jbSwgbWFya1RleHQpKGRvYywgZnJvbSwgdG8sIG9wdGlvbnMsIHR5cGUpO1xyXG5cclxuICAgIHZhciBtYXJrZXIgPSBuZXcgVGV4dE1hcmtlcihkb2MsIHR5cGUpLCBkaWZmID0gY21wKGZyb20sIHRvKTtcclxuICAgIGlmIChvcHRpb25zKSBjb3B5T2JqKG9wdGlvbnMsIG1hcmtlciwgZmFsc2UpO1xyXG4gICAgLy8gRG9uJ3QgY29ubmVjdCBlbXB0eSBtYXJrZXJzIHVubGVzcyBjbGVhcldoZW5FbXB0eSBpcyBmYWxzZVxyXG4gICAgaWYgKGRpZmYgPiAwIHx8IGRpZmYgPT0gMCAmJiBtYXJrZXIuY2xlYXJXaGVuRW1wdHkgIT09IGZhbHNlKVxyXG4gICAgICByZXR1cm4gbWFya2VyO1xyXG4gICAgaWYgKG1hcmtlci5yZXBsYWNlZFdpdGgpIHtcclxuICAgICAgLy8gU2hvd2luZyB1cCBhcyBhIHdpZGdldCBpbXBsaWVzIGNvbGxhcHNlZCAod2lkZ2V0IHJlcGxhY2VzIHRleHQpXHJcbiAgICAgIG1hcmtlci5jb2xsYXBzZWQgPSB0cnVlO1xyXG4gICAgICBtYXJrZXIud2lkZ2V0Tm9kZSA9IGVsdChcInNwYW5cIiwgW21hcmtlci5yZXBsYWNlZFdpdGhdLCBcIkNvZGVNaXJyb3Itd2lkZ2V0XCIpO1xyXG4gICAgICBpZiAoIW9wdGlvbnMuaGFuZGxlTW91c2VFdmVudHMpIG1hcmtlci53aWRnZXROb2RlLnNldEF0dHJpYnV0ZShcImNtLWlnbm9yZS1ldmVudHNcIiwgXCJ0cnVlXCIpO1xyXG4gICAgICBpZiAob3B0aW9ucy5pbnNlcnRMZWZ0KSBtYXJrZXIud2lkZ2V0Tm9kZS5pbnNlcnRMZWZ0ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChtYXJrZXIuY29sbGFwc2VkKSB7XHJcbiAgICAgIGlmIChjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlKGRvYywgZnJvbS5saW5lLCBmcm9tLCB0bywgbWFya2VyKSB8fFxyXG4gICAgICAgICAgZnJvbS5saW5lICE9IHRvLmxpbmUgJiYgY29uZmxpY3RpbmdDb2xsYXBzZWRSYW5nZShkb2MsIHRvLmxpbmUsIGZyb20sIHRvLCBtYXJrZXIpKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluc2VydGluZyBjb2xsYXBzZWQgbWFya2VyIHBhcnRpYWxseSBvdmVybGFwcGluZyBhbiBleGlzdGluZyBvbmVcIik7XHJcbiAgICAgIHNhd0NvbGxhcHNlZFNwYW5zID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobWFya2VyLmFkZFRvSGlzdG9yeSlcclxuICAgICAgYWRkQ2hhbmdlVG9IaXN0b3J5KGRvYywge2Zyb206IGZyb20sIHRvOiB0bywgb3JpZ2luOiBcIm1hcmtUZXh0XCJ9LCBkb2Muc2VsLCBOYU4pO1xyXG5cclxuICAgIHZhciBjdXJMaW5lID0gZnJvbS5saW5lLCBjbSA9IGRvYy5jbSwgdXBkYXRlTWF4TGluZTtcclxuICAgIGRvYy5pdGVyKGN1ckxpbmUsIHRvLmxpbmUgKyAxLCBmdW5jdGlvbihsaW5lKSB7XHJcbiAgICAgIGlmIChjbSAmJiBtYXJrZXIuY29sbGFwc2VkICYmICFjbS5vcHRpb25zLmxpbmVXcmFwcGluZyAmJiB2aXN1YWxMaW5lKGxpbmUpID09IGNtLmRpc3BsYXkubWF4TGluZSlcclxuICAgICAgICB1cGRhdGVNYXhMaW5lID0gdHJ1ZTtcclxuICAgICAgaWYgKG1hcmtlci5jb2xsYXBzZWQgJiYgY3VyTGluZSAhPSBmcm9tLmxpbmUpIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgMCk7XHJcbiAgICAgIGFkZE1hcmtlZFNwYW4obGluZSwgbmV3IE1hcmtlZFNwYW4obWFya2VyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckxpbmUgPT0gZnJvbS5saW5lID8gZnJvbS5jaCA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyTGluZSA9PSB0by5saW5lID8gdG8uY2ggOiBudWxsKSk7XHJcbiAgICAgICsrY3VyTGluZTtcclxuICAgIH0pO1xyXG4gICAgLy8gbGluZUlzSGlkZGVuIGRlcGVuZHMgb24gdGhlIHByZXNlbmNlIG9mIHRoZSBzcGFucywgc28gbmVlZHMgYSBzZWNvbmQgcGFzc1xyXG4gICAgaWYgKG1hcmtlci5jb2xsYXBzZWQpIGRvYy5pdGVyKGZyb20ubGluZSwgdG8ubGluZSArIDEsIGZ1bmN0aW9uKGxpbmUpIHtcclxuICAgICAgaWYgKGxpbmVJc0hpZGRlbihkb2MsIGxpbmUpKSB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIDApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKG1hcmtlci5jbGVhck9uRW50ZXIpIG9uKG1hcmtlciwgXCJiZWZvcmVDdXJzb3JFbnRlclwiLCBmdW5jdGlvbigpIHsgbWFya2VyLmNsZWFyKCk7IH0pO1xyXG5cclxuICAgIGlmIChtYXJrZXIucmVhZE9ubHkpIHtcclxuICAgICAgc2F3UmVhZE9ubHlTcGFucyA9IHRydWU7XHJcbiAgICAgIGlmIChkb2MuaGlzdG9yeS5kb25lLmxlbmd0aCB8fCBkb2MuaGlzdG9yeS51bmRvbmUubGVuZ3RoKVxyXG4gICAgICAgIGRvYy5jbGVhckhpc3RvcnkoKTtcclxuICAgIH1cclxuICAgIGlmIChtYXJrZXIuY29sbGFwc2VkKSB7XHJcbiAgICAgIG1hcmtlci5pZCA9ICsrbmV4dE1hcmtlcklkO1xyXG4gICAgICBtYXJrZXIuYXRvbWljID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChjbSkge1xyXG4gICAgICAvLyBTeW5jIGVkaXRvciBzdGF0ZVxyXG4gICAgICBpZiAodXBkYXRlTWF4TGluZSkgY20uY3VyT3AudXBkYXRlTWF4TGluZSA9IHRydWU7XHJcbiAgICAgIGlmIChtYXJrZXIuY29sbGFwc2VkKVxyXG4gICAgICAgIHJlZ0NoYW5nZShjbSwgZnJvbS5saW5lLCB0by5saW5lICsgMSk7XHJcbiAgICAgIGVsc2UgaWYgKG1hcmtlci5jbGFzc05hbWUgfHwgbWFya2VyLnRpdGxlIHx8IG1hcmtlci5zdGFydFN0eWxlIHx8IG1hcmtlci5lbmRTdHlsZSB8fCBtYXJrZXIuY3NzKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSBmcm9tLmxpbmU7IGkgPD0gdG8ubGluZTsgaSsrKSByZWdMaW5lQ2hhbmdlKGNtLCBpLCBcInRleHRcIik7XHJcbiAgICAgIGlmIChtYXJrZXIuYXRvbWljKSByZUNoZWNrU2VsZWN0aW9uKGNtLmRvYyk7XHJcbiAgICAgIHNpZ25hbExhdGVyKGNtLCBcIm1hcmtlckFkZGVkXCIsIGNtLCBtYXJrZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1hcmtlcjtcclxuICB9XHJcblxyXG4gIC8vIFNIQVJFRCBURVhUTUFSS0VSU1xyXG5cclxuICAvLyBBIHNoYXJlZCBtYXJrZXIgc3BhbnMgbXVsdGlwbGUgbGlua2VkIGRvY3VtZW50cy4gSXQgaXNcclxuICAvLyBpbXBsZW1lbnRlZCBhcyBhIG1ldGEtbWFya2VyLW9iamVjdCBjb250cm9sbGluZyBtdWx0aXBsZSBub3JtYWxcclxuICAvLyBtYXJrZXJzLlxyXG4gIHZhciBTaGFyZWRUZXh0TWFya2VyID0gQ29kZU1pcnJvci5TaGFyZWRUZXh0TWFya2VyID0gZnVuY3Rpb24obWFya2VycywgcHJpbWFyeSkge1xyXG4gICAgdGhpcy5tYXJrZXJzID0gbWFya2VycztcclxuICAgIHRoaXMucHJpbWFyeSA9IHByaW1hcnk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyArK2kpXHJcbiAgICAgIG1hcmtlcnNbaV0ucGFyZW50ID0gdGhpcztcclxuICB9O1xyXG4gIGV2ZW50TWl4aW4oU2hhcmVkVGV4dE1hcmtlcik7XHJcblxyXG4gIFNoYXJlZFRleHRNYXJrZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5leHBsaWNpdGx5Q2xlYXJlZCkgcmV0dXJuO1xyXG4gICAgdGhpcy5leHBsaWNpdGx5Q2xlYXJlZCA9IHRydWU7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWFya2Vycy5sZW5ndGg7ICsraSlcclxuICAgICAgdGhpcy5tYXJrZXJzW2ldLmNsZWFyKCk7XHJcbiAgICBzaWduYWxMYXRlcih0aGlzLCBcImNsZWFyXCIpO1xyXG4gIH07XHJcbiAgU2hhcmVkVGV4dE1hcmtlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHNpZGUsIGxpbmVPYmopIHtcclxuICAgIHJldHVybiB0aGlzLnByaW1hcnkuZmluZChzaWRlLCBsaW5lT2JqKTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBtYXJrVGV4dFNoYXJlZChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB7XHJcbiAgICBvcHRpb25zID0gY29weU9iaihvcHRpb25zKTtcclxuICAgIG9wdGlvbnMuc2hhcmVkID0gZmFsc2U7XHJcbiAgICB2YXIgbWFya2VycyA9IFttYXJrVGV4dChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKV0sIHByaW1hcnkgPSBtYXJrZXJzWzBdO1xyXG4gICAgdmFyIHdpZGdldCA9IG9wdGlvbnMud2lkZ2V0Tm9kZTtcclxuICAgIGxpbmtlZERvY3MoZG9jLCBmdW5jdGlvbihkb2MpIHtcclxuICAgICAgaWYgKHdpZGdldCkgb3B0aW9ucy53aWRnZXROb2RlID0gd2lkZ2V0LmNsb25lTm9kZSh0cnVlKTtcclxuICAgICAgbWFya2Vycy5wdXNoKG1hcmtUZXh0KGRvYywgY2xpcFBvcyhkb2MsIGZyb20pLCBjbGlwUG9zKGRvYywgdG8pLCBvcHRpb25zLCB0eXBlKSk7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLmxpbmtlZC5sZW5ndGg7ICsraSlcclxuICAgICAgICBpZiAoZG9jLmxpbmtlZFtpXS5pc1BhcmVudCkgcmV0dXJuO1xyXG4gICAgICBwcmltYXJ5ID0gbHN0KG1hcmtlcnMpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbmV3IFNoYXJlZFRleHRNYXJrZXIobWFya2VycywgcHJpbWFyeSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmaW5kU2hhcmVkTWFya2Vycyhkb2MpIHtcclxuICAgIHJldHVybiBkb2MuZmluZE1hcmtzKFBvcyhkb2MuZmlyc3QsIDApLCBkb2MuY2xpcFBvcyhQb3MoZG9jLmxhc3RMaW5lKCkpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKG0pIHsgcmV0dXJuIG0ucGFyZW50OyB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNvcHlTaGFyZWRNYXJrZXJzKGRvYywgbWFya2Vycykge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzW2ldLCBwb3MgPSBtYXJrZXIuZmluZCgpO1xyXG4gICAgICB2YXIgbUZyb20gPSBkb2MuY2xpcFBvcyhwb3MuZnJvbSksIG1UbyA9IGRvYy5jbGlwUG9zKHBvcy50byk7XHJcbiAgICAgIGlmIChjbXAobUZyb20sIG1UbykpIHtcclxuICAgICAgICB2YXIgc3ViTWFyayA9IG1hcmtUZXh0KGRvYywgbUZyb20sIG1UbywgbWFya2VyLnByaW1hcnksIG1hcmtlci5wcmltYXJ5LnR5cGUpO1xyXG4gICAgICAgIG1hcmtlci5tYXJrZXJzLnB1c2goc3ViTWFyayk7XHJcbiAgICAgICAgc3ViTWFyay5wYXJlbnQgPSBtYXJrZXI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGRldGFjaFNoYXJlZE1hcmtlcnMobWFya2Vycykge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzW2ldLCBsaW5rZWQgPSBbbWFya2VyLnByaW1hcnkuZG9jXTs7XHJcbiAgICAgIGxpbmtlZERvY3MobWFya2VyLnByaW1hcnkuZG9jLCBmdW5jdGlvbihkKSB7IGxpbmtlZC5wdXNoKGQpOyB9KTtcclxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXJrZXIubWFya2Vycy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIHZhciBzdWJNYXJrZXIgPSBtYXJrZXIubWFya2Vyc1tqXTtcclxuICAgICAgICBpZiAoaW5kZXhPZihsaW5rZWQsIHN1Yk1hcmtlci5kb2MpID09IC0xKSB7XHJcbiAgICAgICAgICBzdWJNYXJrZXIucGFyZW50ID0gbnVsbDtcclxuICAgICAgICAgIG1hcmtlci5tYXJrZXJzLnNwbGljZShqLS0sIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gVEVYVE1BUktFUiBTUEFOU1xyXG5cclxuICBmdW5jdGlvbiBNYXJrZWRTcGFuKG1hcmtlciwgZnJvbSwgdG8pIHtcclxuICAgIHRoaXMubWFya2VyID0gbWFya2VyO1xyXG4gICAgdGhpcy5mcm9tID0gZnJvbTsgdGhpcy50byA9IHRvO1xyXG4gIH1cclxuXHJcbiAgLy8gU2VhcmNoIGFuIGFycmF5IG9mIHNwYW5zIGZvciBhIHNwYW4gbWF0Y2hpbmcgdGhlIGdpdmVuIG1hcmtlci5cclxuICBmdW5jdGlvbiBnZXRNYXJrZWRTcGFuRm9yKHNwYW5zLCBtYXJrZXIpIHtcclxuICAgIGlmIChzcGFucykgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSkge1xyXG4gICAgICB2YXIgc3BhbiA9IHNwYW5zW2ldO1xyXG4gICAgICBpZiAoc3Bhbi5tYXJrZXIgPT0gbWFya2VyKSByZXR1cm4gc3BhbjtcclxuICAgIH1cclxuICB9XHJcbiAgLy8gUmVtb3ZlIGEgc3BhbiBmcm9tIGFuIGFycmF5LCByZXR1cm5pbmcgdW5kZWZpbmVkIGlmIG5vIHNwYW5zIGFyZVxyXG4gIC8vIGxlZnQgKHdlIGRvbid0IHN0b3JlIGFycmF5cyBmb3IgbGluZXMgd2l0aG91dCBzcGFucykuXHJcbiAgZnVuY3Rpb24gcmVtb3ZlTWFya2VkU3BhbihzcGFucywgc3Bhbikge1xyXG4gICAgZm9yICh2YXIgciwgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSlcclxuICAgICAgaWYgKHNwYW5zW2ldICE9IHNwYW4pIChyIHx8IChyID0gW10pKS5wdXNoKHNwYW5zW2ldKTtcclxuICAgIHJldHVybiByO1xyXG4gIH1cclxuICAvLyBBZGQgYSBzcGFuIHRvIGEgbGluZS5cclxuICBmdW5jdGlvbiBhZGRNYXJrZWRTcGFuKGxpbmUsIHNwYW4pIHtcclxuICAgIGxpbmUubWFya2VkU3BhbnMgPSBsaW5lLm1hcmtlZFNwYW5zID8gbGluZS5tYXJrZWRTcGFucy5jb25jYXQoW3NwYW5dKSA6IFtzcGFuXTtcclxuICAgIHNwYW4ubWFya2VyLmF0dGFjaExpbmUobGluZSk7XHJcbiAgfVxyXG5cclxuICAvLyBVc2VkIGZvciB0aGUgYWxnb3JpdGhtIHRoYXQgYWRqdXN0cyBtYXJrZXJzIGZvciBhIGNoYW5nZSBpbiB0aGVcclxuICAvLyBkb2N1bWVudC4gVGhlc2UgZnVuY3Rpb25zIGN1dCBhbiBhcnJheSBvZiBzcGFucyBhdCBhIGdpdmVuXHJcbiAgLy8gY2hhcmFjdGVyIHBvc2l0aW9uLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgcmVtYWluaW5nIGNodW5rcyAob3JcclxuICAvLyB1bmRlZmluZWQgaWYgbm90aGluZyByZW1haW5zKS5cclxuICBmdW5jdGlvbiBtYXJrZWRTcGFuc0JlZm9yZShvbGQsIHN0YXJ0Q2gsIGlzSW5zZXJ0KSB7XHJcbiAgICBpZiAob2xkKSBmb3IgKHZhciBpID0gMCwgbnc7IGkgPCBvbGQubGVuZ3RoOyArK2kpIHtcclxuICAgICAgdmFyIHNwYW4gPSBvbGRbaV0sIG1hcmtlciA9IHNwYW4ubWFya2VyO1xyXG4gICAgICB2YXIgc3RhcnRzQmVmb3JlID0gc3Bhbi5mcm9tID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVMZWZ0ID8gc3Bhbi5mcm9tIDw9IHN0YXJ0Q2ggOiBzcGFuLmZyb20gPCBzdGFydENoKTtcclxuICAgICAgaWYgKHN0YXJ0c0JlZm9yZSB8fCBzcGFuLmZyb20gPT0gc3RhcnRDaCAmJiBtYXJrZXIudHlwZSA9PSBcImJvb2ttYXJrXCIgJiYgKCFpc0luc2VydCB8fCAhc3Bhbi5tYXJrZXIuaW5zZXJ0TGVmdCkpIHtcclxuICAgICAgICB2YXIgZW5kc0FmdGVyID0gc3Bhbi50byA9PSBudWxsIHx8IChtYXJrZXIuaW5jbHVzaXZlUmlnaHQgPyBzcGFuLnRvID49IHN0YXJ0Q2ggOiBzcGFuLnRvID4gc3RhcnRDaCk7XHJcbiAgICAgICAgKG53IHx8IChudyA9IFtdKSkucHVzaChuZXcgTWFya2VkU3BhbihtYXJrZXIsIHNwYW4uZnJvbSwgZW5kc0FmdGVyID8gbnVsbCA6IHNwYW4udG8pKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG53O1xyXG4gIH1cclxuICBmdW5jdGlvbiBtYXJrZWRTcGFuc0FmdGVyKG9sZCwgZW5kQ2gsIGlzSW5zZXJ0KSB7XHJcbiAgICBpZiAob2xkKSBmb3IgKHZhciBpID0gMCwgbnc7IGkgPCBvbGQubGVuZ3RoOyArK2kpIHtcclxuICAgICAgdmFyIHNwYW4gPSBvbGRbaV0sIG1hcmtlciA9IHNwYW4ubWFya2VyO1xyXG4gICAgICB2YXIgZW5kc0FmdGVyID0gc3Bhbi50byA9PSBudWxsIHx8IChtYXJrZXIuaW5jbHVzaXZlUmlnaHQgPyBzcGFuLnRvID49IGVuZENoIDogc3Bhbi50byA+IGVuZENoKTtcclxuICAgICAgaWYgKGVuZHNBZnRlciB8fCBzcGFuLmZyb20gPT0gZW5kQ2ggJiYgbWFya2VyLnR5cGUgPT0gXCJib29rbWFya1wiICYmICghaXNJbnNlcnQgfHwgc3Bhbi5tYXJrZXIuaW5zZXJ0TGVmdCkpIHtcclxuICAgICAgICB2YXIgc3RhcnRzQmVmb3JlID0gc3Bhbi5mcm9tID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVMZWZ0ID8gc3Bhbi5mcm9tIDw9IGVuZENoIDogc3Bhbi5mcm9tIDwgZW5kQ2gpO1xyXG4gICAgICAgIChudyB8fCAobncgPSBbXSkpLnB1c2gobmV3IE1hcmtlZFNwYW4obWFya2VyLCBzdGFydHNCZWZvcmUgPyBudWxsIDogc3Bhbi5mcm9tIC0gZW5kQ2gsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnRvID09IG51bGwgPyBudWxsIDogc3Bhbi50byAtIGVuZENoKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudztcclxuICB9XHJcblxyXG4gIC8vIEdpdmVuIGEgY2hhbmdlIG9iamVjdCwgY29tcHV0ZSB0aGUgbmV3IHNldCBvZiBtYXJrZXIgc3BhbnMgdGhhdFxyXG4gIC8vIGNvdmVyIHRoZSBsaW5lIGluIHdoaWNoIHRoZSBjaGFuZ2UgdG9vayBwbGFjZS4gUmVtb3ZlcyBzcGFuc1xyXG4gIC8vIGVudGlyZWx5IHdpdGhpbiB0aGUgY2hhbmdlLCByZWNvbm5lY3RzIHNwYW5zIGJlbG9uZ2luZyB0byB0aGVcclxuICAvLyBzYW1lIG1hcmtlciB0aGF0IGFwcGVhciBvbiBib3RoIHNpZGVzIG9mIHRoZSBjaGFuZ2UsIGFuZCBjdXRzIG9mZlxyXG4gIC8vIHNwYW5zIHBhcnRpYWxseSB3aXRoaW4gdGhlIGNoYW5nZS4gUmV0dXJucyBhbiBhcnJheSBvZiBzcGFuXHJcbiAgLy8gYXJyYXlzIHdpdGggb25lIGVsZW1lbnQgZm9yIGVhY2ggbGluZSBpbiAoYWZ0ZXIpIHRoZSBjaGFuZ2UuXHJcbiAgZnVuY3Rpb24gc3RyZXRjaFNwYW5zT3ZlckNoYW5nZShkb2MsIGNoYW5nZSkge1xyXG4gICAgaWYgKGNoYW5nZS5mdWxsKSByZXR1cm4gbnVsbDtcclxuICAgIHZhciBvbGRGaXJzdCA9IGlzTGluZShkb2MsIGNoYW5nZS5mcm9tLmxpbmUpICYmIGdldExpbmUoZG9jLCBjaGFuZ2UuZnJvbS5saW5lKS5tYXJrZWRTcGFucztcclxuICAgIHZhciBvbGRMYXN0ID0gaXNMaW5lKGRvYywgY2hhbmdlLnRvLmxpbmUpICYmIGdldExpbmUoZG9jLCBjaGFuZ2UudG8ubGluZSkubWFya2VkU3BhbnM7XHJcbiAgICBpZiAoIW9sZEZpcnN0ICYmICFvbGRMYXN0KSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICB2YXIgc3RhcnRDaCA9IGNoYW5nZS5mcm9tLmNoLCBlbmRDaCA9IGNoYW5nZS50by5jaCwgaXNJbnNlcnQgPSBjbXAoY2hhbmdlLmZyb20sIGNoYW5nZS50bykgPT0gMDtcclxuICAgIC8vIEdldCB0aGUgc3BhbnMgdGhhdCAnc3RpY2sgb3V0JyBvbiBib3RoIHNpZGVzXHJcbiAgICB2YXIgZmlyc3QgPSBtYXJrZWRTcGFuc0JlZm9yZShvbGRGaXJzdCwgc3RhcnRDaCwgaXNJbnNlcnQpO1xyXG4gICAgdmFyIGxhc3QgPSBtYXJrZWRTcGFuc0FmdGVyKG9sZExhc3QsIGVuZENoLCBpc0luc2VydCk7XHJcblxyXG4gICAgLy8gTmV4dCwgbWVyZ2UgdGhvc2UgdHdvIGVuZHNcclxuICAgIHZhciBzYW1lTGluZSA9IGNoYW5nZS50ZXh0Lmxlbmd0aCA9PSAxLCBvZmZzZXQgPSBsc3QoY2hhbmdlLnRleHQpLmxlbmd0aCArIChzYW1lTGluZSA/IHN0YXJ0Q2ggOiAwKTtcclxuICAgIGlmIChmaXJzdCkge1xyXG4gICAgICAvLyBGaXggdXAgLnRvIHByb3BlcnRpZXMgb2YgZmlyc3RcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaXJzdC5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHZhciBzcGFuID0gZmlyc3RbaV07XHJcbiAgICAgICAgaWYgKHNwYW4udG8gPT0gbnVsbCkge1xyXG4gICAgICAgICAgdmFyIGZvdW5kID0gZ2V0TWFya2VkU3BhbkZvcihsYXN0LCBzcGFuLm1hcmtlcik7XHJcbiAgICAgICAgICBpZiAoIWZvdW5kKSBzcGFuLnRvID0gc3RhcnRDaDtcclxuICAgICAgICAgIGVsc2UgaWYgKHNhbWVMaW5lKSBzcGFuLnRvID0gZm91bmQudG8gPT0gbnVsbCA/IG51bGwgOiBmb3VuZC50byArIG9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChsYXN0KSB7XHJcbiAgICAgIC8vIEZpeCB1cCAuZnJvbSBpbiBsYXN0IChvciBtb3ZlIHRoZW0gaW50byBmaXJzdCBpbiBjYXNlIG9mIHNhbWVMaW5lKVxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3QubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICB2YXIgc3BhbiA9IGxhc3RbaV07XHJcbiAgICAgICAgaWYgKHNwYW4udG8gIT0gbnVsbCkgc3Bhbi50byArPSBvZmZzZXQ7XHJcbiAgICAgICAgaWYgKHNwYW4uZnJvbSA9PSBudWxsKSB7XHJcbiAgICAgICAgICB2YXIgZm91bmQgPSBnZXRNYXJrZWRTcGFuRm9yKGZpcnN0LCBzcGFuLm1hcmtlcik7XHJcbiAgICAgICAgICBpZiAoIWZvdW5kKSB7XHJcbiAgICAgICAgICAgIHNwYW4uZnJvbSA9IG9mZnNldDtcclxuICAgICAgICAgICAgaWYgKHNhbWVMaW5lKSAoZmlyc3QgfHwgKGZpcnN0ID0gW10pKS5wdXNoKHNwYW4pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzcGFuLmZyb20gKz0gb2Zmc2V0O1xyXG4gICAgICAgICAgaWYgKHNhbWVMaW5lKSAoZmlyc3QgfHwgKGZpcnN0ID0gW10pKS5wdXNoKHNwYW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gTWFrZSBzdXJlIHdlIGRpZG4ndCBjcmVhdGUgYW55IHplcm8tbGVuZ3RoIHNwYW5zXHJcbiAgICBpZiAoZmlyc3QpIGZpcnN0ID0gY2xlYXJFbXB0eVNwYW5zKGZpcnN0KTtcclxuICAgIGlmIChsYXN0ICYmIGxhc3QgIT0gZmlyc3QpIGxhc3QgPSBjbGVhckVtcHR5U3BhbnMobGFzdCk7XHJcblxyXG4gICAgdmFyIG5ld01hcmtlcnMgPSBbZmlyc3RdO1xyXG4gICAgaWYgKCFzYW1lTGluZSkge1xyXG4gICAgICAvLyBGaWxsIGdhcCB3aXRoIHdob2xlLWxpbmUtc3BhbnNcclxuICAgICAgdmFyIGdhcCA9IGNoYW5nZS50ZXh0Lmxlbmd0aCAtIDIsIGdhcE1hcmtlcnM7XHJcbiAgICAgIGlmIChnYXAgPiAwICYmIGZpcnN0KVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlyc3QubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICBpZiAoZmlyc3RbaV0udG8gPT0gbnVsbClcclxuICAgICAgICAgICAgKGdhcE1hcmtlcnMgfHwgKGdhcE1hcmtlcnMgPSBbXSkpLnB1c2gobmV3IE1hcmtlZFNwYW4oZmlyc3RbaV0ubWFya2VyLCBudWxsLCBudWxsKSk7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2FwOyArK2kpXHJcbiAgICAgICAgbmV3TWFya2Vycy5wdXNoKGdhcE1hcmtlcnMpO1xyXG4gICAgICBuZXdNYXJrZXJzLnB1c2gobGFzdCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3TWFya2VycztcclxuICB9XHJcblxyXG4gIC8vIFJlbW92ZSBzcGFucyB0aGF0IGFyZSBlbXB0eSBhbmQgZG9uJ3QgaGF2ZSBhIGNsZWFyV2hlbkVtcHR5XHJcbiAgLy8gb3B0aW9uIG9mIGZhbHNlLlxyXG4gIGZ1bmN0aW9uIGNsZWFyRW1wdHlTcGFucyhzcGFucykge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSkge1xyXG4gICAgICB2YXIgc3BhbiA9IHNwYW5zW2ldO1xyXG4gICAgICBpZiAoc3Bhbi5mcm9tICE9IG51bGwgJiYgc3Bhbi5mcm9tID09IHNwYW4udG8gJiYgc3Bhbi5tYXJrZXIuY2xlYXJXaGVuRW1wdHkgIT09IGZhbHNlKVxyXG4gICAgICAgIHNwYW5zLnNwbGljZShpLS0sIDEpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFzcGFucy5sZW5ndGgpIHJldHVybiBudWxsO1xyXG4gICAgcmV0dXJuIHNwYW5zO1xyXG4gIH1cclxuXHJcbiAgLy8gVXNlZCBmb3IgdW4vcmUtZG9pbmcgY2hhbmdlcyBmcm9tIHRoZSBoaXN0b3J5LiBDb21iaW5lcyB0aGVcclxuICAvLyByZXN1bHQgb2YgY29tcHV0aW5nIHRoZSBleGlzdGluZyBzcGFucyB3aXRoIHRoZSBzZXQgb2Ygc3BhbnMgdGhhdFxyXG4gIC8vIGV4aXN0ZWQgaW4gdGhlIGhpc3RvcnkgKHNvIHRoYXQgZGVsZXRpbmcgYXJvdW5kIGEgc3BhbiBhbmQgdGhlblxyXG4gIC8vIHVuZG9pbmcgYnJpbmdzIGJhY2sgdGhlIHNwYW4pLlxyXG4gIGZ1bmN0aW9uIG1lcmdlT2xkU3BhbnMoZG9jLCBjaGFuZ2UpIHtcclxuICAgIHZhciBvbGQgPSBnZXRPbGRTcGFucyhkb2MsIGNoYW5nZSk7XHJcbiAgICB2YXIgc3RyZXRjaGVkID0gc3RyZXRjaFNwYW5zT3ZlckNoYW5nZShkb2MsIGNoYW5nZSk7XHJcbiAgICBpZiAoIW9sZCkgcmV0dXJuIHN0cmV0Y2hlZDtcclxuICAgIGlmICghc3RyZXRjaGVkKSByZXR1cm4gb2xkO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIHZhciBvbGRDdXIgPSBvbGRbaV0sIHN0cmV0Y2hDdXIgPSBzdHJldGNoZWRbaV07XHJcbiAgICAgIGlmIChvbGRDdXIgJiYgc3RyZXRjaEN1cikge1xyXG4gICAgICAgIHNwYW5zOiBmb3IgKHZhciBqID0gMDsgaiA8IHN0cmV0Y2hDdXIubGVuZ3RoOyArK2opIHtcclxuICAgICAgICAgIHZhciBzcGFuID0gc3RyZXRjaEN1cltqXTtcclxuICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb2xkQ3VyLmxlbmd0aDsgKytrKVxyXG4gICAgICAgICAgICBpZiAob2xkQ3VyW2tdLm1hcmtlciA9PSBzcGFuLm1hcmtlcikgY29udGludWUgc3BhbnM7XHJcbiAgICAgICAgICBvbGRDdXIucHVzaChzcGFuKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoc3RyZXRjaEN1cikge1xyXG4gICAgICAgIG9sZFtpXSA9IHN0cmV0Y2hDdXI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvbGQ7XHJcbiAgfVxyXG5cclxuICAvLyBVc2VkIHRvICdjbGlwJyBvdXQgcmVhZE9ubHkgcmFuZ2VzIHdoZW4gbWFraW5nIGEgY2hhbmdlLlxyXG4gIGZ1bmN0aW9uIHJlbW92ZVJlYWRPbmx5UmFuZ2VzKGRvYywgZnJvbSwgdG8pIHtcclxuICAgIHZhciBtYXJrZXJzID0gbnVsbDtcclxuICAgIGRvYy5pdGVyKGZyb20ubGluZSwgdG8ubGluZSArIDEsIGZ1bmN0aW9uKGxpbmUpIHtcclxuICAgICAgaWYgKGxpbmUubWFya2VkU3BhbnMpIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5tYXJrZWRTcGFucy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHZhciBtYXJrID0gbGluZS5tYXJrZWRTcGFuc1tpXS5tYXJrZXI7XHJcbiAgICAgICAgaWYgKG1hcmsucmVhZE9ubHkgJiYgKCFtYXJrZXJzIHx8IGluZGV4T2YobWFya2VycywgbWFyaykgPT0gLTEpKVxyXG4gICAgICAgICAgKG1hcmtlcnMgfHwgKG1hcmtlcnMgPSBbXSkpLnB1c2gobWFyayk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgaWYgKCFtYXJrZXJzKSByZXR1cm4gbnVsbDtcclxuICAgIHZhciBwYXJ0cyA9IFt7ZnJvbTogZnJvbSwgdG86IHRvfV07XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgdmFyIG1rID0gbWFya2Vyc1tpXSwgbSA9IG1rLmZpbmQoMCk7XHJcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFydHMubGVuZ3RoOyArK2opIHtcclxuICAgICAgICB2YXIgcCA9IHBhcnRzW2pdO1xyXG4gICAgICAgIGlmIChjbXAocC50bywgbS5mcm9tKSA8IDAgfHwgY21wKHAuZnJvbSwgbS50bykgPiAwKSBjb250aW51ZTtcclxuICAgICAgICB2YXIgbmV3UGFydHMgPSBbaiwgMV0sIGRmcm9tID0gY21wKHAuZnJvbSwgbS5mcm9tKSwgZHRvID0gY21wKHAudG8sIG0udG8pO1xyXG4gICAgICAgIGlmIChkZnJvbSA8IDAgfHwgIW1rLmluY2x1c2l2ZUxlZnQgJiYgIWRmcm9tKVxyXG4gICAgICAgICAgbmV3UGFydHMucHVzaCh7ZnJvbTogcC5mcm9tLCB0bzogbS5mcm9tfSk7XHJcbiAgICAgICAgaWYgKGR0byA+IDAgfHwgIW1rLmluY2x1c2l2ZVJpZ2h0ICYmICFkdG8pXHJcbiAgICAgICAgICBuZXdQYXJ0cy5wdXNoKHtmcm9tOiBtLnRvLCB0bzogcC50b30pO1xyXG4gICAgICAgIHBhcnRzLnNwbGljZS5hcHBseShwYXJ0cywgbmV3UGFydHMpO1xyXG4gICAgICAgIGogKz0gbmV3UGFydHMubGVuZ3RoIC0gMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcnRzO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29ubmVjdCBvciBkaXNjb25uZWN0IHNwYW5zIGZyb20gYSBsaW5lLlxyXG4gIGZ1bmN0aW9uIGRldGFjaE1hcmtlZFNwYW5zKGxpbmUpIHtcclxuICAgIHZhciBzcGFucyA9IGxpbmUubWFya2VkU3BhbnM7XHJcbiAgICBpZiAoIXNwYW5zKSByZXR1cm47XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKVxyXG4gICAgICBzcGFuc1tpXS5tYXJrZXIuZGV0YWNoTGluZShsaW5lKTtcclxuICAgIGxpbmUubWFya2VkU3BhbnMgPSBudWxsO1xyXG4gIH1cclxuICBmdW5jdGlvbiBhdHRhY2hNYXJrZWRTcGFucyhsaW5lLCBzcGFucykge1xyXG4gICAgaWYgKCFzcGFucykgcmV0dXJuO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSlcclxuICAgICAgc3BhbnNbaV0ubWFya2VyLmF0dGFjaExpbmUobGluZSk7XHJcbiAgICBsaW5lLm1hcmtlZFNwYW5zID0gc3BhbnM7XHJcbiAgfVxyXG5cclxuICAvLyBIZWxwZXJzIHVzZWQgd2hlbiBjb21wdXRpbmcgd2hpY2ggb3ZlcmxhcHBpbmcgY29sbGFwc2VkIHNwYW5cclxuICAvLyBjb3VudHMgYXMgdGhlIGxhcmdlciBvbmUuXHJcbiAgZnVuY3Rpb24gZXh0cmFMZWZ0KG1hcmtlcikgeyByZXR1cm4gbWFya2VyLmluY2x1c2l2ZUxlZnQgPyAtMSA6IDA7IH1cclxuICBmdW5jdGlvbiBleHRyYVJpZ2h0KG1hcmtlcikgeyByZXR1cm4gbWFya2VyLmluY2x1c2l2ZVJpZ2h0ID8gMSA6IDA7IH1cclxuXHJcbiAgLy8gUmV0dXJucyBhIG51bWJlciBpbmRpY2F0aW5nIHdoaWNoIG9mIHR3byBvdmVybGFwcGluZyBjb2xsYXBzZWRcclxuICAvLyBzcGFucyBpcyBsYXJnZXIgKGFuZCB0aHVzIGluY2x1ZGVzIHRoZSBvdGhlcikuIEZhbGxzIGJhY2sgdG9cclxuICAvLyBjb21wYXJpbmcgaWRzIHdoZW4gdGhlIHNwYW5zIGNvdmVyIGV4YWN0bHkgdGhlIHNhbWUgcmFuZ2UuXHJcbiAgZnVuY3Rpb24gY29tcGFyZUNvbGxhcHNlZE1hcmtlcnMoYSwgYikge1xyXG4gICAgdmFyIGxlbkRpZmYgPSBhLmxpbmVzLmxlbmd0aCAtIGIubGluZXMubGVuZ3RoO1xyXG4gICAgaWYgKGxlbkRpZmYgIT0gMCkgcmV0dXJuIGxlbkRpZmY7XHJcbiAgICB2YXIgYVBvcyA9IGEuZmluZCgpLCBiUG9zID0gYi5maW5kKCk7XHJcbiAgICB2YXIgZnJvbUNtcCA9IGNtcChhUG9zLmZyb20sIGJQb3MuZnJvbSkgfHwgZXh0cmFMZWZ0KGEpIC0gZXh0cmFMZWZ0KGIpO1xyXG4gICAgaWYgKGZyb21DbXApIHJldHVybiAtZnJvbUNtcDtcclxuICAgIHZhciB0b0NtcCA9IGNtcChhUG9zLnRvLCBiUG9zLnRvKSB8fCBleHRyYVJpZ2h0KGEpIC0gZXh0cmFSaWdodChiKTtcclxuICAgIGlmICh0b0NtcCkgcmV0dXJuIHRvQ21wO1xyXG4gICAgcmV0dXJuIGIuaWQgLSBhLmlkO1xyXG4gIH1cclxuXHJcbiAgLy8gRmluZCBvdXQgd2hldGhlciBhIGxpbmUgZW5kcyBvciBzdGFydHMgaW4gYSBjb2xsYXBzZWQgc3Bhbi4gSWZcclxuICAvLyBzbywgcmV0dXJuIHRoZSBtYXJrZXIgZm9yIHRoYXQgc3Bhbi5cclxuICBmdW5jdGlvbiBjb2xsYXBzZWRTcGFuQXRTaWRlKGxpbmUsIHN0YXJ0KSB7XHJcbiAgICB2YXIgc3BzID0gc2F3Q29sbGFwc2VkU3BhbnMgJiYgbGluZS5tYXJrZWRTcGFucywgZm91bmQ7XHJcbiAgICBpZiAoc3BzKSBmb3IgKHZhciBzcCwgaSA9IDA7IGkgPCBzcHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgc3AgPSBzcHNbaV07XHJcbiAgICAgIGlmIChzcC5tYXJrZXIuY29sbGFwc2VkICYmIChzdGFydCA/IHNwLmZyb20gOiBzcC50bykgPT0gbnVsbCAmJlxyXG4gICAgICAgICAgKCFmb3VuZCB8fCBjb21wYXJlQ29sbGFwc2VkTWFya2Vycyhmb3VuZCwgc3AubWFya2VyKSA8IDApKVxyXG4gICAgICAgIGZvdW5kID0gc3AubWFya2VyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZvdW5kO1xyXG4gIH1cclxuICBmdW5jdGlvbiBjb2xsYXBzZWRTcGFuQXRTdGFydChsaW5lKSB7IHJldHVybiBjb2xsYXBzZWRTcGFuQXRTaWRlKGxpbmUsIHRydWUpOyB9XHJcbiAgZnVuY3Rpb24gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpIHsgcmV0dXJuIGNvbGxhcHNlZFNwYW5BdFNpZGUobGluZSwgZmFsc2UpOyB9XHJcblxyXG4gIC8vIFRlc3Qgd2hldGhlciB0aGVyZSBleGlzdHMgYSBjb2xsYXBzZWQgc3BhbiB0aGF0IHBhcnRpYWxseVxyXG4gIC8vIG92ZXJsYXBzIChjb3ZlcnMgdGhlIHN0YXJ0IG9yIGVuZCwgYnV0IG5vdCBib3RoKSBvZiBhIG5ldyBzcGFuLlxyXG4gIC8vIFN1Y2ggb3ZlcmxhcCBpcyBub3QgYWxsb3dlZC5cclxuICBmdW5jdGlvbiBjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlKGRvYywgbGluZU5vLCBmcm9tLCB0bywgbWFya2VyKSB7XHJcbiAgICB2YXIgbGluZSA9IGdldExpbmUoZG9jLCBsaW5lTm8pO1xyXG4gICAgdmFyIHNwcyA9IHNhd0NvbGxhcHNlZFNwYW5zICYmIGxpbmUubWFya2VkU3BhbnM7XHJcbiAgICBpZiAoc3BzKSBmb3IgKHZhciBpID0gMDsgaSA8IHNwcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICB2YXIgc3AgPSBzcHNbaV07XHJcbiAgICAgIGlmICghc3AubWFya2VyLmNvbGxhcHNlZCkgY29udGludWU7XHJcbiAgICAgIHZhciBmb3VuZCA9IHNwLm1hcmtlci5maW5kKDApO1xyXG4gICAgICB2YXIgZnJvbUNtcCA9IGNtcChmb3VuZC5mcm9tLCBmcm9tKSB8fCBleHRyYUxlZnQoc3AubWFya2VyKSAtIGV4dHJhTGVmdChtYXJrZXIpO1xyXG4gICAgICB2YXIgdG9DbXAgPSBjbXAoZm91bmQudG8sIHRvKSB8fCBleHRyYVJpZ2h0KHNwLm1hcmtlcikgLSBleHRyYVJpZ2h0KG1hcmtlcik7XHJcbiAgICAgIGlmIChmcm9tQ21wID49IDAgJiYgdG9DbXAgPD0gMCB8fCBmcm9tQ21wIDw9IDAgJiYgdG9DbXAgPj0gMCkgY29udGludWU7XHJcbiAgICAgIGlmIChmcm9tQ21wIDw9IDAgJiYgKGNtcChmb3VuZC50bywgZnJvbSkgPiAwIHx8IChzcC5tYXJrZXIuaW5jbHVzaXZlUmlnaHQgJiYgbWFya2VyLmluY2x1c2l2ZUxlZnQpKSB8fFxyXG4gICAgICAgICAgZnJvbUNtcCA+PSAwICYmIChjbXAoZm91bmQuZnJvbSwgdG8pIDwgMCB8fCAoc3AubWFya2VyLmluY2x1c2l2ZUxlZnQgJiYgbWFya2VyLmluY2x1c2l2ZVJpZ2h0KSkpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBBIHZpc3VhbCBsaW5lIGlzIGEgbGluZSBhcyBkcmF3biBvbiB0aGUgc2NyZWVuLiBGb2xkaW5nLCBmb3JcclxuICAvLyBleGFtcGxlLCBjYW4gY2F1c2UgbXVsdGlwbGUgbG9naWNhbCBsaW5lcyB0byBhcHBlYXIgb24gdGhlIHNhbWVcclxuICAvLyB2aXN1YWwgbGluZS4gVGhpcyBmaW5kcyB0aGUgc3RhcnQgb2YgdGhlIHZpc3VhbCBsaW5lIHRoYXQgdGhlXHJcbiAgLy8gZ2l2ZW4gbGluZSBpcyBwYXJ0IG9mICh1c3VhbGx5IHRoYXQgaXMgdGhlIGxpbmUgaXRzZWxmKS5cclxuICBmdW5jdGlvbiB2aXN1YWxMaW5lKGxpbmUpIHtcclxuICAgIHZhciBtZXJnZWQ7XHJcbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0U3RhcnQobGluZSkpXHJcbiAgICAgIGxpbmUgPSBtZXJnZWQuZmluZCgtMSwgdHJ1ZSkubGluZTtcclxuICAgIHJldHVybiBsaW5lO1xyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJucyBhbiBhcnJheSBvZiBsb2dpY2FsIGxpbmVzIHRoYXQgY29udGludWUgdGhlIHZpc3VhbCBsaW5lXHJcbiAgLy8gc3RhcnRlZCBieSB0aGUgYXJndW1lbnQsIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBhcmUgbm8gc3VjaCBsaW5lcy5cclxuICBmdW5jdGlvbiB2aXN1YWxMaW5lQ29udGludWVkKGxpbmUpIHtcclxuICAgIHZhciBtZXJnZWQsIGxpbmVzO1xyXG4gICAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdEVuZChsaW5lKSkge1xyXG4gICAgICBsaW5lID0gbWVyZ2VkLmZpbmQoMSwgdHJ1ZSkubGluZTtcclxuICAgICAgKGxpbmVzIHx8IChsaW5lcyA9IFtdKSkucHVzaChsaW5lKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsaW5lcztcclxuICB9XHJcblxyXG4gIC8vIEdldCB0aGUgbGluZSBudW1iZXIgb2YgdGhlIHN0YXJ0IG9mIHRoZSB2aXN1YWwgbGluZSB0aGF0IHRoZVxyXG4gIC8vIGdpdmVuIGxpbmUgbnVtYmVyIGlzIHBhcnQgb2YuXHJcbiAgZnVuY3Rpb24gdmlzdWFsTGluZU5vKGRvYywgbGluZU4pIHtcclxuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIGxpbmVOKSwgdmlzID0gdmlzdWFsTGluZShsaW5lKTtcclxuICAgIGlmIChsaW5lID09IHZpcykgcmV0dXJuIGxpbmVOO1xyXG4gICAgcmV0dXJuIGxpbmVObyh2aXMpO1xyXG4gIH1cclxuICAvLyBHZXQgdGhlIGxpbmUgbnVtYmVyIG9mIHRoZSBzdGFydCBvZiB0aGUgbmV4dCB2aXN1YWwgbGluZSBhZnRlclxyXG4gIC8vIHRoZSBnaXZlbiBsaW5lLlxyXG4gIGZ1bmN0aW9uIHZpc3VhbExpbmVFbmRObyhkb2MsIGxpbmVOKSB7XHJcbiAgICBpZiAobGluZU4gPiBkb2MubGFzdExpbmUoKSkgcmV0dXJuIGxpbmVOO1xyXG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgbGluZU4pLCBtZXJnZWQ7XHJcbiAgICBpZiAoIWxpbmVJc0hpZGRlbihkb2MsIGxpbmUpKSByZXR1cm4gbGluZU47XHJcbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpKVxyXG4gICAgICBsaW5lID0gbWVyZ2VkLmZpbmQoMSwgdHJ1ZSkubGluZTtcclxuICAgIHJldHVybiBsaW5lTm8obGluZSkgKyAxO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29tcHV0ZSB3aGV0aGVyIGEgbGluZSBpcyBoaWRkZW4uIExpbmVzIGNvdW50IGFzIGhpZGRlbiB3aGVuIHRoZXlcclxuICAvLyBhcmUgcGFydCBvZiBhIHZpc3VhbCBsaW5lIHRoYXQgc3RhcnRzIHdpdGggYW5vdGhlciBsaW5lLCBvciB3aGVuXHJcbiAgLy8gdGhleSBhcmUgZW50aXJlbHkgY292ZXJlZCBieSBjb2xsYXBzZWQsIG5vbi13aWRnZXQgc3Bhbi5cclxuICBmdW5jdGlvbiBsaW5lSXNIaWRkZW4oZG9jLCBsaW5lKSB7XHJcbiAgICB2YXIgc3BzID0gc2F3Q29sbGFwc2VkU3BhbnMgJiYgbGluZS5tYXJrZWRTcGFucztcclxuICAgIGlmIChzcHMpIGZvciAodmFyIHNwLCBpID0gMDsgaSA8IHNwcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICBzcCA9IHNwc1tpXTtcclxuICAgICAgaWYgKCFzcC5tYXJrZXIuY29sbGFwc2VkKSBjb250aW51ZTtcclxuICAgICAgaWYgKHNwLmZyb20gPT0gbnVsbCkgcmV0dXJuIHRydWU7XHJcbiAgICAgIGlmIChzcC5tYXJrZXIud2lkZ2V0Tm9kZSkgY29udGludWU7XHJcbiAgICAgIGlmIChzcC5mcm9tID09IDAgJiYgc3AubWFya2VyLmluY2x1c2l2ZUxlZnQgJiYgbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBsaW5lLCBzcCkpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGxpbmVJc0hpZGRlbklubmVyKGRvYywgbGluZSwgc3Bhbikge1xyXG4gICAgaWYgKHNwYW4udG8gPT0gbnVsbCkge1xyXG4gICAgICB2YXIgZW5kID0gc3Bhbi5tYXJrZXIuZmluZCgxLCB0cnVlKTtcclxuICAgICAgcmV0dXJuIGxpbmVJc0hpZGRlbklubmVyKGRvYywgZW5kLmxpbmUsIGdldE1hcmtlZFNwYW5Gb3IoZW5kLmxpbmUubWFya2VkU3BhbnMsIHNwYW4ubWFya2VyKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc3Bhbi5tYXJrZXIuaW5jbHVzaXZlUmlnaHQgJiYgc3Bhbi50byA9PSBsaW5lLnRleHQubGVuZ3RoKVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGZvciAodmFyIHNwLCBpID0gMDsgaSA8IGxpbmUubWFya2VkU3BhbnMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgc3AgPSBsaW5lLm1hcmtlZFNwYW5zW2ldO1xyXG4gICAgICBpZiAoc3AubWFya2VyLmNvbGxhcHNlZCAmJiAhc3AubWFya2VyLndpZGdldE5vZGUgJiYgc3AuZnJvbSA9PSBzcGFuLnRvICYmXHJcbiAgICAgICAgICAoc3AudG8gPT0gbnVsbCB8fCBzcC50byAhPSBzcGFuLmZyb20pICYmXHJcbiAgICAgICAgICAoc3AubWFya2VyLmluY2x1c2l2ZUxlZnQgfHwgc3Bhbi5tYXJrZXIuaW5jbHVzaXZlUmlnaHQpICYmXHJcbiAgICAgICAgICBsaW5lSXNIaWRkZW5Jbm5lcihkb2MsIGxpbmUsIHNwKSkgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBMSU5FIFdJREdFVFNcclxuXHJcbiAgLy8gTGluZSB3aWRnZXRzIGFyZSBibG9jayBlbGVtZW50cyBkaXNwbGF5ZWQgYWJvdmUgb3IgYmVsb3cgYSBsaW5lLlxyXG5cclxuICB2YXIgTGluZVdpZGdldCA9IENvZGVNaXJyb3IuTGluZVdpZGdldCA9IGZ1bmN0aW9uKGRvYywgbm9kZSwgb3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMpIGZvciAodmFyIG9wdCBpbiBvcHRpb25zKSBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHQpKVxyXG4gICAgICB0aGlzW29wdF0gPSBvcHRpb25zW29wdF07XHJcbiAgICB0aGlzLmRvYyA9IGRvYztcclxuICAgIHRoaXMubm9kZSA9IG5vZGU7XHJcbiAgfTtcclxuICBldmVudE1peGluKExpbmVXaWRnZXQpO1xyXG5cclxuICBmdW5jdGlvbiBhZGp1c3RTY3JvbGxXaGVuQWJvdmVWaXNpYmxlKGNtLCBsaW5lLCBkaWZmKSB7XHJcbiAgICBpZiAoaGVpZ2h0QXRMaW5lKGxpbmUpIDwgKChjbS5jdXJPcCAmJiBjbS5jdXJPcC5zY3JvbGxUb3ApIHx8IGNtLmRvYy5zY3JvbGxUb3ApKVxyXG4gICAgICBhZGRUb1Njcm9sbFBvcyhjbSwgbnVsbCwgZGlmZik7XHJcbiAgfVxyXG5cclxuICBMaW5lV2lkZ2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGNtID0gdGhpcy5kb2MuY20sIHdzID0gdGhpcy5saW5lLndpZGdldHMsIGxpbmUgPSB0aGlzLmxpbmUsIG5vID0gbGluZU5vKGxpbmUpO1xyXG4gICAgaWYgKG5vID09IG51bGwgfHwgIXdzKSByZXR1cm47XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdzLmxlbmd0aDsgKytpKSBpZiAod3NbaV0gPT0gdGhpcykgd3Muc3BsaWNlKGktLSwgMSk7XHJcbiAgICBpZiAoIXdzLmxlbmd0aCkgbGluZS53aWRnZXRzID0gbnVsbDtcclxuICAgIHZhciBoZWlnaHQgPSB3aWRnZXRIZWlnaHQodGhpcyk7XHJcbiAgICB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIE1hdGgubWF4KDAsIGxpbmUuaGVpZ2h0IC0gaGVpZ2h0KSk7XHJcbiAgICBpZiAoY20pIHJ1bkluT3AoY20sIGZ1bmN0aW9uKCkge1xyXG4gICAgICBhZGp1c3RTY3JvbGxXaGVuQWJvdmVWaXNpYmxlKGNtLCBsaW5lLCAtaGVpZ2h0KTtcclxuICAgICAgcmVnTGluZUNoYW5nZShjbSwgbm8sIFwid2lkZ2V0XCIpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuICBMaW5lV2lkZ2V0LnByb3RvdHlwZS5jaGFuZ2VkID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgb2xkSCA9IHRoaXMuaGVpZ2h0LCBjbSA9IHRoaXMuZG9jLmNtLCBsaW5lID0gdGhpcy5saW5lO1xyXG4gICAgdGhpcy5oZWlnaHQgPSBudWxsO1xyXG4gICAgdmFyIGRpZmYgPSB3aWRnZXRIZWlnaHQodGhpcykgLSBvbGRIO1xyXG4gICAgaWYgKCFkaWZmKSByZXR1cm47XHJcbiAgICB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGxpbmUuaGVpZ2h0ICsgZGlmZik7XHJcbiAgICBpZiAoY20pIHJ1bkluT3AoY20sIGZ1bmN0aW9uKCkge1xyXG4gICAgICBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XHJcbiAgICAgIGFkanVzdFNjcm9sbFdoZW5BYm92ZVZpc2libGUoY20sIGxpbmUsIGRpZmYpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gd2lkZ2V0SGVpZ2h0KHdpZGdldCkge1xyXG4gICAgaWYgKHdpZGdldC5oZWlnaHQgIT0gbnVsbCkgcmV0dXJuIHdpZGdldC5oZWlnaHQ7XHJcbiAgICB2YXIgY20gPSB3aWRnZXQuZG9jLmNtO1xyXG4gICAgaWYgKCFjbSkgcmV0dXJuIDA7XHJcbiAgICBpZiAoIWNvbnRhaW5zKGRvY3VtZW50LmJvZHksIHdpZGdldC5ub2RlKSkge1xyXG4gICAgICB2YXIgcGFyZW50U3R5bGUgPSBcInBvc2l0aW9uOiByZWxhdGl2ZTtcIjtcclxuICAgICAgaWYgKHdpZGdldC5jb3Zlckd1dHRlcilcclxuICAgICAgICBwYXJlbnRTdHlsZSArPSBcIm1hcmdpbi1sZWZ0OiAtXCIgKyBjbS5kaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGggKyBcInB4O1wiO1xyXG4gICAgICBpZiAod2lkZ2V0Lm5vSFNjcm9sbClcclxuICAgICAgICBwYXJlbnRTdHlsZSArPSBcIndpZHRoOiBcIiArIGNtLmRpc3BsYXkud3JhcHBlci5jbGllbnRXaWR0aCArIFwicHg7XCI7XHJcbiAgICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGNtLmRpc3BsYXkubWVhc3VyZSwgZWx0KFwiZGl2XCIsIFt3aWRnZXQubm9kZV0sIG51bGwsIHBhcmVudFN0eWxlKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gd2lkZ2V0LmhlaWdodCA9IHdpZGdldC5ub2RlLm9mZnNldEhlaWdodDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFkZExpbmVXaWRnZXQoZG9jLCBoYW5kbGUsIG5vZGUsIG9wdGlvbnMpIHtcclxuICAgIHZhciB3aWRnZXQgPSBuZXcgTGluZVdpZGdldChkb2MsIG5vZGUsIG9wdGlvbnMpO1xyXG4gICAgdmFyIGNtID0gZG9jLmNtO1xyXG4gICAgaWYgKGNtICYmIHdpZGdldC5ub0hTY3JvbGwpIGNtLmRpc3BsYXkuYWxpZ25XaWRnZXRzID0gdHJ1ZTtcclxuICAgIGNoYW5nZUxpbmUoZG9jLCBoYW5kbGUsIFwid2lkZ2V0XCIsIGZ1bmN0aW9uKGxpbmUpIHtcclxuICAgICAgdmFyIHdpZGdldHMgPSBsaW5lLndpZGdldHMgfHwgKGxpbmUud2lkZ2V0cyA9IFtdKTtcclxuICAgICAgaWYgKHdpZGdldC5pbnNlcnRBdCA9PSBudWxsKSB3aWRnZXRzLnB1c2god2lkZ2V0KTtcclxuICAgICAgZWxzZSB3aWRnZXRzLnNwbGljZShNYXRoLm1pbih3aWRnZXRzLmxlbmd0aCAtIDEsIE1hdGgubWF4KDAsIHdpZGdldC5pbnNlcnRBdCkpLCAwLCB3aWRnZXQpO1xyXG4gICAgICB3aWRnZXQubGluZSA9IGxpbmU7XHJcbiAgICAgIGlmIChjbSAmJiAhbGluZUlzSGlkZGVuKGRvYywgbGluZSkpIHtcclxuICAgICAgICB2YXIgYWJvdmVWaXNpYmxlID0gaGVpZ2h0QXRMaW5lKGxpbmUpIDwgZG9jLnNjcm9sbFRvcDtcclxuICAgICAgICB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGxpbmUuaGVpZ2h0ICsgd2lkZ2V0SGVpZ2h0KHdpZGdldCkpO1xyXG4gICAgICAgIGlmIChhYm92ZVZpc2libGUpIGFkZFRvU2Nyb2xsUG9zKGNtLCBudWxsLCB3aWRnZXQuaGVpZ2h0KTtcclxuICAgICAgICBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB3aWRnZXQ7XHJcbiAgfVxyXG5cclxuICAvLyBMSU5FIERBVEEgU1RSVUNUVVJFXHJcblxyXG4gIC8vIExpbmUgb2JqZWN0cy4gVGhlc2UgaG9sZCBzdGF0ZSByZWxhdGVkIHRvIGEgbGluZSwgaW5jbHVkaW5nXHJcbiAgLy8gaGlnaGxpZ2h0aW5nIGluZm8gKHRoZSBzdHlsZXMgYXJyYXkpLlxyXG4gIHZhciBMaW5lID0gQ29kZU1pcnJvci5MaW5lID0gZnVuY3Rpb24odGV4dCwgbWFya2VkU3BhbnMsIGVzdGltYXRlSGVpZ2h0KSB7XHJcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xyXG4gICAgYXR0YWNoTWFya2VkU3BhbnModGhpcywgbWFya2VkU3BhbnMpO1xyXG4gICAgdGhpcy5oZWlnaHQgPSBlc3RpbWF0ZUhlaWdodCA/IGVzdGltYXRlSGVpZ2h0KHRoaXMpIDogMTtcclxuICB9O1xyXG4gIGV2ZW50TWl4aW4oTGluZSk7XHJcbiAgTGluZS5wcm90b3R5cGUubGluZU5vID0gZnVuY3Rpb24oKSB7IHJldHVybiBsaW5lTm8odGhpcyk7IH07XHJcblxyXG4gIC8vIENoYW5nZSB0aGUgY29udGVudCAodGV4dCwgbWFya2Vycykgb2YgYSBsaW5lLiBBdXRvbWF0aWNhbGx5XHJcbiAgLy8gaW52YWxpZGF0ZXMgY2FjaGVkIGluZm9ybWF0aW9uIGFuZCB0cmllcyB0byByZS1lc3RpbWF0ZSB0aGVcclxuICAvLyBsaW5lJ3MgaGVpZ2h0LlxyXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmUobGluZSwgdGV4dCwgbWFya2VkU3BhbnMsIGVzdGltYXRlSGVpZ2h0KSB7XHJcbiAgICBsaW5lLnRleHQgPSB0ZXh0O1xyXG4gICAgaWYgKGxpbmUuc3RhdGVBZnRlcikgbGluZS5zdGF0ZUFmdGVyID0gbnVsbDtcclxuICAgIGlmIChsaW5lLnN0eWxlcykgbGluZS5zdHlsZXMgPSBudWxsO1xyXG4gICAgaWYgKGxpbmUub3JkZXIgIT0gbnVsbCkgbGluZS5vcmRlciA9IG51bGw7XHJcbiAgICBkZXRhY2hNYXJrZWRTcGFucyhsaW5lKTtcclxuICAgIGF0dGFjaE1hcmtlZFNwYW5zKGxpbmUsIG1hcmtlZFNwYW5zKTtcclxuICAgIHZhciBlc3RIZWlnaHQgPSBlc3RpbWF0ZUhlaWdodCA/IGVzdGltYXRlSGVpZ2h0KGxpbmUpIDogMTtcclxuICAgIGlmIChlc3RIZWlnaHQgIT0gbGluZS5oZWlnaHQpIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgZXN0SGVpZ2h0KTtcclxuICB9XHJcblxyXG4gIC8vIERldGFjaCBhIGxpbmUgZnJvbSB0aGUgZG9jdW1lbnQgdHJlZSBhbmQgaXRzIG1hcmtlcnMuXHJcbiAgZnVuY3Rpb24gY2xlYW5VcExpbmUobGluZSkge1xyXG4gICAgbGluZS5wYXJlbnQgPSBudWxsO1xyXG4gICAgZGV0YWNoTWFya2VkU3BhbnMobGluZSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBleHRyYWN0TGluZUNsYXNzZXModHlwZSwgb3V0cHV0KSB7XHJcbiAgICBpZiAodHlwZSkgZm9yICg7Oykge1xyXG4gICAgICB2YXIgbGluZUNsYXNzID0gdHlwZS5tYXRjaCgvKD86XnxcXHMrKWxpbmUtKGJhY2tncm91bmQtKT8oXFxTKykvKTtcclxuICAgICAgaWYgKCFsaW5lQ2xhc3MpIGJyZWFrO1xyXG4gICAgICB0eXBlID0gdHlwZS5zbGljZSgwLCBsaW5lQ2xhc3MuaW5kZXgpICsgdHlwZS5zbGljZShsaW5lQ2xhc3MuaW5kZXggKyBsaW5lQ2xhc3NbMF0ubGVuZ3RoKTtcclxuICAgICAgdmFyIHByb3AgPSBsaW5lQ2xhc3NbMV0gPyBcImJnQ2xhc3NcIiA6IFwidGV4dENsYXNzXCI7XHJcbiAgICAgIGlmIChvdXRwdXRbcHJvcF0gPT0gbnVsbClcclxuICAgICAgICBvdXRwdXRbcHJvcF0gPSBsaW5lQ2xhc3NbMl07XHJcbiAgICAgIGVsc2UgaWYgKCEobmV3IFJlZ0V4cChcIig/Ol58XFxzKVwiICsgbGluZUNsYXNzWzJdICsgXCIoPzokfFxccylcIikpLnRlc3Qob3V0cHV0W3Byb3BdKSlcclxuICAgICAgICBvdXRwdXRbcHJvcF0gKz0gXCIgXCIgKyBsaW5lQ2xhc3NbMl07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHlwZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNhbGxCbGFua0xpbmUobW9kZSwgc3RhdGUpIHtcclxuICAgIGlmIChtb2RlLmJsYW5rTGluZSkgcmV0dXJuIG1vZGUuYmxhbmtMaW5lKHN0YXRlKTtcclxuICAgIGlmICghbW9kZS5pbm5lck1vZGUpIHJldHVybjtcclxuICAgIHZhciBpbm5lciA9IENvZGVNaXJyb3IuaW5uZXJNb2RlKG1vZGUsIHN0YXRlKTtcclxuICAgIGlmIChpbm5lci5tb2RlLmJsYW5rTGluZSkgcmV0dXJuIGlubmVyLm1vZGUuYmxhbmtMaW5lKGlubmVyLnN0YXRlKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlYWRUb2tlbihtb2RlLCBzdHJlYW0sIHN0YXRlLCBpbm5lcikge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XHJcbiAgICAgIGlmIChpbm5lcikgaW5uZXJbMF0gPSBDb2RlTWlycm9yLmlubmVyTW9kZShtb2RlLCBzdGF0ZSkubW9kZTtcclxuICAgICAgdmFyIHN0eWxlID0gbW9kZS50b2tlbihzdHJlYW0sIHN0YXRlKTtcclxuICAgICAgaWYgKHN0cmVhbS5wb3MgPiBzdHJlYW0uc3RhcnQpIHJldHVybiBzdHlsZTtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGUgXCIgKyBtb2RlLm5hbWUgKyBcIiBmYWlsZWQgdG8gYWR2YW5jZSBzdHJlYW0uXCIpO1xyXG4gIH1cclxuXHJcbiAgLy8gVXRpbGl0eSBmb3IgZ2V0VG9rZW5BdCBhbmQgZ2V0TGluZVRva2Vuc1xyXG4gIGZ1bmN0aW9uIHRha2VUb2tlbihjbSwgcG9zLCBwcmVjaXNlLCBhc0FycmF5KSB7XHJcbiAgICBmdW5jdGlvbiBnZXRPYmooY29weSkge1xyXG4gICAgICByZXR1cm4ge3N0YXJ0OiBzdHJlYW0uc3RhcnQsIGVuZDogc3RyZWFtLnBvcyxcclxuICAgICAgICAgICAgICBzdHJpbmc6IHN0cmVhbS5jdXJyZW50KCksXHJcbiAgICAgICAgICAgICAgdHlwZTogc3R5bGUgfHwgbnVsbCxcclxuICAgICAgICAgICAgICBzdGF0ZTogY29weSA/IGNvcHlTdGF0ZShkb2MubW9kZSwgc3RhdGUpIDogc3RhdGV9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkb2MgPSBjbS5kb2MsIG1vZGUgPSBkb2MubW9kZSwgc3R5bGU7XHJcbiAgICBwb3MgPSBjbGlwUG9zKGRvYywgcG9zKTtcclxuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIHBvcy5saW5lKSwgc3RhdGUgPSBnZXRTdGF0ZUJlZm9yZShjbSwgcG9zLmxpbmUsIHByZWNpc2UpO1xyXG4gICAgdmFyIHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0obGluZS50ZXh0LCBjbS5vcHRpb25zLnRhYlNpemUpLCB0b2tlbnM7XHJcbiAgICBpZiAoYXNBcnJheSkgdG9rZW5zID0gW107XHJcbiAgICB3aGlsZSAoKGFzQXJyYXkgfHwgc3RyZWFtLnBvcyA8IHBvcy5jaCkgJiYgIXN0cmVhbS5lb2woKSkge1xyXG4gICAgICBzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xyXG4gICAgICBzdHlsZSA9IHJlYWRUb2tlbihtb2RlLCBzdHJlYW0sIHN0YXRlKTtcclxuICAgICAgaWYgKGFzQXJyYXkpIHRva2Vucy5wdXNoKGdldE9iaih0cnVlKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXNBcnJheSA/IHRva2VucyA6IGdldE9iaigpO1xyXG4gIH1cclxuXHJcbiAgLy8gUnVuIHRoZSBnaXZlbiBtb2RlJ3MgcGFyc2VyIG92ZXIgYSBsaW5lLCBjYWxsaW5nIGYgZm9yIGVhY2ggdG9rZW4uXHJcbiAgZnVuY3Rpb24gcnVuTW9kZShjbSwgdGV4dCwgbW9kZSwgc3RhdGUsIGYsIGxpbmVDbGFzc2VzLCBmb3JjZVRvRW5kKSB7XHJcbiAgICB2YXIgZmxhdHRlblNwYW5zID0gbW9kZS5mbGF0dGVuU3BhbnM7XHJcbiAgICBpZiAoZmxhdHRlblNwYW5zID09IG51bGwpIGZsYXR0ZW5TcGFucyA9IGNtLm9wdGlvbnMuZmxhdHRlblNwYW5zO1xyXG4gICAgdmFyIGN1clN0YXJ0ID0gMCwgY3VyU3R5bGUgPSBudWxsO1xyXG4gICAgdmFyIHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0odGV4dCwgY20ub3B0aW9ucy50YWJTaXplKSwgc3R5bGU7XHJcbiAgICB2YXIgaW5uZXIgPSBjbS5vcHRpb25zLmFkZE1vZGVDbGFzcyAmJiBbbnVsbF07XHJcbiAgICBpZiAodGV4dCA9PSBcIlwiKSBleHRyYWN0TGluZUNsYXNzZXMoY2FsbEJsYW5rTGluZShtb2RlLCBzdGF0ZSksIGxpbmVDbGFzc2VzKTtcclxuICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XHJcbiAgICAgIGlmIChzdHJlYW0ucG9zID4gY20ub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGgpIHtcclxuICAgICAgICBmbGF0dGVuU3BhbnMgPSBmYWxzZTtcclxuICAgICAgICBpZiAoZm9yY2VUb0VuZCkgcHJvY2Vzc0xpbmUoY20sIHRleHQsIHN0YXRlLCBzdHJlYW0ucG9zKTtcclxuICAgICAgICBzdHJlYW0ucG9zID0gdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgc3R5bGUgPSBudWxsO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN0eWxlID0gZXh0cmFjdExpbmVDbGFzc2VzKHJlYWRUb2tlbihtb2RlLCBzdHJlYW0sIHN0YXRlLCBpbm5lciksIGxpbmVDbGFzc2VzKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaW5uZXIpIHtcclxuICAgICAgICB2YXIgbU5hbWUgPSBpbm5lclswXS5uYW1lO1xyXG4gICAgICAgIGlmIChtTmFtZSkgc3R5bGUgPSBcIm0tXCIgKyAoc3R5bGUgPyBtTmFtZSArIFwiIFwiICsgc3R5bGUgOiBtTmFtZSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFmbGF0dGVuU3BhbnMgfHwgY3VyU3R5bGUgIT0gc3R5bGUpIHtcclxuICAgICAgICB3aGlsZSAoY3VyU3RhcnQgPCBzdHJlYW0uc3RhcnQpIHtcclxuICAgICAgICAgIGN1clN0YXJ0ID0gTWF0aC5taW4oc3RyZWFtLnN0YXJ0LCBjdXJTdGFydCArIDUwMDAwKTtcclxuICAgICAgICAgIGYoY3VyU3RhcnQsIGN1clN0eWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VyU3R5bGUgPSBzdHlsZTtcclxuICAgICAgfVxyXG4gICAgICBzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xyXG4gICAgfVxyXG4gICAgd2hpbGUgKGN1clN0YXJ0IDwgc3RyZWFtLnBvcykge1xyXG4gICAgICAvLyBXZWJraXQgc2VlbXMgdG8gcmVmdXNlIHRvIHJlbmRlciB0ZXh0IG5vZGVzIGxvbmdlciB0aGFuIDU3NDQ0IGNoYXJhY3RlcnNcclxuICAgICAgdmFyIHBvcyA9IE1hdGgubWluKHN0cmVhbS5wb3MsIGN1clN0YXJ0ICsgNTAwMDApO1xyXG4gICAgICBmKHBvcywgY3VyU3R5bGUpO1xyXG4gICAgICBjdXJTdGFydCA9IHBvcztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENvbXB1dGUgYSBzdHlsZSBhcnJheSAoYW4gYXJyYXkgc3RhcnRpbmcgd2l0aCBhIG1vZGUgZ2VuZXJhdGlvblxyXG4gIC8vIC0tIGZvciBpbnZhbGlkYXRpb24gLS0gZm9sbG93ZWQgYnkgcGFpcnMgb2YgZW5kIHBvc2l0aW9ucyBhbmRcclxuICAvLyBzdHlsZSBzdHJpbmdzKSwgd2hpY2ggaXMgdXNlZCB0byBoaWdobGlnaHQgdGhlIHRva2VucyBvbiB0aGVcclxuICAvLyBsaW5lLlxyXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodExpbmUoY20sIGxpbmUsIHN0YXRlLCBmb3JjZVRvRW5kKSB7XHJcbiAgICAvLyBBIHN0eWxlcyBhcnJheSBhbHdheXMgc3RhcnRzIHdpdGggYSBudW1iZXIgaWRlbnRpZnlpbmcgdGhlXHJcbiAgICAvLyBtb2RlL292ZXJsYXlzIHRoYXQgaXQgaXMgYmFzZWQgb24gKGZvciBlYXN5IGludmFsaWRhdGlvbikuXHJcbiAgICB2YXIgc3QgPSBbY20uc3RhdGUubW9kZUdlbl0sIGxpbmVDbGFzc2VzID0ge307XHJcbiAgICAvLyBDb21wdXRlIHRoZSBiYXNlIGFycmF5IG9mIHN0eWxlc1xyXG4gICAgcnVuTW9kZShjbSwgbGluZS50ZXh0LCBjbS5kb2MubW9kZSwgc3RhdGUsIGZ1bmN0aW9uKGVuZCwgc3R5bGUpIHtcclxuICAgICAgc3QucHVzaChlbmQsIHN0eWxlKTtcclxuICAgIH0sIGxpbmVDbGFzc2VzLCBmb3JjZVRvRW5kKTtcclxuXHJcbiAgICAvLyBSdW4gb3ZlcmxheXMsIGFkanVzdCBzdHlsZSBhcnJheS5cclxuICAgIGZvciAodmFyIG8gPSAwOyBvIDwgY20uc3RhdGUub3ZlcmxheXMubGVuZ3RoOyArK28pIHtcclxuICAgICAgdmFyIG92ZXJsYXkgPSBjbS5zdGF0ZS5vdmVybGF5c1tvXSwgaSA9IDEsIGF0ID0gMDtcclxuICAgICAgcnVuTW9kZShjbSwgbGluZS50ZXh0LCBvdmVybGF5Lm1vZGUsIHRydWUsIGZ1bmN0aW9uKGVuZCwgc3R5bGUpIHtcclxuICAgICAgICB2YXIgc3RhcnQgPSBpO1xyXG4gICAgICAgIC8vIEVuc3VyZSB0aGVyZSdzIGEgdG9rZW4gZW5kIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLCBhbmQgdGhhdCBpIHBvaW50cyBhdCBpdFxyXG4gICAgICAgIHdoaWxlIChhdCA8IGVuZCkge1xyXG4gICAgICAgICAgdmFyIGlfZW5kID0gc3RbaV07XHJcbiAgICAgICAgICBpZiAoaV9lbmQgPiBlbmQpXHJcbiAgICAgICAgICAgIHN0LnNwbGljZShpLCAxLCBlbmQsIHN0W2krMV0sIGlfZW5kKTtcclxuICAgICAgICAgIGkgKz0gMjtcclxuICAgICAgICAgIGF0ID0gTWF0aC5taW4oZW5kLCBpX2VuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghc3R5bGUpIHJldHVybjtcclxuICAgICAgICBpZiAob3ZlcmxheS5vcGFxdWUpIHtcclxuICAgICAgICAgIHN0LnNwbGljZShzdGFydCwgaSAtIHN0YXJ0LCBlbmQsIFwiY20tb3ZlcmxheSBcIiArIHN0eWxlKTtcclxuICAgICAgICAgIGkgPSBzdGFydCArIDI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZvciAoOyBzdGFydCA8IGk7IHN0YXJ0ICs9IDIpIHtcclxuICAgICAgICAgICAgdmFyIGN1ciA9IHN0W3N0YXJ0KzFdO1xyXG4gICAgICAgICAgICBzdFtzdGFydCsxXSA9IChjdXIgPyBjdXIgKyBcIiBcIiA6IFwiXCIpICsgXCJjbS1vdmVybGF5IFwiICsgc3R5bGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCBsaW5lQ2xhc3Nlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtzdHlsZXM6IHN0LCBjbGFzc2VzOiBsaW5lQ2xhc3Nlcy5iZ0NsYXNzIHx8IGxpbmVDbGFzc2VzLnRleHRDbGFzcyA/IGxpbmVDbGFzc2VzIDogbnVsbH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRMaW5lU3R5bGVzKGNtLCBsaW5lLCB1cGRhdGVGcm9udGllcikge1xyXG4gICAgaWYgKCFsaW5lLnN0eWxlcyB8fCBsaW5lLnN0eWxlc1swXSAhPSBjbS5zdGF0ZS5tb2RlR2VuKSB7XHJcbiAgICAgIHZhciByZXN1bHQgPSBoaWdobGlnaHRMaW5lKGNtLCBsaW5lLCBsaW5lLnN0YXRlQWZ0ZXIgPSBnZXRTdGF0ZUJlZm9yZShjbSwgbGluZU5vKGxpbmUpKSk7XHJcbiAgICAgIGxpbmUuc3R5bGVzID0gcmVzdWx0LnN0eWxlcztcclxuICAgICAgaWYgKHJlc3VsdC5jbGFzc2VzKSBsaW5lLnN0eWxlQ2xhc3NlcyA9IHJlc3VsdC5jbGFzc2VzO1xyXG4gICAgICBlbHNlIGlmIChsaW5lLnN0eWxlQ2xhc3NlcykgbGluZS5zdHlsZUNsYXNzZXMgPSBudWxsO1xyXG4gICAgICBpZiAodXBkYXRlRnJvbnRpZXIgPT09IGNtLmRvYy5mcm9udGllcikgY20uZG9jLmZyb250aWVyKys7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGluZS5zdHlsZXM7XHJcbiAgfVxyXG5cclxuICAvLyBMaWdodHdlaWdodCBmb3JtIG9mIGhpZ2hsaWdodCAtLSBwcm9jZWVkIG92ZXIgdGhpcyBsaW5lIGFuZFxyXG4gIC8vIHVwZGF0ZSBzdGF0ZSwgYnV0IGRvbid0IHNhdmUgYSBzdHlsZSBhcnJheS4gVXNlZCBmb3IgbGluZXMgdGhhdFxyXG4gIC8vIGFyZW4ndCBjdXJyZW50bHkgdmlzaWJsZS5cclxuICBmdW5jdGlvbiBwcm9jZXNzTGluZShjbSwgdGV4dCwgc3RhdGUsIHN0YXJ0QXQpIHtcclxuICAgIHZhciBtb2RlID0gY20uZG9jLm1vZGU7XHJcbiAgICB2YXIgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbSh0ZXh0LCBjbS5vcHRpb25zLnRhYlNpemUpO1xyXG4gICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcyA9IHN0YXJ0QXQgfHwgMDtcclxuICAgIGlmICh0ZXh0ID09IFwiXCIpIGNhbGxCbGFua0xpbmUobW9kZSwgc3RhdGUpO1xyXG4gICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkgJiYgc3RyZWFtLnBvcyA8PSBjbS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aCkge1xyXG4gICAgICByZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBzdGF0ZSk7XHJcbiAgICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDb252ZXJ0IGEgc3R5bGUgYXMgcmV0dXJuZWQgYnkgYSBtb2RlIChlaXRoZXIgbnVsbCwgb3IgYSBzdHJpbmdcclxuICAvLyBjb250YWluaW5nIG9uZSBvciBtb3JlIHN0eWxlcykgdG8gYSBDU1Mgc3R5bGUuIFRoaXMgaXMgY2FjaGVkLFxyXG4gIC8vIGFuZCBhbHNvIGxvb2tzIGZvciBsaW5lLXdpZGUgc3R5bGVzLlxyXG4gIHZhciBzdHlsZVRvQ2xhc3NDYWNoZSA9IHt9LCBzdHlsZVRvQ2xhc3NDYWNoZVdpdGhNb2RlID0ge307XHJcbiAgZnVuY3Rpb24gaW50ZXJwcmV0VG9rZW5TdHlsZShzdHlsZSwgb3B0aW9ucykge1xyXG4gICAgaWYgKCFzdHlsZSB8fCAvXlxccyokLy50ZXN0KHN0eWxlKSkgcmV0dXJuIG51bGw7XHJcbiAgICB2YXIgY2FjaGUgPSBvcHRpb25zLmFkZE1vZGVDbGFzcyA/IHN0eWxlVG9DbGFzc0NhY2hlV2l0aE1vZGUgOiBzdHlsZVRvQ2xhc3NDYWNoZTtcclxuICAgIHJldHVybiBjYWNoZVtzdHlsZV0gfHxcclxuICAgICAgKGNhY2hlW3N0eWxlXSA9IHN0eWxlLnJlcGxhY2UoL1xcUysvZywgXCJjbS0kJlwiKSk7XHJcbiAgfVxyXG5cclxuICAvLyBSZW5kZXIgdGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGV4dCBvZiBhIGxpbmUuIEFsc28gYnVpbGRzXHJcbiAgLy8gdXAgYSAnbGluZSBtYXAnLCB3aGljaCBwb2ludHMgYXQgdGhlIERPTSBub2RlcyB0aGF0IHJlcHJlc2VudFxyXG4gIC8vIHNwZWNpZmljIHN0cmV0Y2hlcyBvZiB0ZXh0LCBhbmQgaXMgdXNlZCBieSB0aGUgbWVhc3VyaW5nIGNvZGUuXHJcbiAgLy8gVGhlIHJldHVybmVkIG9iamVjdCBjb250YWlucyB0aGUgRE9NIG5vZGUsIHRoaXMgbWFwLCBhbmRcclxuICAvLyBpbmZvcm1hdGlvbiBhYm91dCBsaW5lLXdpZGUgc3R5bGVzIHRoYXQgd2VyZSBzZXQgYnkgdGhlIG1vZGUuXHJcbiAgZnVuY3Rpb24gYnVpbGRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpIHtcclxuICAgIC8vIFRoZSBwYWRkaW5nLXJpZ2h0IGZvcmNlcyB0aGUgZWxlbWVudCB0byBoYXZlIGEgJ2JvcmRlcicsIHdoaWNoXHJcbiAgICAvLyBpcyBuZWVkZWQgb24gV2Via2l0IHRvIGJlIGFibGUgdG8gZ2V0IGxpbmUtbGV2ZWwgYm91bmRpbmdcclxuICAgIC8vIHJlY3RhbmdsZXMgZm9yIGl0IChpbiBtZWFzdXJlQ2hhcikuXHJcbiAgICB2YXIgY29udGVudCA9IGVsdChcInNwYW5cIiwgbnVsbCwgbnVsbCwgd2Via2l0ID8gXCJwYWRkaW5nLXJpZ2h0OiAuMXB4XCIgOiBudWxsKTtcclxuICAgIHZhciBidWlsZGVyID0ge3ByZTogZWx0KFwicHJlXCIsIFtjb250ZW50XSksIGNvbnRlbnQ6IGNvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICBjb2w6IDAsIHBvczogMCwgY206IGNtLFxyXG4gICAgICAgICAgICAgICAgICAgc3BsaXRTcGFjZXM6IChpZSB8fCB3ZWJraXQpICYmIGNtLmdldE9wdGlvbihcImxpbmVXcmFwcGluZ1wiKX07XHJcbiAgICBsaW5lVmlldy5tZWFzdXJlID0ge307XHJcblxyXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBsb2dpY2FsIGxpbmVzIHRoYXQgbWFrZSB1cCB0aGlzIHZpc3VhbCBsaW5lLlxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gKGxpbmVWaWV3LnJlc3QgPyBsaW5lVmlldy5yZXN0Lmxlbmd0aCA6IDApOyBpKyspIHtcclxuICAgICAgdmFyIGxpbmUgPSBpID8gbGluZVZpZXcucmVzdFtpIC0gMV0gOiBsaW5lVmlldy5saW5lLCBvcmRlcjtcclxuICAgICAgYnVpbGRlci5wb3MgPSAwO1xyXG4gICAgICBidWlsZGVyLmFkZFRva2VuID0gYnVpbGRUb2tlbjtcclxuICAgICAgLy8gT3B0aW9uYWxseSB3aXJlIGluIHNvbWUgaGFja3MgaW50byB0aGUgdG9rZW4tcmVuZGVyaW5nXHJcbiAgICAgIC8vIGFsZ29yaXRobSwgdG8gZGVhbCB3aXRoIGJyb3dzZXIgcXVpcmtzLlxyXG4gICAgICBpZiAoaGFzQmFkQmlkaVJlY3RzKGNtLmRpc3BsYXkubWVhc3VyZSkgJiYgKG9yZGVyID0gZ2V0T3JkZXIobGluZSkpKVxyXG4gICAgICAgIGJ1aWxkZXIuYWRkVG9rZW4gPSBidWlsZFRva2VuQmFkQmlkaShidWlsZGVyLmFkZFRva2VuLCBvcmRlcik7XHJcbiAgICAgIGJ1aWxkZXIubWFwID0gW107XHJcbiAgICAgIHZhciBhbGxvd0Zyb250aWVyVXBkYXRlID0gbGluZVZpZXcgIT0gY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkICYmIGxpbmVObyhsaW5lKTtcclxuICAgICAgaW5zZXJ0TGluZUNvbnRlbnQobGluZSwgYnVpbGRlciwgZ2V0TGluZVN0eWxlcyhjbSwgbGluZSwgYWxsb3dGcm9udGllclVwZGF0ZSkpO1xyXG4gICAgICBpZiAobGluZS5zdHlsZUNsYXNzZXMpIHtcclxuICAgICAgICBpZiAobGluZS5zdHlsZUNsYXNzZXMuYmdDbGFzcylcclxuICAgICAgICAgIGJ1aWxkZXIuYmdDbGFzcyA9IGpvaW5DbGFzc2VzKGxpbmUuc3R5bGVDbGFzc2VzLmJnQ2xhc3MsIGJ1aWxkZXIuYmdDbGFzcyB8fCBcIlwiKTtcclxuICAgICAgICBpZiAobGluZS5zdHlsZUNsYXNzZXMudGV4dENsYXNzKVxyXG4gICAgICAgICAgYnVpbGRlci50ZXh0Q2xhc3MgPSBqb2luQ2xhc3NlcyhsaW5lLnN0eWxlQ2xhc3Nlcy50ZXh0Q2xhc3MsIGJ1aWxkZXIudGV4dENsYXNzIHx8IFwiXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBFbnN1cmUgYXQgbGVhc3QgYSBzaW5nbGUgbm9kZSBpcyBwcmVzZW50LCBmb3IgbWVhc3VyaW5nLlxyXG4gICAgICBpZiAoYnVpbGRlci5tYXAubGVuZ3RoID09IDApXHJcbiAgICAgICAgYnVpbGRlci5tYXAucHVzaCgwLCAwLCBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQoemVyb1dpZHRoRWxlbWVudChjbS5kaXNwbGF5Lm1lYXN1cmUpKSk7XHJcblxyXG4gICAgICAvLyBTdG9yZSB0aGUgbWFwIGFuZCBhIGNhY2hlIG9iamVjdCBmb3IgdGhlIGN1cnJlbnQgbG9naWNhbCBsaW5lXHJcbiAgICAgIGlmIChpID09IDApIHtcclxuICAgICAgICBsaW5lVmlldy5tZWFzdXJlLm1hcCA9IGJ1aWxkZXIubWFwO1xyXG4gICAgICAgIGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGUgPSB7fTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAobGluZVZpZXcubWVhc3VyZS5tYXBzIHx8IChsaW5lVmlldy5tZWFzdXJlLm1hcHMgPSBbXSkpLnB1c2goYnVpbGRlci5tYXApO1xyXG4gICAgICAgIChsaW5lVmlldy5tZWFzdXJlLmNhY2hlcyB8fCAobGluZVZpZXcubWVhc3VyZS5jYWNoZXMgPSBbXSkpLnB1c2goe30pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2VlIGlzc3VlICMyOTAxXHJcbiAgICBpZiAod2Via2l0ICYmIC9cXGJjbS10YWJcXGIvLnRlc3QoYnVpbGRlci5jb250ZW50Lmxhc3RDaGlsZC5jbGFzc05hbWUpKVxyXG4gICAgICBidWlsZGVyLmNvbnRlbnQuY2xhc3NOYW1lID0gXCJjbS10YWItd3JhcC1oYWNrXCI7XHJcblxyXG4gICAgc2lnbmFsKGNtLCBcInJlbmRlckxpbmVcIiwgY20sIGxpbmVWaWV3LmxpbmUsIGJ1aWxkZXIucHJlKTtcclxuICAgIGlmIChidWlsZGVyLnByZS5jbGFzc05hbWUpXHJcbiAgICAgIGJ1aWxkZXIudGV4dENsYXNzID0gam9pbkNsYXNzZXMoYnVpbGRlci5wcmUuY2xhc3NOYW1lLCBidWlsZGVyLnRleHRDbGFzcyB8fCBcIlwiKTtcclxuXHJcbiAgICByZXR1cm4gYnVpbGRlcjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGRlZmF1bHRTcGVjaWFsQ2hhclBsYWNlaG9sZGVyKGNoKSB7XHJcbiAgICB2YXIgdG9rZW4gPSBlbHQoXCJzcGFuXCIsIFwiXFx1MjAyMlwiLCBcImNtLWludmFsaWRjaGFyXCIpO1xyXG4gICAgdG9rZW4udGl0bGUgPSBcIlxcXFx1XCIgKyBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTtcclxuICAgIHRva2VuLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdG9rZW4udGl0bGUpO1xyXG4gICAgcmV0dXJuIHRva2VuO1xyXG4gIH1cclxuXHJcbiAgLy8gQnVpbGQgdXAgdGhlIERPTSByZXByZXNlbnRhdGlvbiBmb3IgYSBzaW5nbGUgdG9rZW4sIGFuZCBhZGQgaXQgdG9cclxuICAvLyB0aGUgbGluZSBtYXAuIFRha2VzIGNhcmUgdG8gcmVuZGVyIHNwZWNpYWwgY2hhcmFjdGVycyBzZXBhcmF0ZWx5LlxyXG4gIGZ1bmN0aW9uIGJ1aWxkVG9rZW4oYnVpbGRlciwgdGV4dCwgc3R5bGUsIHN0YXJ0U3R5bGUsIGVuZFN0eWxlLCB0aXRsZSwgY3NzKSB7XHJcbiAgICBpZiAoIXRleHQpIHJldHVybjtcclxuICAgIHZhciBkaXNwbGF5VGV4dCA9IGJ1aWxkZXIuc3BsaXRTcGFjZXMgPyB0ZXh0LnJlcGxhY2UoLyB7Myx9L2csIHNwbGl0U3BhY2VzKSA6IHRleHQ7XHJcbiAgICB2YXIgc3BlY2lhbCA9IGJ1aWxkZXIuY20uc3RhdGUuc3BlY2lhbENoYXJzLCBtdXN0V3JhcCA9IGZhbHNlO1xyXG4gICAgaWYgKCFzcGVjaWFsLnRlc3QodGV4dCkpIHtcclxuICAgICAgYnVpbGRlci5jb2wgKz0gdGV4dC5sZW5ndGg7XHJcbiAgICAgIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGlzcGxheVRleHQpO1xyXG4gICAgICBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIHRleHQubGVuZ3RoLCBjb250ZW50KTtcclxuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5KSBtdXN0V3JhcCA9IHRydWU7XHJcbiAgICAgIGJ1aWxkZXIucG9zICs9IHRleHQubGVuZ3RoO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHBvcyA9IDA7XHJcbiAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgc3BlY2lhbC5sYXN0SW5kZXggPSBwb3M7XHJcbiAgICAgICAgdmFyIG0gPSBzcGVjaWFsLmV4ZWModGV4dCk7XHJcbiAgICAgICAgdmFyIHNraXBwZWQgPSBtID8gbS5pbmRleCAtIHBvcyA6IHRleHQubGVuZ3RoIC0gcG9zO1xyXG4gICAgICAgIGlmIChza2lwcGVkKSB7XHJcbiAgICAgICAgICB2YXIgdHh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGlzcGxheVRleHQuc2xpY2UocG9zLCBwb3MgKyBza2lwcGVkKSk7XHJcbiAgICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFwic3BhblwiLCBbdHh0XSkpO1xyXG4gICAgICAgICAgZWxzZSBjb250ZW50LmFwcGVuZENoaWxkKHR4dCk7XHJcbiAgICAgICAgICBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIHNraXBwZWQsIHR4dCk7XHJcbiAgICAgICAgICBidWlsZGVyLmNvbCArPSBza2lwcGVkO1xyXG4gICAgICAgICAgYnVpbGRlci5wb3MgKz0gc2tpcHBlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFtKSBicmVhaztcclxuICAgICAgICBwb3MgKz0gc2tpcHBlZCArIDE7XHJcbiAgICAgICAgaWYgKG1bMF0gPT0gXCJcXHRcIikge1xyXG4gICAgICAgICAgdmFyIHRhYlNpemUgPSBidWlsZGVyLmNtLm9wdGlvbnMudGFiU2l6ZSwgdGFiV2lkdGggPSB0YWJTaXplIC0gYnVpbGRlci5jb2wgJSB0YWJTaXplO1xyXG4gICAgICAgICAgdmFyIHR4dCA9IGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFwic3BhblwiLCBzcGFjZVN0cih0YWJXaWR0aCksIFwiY20tdGFiXCIpKTtcclxuICAgICAgICAgIHR4dC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwicHJlc2VudGF0aW9uXCIpO1xyXG4gICAgICAgICAgdHh0LnNldEF0dHJpYnV0ZShcImNtLXRleHRcIiwgXCJcXHRcIik7XHJcbiAgICAgICAgICBidWlsZGVyLmNvbCArPSB0YWJXaWR0aDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFyIHR4dCA9IGJ1aWxkZXIuY20ub3B0aW9ucy5zcGVjaWFsQ2hhclBsYWNlaG9sZGVyKG1bMF0pO1xyXG4gICAgICAgICAgdHh0LnNldEF0dHJpYnV0ZShcImNtLXRleHRcIiwgbVswXSk7XHJcbiAgICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFwic3BhblwiLCBbdHh0XSkpO1xyXG4gICAgICAgICAgZWxzZSBjb250ZW50LmFwcGVuZENoaWxkKHR4dCk7XHJcbiAgICAgICAgICBidWlsZGVyLmNvbCArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIDEsIHR4dCk7XHJcbiAgICAgICAgYnVpbGRlci5wb3MrKztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHN0eWxlIHx8IHN0YXJ0U3R5bGUgfHwgZW5kU3R5bGUgfHwgbXVzdFdyYXAgfHwgY3NzKSB7XHJcbiAgICAgIHZhciBmdWxsU3R5bGUgPSBzdHlsZSB8fCBcIlwiO1xyXG4gICAgICBpZiAoc3RhcnRTdHlsZSkgZnVsbFN0eWxlICs9IHN0YXJ0U3R5bGU7XHJcbiAgICAgIGlmIChlbmRTdHlsZSkgZnVsbFN0eWxlICs9IGVuZFN0eWxlO1xyXG4gICAgICB2YXIgdG9rZW4gPSBlbHQoXCJzcGFuXCIsIFtjb250ZW50XSwgZnVsbFN0eWxlLCBjc3MpO1xyXG4gICAgICBpZiAodGl0bGUpIHRva2VuLnRpdGxlID0gdGl0bGU7XHJcbiAgICAgIHJldHVybiBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQodG9rZW4pO1xyXG4gICAgfVxyXG4gICAgYnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKGNvbnRlbnQpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc3BsaXRTcGFjZXMob2xkKSB7XHJcbiAgICB2YXIgb3V0ID0gXCIgXCI7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGggLSAyOyArK2kpIG91dCArPSBpICUgMiA/IFwiIFwiIDogXCJcXHUwMGEwXCI7XHJcbiAgICBvdXQgKz0gXCIgXCI7XHJcbiAgICByZXR1cm4gb3V0O1xyXG4gIH1cclxuXHJcbiAgLy8gV29yayBhcm91bmQgbm9uc2Vuc2UgZGltZW5zaW9ucyBiZWluZyByZXBvcnRlZCBmb3Igc3RyZXRjaGVzIG9mXHJcbiAgLy8gcmlnaHQtdG8tbGVmdCB0ZXh0LlxyXG4gIGZ1bmN0aW9uIGJ1aWxkVG9rZW5CYWRCaWRpKGlubmVyLCBvcmRlcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGJ1aWxkZXIsIHRleHQsIHN0eWxlLCBzdGFydFN0eWxlLCBlbmRTdHlsZSwgdGl0bGUsIGNzcykge1xyXG4gICAgICBzdHlsZSA9IHN0eWxlID8gc3R5bGUgKyBcIiBjbS1mb3JjZS1ib3JkZXJcIiA6IFwiY20tZm9yY2UtYm9yZGVyXCI7XHJcbiAgICAgIHZhciBzdGFydCA9IGJ1aWxkZXIucG9zLCBlbmQgPSBzdGFydCArIHRleHQubGVuZ3RoO1xyXG4gICAgICBmb3IgKDs7KSB7XHJcbiAgICAgICAgLy8gRmluZCB0aGUgcGFydCB0aGF0IG92ZXJsYXBzIHdpdGggdGhlIHN0YXJ0IG9mIHRoaXMgdGV4dFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIHZhciBwYXJ0ID0gb3JkZXJbaV07XHJcbiAgICAgICAgICBpZiAocGFydC50byA+IHN0YXJ0ICYmIHBhcnQuZnJvbSA8PSBzdGFydCkgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXJ0LnRvID49IGVuZCkgcmV0dXJuIGlubmVyKGJ1aWxkZXIsIHRleHQsIHN0eWxlLCBzdGFydFN0eWxlLCBlbmRTdHlsZSwgdGl0bGUsIGNzcyk7XHJcbiAgICAgICAgaW5uZXIoYnVpbGRlciwgdGV4dC5zbGljZSgwLCBwYXJ0LnRvIC0gc3RhcnQpLCBzdHlsZSwgc3RhcnRTdHlsZSwgbnVsbCwgdGl0bGUsIGNzcyk7XHJcbiAgICAgICAgc3RhcnRTdHlsZSA9IG51bGw7XHJcbiAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UocGFydC50byAtIHN0YXJ0KTtcclxuICAgICAgICBzdGFydCA9IHBhcnQudG87XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBidWlsZENvbGxhcHNlZFNwYW4oYnVpbGRlciwgc2l6ZSwgbWFya2VyLCBpZ25vcmVXaWRnZXQpIHtcclxuICAgIHZhciB3aWRnZXQgPSAhaWdub3JlV2lkZ2V0ICYmIG1hcmtlci53aWRnZXROb2RlO1xyXG4gICAgaWYgKHdpZGdldCkgYnVpbGRlci5tYXAucHVzaChidWlsZGVyLnBvcywgYnVpbGRlci5wb3MgKyBzaXplLCB3aWRnZXQpO1xyXG4gICAgaWYgKCFpZ25vcmVXaWRnZXQgJiYgYnVpbGRlci5jbS5kaXNwbGF5LmlucHV0Lm5lZWRzQ29udGVudEF0dHJpYnV0ZSkge1xyXG4gICAgICBpZiAoIXdpZGdldClcclxuICAgICAgICB3aWRnZXQgPSBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIikpO1xyXG4gICAgICB3aWRnZXQuc2V0QXR0cmlidXRlKFwiY20tbWFya2VyXCIsIG1hcmtlci5pZCk7XHJcbiAgICB9XHJcbiAgICBpZiAod2lkZ2V0KSB7XHJcbiAgICAgIGJ1aWxkZXIuY20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKHdpZGdldCk7XHJcbiAgICAgIGJ1aWxkZXIuY29udGVudC5hcHBlbmRDaGlsZCh3aWRnZXQpO1xyXG4gICAgfVxyXG4gICAgYnVpbGRlci5wb3MgKz0gc2l6ZTtcclxuICB9XHJcblxyXG4gIC8vIE91dHB1dHMgYSBudW1iZXIgb2Ygc3BhbnMgdG8gbWFrZSB1cCBhIGxpbmUsIHRha2luZyBoaWdobGlnaHRpbmdcclxuICAvLyBhbmQgbWFya2VkIHRleHQgaW50byBhY2NvdW50LlxyXG4gIGZ1bmN0aW9uIGluc2VydExpbmVDb250ZW50KGxpbmUsIGJ1aWxkZXIsIHN0eWxlcykge1xyXG4gICAgdmFyIHNwYW5zID0gbGluZS5tYXJrZWRTcGFucywgYWxsVGV4dCA9IGxpbmUudGV4dCwgYXQgPSAwO1xyXG4gICAgaWYgKCFzcGFucykge1xyXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrPTIpXHJcbiAgICAgICAgYnVpbGRlci5hZGRUb2tlbihidWlsZGVyLCBhbGxUZXh0LnNsaWNlKGF0LCBhdCA9IHN0eWxlc1tpXSksIGludGVycHJldFRva2VuU3R5bGUoc3R5bGVzW2krMV0sIGJ1aWxkZXIuY20ub3B0aW9ucykpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGxlbiA9IGFsbFRleHQubGVuZ3RoLCBwb3MgPSAwLCBpID0gMSwgdGV4dCA9IFwiXCIsIHN0eWxlLCBjc3M7XHJcbiAgICB2YXIgbmV4dENoYW5nZSA9IDAsIHNwYW5TdHlsZSwgc3BhbkVuZFN0eWxlLCBzcGFuU3RhcnRTdHlsZSwgdGl0bGUsIGNvbGxhcHNlZDtcclxuICAgIGZvciAoOzspIHtcclxuICAgICAgaWYgKG5leHRDaGFuZ2UgPT0gcG9zKSB7IC8vIFVwZGF0ZSBjdXJyZW50IG1hcmtlciBzZXRcclxuICAgICAgICBzcGFuU3R5bGUgPSBzcGFuRW5kU3R5bGUgPSBzcGFuU3RhcnRTdHlsZSA9IHRpdGxlID0gY3NzID0gXCJcIjtcclxuICAgICAgICBjb2xsYXBzZWQgPSBudWxsOyBuZXh0Q2hhbmdlID0gSW5maW5pdHk7XHJcbiAgICAgICAgdmFyIGZvdW5kQm9va21hcmtzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzcGFucy5sZW5ndGg7ICsraikge1xyXG4gICAgICAgICAgdmFyIHNwID0gc3BhbnNbal0sIG0gPSBzcC5tYXJrZXI7XHJcbiAgICAgICAgICBpZiAoc3AuZnJvbSA8PSBwb3MgJiYgKHNwLnRvID09IG51bGwgfHwgc3AudG8gPiBwb3MpKSB7XHJcbiAgICAgICAgICAgIGlmIChzcC50byAhPSBudWxsICYmIG5leHRDaGFuZ2UgPiBzcC50bykgeyBuZXh0Q2hhbmdlID0gc3AudG87IHNwYW5FbmRTdHlsZSA9IFwiXCI7IH1cclxuICAgICAgICAgICAgaWYgKG0uY2xhc3NOYW1lKSBzcGFuU3R5bGUgKz0gXCIgXCIgKyBtLmNsYXNzTmFtZTtcclxuICAgICAgICAgICAgaWYgKG0uY3NzKSBjc3MgPSBtLmNzcztcclxuICAgICAgICAgICAgaWYgKG0uc3RhcnRTdHlsZSAmJiBzcC5mcm9tID09IHBvcykgc3BhblN0YXJ0U3R5bGUgKz0gXCIgXCIgKyBtLnN0YXJ0U3R5bGU7XHJcbiAgICAgICAgICAgIGlmIChtLmVuZFN0eWxlICYmIHNwLnRvID09IG5leHRDaGFuZ2UpIHNwYW5FbmRTdHlsZSArPSBcIiBcIiArIG0uZW5kU3R5bGU7XHJcbiAgICAgICAgICAgIGlmIChtLnRpdGxlICYmICF0aXRsZSkgdGl0bGUgPSBtLnRpdGxlO1xyXG4gICAgICAgICAgICBpZiAobS5jb2xsYXBzZWQgJiYgKCFjb2xsYXBzZWQgfHwgY29tcGFyZUNvbGxhcHNlZE1hcmtlcnMoY29sbGFwc2VkLm1hcmtlciwgbSkgPCAwKSlcclxuICAgICAgICAgICAgICBjb2xsYXBzZWQgPSBzcDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoc3AuZnJvbSA+IHBvcyAmJiBuZXh0Q2hhbmdlID4gc3AuZnJvbSkge1xyXG4gICAgICAgICAgICBuZXh0Q2hhbmdlID0gc3AuZnJvbTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChtLnR5cGUgPT0gXCJib29rbWFya1wiICYmIHNwLmZyb20gPT0gcG9zICYmIG0ud2lkZ2V0Tm9kZSkgZm91bmRCb29rbWFya3MucHVzaChtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbGxhcHNlZCAmJiAoY29sbGFwc2VkLmZyb20gfHwgMCkgPT0gcG9zKSB7XHJcbiAgICAgICAgICBidWlsZENvbGxhcHNlZFNwYW4oYnVpbGRlciwgKGNvbGxhcHNlZC50byA9PSBudWxsID8gbGVuICsgMSA6IGNvbGxhcHNlZC50bykgLSBwb3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGFwc2VkLm1hcmtlciwgY29sbGFwc2VkLmZyb20gPT0gbnVsbCk7XHJcbiAgICAgICAgICBpZiAoY29sbGFwc2VkLnRvID09IG51bGwpIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFjb2xsYXBzZWQgJiYgZm91bmRCb29rbWFya3MubGVuZ3RoKSBmb3IgKHZhciBqID0gMDsgaiA8IGZvdW5kQm9va21hcmtzLmxlbmd0aDsgKytqKVxyXG4gICAgICAgICAgYnVpbGRDb2xsYXBzZWRTcGFuKGJ1aWxkZXIsIDAsIGZvdW5kQm9va21hcmtzW2pdKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocG9zID49IGxlbikgYnJlYWs7XHJcblxyXG4gICAgICB2YXIgdXB0byA9IE1hdGgubWluKGxlbiwgbmV4dENoYW5nZSk7XHJcbiAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgaWYgKHRleHQpIHtcclxuICAgICAgICAgIHZhciBlbmQgPSBwb3MgKyB0ZXh0Lmxlbmd0aDtcclxuICAgICAgICAgIGlmICghY29sbGFwc2VkKSB7XHJcbiAgICAgICAgICAgIHZhciB0b2tlblRleHQgPSBlbmQgPiB1cHRvID8gdGV4dC5zbGljZSgwLCB1cHRvIC0gcG9zKSA6IHRleHQ7XHJcbiAgICAgICAgICAgIGJ1aWxkZXIuYWRkVG9rZW4oYnVpbGRlciwgdG9rZW5UZXh0LCBzdHlsZSA/IHN0eWxlICsgc3BhblN0eWxlIDogc3BhblN0eWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW5TdGFydFN0eWxlLCBwb3MgKyB0b2tlblRleHQubGVuZ3RoID09IG5leHRDaGFuZ2UgPyBzcGFuRW5kU3R5bGUgOiBcIlwiLCB0aXRsZSwgY3NzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChlbmQgPj0gdXB0bykge3RleHQgPSB0ZXh0LnNsaWNlKHVwdG8gLSBwb3MpOyBwb3MgPSB1cHRvOyBicmVhazt9XHJcbiAgICAgICAgICBwb3MgPSBlbmQ7XHJcbiAgICAgICAgICBzcGFuU3RhcnRTdHlsZSA9IFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRleHQgPSBhbGxUZXh0LnNsaWNlKGF0LCBhdCA9IHN0eWxlc1tpKytdKTtcclxuICAgICAgICBzdHlsZSA9IGludGVycHJldFRva2VuU3R5bGUoc3R5bGVzW2krK10sIGJ1aWxkZXIuY20ub3B0aW9ucyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIERPQ1VNRU5UIERBVEEgU1RSVUNUVVJFXHJcblxyXG4gIC8vIEJ5IGRlZmF1bHQsIHVwZGF0ZXMgdGhhdCBzdGFydCBhbmQgZW5kIGF0IHRoZSBiZWdpbm5pbmcgb2YgYSBsaW5lXHJcbiAgLy8gYXJlIHRyZWF0ZWQgc3BlY2lhbGx5LCBpbiBvcmRlciB0byBtYWtlIHRoZSBhc3NvY2lhdGlvbiBvZiBsaW5lXHJcbiAgLy8gd2lkZ2V0cyBhbmQgbWFya2VyIGVsZW1lbnRzIHdpdGggdGhlIHRleHQgYmVoYXZlIG1vcmUgaW50dWl0aXZlLlxyXG4gIGZ1bmN0aW9uIGlzV2hvbGVMaW5lVXBkYXRlKGRvYywgY2hhbmdlKSB7XHJcbiAgICByZXR1cm4gY2hhbmdlLmZyb20uY2ggPT0gMCAmJiBjaGFuZ2UudG8uY2ggPT0gMCAmJiBsc3QoY2hhbmdlLnRleHQpID09IFwiXCIgJiZcclxuICAgICAgKCFkb2MuY20gfHwgZG9jLmNtLm9wdGlvbnMud2hvbGVMaW5lVXBkYXRlQmVmb3JlKTtcclxuICB9XHJcblxyXG4gIC8vIFBlcmZvcm0gYSBjaGFuZ2Ugb24gdGhlIGRvY3VtZW50IGRhdGEgc3RydWN0dXJlLlxyXG4gIGZ1bmN0aW9uIHVwZGF0ZURvYyhkb2MsIGNoYW5nZSwgbWFya2VkU3BhbnMsIGVzdGltYXRlSGVpZ2h0KSB7XHJcbiAgICBmdW5jdGlvbiBzcGFuc0ZvcihuKSB7cmV0dXJuIG1hcmtlZFNwYW5zID8gbWFya2VkU3BhbnNbbl0gOiBudWxsO31cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZShsaW5lLCB0ZXh0LCBzcGFucykge1xyXG4gICAgICB1cGRhdGVMaW5lKGxpbmUsIHRleHQsIHNwYW5zLCBlc3RpbWF0ZUhlaWdodCk7XHJcbiAgICAgIHNpZ25hbExhdGVyKGxpbmUsIFwiY2hhbmdlXCIsIGxpbmUsIGNoYW5nZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBsaW5lc0ZvcihzdGFydCwgZW5kKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydCwgcmVzdWx0ID0gW107IGkgPCBlbmQ7ICsraSlcclxuICAgICAgICByZXN1bHQucHVzaChuZXcgTGluZSh0ZXh0W2ldLCBzcGFuc0ZvcihpKSwgZXN0aW1hdGVIZWlnaHQpKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZnJvbSA9IGNoYW5nZS5mcm9tLCB0byA9IGNoYW5nZS50bywgdGV4dCA9IGNoYW5nZS50ZXh0O1xyXG4gICAgdmFyIGZpcnN0TGluZSA9IGdldExpbmUoZG9jLCBmcm9tLmxpbmUpLCBsYXN0TGluZSA9IGdldExpbmUoZG9jLCB0by5saW5lKTtcclxuICAgIHZhciBsYXN0VGV4dCA9IGxzdCh0ZXh0KSwgbGFzdFNwYW5zID0gc3BhbnNGb3IodGV4dC5sZW5ndGggLSAxKSwgbmxpbmVzID0gdG8ubGluZSAtIGZyb20ubGluZTtcclxuXHJcbiAgICAvLyBBZGp1c3QgdGhlIGxpbmUgc3RydWN0dXJlXHJcbiAgICBpZiAoY2hhbmdlLmZ1bGwpIHtcclxuICAgICAgZG9jLmluc2VydCgwLCBsaW5lc0ZvcigwLCB0ZXh0Lmxlbmd0aCkpO1xyXG4gICAgICBkb2MucmVtb3ZlKHRleHQubGVuZ3RoLCBkb2Muc2l6ZSAtIHRleHQubGVuZ3RoKTtcclxuICAgIH0gZWxzZSBpZiAoaXNXaG9sZUxpbmVVcGRhdGUoZG9jLCBjaGFuZ2UpKSB7XHJcbiAgICAgIC8vIFRoaXMgaXMgYSB3aG9sZS1saW5lIHJlcGxhY2UuIFRyZWF0ZWQgc3BlY2lhbGx5IHRvIG1ha2VcclxuICAgICAgLy8gc3VyZSBsaW5lIG9iamVjdHMgbW92ZSB0aGUgd2F5IHRoZXkgYXJlIHN1cHBvc2VkIHRvLlxyXG4gICAgICB2YXIgYWRkZWQgPSBsaW5lc0ZvcigwLCB0ZXh0Lmxlbmd0aCAtIDEpO1xyXG4gICAgICB1cGRhdGUobGFzdExpbmUsIGxhc3RMaW5lLnRleHQsIGxhc3RTcGFucyk7XHJcbiAgICAgIGlmIChubGluZXMpIGRvYy5yZW1vdmUoZnJvbS5saW5lLCBubGluZXMpO1xyXG4gICAgICBpZiAoYWRkZWQubGVuZ3RoKSBkb2MuaW5zZXJ0KGZyb20ubGluZSwgYWRkZWQpO1xyXG4gICAgfSBlbHNlIGlmIChmaXJzdExpbmUgPT0gbGFzdExpbmUpIHtcclxuICAgICAgaWYgKHRleHQubGVuZ3RoID09IDEpIHtcclxuICAgICAgICB1cGRhdGUoZmlyc3RMaW5lLCBmaXJzdExpbmUudGV4dC5zbGljZSgwLCBmcm9tLmNoKSArIGxhc3RUZXh0ICsgZmlyc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLCBsYXN0U3BhbnMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBhZGRlZCA9IGxpbmVzRm9yKDEsIHRleHQubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgYWRkZWQucHVzaChuZXcgTGluZShsYXN0VGV4dCArIGZpcnN0TGluZS50ZXh0LnNsaWNlKHRvLmNoKSwgbGFzdFNwYW5zLCBlc3RpbWF0ZUhlaWdodCkpO1xyXG4gICAgICAgIHVwZGF0ZShmaXJzdExpbmUsIGZpcnN0TGluZS50ZXh0LnNsaWNlKDAsIGZyb20uY2gpICsgdGV4dFswXSwgc3BhbnNGb3IoMCkpO1xyXG4gICAgICAgIGRvYy5pbnNlcnQoZnJvbS5saW5lICsgMSwgYWRkZWQpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHRleHQubGVuZ3RoID09IDEpIHtcclxuICAgICAgdXBkYXRlKGZpcnN0TGluZSwgZmlyc3RMaW5lLnRleHQuc2xpY2UoMCwgZnJvbS5jaCkgKyB0ZXh0WzBdICsgbGFzdExpbmUudGV4dC5zbGljZSh0by5jaCksIHNwYW5zRm9yKDApKTtcclxuICAgICAgZG9jLnJlbW92ZShmcm9tLmxpbmUgKyAxLCBubGluZXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdXBkYXRlKGZpcnN0TGluZSwgZmlyc3RMaW5lLnRleHQuc2xpY2UoMCwgZnJvbS5jaCkgKyB0ZXh0WzBdLCBzcGFuc0ZvcigwKSk7XHJcbiAgICAgIHVwZGF0ZShsYXN0TGluZSwgbGFzdFRleHQgKyBsYXN0TGluZS50ZXh0LnNsaWNlKHRvLmNoKSwgbGFzdFNwYW5zKTtcclxuICAgICAgdmFyIGFkZGVkID0gbGluZXNGb3IoMSwgdGV4dC5sZW5ndGggLSAxKTtcclxuICAgICAgaWYgKG5saW5lcyA+IDEpIGRvYy5yZW1vdmUoZnJvbS5saW5lICsgMSwgbmxpbmVzIC0gMSk7XHJcbiAgICAgIGRvYy5pbnNlcnQoZnJvbS5saW5lICsgMSwgYWRkZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHNpZ25hbExhdGVyKGRvYywgXCJjaGFuZ2VcIiwgZG9jLCBjaGFuZ2UpO1xyXG4gIH1cclxuXHJcbiAgLy8gVGhlIGRvY3VtZW50IGlzIHJlcHJlc2VudGVkIGFzIGEgQlRyZWUgY29uc2lzdGluZyBvZiBsZWF2ZXMsIHdpdGhcclxuICAvLyBjaHVuayBvZiBsaW5lcyBpbiB0aGVtLCBhbmQgYnJhbmNoZXMsIHdpdGggdXAgdG8gdGVuIGxlYXZlcyBvclxyXG4gIC8vIG90aGVyIGJyYW5jaCBub2RlcyBiZWxvdyB0aGVtLiBUaGUgdG9wIG5vZGUgaXMgYWx3YXlzIGEgYnJhbmNoXHJcbiAgLy8gbm9kZSwgYW5kIGlzIHRoZSBkb2N1bWVudCBvYmplY3QgaXRzZWxmIChtZWFuaW5nIGl0IGhhc1xyXG4gIC8vIGFkZGl0aW9uYWwgbWV0aG9kcyBhbmQgcHJvcGVydGllcykuXHJcbiAgLy9cclxuICAvLyBBbGwgbm9kZXMgaGF2ZSBwYXJlbnQgbGlua3MuIFRoZSB0cmVlIGlzIHVzZWQgYm90aCB0byBnbyBmcm9tXHJcbiAgLy8gbGluZSBudW1iZXJzIHRvIGxpbmUgb2JqZWN0cywgYW5kIHRvIGdvIGZyb20gb2JqZWN0cyB0byBudW1iZXJzLlxyXG4gIC8vIEl0IGFsc28gaW5kZXhlcyBieSBoZWlnaHQsIGFuZCBpcyB1c2VkIHRvIGNvbnZlcnQgYmV0d2VlbiBoZWlnaHRcclxuICAvLyBhbmQgbGluZSBvYmplY3QsIGFuZCB0byBmaW5kIHRoZSB0b3RhbCBoZWlnaHQgb2YgdGhlIGRvY3VtZW50LlxyXG4gIC8vXHJcbiAgLy8gU2VlIGFsc28gaHR0cDovL21hcmlqbmhhdmVyYmVrZS5ubC9ibG9nL2NvZGVtaXJyb3ItbGluZS10cmVlLmh0bWxcclxuXHJcbiAgZnVuY3Rpb24gTGVhZkNodW5rKGxpbmVzKSB7XHJcbiAgICB0aGlzLmxpbmVzID0gbGluZXM7XHJcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgaGVpZ2h0ID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIGxpbmVzW2ldLnBhcmVudCA9IHRoaXM7XHJcbiAgICAgIGhlaWdodCArPSBsaW5lc1tpXS5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICB9XHJcblxyXG4gIExlYWZDaHVuay5wcm90b3R5cGUgPSB7XHJcbiAgICBjaHVua1NpemU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5saW5lcy5sZW5ndGg7IH0sXHJcbiAgICAvLyBSZW1vdmUgdGhlIG4gbGluZXMgYXQgb2Zmc2V0ICdhdCcuXHJcbiAgICByZW1vdmVJbm5lcjogZnVuY3Rpb24oYXQsIG4pIHtcclxuICAgICAgZm9yICh2YXIgaSA9IGF0LCBlID0gYXQgKyBuOyBpIDwgZTsgKytpKSB7XHJcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2ldO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0IC09IGxpbmUuaGVpZ2h0O1xyXG4gICAgICAgIGNsZWFuVXBMaW5lKGxpbmUpO1xyXG4gICAgICAgIHNpZ25hbExhdGVyKGxpbmUsIFwiZGVsZXRlXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubGluZXMuc3BsaWNlKGF0LCBuKTtcclxuICAgIH0sXHJcbiAgICAvLyBIZWxwZXIgdXNlZCB0byBjb2xsYXBzZSBhIHNtYWxsIGJyYW5jaCBpbnRvIGEgc2luZ2xlIGxlYWYuXHJcbiAgICBjb2xsYXBzZTogZnVuY3Rpb24obGluZXMpIHtcclxuICAgICAgbGluZXMucHVzaC5hcHBseShsaW5lcywgdGhpcy5saW5lcyk7XHJcbiAgICB9LFxyXG4gICAgLy8gSW5zZXJ0IHRoZSBnaXZlbiBhcnJheSBvZiBsaW5lcyBhdCBvZmZzZXQgJ2F0JywgY291bnQgdGhlbSBhc1xyXG4gICAgLy8gaGF2aW5nIHRoZSBnaXZlbiBoZWlnaHQuXHJcbiAgICBpbnNlcnRJbm5lcjogZnVuY3Rpb24oYXQsIGxpbmVzLCBoZWlnaHQpIHtcclxuICAgICAgdGhpcy5oZWlnaHQgKz0gaGVpZ2h0O1xyXG4gICAgICB0aGlzLmxpbmVzID0gdGhpcy5saW5lcy5zbGljZSgwLCBhdCkuY29uY2F0KGxpbmVzKS5jb25jYXQodGhpcy5saW5lcy5zbGljZShhdCkpO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSBsaW5lc1tpXS5wYXJlbnQgPSB0aGlzO1xyXG4gICAgfSxcclxuICAgIC8vIFVzZWQgdG8gaXRlcmF0ZSBvdmVyIGEgcGFydCBvZiB0aGUgdHJlZS5cclxuICAgIGl0ZXJOOiBmdW5jdGlvbihhdCwgbiwgb3ApIHtcclxuICAgICAgZm9yICh2YXIgZSA9IGF0ICsgbjsgYXQgPCBlOyArK2F0KVxyXG4gICAgICAgIGlmIChvcCh0aGlzLmxpbmVzW2F0XSkpIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIEJyYW5jaENodW5rKGNoaWxkcmVuKSB7XHJcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICB2YXIgc2l6ZSA9IDAsIGhlaWdodCA9IDA7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIHZhciBjaCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICBzaXplICs9IGNoLmNodW5rU2l6ZSgpOyBoZWlnaHQgKz0gY2guaGVpZ2h0O1xyXG4gICAgICBjaC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zaXplID0gc2l6ZTtcclxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgQnJhbmNoQ2h1bmsucHJvdG90eXBlID0ge1xyXG4gICAgY2h1bmtTaXplOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc2l6ZTsgfSxcclxuICAgIHJlbW92ZUlubmVyOiBmdW5jdGlvbihhdCwgbikge1xyXG4gICAgICB0aGlzLnNpemUgLT0gbjtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgc3ogPSBjaGlsZC5jaHVua1NpemUoKTtcclxuICAgICAgICBpZiAoYXQgPCBzeikge1xyXG4gICAgICAgICAgdmFyIHJtID0gTWF0aC5taW4obiwgc3ogLSBhdCksIG9sZEhlaWdodCA9IGNoaWxkLmhlaWdodDtcclxuICAgICAgICAgIGNoaWxkLnJlbW92ZUlubmVyKGF0LCBybSk7XHJcbiAgICAgICAgICB0aGlzLmhlaWdodCAtPSBvbGRIZWlnaHQgLSBjaGlsZC5oZWlnaHQ7XHJcbiAgICAgICAgICBpZiAoc3ogPT0gcm0pIHsgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaS0tLCAxKTsgY2hpbGQucGFyZW50ID0gbnVsbDsgfVxyXG4gICAgICAgICAgaWYgKChuIC09IHJtKSA9PSAwKSBicmVhaztcclxuICAgICAgICAgIGF0ID0gMDtcclxuICAgICAgICB9IGVsc2UgYXQgLT0gc3o7XHJcbiAgICAgIH1cclxuICAgICAgLy8gSWYgdGhlIHJlc3VsdCBpcyBzbWFsbGVyIHRoYW4gMjUgbGluZXMsIGVuc3VyZSB0aGF0IGl0IGlzIGFcclxuICAgICAgLy8gc2luZ2xlIGxlYWYgbm9kZS5cclxuICAgICAgaWYgKHRoaXMuc2l6ZSAtIG4gPCAyNSAmJlxyXG4gICAgICAgICAgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMSB8fCAhKHRoaXMuY2hpbGRyZW5bMF0gaW5zdGFuY2VvZiBMZWFmQ2h1bmspKSkge1xyXG4gICAgICAgIHZhciBsaW5lcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY29sbGFwc2UobGluZXMpO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbbmV3IExlYWZDaHVuayhsaW5lcyldO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW5bMF0ucGFyZW50ID0gdGhpcztcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNvbGxhcHNlOiBmdW5jdGlvbihsaW5lcykge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHRoaXMuY2hpbGRyZW5baV0uY29sbGFwc2UobGluZXMpO1xyXG4gICAgfSxcclxuICAgIGluc2VydElubmVyOiBmdW5jdGlvbihhdCwgbGluZXMsIGhlaWdodCkge1xyXG4gICAgICB0aGlzLnNpemUgKz0gbGluZXMubGVuZ3RoO1xyXG4gICAgICB0aGlzLmhlaWdodCArPSBoZWlnaHQ7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIHN6ID0gY2hpbGQuY2h1bmtTaXplKCk7XHJcbiAgICAgICAgaWYgKGF0IDw9IHN6KSB7XHJcbiAgICAgICAgICBjaGlsZC5pbnNlcnRJbm5lcihhdCwgbGluZXMsIGhlaWdodCk7XHJcbiAgICAgICAgICBpZiAoY2hpbGQubGluZXMgJiYgY2hpbGQubGluZXMubGVuZ3RoID4gNTApIHtcclxuICAgICAgICAgICAgd2hpbGUgKGNoaWxkLmxpbmVzLmxlbmd0aCA+IDUwKSB7XHJcbiAgICAgICAgICAgICAgdmFyIHNwaWxsZWQgPSBjaGlsZC5saW5lcy5zcGxpY2UoY2hpbGQubGluZXMubGVuZ3RoIC0gMjUsIDI1KTtcclxuICAgICAgICAgICAgICB2YXIgbmV3bGVhZiA9IG5ldyBMZWFmQ2h1bmsoc3BpbGxlZCk7XHJcbiAgICAgICAgICAgICAgY2hpbGQuaGVpZ2h0IC09IG5ld2xlYWYuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGkgKyAxLCAwLCBuZXdsZWFmKTtcclxuICAgICAgICAgICAgICBuZXdsZWFmLnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5tYXliZVNwaWxsKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgYXQgLT0gc3o7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvLyBXaGVuIGEgbm9kZSBoYXMgZ3Jvd24sIGNoZWNrIHdoZXRoZXIgaXQgc2hvdWxkIGJlIHNwbGl0LlxyXG4gICAgbWF5YmVTcGlsbDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA8PSAxMCkgcmV0dXJuO1xyXG4gICAgICB2YXIgbWUgPSB0aGlzO1xyXG4gICAgICBkbyB7XHJcbiAgICAgICAgdmFyIHNwaWxsZWQgPSBtZS5jaGlsZHJlbi5zcGxpY2UobWUuY2hpbGRyZW4ubGVuZ3RoIC0gNSwgNSk7XHJcbiAgICAgICAgdmFyIHNpYmxpbmcgPSBuZXcgQnJhbmNoQ2h1bmsoc3BpbGxlZCk7XHJcbiAgICAgICAgaWYgKCFtZS5wYXJlbnQpIHsgLy8gQmVjb21lIHRoZSBwYXJlbnQgbm9kZVxyXG4gICAgICAgICAgdmFyIGNvcHkgPSBuZXcgQnJhbmNoQ2h1bmsobWUuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgY29weS5wYXJlbnQgPSBtZTtcclxuICAgICAgICAgIG1lLmNoaWxkcmVuID0gW2NvcHksIHNpYmxpbmddO1xyXG4gICAgICAgICAgbWUgPSBjb3B5O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBtZS5zaXplIC09IHNpYmxpbmcuc2l6ZTtcclxuICAgICAgICAgIG1lLmhlaWdodCAtPSBzaWJsaW5nLmhlaWdodDtcclxuICAgICAgICAgIHZhciBteUluZGV4ID0gaW5kZXhPZihtZS5wYXJlbnQuY2hpbGRyZW4sIG1lKTtcclxuICAgICAgICAgIG1lLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UobXlJbmRleCArIDEsIDAsIHNpYmxpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzaWJsaW5nLnBhcmVudCA9IG1lLnBhcmVudDtcclxuICAgICAgfSB3aGlsZSAobWUuY2hpbGRyZW4ubGVuZ3RoID4gMTApO1xyXG4gICAgICBtZS5wYXJlbnQubWF5YmVTcGlsbCgpO1xyXG4gICAgfSxcclxuICAgIGl0ZXJOOiBmdW5jdGlvbihhdCwgbiwgb3ApIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgc3ogPSBjaGlsZC5jaHVua1NpemUoKTtcclxuICAgICAgICBpZiAoYXQgPCBzeikge1xyXG4gICAgICAgICAgdmFyIHVzZWQgPSBNYXRoLm1pbihuLCBzeiAtIGF0KTtcclxuICAgICAgICAgIGlmIChjaGlsZC5pdGVyTihhdCwgdXNlZCwgb3ApKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIGlmICgobiAtPSB1c2VkKSA9PSAwKSBicmVhaztcclxuICAgICAgICAgIGF0ID0gMDtcclxuICAgICAgICB9IGVsc2UgYXQgLT0gc3o7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICB2YXIgbmV4dERvY0lkID0gMDtcclxuICB2YXIgRG9jID0gQ29kZU1pcnJvci5Eb2MgPSBmdW5jdGlvbih0ZXh0LCBtb2RlLCBmaXJzdExpbmUpIHtcclxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEb2MpKSByZXR1cm4gbmV3IERvYyh0ZXh0LCBtb2RlLCBmaXJzdExpbmUpO1xyXG4gICAgaWYgKGZpcnN0TGluZSA9PSBudWxsKSBmaXJzdExpbmUgPSAwO1xyXG5cclxuICAgIEJyYW5jaENodW5rLmNhbGwodGhpcywgW25ldyBMZWFmQ2h1bmsoW25ldyBMaW5lKFwiXCIsIG51bGwpXSldKTtcclxuICAgIHRoaXMuZmlyc3QgPSBmaXJzdExpbmU7XHJcbiAgICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsTGVmdCA9IDA7XHJcbiAgICB0aGlzLmNhbnRFZGl0ID0gZmFsc2U7XHJcbiAgICB0aGlzLmNsZWFuR2VuZXJhdGlvbiA9IDE7XHJcbiAgICB0aGlzLmZyb250aWVyID0gZmlyc3RMaW5lO1xyXG4gICAgdmFyIHN0YXJ0ID0gUG9zKGZpcnN0TGluZSwgMCk7XHJcbiAgICB0aGlzLnNlbCA9IHNpbXBsZVNlbGVjdGlvbihzdGFydCk7XHJcbiAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSGlzdG9yeShudWxsKTtcclxuICAgIHRoaXMuaWQgPSArK25leHREb2NJZDtcclxuICAgIHRoaXMubW9kZU9wdGlvbiA9IG1vZGU7XHJcblxyXG4gICAgaWYgKHR5cGVvZiB0ZXh0ID09IFwic3RyaW5nXCIpIHRleHQgPSBzcGxpdExpbmVzKHRleHQpO1xyXG4gICAgdXBkYXRlRG9jKHRoaXMsIHtmcm9tOiBzdGFydCwgdG86IHN0YXJ0LCB0ZXh0OiB0ZXh0fSk7XHJcbiAgICBzZXRTZWxlY3Rpb24odGhpcywgc2ltcGxlU2VsZWN0aW9uKHN0YXJ0KSwgc2VsX2RvbnRTY3JvbGwpO1xyXG4gIH07XHJcblxyXG4gIERvYy5wcm90b3R5cGUgPSBjcmVhdGVPYmooQnJhbmNoQ2h1bmsucHJvdG90eXBlLCB7XHJcbiAgICBjb25zdHJ1Y3RvcjogRG9jLFxyXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBkb2N1bWVudC4gU3VwcG9ydHMgdHdvIGZvcm1zIC0tIHdpdGggb25seSBvbmVcclxuICAgIC8vIGFyZ3VtZW50LCBpdCBjYWxscyB0aGF0IGZvciBlYWNoIGxpbmUgaW4gdGhlIGRvY3VtZW50LiBXaXRoXHJcbiAgICAvLyB0aHJlZSwgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgcmFuZ2UgZ2l2ZW4gYnkgdGhlIGZpcnN0IHR3byAod2l0aFxyXG4gICAgLy8gdGhlIHNlY29uZCBiZWluZyBub24taW5jbHVzaXZlKS5cclxuICAgIGl0ZXI6IGZ1bmN0aW9uKGZyb20sIHRvLCBvcCkge1xyXG4gICAgICBpZiAob3ApIHRoaXMuaXRlck4oZnJvbSAtIHRoaXMuZmlyc3QsIHRvIC0gZnJvbSwgb3ApO1xyXG4gICAgICBlbHNlIHRoaXMuaXRlck4odGhpcy5maXJzdCwgdGhpcy5maXJzdCArIHRoaXMuc2l6ZSwgZnJvbSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIE5vbi1wdWJsaWMgaW50ZXJmYWNlIGZvciBhZGRpbmcgYW5kIHJlbW92aW5nIGxpbmVzLlxyXG4gICAgaW5zZXJ0OiBmdW5jdGlvbihhdCwgbGluZXMpIHtcclxuICAgICAgdmFyIGhlaWdodCA9IDA7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIGhlaWdodCArPSBsaW5lc1tpXS5oZWlnaHQ7XHJcbiAgICAgIHRoaXMuaW5zZXJ0SW5uZXIoYXQgLSB0aGlzLmZpcnN0LCBsaW5lcywgaGVpZ2h0KTtcclxuICAgIH0sXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uKGF0LCBuKSB7IHRoaXMucmVtb3ZlSW5uZXIoYXQgLSB0aGlzLmZpcnN0LCBuKTsgfSxcclxuXHJcbiAgICAvLyBGcm9tIGhlcmUsIHRoZSBtZXRob2RzIGFyZSBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLiBNb3N0XHJcbiAgICAvLyBhcmUgYWxzbyBhdmFpbGFibGUgZnJvbSBDb2RlTWlycm9yIChlZGl0b3IpIGluc3RhbmNlcy5cclxuXHJcbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24obGluZVNlcCkge1xyXG4gICAgICB2YXIgbGluZXMgPSBnZXRMaW5lcyh0aGlzLCB0aGlzLmZpcnN0LCB0aGlzLmZpcnN0ICsgdGhpcy5zaXplKTtcclxuICAgICAgaWYgKGxpbmVTZXAgPT09IGZhbHNlKSByZXR1cm4gbGluZXM7XHJcbiAgICAgIHJldHVybiBsaW5lcy5qb2luKGxpbmVTZXAgfHwgXCJcXG5cIik7XHJcbiAgICB9LFxyXG4gICAgc2V0VmFsdWU6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGNvZGUpIHtcclxuICAgICAgdmFyIHRvcCA9IFBvcyh0aGlzLmZpcnN0LCAwKSwgbGFzdCA9IHRoaXMuZmlyc3QgKyB0aGlzLnNpemUgLSAxO1xyXG4gICAgICBtYWtlQ2hhbmdlKHRoaXMsIHtmcm9tOiB0b3AsIHRvOiBQb3MobGFzdCwgZ2V0TGluZSh0aGlzLCBsYXN0KS50ZXh0Lmxlbmd0aCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHNwbGl0TGluZXMoY29kZSksIG9yaWdpbjogXCJzZXRWYWx1ZVwiLCBmdWxsOiB0cnVlfSwgdHJ1ZSk7XHJcbiAgICAgIHNldFNlbGVjdGlvbih0aGlzLCBzaW1wbGVTZWxlY3Rpb24odG9wKSk7XHJcbiAgICB9KSxcclxuICAgIHJlcGxhY2VSYW5nZTogZnVuY3Rpb24oY29kZSwgZnJvbSwgdG8sIG9yaWdpbikge1xyXG4gICAgICBmcm9tID0gY2xpcFBvcyh0aGlzLCBmcm9tKTtcclxuICAgICAgdG8gPSB0byA/IGNsaXBQb3ModGhpcywgdG8pIDogZnJvbTtcclxuICAgICAgcmVwbGFjZVJhbmdlKHRoaXMsIGNvZGUsIGZyb20sIHRvLCBvcmlnaW4pO1xyXG4gICAgfSxcclxuICAgIGdldFJhbmdlOiBmdW5jdGlvbihmcm9tLCB0bywgbGluZVNlcCkge1xyXG4gICAgICB2YXIgbGluZXMgPSBnZXRCZXR3ZWVuKHRoaXMsIGNsaXBQb3ModGhpcywgZnJvbSksIGNsaXBQb3ModGhpcywgdG8pKTtcclxuICAgICAgaWYgKGxpbmVTZXAgPT09IGZhbHNlKSByZXR1cm4gbGluZXM7XHJcbiAgICAgIHJldHVybiBsaW5lcy5qb2luKGxpbmVTZXAgfHwgXCJcXG5cIik7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldExpbmU6IGZ1bmN0aW9uKGxpbmUpIHt2YXIgbCA9IHRoaXMuZ2V0TGluZUhhbmRsZShsaW5lKTsgcmV0dXJuIGwgJiYgbC50ZXh0O30sXHJcblxyXG4gICAgZ2V0TGluZUhhbmRsZTogZnVuY3Rpb24obGluZSkge2lmIChpc0xpbmUodGhpcywgbGluZSkpIHJldHVybiBnZXRMaW5lKHRoaXMsIGxpbmUpO30sXHJcbiAgICBnZXRMaW5lTnVtYmVyOiBmdW5jdGlvbihsaW5lKSB7cmV0dXJuIGxpbmVObyhsaW5lKTt9LFxyXG5cclxuICAgIGdldExpbmVIYW5kbGVWaXN1YWxTdGFydDogZnVuY3Rpb24obGluZSkge1xyXG4gICAgICBpZiAodHlwZW9mIGxpbmUgPT0gXCJudW1iZXJcIikgbGluZSA9IGdldExpbmUodGhpcywgbGluZSk7XHJcbiAgICAgIHJldHVybiB2aXN1YWxMaW5lKGxpbmUpO1xyXG4gICAgfSxcclxuXHJcbiAgICBsaW5lQ291bnQ6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLnNpemU7fSxcclxuICAgIGZpcnN0TGluZTogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuZmlyc3Q7fSxcclxuICAgIGxhc3RMaW5lOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5maXJzdCArIHRoaXMuc2l6ZSAtIDE7fSxcclxuXHJcbiAgICBjbGlwUG9zOiBmdW5jdGlvbihwb3MpIHtyZXR1cm4gY2xpcFBvcyh0aGlzLCBwb3MpO30sXHJcblxyXG4gICAgZ2V0Q3Vyc29yOiBmdW5jdGlvbihzdGFydCkge1xyXG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLnNlbC5wcmltYXJ5KCksIHBvcztcclxuICAgICAgaWYgKHN0YXJ0ID09IG51bGwgfHwgc3RhcnQgPT0gXCJoZWFkXCIpIHBvcyA9IHJhbmdlLmhlYWQ7XHJcbiAgICAgIGVsc2UgaWYgKHN0YXJ0ID09IFwiYW5jaG9yXCIpIHBvcyA9IHJhbmdlLmFuY2hvcjtcclxuICAgICAgZWxzZSBpZiAoc3RhcnQgPT0gXCJlbmRcIiB8fCBzdGFydCA9PSBcInRvXCIgfHwgc3RhcnQgPT09IGZhbHNlKSBwb3MgPSByYW5nZS50bygpO1xyXG4gICAgICBlbHNlIHBvcyA9IHJhbmdlLmZyb20oKTtcclxuICAgICAgcmV0dXJuIHBvcztcclxuICAgIH0sXHJcbiAgICBsaXN0U2VsZWN0aW9uczogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnNlbC5yYW5nZXM7IH0sXHJcbiAgICBzb21ldGhpbmdTZWxlY3RlZDogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCk7fSxcclxuXHJcbiAgICBzZXRDdXJzb3I6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGxpbmUsIGNoLCBvcHRpb25zKSB7XHJcbiAgICAgIHNldFNpbXBsZVNlbGVjdGlvbih0aGlzLCBjbGlwUG9zKHRoaXMsIHR5cGVvZiBsaW5lID09IFwibnVtYmVyXCIgPyBQb3MobGluZSwgY2ggfHwgMCkgOiBsaW5lKSwgbnVsbCwgb3B0aW9ucyk7XHJcbiAgICB9KSxcclxuICAgIHNldFNlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oYW5jaG9yLCBoZWFkLCBvcHRpb25zKSB7XHJcbiAgICAgIHNldFNpbXBsZVNlbGVjdGlvbih0aGlzLCBjbGlwUG9zKHRoaXMsIGFuY2hvciksIGNsaXBQb3ModGhpcywgaGVhZCB8fCBhbmNob3IpLCBvcHRpb25zKTtcclxuICAgIH0pLFxyXG4gICAgZXh0ZW5kU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbihoZWFkLCBvdGhlciwgb3B0aW9ucykge1xyXG4gICAgICBleHRlbmRTZWxlY3Rpb24odGhpcywgY2xpcFBvcyh0aGlzLCBoZWFkKSwgb3RoZXIgJiYgY2xpcFBvcyh0aGlzLCBvdGhlciksIG9wdGlvbnMpO1xyXG4gICAgfSksXHJcbiAgICBleHRlbmRTZWxlY3Rpb25zOiBkb2NNZXRob2RPcChmdW5jdGlvbihoZWFkcywgb3B0aW9ucykge1xyXG4gICAgICBleHRlbmRTZWxlY3Rpb25zKHRoaXMsIGNsaXBQb3NBcnJheSh0aGlzLCBoZWFkcywgb3B0aW9ucykpO1xyXG4gICAgfSksXHJcbiAgICBleHRlbmRTZWxlY3Rpb25zQnk6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGYsIG9wdGlvbnMpIHtcclxuICAgICAgZXh0ZW5kU2VsZWN0aW9ucyh0aGlzLCBtYXAodGhpcy5zZWwucmFuZ2VzLCBmKSwgb3B0aW9ucyk7XHJcbiAgICB9KSxcclxuICAgIHNldFNlbGVjdGlvbnM6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKHJhbmdlcywgcHJpbWFyeSwgb3B0aW9ucykge1xyXG4gICAgICBpZiAoIXJhbmdlcy5sZW5ndGgpIHJldHVybjtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIG91dCA9IFtdOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIG91dFtpXSA9IG5ldyBSYW5nZShjbGlwUG9zKHRoaXMsIHJhbmdlc1tpXS5hbmNob3IpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwUG9zKHRoaXMsIHJhbmdlc1tpXS5oZWFkKSk7XHJcbiAgICAgIGlmIChwcmltYXJ5ID09IG51bGwpIHByaW1hcnkgPSBNYXRoLm1pbihyYW5nZXMubGVuZ3RoIC0gMSwgdGhpcy5zZWwucHJpbUluZGV4KTtcclxuICAgICAgc2V0U2VsZWN0aW9uKHRoaXMsIG5vcm1hbGl6ZVNlbGVjdGlvbihvdXQsIHByaW1hcnkpLCBvcHRpb25zKTtcclxuICAgIH0pLFxyXG4gICAgYWRkU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbihhbmNob3IsIGhlYWQsIG9wdGlvbnMpIHtcclxuICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuc2VsLnJhbmdlcy5zbGljZSgwKTtcclxuICAgICAgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKGNsaXBQb3ModGhpcywgYW5jaG9yKSwgY2xpcFBvcyh0aGlzLCBoZWFkIHx8IGFuY2hvcikpKTtcclxuICAgICAgc2V0U2VsZWN0aW9uKHRoaXMsIG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMsIHJhbmdlcy5sZW5ndGggLSAxKSwgb3B0aW9ucyk7XHJcbiAgICB9KSxcclxuXHJcbiAgICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uKGxpbmVTZXApIHtcclxuICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuc2VsLnJhbmdlcywgbGluZXM7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHNlbCA9IGdldEJldHdlZW4odGhpcywgcmFuZ2VzW2ldLmZyb20oKSwgcmFuZ2VzW2ldLnRvKCkpO1xyXG4gICAgICAgIGxpbmVzID0gbGluZXMgPyBsaW5lcy5jb25jYXQoc2VsKSA6IHNlbDtcclxuICAgICAgfVxyXG4gICAgICBpZiAobGluZVNlcCA9PT0gZmFsc2UpIHJldHVybiBsaW5lcztcclxuICAgICAgZWxzZSByZXR1cm4gbGluZXMuam9pbihsaW5lU2VwIHx8IFwiXFxuXCIpO1xyXG4gICAgfSxcclxuICAgIGdldFNlbGVjdGlvbnM6IGZ1bmN0aW9uKGxpbmVTZXApIHtcclxuICAgICAgdmFyIHBhcnRzID0gW10sIHJhbmdlcyA9IHRoaXMuc2VsLnJhbmdlcztcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgc2VsID0gZ2V0QmV0d2Vlbih0aGlzLCByYW5nZXNbaV0uZnJvbSgpLCByYW5nZXNbaV0udG8oKSk7XHJcbiAgICAgICAgaWYgKGxpbmVTZXAgIT09IGZhbHNlKSBzZWwgPSBzZWwuam9pbihsaW5lU2VwIHx8IFwiXFxuXCIpO1xyXG4gICAgICAgIHBhcnRzW2ldID0gc2VsO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBwYXJ0cztcclxuICAgIH0sXHJcbiAgICByZXBsYWNlU2VsZWN0aW9uOiBmdW5jdGlvbihjb2RlLCBjb2xsYXBzZSwgb3JpZ2luKSB7XHJcbiAgICAgIHZhciBkdXAgPSBbXTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgZHVwW2ldID0gY29kZTtcclxuICAgICAgdGhpcy5yZXBsYWNlU2VsZWN0aW9ucyhkdXAsIGNvbGxhcHNlLCBvcmlnaW4gfHwgXCIraW5wdXRcIik7XHJcbiAgICB9LFxyXG4gICAgcmVwbGFjZVNlbGVjdGlvbnM6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGNvZGUsIGNvbGxhcHNlLCBvcmlnaW4pIHtcclxuICAgICAgdmFyIGNoYW5nZXMgPSBbXSwgc2VsID0gdGhpcy5zZWw7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciByYW5nZSA9IHNlbC5yYW5nZXNbaV07XHJcbiAgICAgICAgY2hhbmdlc1tpXSA9IHtmcm9tOiByYW5nZS5mcm9tKCksIHRvOiByYW5nZS50bygpLCB0ZXh0OiBzcGxpdExpbmVzKGNvZGVbaV0pLCBvcmlnaW46IG9yaWdpbn07XHJcbiAgICAgIH1cclxuICAgICAgdmFyIG5ld1NlbCA9IGNvbGxhcHNlICYmIGNvbGxhcHNlICE9IFwiZW5kXCIgJiYgY29tcHV0ZVJlcGxhY2VkU2VsKHRoaXMsIGNoYW5nZXMsIGNvbGxhcHNlKTtcclxuICAgICAgZm9yICh2YXIgaSA9IGNoYW5nZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICAgICAgbWFrZUNoYW5nZSh0aGlzLCBjaGFuZ2VzW2ldKTtcclxuICAgICAgaWYgKG5ld1NlbCkgc2V0U2VsZWN0aW9uUmVwbGFjZUhpc3RvcnkodGhpcywgbmV3U2VsKTtcclxuICAgICAgZWxzZSBpZiAodGhpcy5jbSkgZW5zdXJlQ3Vyc29yVmlzaWJsZSh0aGlzLmNtKTtcclxuICAgIH0pLFxyXG4gICAgdW5kbzogZG9jTWV0aG9kT3AoZnVuY3Rpb24oKSB7bWFrZUNoYW5nZUZyb21IaXN0b3J5KHRoaXMsIFwidW5kb1wiKTt9KSxcclxuICAgIHJlZG86IGRvY01ldGhvZE9wKGZ1bmN0aW9uKCkge21ha2VDaGFuZ2VGcm9tSGlzdG9yeSh0aGlzLCBcInJlZG9cIik7fSksXHJcbiAgICB1bmRvU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbigpIHttYWtlQ2hhbmdlRnJvbUhpc3RvcnkodGhpcywgXCJ1bmRvXCIsIHRydWUpO30pLFxyXG4gICAgcmVkb1NlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oKSB7bWFrZUNoYW5nZUZyb21IaXN0b3J5KHRoaXMsIFwicmVkb1wiLCB0cnVlKTt9KSxcclxuXHJcbiAgICBzZXRFeHRlbmRpbmc6IGZ1bmN0aW9uKHZhbCkge3RoaXMuZXh0ZW5kID0gdmFsO30sXHJcbiAgICBnZXRFeHRlbmRpbmc6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmV4dGVuZDt9LFxyXG5cclxuICAgIGhpc3RvcnlTaXplOiBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGhpc3QgPSB0aGlzLmhpc3RvcnksIGRvbmUgPSAwLCB1bmRvbmUgPSAwO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhpc3QuZG9uZS5sZW5ndGg7IGkrKykgaWYgKCFoaXN0LmRvbmVbaV0ucmFuZ2VzKSArK2RvbmU7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlzdC51bmRvbmUubGVuZ3RoOyBpKyspIGlmICghaGlzdC51bmRvbmVbaV0ucmFuZ2VzKSArK3VuZG9uZTtcclxuICAgICAgcmV0dXJuIHt1bmRvOiBkb25lLCByZWRvOiB1bmRvbmV9O1xyXG4gICAgfSxcclxuICAgIGNsZWFySGlzdG9yeTogZnVuY3Rpb24oKSB7dGhpcy5oaXN0b3J5ID0gbmV3IEhpc3RvcnkodGhpcy5oaXN0b3J5Lm1heEdlbmVyYXRpb24pO30sXHJcblxyXG4gICAgbWFya0NsZWFuOiBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy5jbGVhbkdlbmVyYXRpb24gPSB0aGlzLmNoYW5nZUdlbmVyYXRpb24odHJ1ZSk7XHJcbiAgICB9LFxyXG4gICAgY2hhbmdlR2VuZXJhdGlvbjogZnVuY3Rpb24oZm9yY2VTcGxpdCkge1xyXG4gICAgICBpZiAoZm9yY2VTcGxpdClcclxuICAgICAgICB0aGlzLmhpc3RvcnkubGFzdE9wID0gdGhpcy5oaXN0b3J5Lmxhc3RTZWxPcCA9IHRoaXMuaGlzdG9yeS5sYXN0T3JpZ2luID0gbnVsbDtcclxuICAgICAgcmV0dXJuIHRoaXMuaGlzdG9yeS5nZW5lcmF0aW9uO1xyXG4gICAgfSxcclxuICAgIGlzQ2xlYW46IGZ1bmN0aW9uIChnZW4pIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaGlzdG9yeS5nZW5lcmF0aW9uID09IChnZW4gfHwgdGhpcy5jbGVhbkdlbmVyYXRpb24pO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRIaXN0b3J5OiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHtkb25lOiBjb3B5SGlzdG9yeUFycmF5KHRoaXMuaGlzdG9yeS5kb25lKSxcclxuICAgICAgICAgICAgICB1bmRvbmU6IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LnVuZG9uZSl9O1xyXG4gICAgfSxcclxuICAgIHNldEhpc3Rvcnk6IGZ1bmN0aW9uKGhpc3REYXRhKSB7XHJcbiAgICAgIHZhciBoaXN0ID0gdGhpcy5oaXN0b3J5ID0gbmV3IEhpc3RvcnkodGhpcy5oaXN0b3J5Lm1heEdlbmVyYXRpb24pO1xyXG4gICAgICBoaXN0LmRvbmUgPSBjb3B5SGlzdG9yeUFycmF5KGhpc3REYXRhLmRvbmUuc2xpY2UoMCksIG51bGwsIHRydWUpO1xyXG4gICAgICBoaXN0LnVuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkoaGlzdERhdGEudW5kb25lLnNsaWNlKDApLCBudWxsLCB0cnVlKTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkTGluZUNsYXNzOiBkb2NNZXRob2RPcChmdW5jdGlvbihoYW5kbGUsIHdoZXJlLCBjbHMpIHtcclxuICAgICAgcmV0dXJuIGNoYW5nZUxpbmUodGhpcywgaGFuZGxlLCB3aGVyZSA9PSBcImd1dHRlclwiID8gXCJndXR0ZXJcIiA6IFwiY2xhc3NcIiwgZnVuY3Rpb24obGluZSkge1xyXG4gICAgICAgIHZhciBwcm9wID0gd2hlcmUgPT0gXCJ0ZXh0XCIgPyBcInRleHRDbGFzc1wiXHJcbiAgICAgICAgICAgICAgICAgOiB3aGVyZSA9PSBcImJhY2tncm91bmRcIiA/IFwiYmdDbGFzc1wiXHJcbiAgICAgICAgICAgICAgICAgOiB3aGVyZSA9PSBcImd1dHRlclwiID8gXCJndXR0ZXJDbGFzc1wiIDogXCJ3cmFwQ2xhc3NcIjtcclxuICAgICAgICBpZiAoIWxpbmVbcHJvcF0pIGxpbmVbcHJvcF0gPSBjbHM7XHJcbiAgICAgICAgZWxzZSBpZiAoY2xhc3NUZXN0KGNscykudGVzdChsaW5lW3Byb3BdKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGVsc2UgbGluZVtwcm9wXSArPSBcIiBcIiArIGNscztcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfSk7XHJcbiAgICB9KSxcclxuICAgIHJlbW92ZUxpbmVDbGFzczogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGFuZGxlLCB3aGVyZSwgY2xzKSB7XHJcbiAgICAgIHJldHVybiBjaGFuZ2VMaW5lKHRoaXMsIGhhbmRsZSwgd2hlcmUgPT0gXCJndXR0ZXJcIiA/IFwiZ3V0dGVyXCIgOiBcImNsYXNzXCIsIGZ1bmN0aW9uKGxpbmUpIHtcclxuICAgICAgICB2YXIgcHJvcCA9IHdoZXJlID09IFwidGV4dFwiID8gXCJ0ZXh0Q2xhc3NcIlxyXG4gICAgICAgICAgICAgICAgIDogd2hlcmUgPT0gXCJiYWNrZ3JvdW5kXCIgPyBcImJnQ2xhc3NcIlxyXG4gICAgICAgICAgICAgICAgIDogd2hlcmUgPT0gXCJndXR0ZXJcIiA/IFwiZ3V0dGVyQ2xhc3NcIiA6IFwid3JhcENsYXNzXCI7XHJcbiAgICAgICAgdmFyIGN1ciA9IGxpbmVbcHJvcF07XHJcbiAgICAgICAgaWYgKCFjdXIpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBlbHNlIGlmIChjbHMgPT0gbnVsbCkgbGluZVtwcm9wXSA9IG51bGw7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICB2YXIgZm91bmQgPSBjdXIubWF0Y2goY2xhc3NUZXN0KGNscykpO1xyXG4gICAgICAgICAgaWYgKCFmb3VuZCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgdmFyIGVuZCA9IGZvdW5kLmluZGV4ICsgZm91bmRbMF0ubGVuZ3RoO1xyXG4gICAgICAgICAgbGluZVtwcm9wXSA9IGN1ci5zbGljZSgwLCBmb3VuZC5pbmRleCkgKyAoIWZvdW5kLmluZGV4IHx8IGVuZCA9PSBjdXIubGVuZ3RoID8gXCJcIiA6IFwiIFwiKSArIGN1ci5zbGljZShlbmQpIHx8IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9KTtcclxuICAgIH0pLFxyXG5cclxuICAgIGFkZExpbmVXaWRnZXQ6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGhhbmRsZSwgbm9kZSwgb3B0aW9ucykge1xyXG4gICAgICByZXR1cm4gYWRkTGluZVdpZGdldCh0aGlzLCBoYW5kbGUsIG5vZGUsIG9wdGlvbnMpO1xyXG4gICAgfSksXHJcbiAgICByZW1vdmVMaW5lV2lkZ2V0OiBmdW5jdGlvbih3aWRnZXQpIHsgd2lkZ2V0LmNsZWFyKCk7IH0sXHJcblxyXG4gICAgbWFya1RleHQ6IGZ1bmN0aW9uKGZyb20sIHRvLCBvcHRpb25zKSB7XHJcbiAgICAgIHJldHVybiBtYXJrVGV4dCh0aGlzLCBjbGlwUG9zKHRoaXMsIGZyb20pLCBjbGlwUG9zKHRoaXMsIHRvKSwgb3B0aW9ucywgXCJyYW5nZVwiKTtcclxuICAgIH0sXHJcbiAgICBzZXRCb29rbWFyazogZnVuY3Rpb24ocG9zLCBvcHRpb25zKSB7XHJcbiAgICAgIHZhciByZWFsT3B0cyA9IHtyZXBsYWNlZFdpdGg6IG9wdGlvbnMgJiYgKG9wdGlvbnMubm9kZVR5cGUgPT0gbnVsbCA/IG9wdGlvbnMud2lkZ2V0IDogb3B0aW9ucyksXHJcbiAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRMZWZ0OiBvcHRpb25zICYmIG9wdGlvbnMuaW5zZXJ0TGVmdCxcclxuICAgICAgICAgICAgICAgICAgICAgIGNsZWFyV2hlbkVtcHR5OiBmYWxzZSwgc2hhcmVkOiBvcHRpb25zICYmIG9wdGlvbnMuc2hhcmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgaGFuZGxlTW91c2VFdmVudHM6IG9wdGlvbnMgJiYgb3B0aW9ucy5oYW5kbGVNb3VzZUV2ZW50c307XHJcbiAgICAgIHBvcyA9IGNsaXBQb3ModGhpcywgcG9zKTtcclxuICAgICAgcmV0dXJuIG1hcmtUZXh0KHRoaXMsIHBvcywgcG9zLCByZWFsT3B0cywgXCJib29rbWFya1wiKTtcclxuICAgIH0sXHJcbiAgICBmaW5kTWFya3NBdDogZnVuY3Rpb24ocG9zKSB7XHJcbiAgICAgIHBvcyA9IGNsaXBQb3ModGhpcywgcG9zKTtcclxuICAgICAgdmFyIG1hcmtlcnMgPSBbXSwgc3BhbnMgPSBnZXRMaW5lKHRoaXMsIHBvcy5saW5lKS5tYXJrZWRTcGFucztcclxuICAgICAgaWYgKHNwYW5zKSBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdmFyIHNwYW4gPSBzcGFuc1tpXTtcclxuICAgICAgICBpZiAoKHNwYW4uZnJvbSA9PSBudWxsIHx8IHNwYW4uZnJvbSA8PSBwb3MuY2gpICYmXHJcbiAgICAgICAgICAgIChzcGFuLnRvID09IG51bGwgfHwgc3Bhbi50byA+PSBwb3MuY2gpKVxyXG4gICAgICAgICAgbWFya2Vycy5wdXNoKHNwYW4ubWFya2VyLnBhcmVudCB8fCBzcGFuLm1hcmtlcik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG1hcmtlcnM7XHJcbiAgICB9LFxyXG4gICAgZmluZE1hcmtzOiBmdW5jdGlvbihmcm9tLCB0bywgZmlsdGVyKSB7XHJcbiAgICAgIGZyb20gPSBjbGlwUG9zKHRoaXMsIGZyb20pOyB0byA9IGNsaXBQb3ModGhpcywgdG8pO1xyXG4gICAgICB2YXIgZm91bmQgPSBbXSwgbGluZU5vID0gZnJvbS5saW5lO1xyXG4gICAgICB0aGlzLml0ZXIoZnJvbS5saW5lLCB0by5saW5lICsgMSwgZnVuY3Rpb24obGluZSkge1xyXG4gICAgICAgIHZhciBzcGFucyA9IGxpbmUubWFya2VkU3BhbnM7XHJcbiAgICAgICAgaWYgKHNwYW5zKSBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICB2YXIgc3BhbiA9IHNwYW5zW2ldO1xyXG4gICAgICAgICAgaWYgKCEobGluZU5vID09IGZyb20ubGluZSAmJiBmcm9tLmNoID4gc3Bhbi50byB8fFxyXG4gICAgICAgICAgICAgICAgc3Bhbi5mcm9tID09IG51bGwgJiYgbGluZU5vICE9IGZyb20ubGluZXx8XHJcbiAgICAgICAgICAgICAgICBsaW5lTm8gPT0gdG8ubGluZSAmJiBzcGFuLmZyb20gPiB0by5jaCkgJiZcclxuICAgICAgICAgICAgICAoIWZpbHRlciB8fCBmaWx0ZXIoc3Bhbi5tYXJrZXIpKSlcclxuICAgICAgICAgICAgZm91bmQucHVzaChzcGFuLm1hcmtlci5wYXJlbnQgfHwgc3Bhbi5tYXJrZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICArK2xpbmVObztcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBmb3VuZDtcclxuICAgIH0sXHJcbiAgICBnZXRBbGxNYXJrczogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBtYXJrZXJzID0gW107XHJcbiAgICAgIHRoaXMuaXRlcihmdW5jdGlvbihsaW5lKSB7XHJcbiAgICAgICAgdmFyIHNwcyA9IGxpbmUubWFya2VkU3BhbnM7XHJcbiAgICAgICAgaWYgKHNwcykgZm9yICh2YXIgaSA9IDA7IGkgPCBzcHMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICBpZiAoc3BzW2ldLmZyb20gIT0gbnVsbCkgbWFya2Vycy5wdXNoKHNwc1tpXS5tYXJrZXIpO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIG1hcmtlcnM7XHJcbiAgICB9LFxyXG5cclxuICAgIHBvc0Zyb21JbmRleDogZnVuY3Rpb24ob2ZmKSB7XHJcbiAgICAgIHZhciBjaCwgbGluZU5vID0gdGhpcy5maXJzdDtcclxuICAgICAgdGhpcy5pdGVyKGZ1bmN0aW9uKGxpbmUpIHtcclxuICAgICAgICB2YXIgc3ogPSBsaW5lLnRleHQubGVuZ3RoICsgMTtcclxuICAgICAgICBpZiAoc3ogPiBvZmYpIHsgY2ggPSBvZmY7IHJldHVybiB0cnVlOyB9XHJcbiAgICAgICAgb2ZmIC09IHN6O1xyXG4gICAgICAgICsrbGluZU5vO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGNsaXBQb3ModGhpcywgUG9zKGxpbmVObywgY2gpKTtcclxuICAgIH0sXHJcbiAgICBpbmRleEZyb21Qb3M6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuICAgICAgY29vcmRzID0gY2xpcFBvcyh0aGlzLCBjb29yZHMpO1xyXG4gICAgICB2YXIgaW5kZXggPSBjb29yZHMuY2g7XHJcbiAgICAgIGlmIChjb29yZHMubGluZSA8IHRoaXMuZmlyc3QgfHwgY29vcmRzLmNoIDwgMCkgcmV0dXJuIDA7XHJcbiAgICAgIHRoaXMuaXRlcih0aGlzLmZpcnN0LCBjb29yZHMubGluZSwgZnVuY3Rpb24gKGxpbmUpIHtcclxuICAgICAgICBpbmRleCArPSBsaW5lLnRleHQubGVuZ3RoICsgMTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBpbmRleDtcclxuICAgIH0sXHJcblxyXG4gICAgY29weTogZnVuY3Rpb24oY29weUhpc3RvcnkpIHtcclxuICAgICAgdmFyIGRvYyA9IG5ldyBEb2MoZ2V0TGluZXModGhpcywgdGhpcy5maXJzdCwgdGhpcy5maXJzdCArIHRoaXMuc2l6ZSksIHRoaXMubW9kZU9wdGlvbiwgdGhpcy5maXJzdCk7XHJcbiAgICAgIGRvYy5zY3JvbGxUb3AgPSB0aGlzLnNjcm9sbFRvcDsgZG9jLnNjcm9sbExlZnQgPSB0aGlzLnNjcm9sbExlZnQ7XHJcbiAgICAgIGRvYy5zZWwgPSB0aGlzLnNlbDtcclxuICAgICAgZG9jLmV4dGVuZCA9IGZhbHNlO1xyXG4gICAgICBpZiAoY29weUhpc3RvcnkpIHtcclxuICAgICAgICBkb2MuaGlzdG9yeS51bmRvRGVwdGggPSB0aGlzLmhpc3RvcnkudW5kb0RlcHRoO1xyXG4gICAgICAgIGRvYy5zZXRIaXN0b3J5KHRoaXMuZ2V0SGlzdG9yeSgpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZG9jO1xyXG4gICAgfSxcclxuXHJcbiAgICBsaW5rZWREb2M6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XHJcbiAgICAgIHZhciBmcm9tID0gdGhpcy5maXJzdCwgdG8gPSB0aGlzLmZpcnN0ICsgdGhpcy5zaXplO1xyXG4gICAgICBpZiAob3B0aW9ucy5mcm9tICE9IG51bGwgJiYgb3B0aW9ucy5mcm9tID4gZnJvbSkgZnJvbSA9IG9wdGlvbnMuZnJvbTtcclxuICAgICAgaWYgKG9wdGlvbnMudG8gIT0gbnVsbCAmJiBvcHRpb25zLnRvIDwgdG8pIHRvID0gb3B0aW9ucy50bztcclxuICAgICAgdmFyIGNvcHkgPSBuZXcgRG9jKGdldExpbmVzKHRoaXMsIGZyb20sIHRvKSwgb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZU9wdGlvbiwgZnJvbSk7XHJcbiAgICAgIGlmIChvcHRpb25zLnNoYXJlZEhpc3QpIGNvcHkuaGlzdG9yeSA9IHRoaXMuaGlzdG9yeTtcclxuICAgICAgKHRoaXMubGlua2VkIHx8ICh0aGlzLmxpbmtlZCA9IFtdKSkucHVzaCh7ZG9jOiBjb3B5LCBzaGFyZWRIaXN0OiBvcHRpb25zLnNoYXJlZEhpc3R9KTtcclxuICAgICAgY29weS5saW5rZWQgPSBbe2RvYzogdGhpcywgaXNQYXJlbnQ6IHRydWUsIHNoYXJlZEhpc3Q6IG9wdGlvbnMuc2hhcmVkSGlzdH1dO1xyXG4gICAgICBjb3B5U2hhcmVkTWFya2Vycyhjb3B5LCBmaW5kU2hhcmVkTWFya2Vycyh0aGlzKSk7XHJcbiAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgfSxcclxuICAgIHVubGlua0RvYzogZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQ29kZU1pcnJvcikgb3RoZXIgPSBvdGhlci5kb2M7XHJcbiAgICAgIGlmICh0aGlzLmxpbmtlZCkgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmtlZC5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHZhciBsaW5rID0gdGhpcy5saW5rZWRbaV07XHJcbiAgICAgICAgaWYgKGxpbmsuZG9jICE9IG90aGVyKSBjb250aW51ZTtcclxuICAgICAgICB0aGlzLmxpbmtlZC5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgb3RoZXIudW5saW5rRG9jKHRoaXMpO1xyXG4gICAgICAgIGRldGFjaFNoYXJlZE1hcmtlcnMoZmluZFNoYXJlZE1hcmtlcnModGhpcykpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIElmIHRoZSBoaXN0b3JpZXMgd2VyZSBzaGFyZWQsIHNwbGl0IHRoZW0gYWdhaW5cclxuICAgICAgaWYgKG90aGVyLmhpc3RvcnkgPT0gdGhpcy5oaXN0b3J5KSB7XHJcbiAgICAgICAgdmFyIHNwbGl0SWRzID0gW290aGVyLmlkXTtcclxuICAgICAgICBsaW5rZWREb2NzKG90aGVyLCBmdW5jdGlvbihkb2MpIHtzcGxpdElkcy5wdXNoKGRvYy5pZCk7fSwgdHJ1ZSk7XHJcbiAgICAgICAgb3RoZXIuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KG51bGwpO1xyXG4gICAgICAgIG90aGVyLmhpc3RvcnkuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LmRvbmUsIHNwbGl0SWRzKTtcclxuICAgICAgICBvdGhlci5oaXN0b3J5LnVuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LnVuZG9uZSwgc3BsaXRJZHMpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgaXRlckxpbmtlZERvY3M6IGZ1bmN0aW9uKGYpIHtsaW5rZWREb2NzKHRoaXMsIGYpO30sXHJcblxyXG4gICAgZ2V0TW9kZTogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMubW9kZTt9LFxyXG4gICAgZ2V0RWRpdG9yOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5jbTt9XHJcbiAgfSk7XHJcblxyXG4gIC8vIFB1YmxpYyBhbGlhcy5cclxuICBEb2MucHJvdG90eXBlLmVhY2hMaW5lID0gRG9jLnByb3RvdHlwZS5pdGVyO1xyXG5cclxuICAvLyBTZXQgdXAgbWV0aG9kcyBvbiBDb2RlTWlycm9yJ3MgcHJvdG90eXBlIHRvIHJlZGlyZWN0IHRvIHRoZSBlZGl0b3IncyBkb2N1bWVudC5cclxuICB2YXIgZG9udERlbGVnYXRlID0gXCJpdGVyIGluc2VydCByZW1vdmUgY29weSBnZXRFZGl0b3JcIi5zcGxpdChcIiBcIik7XHJcbiAgZm9yICh2YXIgcHJvcCBpbiBEb2MucHJvdG90eXBlKSBpZiAoRG9jLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBpbmRleE9mKGRvbnREZWxlZ2F0ZSwgcHJvcCkgPCAwKVxyXG4gICAgQ29kZU1pcnJvci5wcm90b3R5cGVbcHJvcF0gPSAoZnVuY3Rpb24obWV0aG9kKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtyZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMuZG9jLCBhcmd1bWVudHMpO307XHJcbiAgICB9KShEb2MucHJvdG90eXBlW3Byb3BdKTtcclxuXHJcbiAgZXZlbnRNaXhpbihEb2MpO1xyXG5cclxuICAvLyBDYWxsIGYgZm9yIGFsbCBsaW5rZWQgZG9jdW1lbnRzLlxyXG4gIGZ1bmN0aW9uIGxpbmtlZERvY3MoZG9jLCBmLCBzaGFyZWRIaXN0T25seSkge1xyXG4gICAgZnVuY3Rpb24gcHJvcGFnYXRlKGRvYywgc2tpcCwgc2hhcmVkSGlzdCkge1xyXG4gICAgICBpZiAoZG9jLmxpbmtlZCkgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2MubGlua2VkLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdmFyIHJlbCA9IGRvYy5saW5rZWRbaV07XHJcbiAgICAgICAgaWYgKHJlbC5kb2MgPT0gc2tpcCkgY29udGludWU7XHJcbiAgICAgICAgdmFyIHNoYXJlZCA9IHNoYXJlZEhpc3QgJiYgcmVsLnNoYXJlZEhpc3Q7XHJcbiAgICAgICAgaWYgKHNoYXJlZEhpc3RPbmx5ICYmICFzaGFyZWQpIGNvbnRpbnVlO1xyXG4gICAgICAgIGYocmVsLmRvYywgc2hhcmVkKTtcclxuICAgICAgICBwcm9wYWdhdGUocmVsLmRvYywgZG9jLCBzaGFyZWQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBwcm9wYWdhdGUoZG9jLCBudWxsLCB0cnVlKTtcclxuICB9XHJcblxyXG4gIC8vIEF0dGFjaCBhIGRvY3VtZW50IHRvIGFuIGVkaXRvci5cclxuICBmdW5jdGlvbiBhdHRhY2hEb2MoY20sIGRvYykge1xyXG4gICAgaWYgKGRvYy5jbSkgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBkb2N1bWVudCBpcyBhbHJlYWR5IGluIHVzZS5cIik7XHJcbiAgICBjbS5kb2MgPSBkb2M7XHJcbiAgICBkb2MuY20gPSBjbTtcclxuICAgIGVzdGltYXRlTGluZUhlaWdodHMoY20pO1xyXG4gICAgbG9hZE1vZGUoY20pO1xyXG4gICAgaWYgKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykgZmluZE1heExpbmUoY20pO1xyXG4gICAgY20ub3B0aW9ucy5tb2RlID0gZG9jLm1vZGVPcHRpb247XHJcbiAgICByZWdDaGFuZ2UoY20pO1xyXG4gIH1cclxuXHJcbiAgLy8gTElORSBVVElMSVRJRVNcclxuXHJcbiAgLy8gRmluZCB0aGUgbGluZSBvYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGluZSBudW1iZXIuXHJcbiAgZnVuY3Rpb24gZ2V0TGluZShkb2MsIG4pIHtcclxuICAgIG4gLT0gZG9jLmZpcnN0O1xyXG4gICAgaWYgKG4gPCAwIHx8IG4gPj0gZG9jLnNpemUpIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIGxpbmUgXCIgKyAobiArIGRvYy5maXJzdCkgKyBcIiBpbiB0aGUgZG9jdW1lbnQuXCIpO1xyXG4gICAgZm9yICh2YXIgY2h1bmsgPSBkb2M7ICFjaHVuay5saW5lczspIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7OyArK2kpIHtcclxuICAgICAgICB2YXIgY2hpbGQgPSBjaHVuay5jaGlsZHJlbltpXSwgc3ogPSBjaGlsZC5jaHVua1NpemUoKTtcclxuICAgICAgICBpZiAobiA8IHN6KSB7IGNodW5rID0gY2hpbGQ7IGJyZWFrOyB9XHJcbiAgICAgICAgbiAtPSBzejtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNodW5rLmxpbmVzW25dO1xyXG4gIH1cclxuXHJcbiAgLy8gR2V0IHRoZSBwYXJ0IG9mIGEgZG9jdW1lbnQgYmV0d2VlbiB0d28gcG9zaXRpb25zLCBhcyBhbiBhcnJheSBvZlxyXG4gIC8vIHN0cmluZ3MuXHJcbiAgZnVuY3Rpb24gZ2V0QmV0d2Vlbihkb2MsIHN0YXJ0LCBlbmQpIHtcclxuICAgIHZhciBvdXQgPSBbXSwgbiA9IHN0YXJ0LmxpbmU7XHJcbiAgICBkb2MuaXRlcihzdGFydC5saW5lLCBlbmQubGluZSArIDEsIGZ1bmN0aW9uKGxpbmUpIHtcclxuICAgICAgdmFyIHRleHQgPSBsaW5lLnRleHQ7XHJcbiAgICAgIGlmIChuID09IGVuZC5saW5lKSB0ZXh0ID0gdGV4dC5zbGljZSgwLCBlbmQuY2gpO1xyXG4gICAgICBpZiAobiA9PSBzdGFydC5saW5lKSB0ZXh0ID0gdGV4dC5zbGljZShzdGFydC5jaCk7XHJcbiAgICAgIG91dC5wdXNoKHRleHQpO1xyXG4gICAgICArK247XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBvdXQ7XHJcbiAgfVxyXG4gIC8vIEdldCB0aGUgbGluZXMgYmV0d2VlbiBmcm9tIGFuZCB0bywgYXMgYXJyYXkgb2Ygc3RyaW5ncy5cclxuICBmdW5jdGlvbiBnZXRMaW5lcyhkb2MsIGZyb20sIHRvKSB7XHJcbiAgICB2YXIgb3V0ID0gW107XHJcbiAgICBkb2MuaXRlcihmcm9tLCB0bywgZnVuY3Rpb24obGluZSkgeyBvdXQucHVzaChsaW5lLnRleHQpOyB9KTtcclxuICAgIHJldHVybiBvdXQ7XHJcbiAgfVxyXG5cclxuICAvLyBVcGRhdGUgdGhlIGhlaWdodCBvZiBhIGxpbmUsIHByb3BhZ2F0aW5nIHRoZSBoZWlnaHQgY2hhbmdlXHJcbiAgLy8gdXB3YXJkcyB0byBwYXJlbnQgbm9kZXMuXHJcbiAgZnVuY3Rpb24gdXBkYXRlTGluZUhlaWdodChsaW5lLCBoZWlnaHQpIHtcclxuICAgIHZhciBkaWZmID0gaGVpZ2h0IC0gbGluZS5oZWlnaHQ7XHJcbiAgICBpZiAoZGlmZikgZm9yICh2YXIgbiA9IGxpbmU7IG47IG4gPSBuLnBhcmVudCkgbi5oZWlnaHQgKz0gZGlmZjtcclxuICB9XHJcblxyXG4gIC8vIEdpdmVuIGEgbGluZSBvYmplY3QsIGZpbmQgaXRzIGxpbmUgbnVtYmVyIGJ5IHdhbGtpbmcgdXAgdGhyb3VnaFxyXG4gIC8vIGl0cyBwYXJlbnQgbGlua3MuXHJcbiAgZnVuY3Rpb24gbGluZU5vKGxpbmUpIHtcclxuICAgIGlmIChsaW5lLnBhcmVudCA9PSBudWxsKSByZXR1cm4gbnVsbDtcclxuICAgIHZhciBjdXIgPSBsaW5lLnBhcmVudCwgbm8gPSBpbmRleE9mKGN1ci5saW5lcywgbGluZSk7XHJcbiAgICBmb3IgKHZhciBjaHVuayA9IGN1ci5wYXJlbnQ7IGNodW5rOyBjdXIgPSBjaHVuaywgY2h1bmsgPSBjaHVuay5wYXJlbnQpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7OyArK2kpIHtcclxuICAgICAgICBpZiAoY2h1bmsuY2hpbGRyZW5baV0gPT0gY3VyKSBicmVhaztcclxuICAgICAgICBubyArPSBjaHVuay5jaGlsZHJlbltpXS5jaHVua1NpemUoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vICsgY3VyLmZpcnN0O1xyXG4gIH1cclxuXHJcbiAgLy8gRmluZCB0aGUgbGluZSBhdCB0aGUgZ2l2ZW4gdmVydGljYWwgcG9zaXRpb24sIHVzaW5nIHRoZSBoZWlnaHRcclxuICAvLyBpbmZvcm1hdGlvbiBpbiB0aGUgZG9jdW1lbnQgdHJlZS5cclxuICBmdW5jdGlvbiBsaW5lQXRIZWlnaHQoY2h1bmssIGgpIHtcclxuICAgIHZhciBuID0gY2h1bmsuZmlyc3Q7XHJcbiAgICBvdXRlcjogZG8ge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkID0gY2h1bmsuY2hpbGRyZW5baV0sIGNoID0gY2hpbGQuaGVpZ2h0O1xyXG4gICAgICAgIGlmIChoIDwgY2gpIHsgY2h1bmsgPSBjaGlsZDsgY29udGludWUgb3V0ZXI7IH1cclxuICAgICAgICBoIC09IGNoO1xyXG4gICAgICAgIG4gKz0gY2hpbGQuY2h1bmtTaXplKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9IHdoaWxlICghY2h1bmsubGluZXMpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaHVuay5saW5lcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICB2YXIgbGluZSA9IGNodW5rLmxpbmVzW2ldLCBsaCA9IGxpbmUuaGVpZ2h0O1xyXG4gICAgICBpZiAoaCA8IGxoKSBicmVhaztcclxuICAgICAgaCAtPSBsaDtcclxuICAgIH1cclxuICAgIHJldHVybiBuICsgaTtcclxuICB9XHJcblxyXG5cclxuICAvLyBGaW5kIHRoZSBoZWlnaHQgYWJvdmUgdGhlIGdpdmVuIGxpbmUuXHJcbiAgZnVuY3Rpb24gaGVpZ2h0QXRMaW5lKGxpbmVPYmopIHtcclxuICAgIGxpbmVPYmogPSB2aXN1YWxMaW5lKGxpbmVPYmopO1xyXG5cclxuICAgIHZhciBoID0gMCwgY2h1bmsgPSBsaW5lT2JqLnBhcmVudDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmsubGluZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgdmFyIGxpbmUgPSBjaHVuay5saW5lc1tpXTtcclxuICAgICAgaWYgKGxpbmUgPT0gbGluZU9iaikgYnJlYWs7XHJcbiAgICAgIGVsc2UgaCArPSBsaW5lLmhlaWdodDtcclxuICAgIH1cclxuICAgIGZvciAodmFyIHAgPSBjaHVuay5wYXJlbnQ7IHA7IGNodW5rID0gcCwgcCA9IGNodW5rLnBhcmVudCkge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICB2YXIgY3VyID0gcC5jaGlsZHJlbltpXTtcclxuICAgICAgICBpZiAoY3VyID09IGNodW5rKSBicmVhaztcclxuICAgICAgICBlbHNlIGggKz0gY3VyLmhlaWdodDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGg7XHJcbiAgfVxyXG5cclxuICAvLyBHZXQgdGhlIGJpZGkgb3JkZXJpbmcgZm9yIHRoZSBnaXZlbiBsaW5lIChhbmQgY2FjaGUgaXQpLiBSZXR1cm5zXHJcbiAgLy8gZmFsc2UgZm9yIGxpbmVzIHRoYXQgYXJlIGZ1bGx5IGxlZnQtdG8tcmlnaHQsIGFuZCBhbiBhcnJheSBvZlxyXG4gIC8vIEJpZGlTcGFuIG9iamVjdHMgb3RoZXJ3aXNlLlxyXG4gIGZ1bmN0aW9uIGdldE9yZGVyKGxpbmUpIHtcclxuICAgIHZhciBvcmRlciA9IGxpbmUub3JkZXI7XHJcbiAgICBpZiAob3JkZXIgPT0gbnVsbCkgb3JkZXIgPSBsaW5lLm9yZGVyID0gYmlkaU9yZGVyaW5nKGxpbmUudGV4dCk7XHJcbiAgICByZXR1cm4gb3JkZXI7XHJcbiAgfVxyXG5cclxuICAvLyBISVNUT1JZXHJcblxyXG4gIGZ1bmN0aW9uIEhpc3Rvcnkoc3RhcnRHZW4pIHtcclxuICAgIC8vIEFycmF5cyBvZiBjaGFuZ2UgZXZlbnRzIGFuZCBzZWxlY3Rpb25zLiBEb2luZyBzb21ldGhpbmcgYWRkcyBhblxyXG4gICAgLy8gZXZlbnQgdG8gZG9uZSBhbmQgY2xlYXJzIHVuZG8uIFVuZG9pbmcgbW92ZXMgZXZlbnRzIGZyb20gZG9uZVxyXG4gICAgLy8gdG8gdW5kb25lLCByZWRvaW5nIG1vdmVzIHRoZW0gaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cclxuICAgIHRoaXMuZG9uZSA9IFtdOyB0aGlzLnVuZG9uZSA9IFtdO1xyXG4gICAgdGhpcy51bmRvRGVwdGggPSBJbmZpbml0eTtcclxuICAgIC8vIFVzZWQgdG8gdHJhY2sgd2hlbiBjaGFuZ2VzIGNhbiBiZSBtZXJnZWQgaW50byBhIHNpbmdsZSB1bmRvXHJcbiAgICAvLyBldmVudFxyXG4gICAgdGhpcy5sYXN0TW9kVGltZSA9IHRoaXMubGFzdFNlbFRpbWUgPSAwO1xyXG4gICAgdGhpcy5sYXN0T3AgPSB0aGlzLmxhc3RTZWxPcCA9IG51bGw7XHJcbiAgICB0aGlzLmxhc3RPcmlnaW4gPSB0aGlzLmxhc3RTZWxPcmlnaW4gPSBudWxsO1xyXG4gICAgLy8gVXNlZCBieSB0aGUgaXNDbGVhbigpIG1ldGhvZFxyXG4gICAgdGhpcy5nZW5lcmF0aW9uID0gdGhpcy5tYXhHZW5lcmF0aW9uID0gc3RhcnRHZW4gfHwgMTtcclxuICB9XHJcblxyXG4gIC8vIENyZWF0ZSBhIGhpc3RvcnkgY2hhbmdlIGV2ZW50IGZyb20gYW4gdXBkYXRlRG9jLXN0eWxlIGNoYW5nZVxyXG4gIC8vIG9iamVjdC5cclxuICBmdW5jdGlvbiBoaXN0b3J5Q2hhbmdlRnJvbUNoYW5nZShkb2MsIGNoYW5nZSkge1xyXG4gICAgdmFyIGhpc3RDaGFuZ2UgPSB7ZnJvbTogY29weVBvcyhjaGFuZ2UuZnJvbSksIHRvOiBjaGFuZ2VFbmQoY2hhbmdlKSwgdGV4dDogZ2V0QmV0d2Vlbihkb2MsIGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pfTtcclxuICAgIGF0dGFjaExvY2FsU3BhbnMoZG9jLCBoaXN0Q2hhbmdlLCBjaGFuZ2UuZnJvbS5saW5lLCBjaGFuZ2UudG8ubGluZSArIDEpO1xyXG4gICAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uKGRvYykge2F0dGFjaExvY2FsU3BhbnMoZG9jLCBoaXN0Q2hhbmdlLCBjaGFuZ2UuZnJvbS5saW5lLCBjaGFuZ2UudG8ubGluZSArIDEpO30sIHRydWUpO1xyXG4gICAgcmV0dXJuIGhpc3RDaGFuZ2U7XHJcbiAgfVxyXG5cclxuICAvLyBQb3AgYWxsIHNlbGVjdGlvbiBldmVudHMgb2ZmIHRoZSBlbmQgb2YgYSBoaXN0b3J5IGFycmF5LiBTdG9wIGF0XHJcbiAgLy8gYSBjaGFuZ2UgZXZlbnQuXHJcbiAgZnVuY3Rpb24gY2xlYXJTZWxlY3Rpb25FdmVudHMoYXJyYXkpIHtcclxuICAgIHdoaWxlIChhcnJheS5sZW5ndGgpIHtcclxuICAgICAgdmFyIGxhc3QgPSBsc3QoYXJyYXkpO1xyXG4gICAgICBpZiAobGFzdC5yYW5nZXMpIGFycmF5LnBvcCgpO1xyXG4gICAgICBlbHNlIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRmluZCB0aGUgdG9wIGNoYW5nZSBldmVudCBpbiB0aGUgaGlzdG9yeS4gUG9wIG9mZiBzZWxlY3Rpb25cclxuICAvLyBldmVudHMgdGhhdCBhcmUgaW4gdGhlIHdheS5cclxuICBmdW5jdGlvbiBsYXN0Q2hhbmdlRXZlbnQoaGlzdCwgZm9yY2UpIHtcclxuICAgIGlmIChmb3JjZSkge1xyXG4gICAgICBjbGVhclNlbGVjdGlvbkV2ZW50cyhoaXN0LmRvbmUpO1xyXG4gICAgICByZXR1cm4gbHN0KGhpc3QuZG9uZSk7XHJcbiAgICB9IGVsc2UgaWYgKGhpc3QuZG9uZS5sZW5ndGggJiYgIWxzdChoaXN0LmRvbmUpLnJhbmdlcykge1xyXG4gICAgICByZXR1cm4gbHN0KGhpc3QuZG9uZSk7XHJcbiAgICB9IGVsc2UgaWYgKGhpc3QuZG9uZS5sZW5ndGggPiAxICYmICFoaXN0LmRvbmVbaGlzdC5kb25lLmxlbmd0aCAtIDJdLnJhbmdlcykge1xyXG4gICAgICBoaXN0LmRvbmUucG9wKCk7XHJcbiAgICAgIHJldHVybiBsc3QoaGlzdC5kb25lKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFJlZ2lzdGVyIGEgY2hhbmdlIGluIHRoZSBoaXN0b3J5LiBNZXJnZXMgY2hhbmdlcyB0aGF0IGFyZSB3aXRoaW5cclxuICAvLyBhIHNpbmdsZSBvcGVyYXRpb24sIG9yZSBhcmUgY2xvc2UgdG9nZXRoZXIgd2l0aCBhbiBvcmlnaW4gdGhhdFxyXG4gIC8vIGFsbG93cyBtZXJnaW5nIChzdGFydGluZyB3aXRoIFwiK1wiKSBpbnRvIGEgc2luZ2xlIGV2ZW50LlxyXG4gIGZ1bmN0aW9uIGFkZENoYW5nZVRvSGlzdG9yeShkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIG9wSWQpIHtcclxuICAgIHZhciBoaXN0ID0gZG9jLmhpc3Rvcnk7XHJcbiAgICBoaXN0LnVuZG9uZS5sZW5ndGggPSAwO1xyXG4gICAgdmFyIHRpbWUgPSArbmV3IERhdGUsIGN1cjtcclxuXHJcbiAgICBpZiAoKGhpc3QubGFzdE9wID09IG9wSWQgfHxcclxuICAgICAgICAgaGlzdC5sYXN0T3JpZ2luID09IGNoYW5nZS5vcmlnaW4gJiYgY2hhbmdlLm9yaWdpbiAmJlxyXG4gICAgICAgICAoKGNoYW5nZS5vcmlnaW4uY2hhckF0KDApID09IFwiK1wiICYmIGRvYy5jbSAmJiBoaXN0Lmxhc3RNb2RUaW1lID4gdGltZSAtIGRvYy5jbS5vcHRpb25zLmhpc3RvcnlFdmVudERlbGF5KSB8fFxyXG4gICAgICAgICAgY2hhbmdlLm9yaWdpbi5jaGFyQXQoMCkgPT0gXCIqXCIpKSAmJlxyXG4gICAgICAgIChjdXIgPSBsYXN0Q2hhbmdlRXZlbnQoaGlzdCwgaGlzdC5sYXN0T3AgPT0gb3BJZCkpKSB7XHJcbiAgICAgIC8vIE1lcmdlIHRoaXMgY2hhbmdlIGludG8gdGhlIGxhc3QgZXZlbnRcclxuICAgICAgdmFyIGxhc3QgPSBsc3QoY3VyLmNoYW5nZXMpO1xyXG4gICAgICBpZiAoY21wKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pID09IDAgJiYgY21wKGNoYW5nZS5mcm9tLCBsYXN0LnRvKSA9PSAwKSB7XHJcbiAgICAgICAgLy8gT3B0aW1pemVkIGNhc2UgZm9yIHNpbXBsZSBpbnNlcnRpb24gLS0gZG9uJ3Qgd2FudCB0byBhZGRcclxuICAgICAgICAvLyBuZXcgY2hhbmdlc2V0cyBmb3IgZXZlcnkgY2hhcmFjdGVyIHR5cGVkXHJcbiAgICAgICAgbGFzdC50byA9IGNoYW5nZUVuZChjaGFuZ2UpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEFkZCBuZXcgc3ViLWV2ZW50XHJcbiAgICAgICAgY3VyLmNoYW5nZXMucHVzaChoaXN0b3J5Q2hhbmdlRnJvbUNoYW5nZShkb2MsIGNoYW5nZSkpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBDYW4gbm90IGJlIG1lcmdlZCwgc3RhcnQgYSBuZXcgZXZlbnQuXHJcbiAgICAgIHZhciBiZWZvcmUgPSBsc3QoaGlzdC5kb25lKTtcclxuICAgICAgaWYgKCFiZWZvcmUgfHwgIWJlZm9yZS5yYW5nZXMpXHJcbiAgICAgICAgcHVzaFNlbGVjdGlvblRvSGlzdG9yeShkb2Muc2VsLCBoaXN0LmRvbmUpO1xyXG4gICAgICBjdXIgPSB7Y2hhbmdlczogW2hpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlKGRvYywgY2hhbmdlKV0sXHJcbiAgICAgICAgICAgICBnZW5lcmF0aW9uOiBoaXN0LmdlbmVyYXRpb259O1xyXG4gICAgICBoaXN0LmRvbmUucHVzaChjdXIpO1xyXG4gICAgICB3aGlsZSAoaGlzdC5kb25lLmxlbmd0aCA+IGhpc3QudW5kb0RlcHRoKSB7XHJcbiAgICAgICAgaGlzdC5kb25lLnNoaWZ0KCk7XHJcbiAgICAgICAgaWYgKCFoaXN0LmRvbmVbMF0ucmFuZ2VzKSBoaXN0LmRvbmUuc2hpZnQoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGlzdC5kb25lLnB1c2goc2VsQWZ0ZXIpO1xyXG4gICAgaGlzdC5nZW5lcmF0aW9uID0gKytoaXN0Lm1heEdlbmVyYXRpb247XHJcbiAgICBoaXN0Lmxhc3RNb2RUaW1lID0gaGlzdC5sYXN0U2VsVGltZSA9IHRpbWU7XHJcbiAgICBoaXN0Lmxhc3RPcCA9IGhpc3QubGFzdFNlbE9wID0gb3BJZDtcclxuICAgIGhpc3QubGFzdE9yaWdpbiA9IGhpc3QubGFzdFNlbE9yaWdpbiA9IGNoYW5nZS5vcmlnaW47XHJcblxyXG4gICAgaWYgKCFsYXN0KSBzaWduYWwoZG9jLCBcImhpc3RvcnlBZGRlZFwiKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbkV2ZW50Q2FuQmVNZXJnZWQoZG9jLCBvcmlnaW4sIHByZXYsIHNlbCkge1xyXG4gICAgdmFyIGNoID0gb3JpZ2luLmNoYXJBdCgwKTtcclxuICAgIHJldHVybiBjaCA9PSBcIipcIiB8fFxyXG4gICAgICBjaCA9PSBcIitcIiAmJlxyXG4gICAgICBwcmV2LnJhbmdlcy5sZW5ndGggPT0gc2VsLnJhbmdlcy5sZW5ndGggJiZcclxuICAgICAgcHJldi5zb21ldGhpbmdTZWxlY3RlZCgpID09IHNlbC5zb21ldGhpbmdTZWxlY3RlZCgpICYmXHJcbiAgICAgIG5ldyBEYXRlIC0gZG9jLmhpc3RvcnkubGFzdFNlbFRpbWUgPD0gKGRvYy5jbSA/IGRvYy5jbS5vcHRpb25zLmhpc3RvcnlFdmVudERlbGF5IDogNTAwKTtcclxuICB9XHJcblxyXG4gIC8vIENhbGxlZCB3aGVuZXZlciB0aGUgc2VsZWN0aW9uIGNoYW5nZXMsIHNldHMgdGhlIG5ldyBzZWxlY3Rpb24gYXNcclxuICAvLyB0aGUgcGVuZGluZyBzZWxlY3Rpb24gaW4gdGhlIGhpc3RvcnksIGFuZCBwdXNoZXMgdGhlIG9sZCBwZW5kaW5nXHJcbiAgLy8gc2VsZWN0aW9uIGludG8gdGhlICdkb25lJyBhcnJheSB3aGVuIGl0IHdhcyBzaWduaWZpY2FudGx5XHJcbiAgLy8gZGlmZmVyZW50IChpbiBudW1iZXIgb2Ygc2VsZWN0ZWQgcmFuZ2VzLCBlbXB0aW5lc3MsIG9yIHRpbWUpLlxyXG4gIGZ1bmN0aW9uIGFkZFNlbGVjdGlvblRvSGlzdG9yeShkb2MsIHNlbCwgb3BJZCwgb3B0aW9ucykge1xyXG4gICAgdmFyIGhpc3QgPSBkb2MuaGlzdG9yeSwgb3JpZ2luID0gb3B0aW9ucyAmJiBvcHRpb25zLm9yaWdpbjtcclxuXHJcbiAgICAvLyBBIG5ldyBldmVudCBpcyBzdGFydGVkIHdoZW4gdGhlIHByZXZpb3VzIG9yaWdpbiBkb2VzIG5vdCBtYXRjaFxyXG4gICAgLy8gdGhlIGN1cnJlbnQsIG9yIHRoZSBvcmlnaW5zIGRvbid0IGFsbG93IG1hdGNoaW5nLiBPcmlnaW5zXHJcbiAgICAvLyBzdGFydGluZyB3aXRoICogYXJlIGFsd2F5cyBtZXJnZWQsIHRob3NlIHN0YXJ0aW5nIHdpdGggKyBhcmVcclxuICAgIC8vIG1lcmdlZCB3aGVuIHNpbWlsYXIgYW5kIGNsb3NlIHRvZ2V0aGVyIGluIHRpbWUuXHJcbiAgICBpZiAob3BJZCA9PSBoaXN0Lmxhc3RTZWxPcCB8fFxyXG4gICAgICAgIChvcmlnaW4gJiYgaGlzdC5sYXN0U2VsT3JpZ2luID09IG9yaWdpbiAmJlxyXG4gICAgICAgICAoaGlzdC5sYXN0TW9kVGltZSA9PSBoaXN0Lmxhc3RTZWxUaW1lICYmIGhpc3QubGFzdE9yaWdpbiA9PSBvcmlnaW4gfHxcclxuICAgICAgICAgIHNlbGVjdGlvbkV2ZW50Q2FuQmVNZXJnZWQoZG9jLCBvcmlnaW4sIGxzdChoaXN0LmRvbmUpLCBzZWwpKSkpXHJcbiAgICAgIGhpc3QuZG9uZVtoaXN0LmRvbmUubGVuZ3RoIC0gMV0gPSBzZWw7XHJcbiAgICBlbHNlXHJcbiAgICAgIHB1c2hTZWxlY3Rpb25Ub0hpc3Rvcnkoc2VsLCBoaXN0LmRvbmUpO1xyXG5cclxuICAgIGhpc3QubGFzdFNlbFRpbWUgPSArbmV3IERhdGU7XHJcbiAgICBoaXN0Lmxhc3RTZWxPcmlnaW4gPSBvcmlnaW47XHJcbiAgICBoaXN0Lmxhc3RTZWxPcCA9IG9wSWQ7XHJcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNsZWFyUmVkbyAhPT0gZmFsc2UpXHJcbiAgICAgIGNsZWFyU2VsZWN0aW9uRXZlbnRzKGhpc3QudW5kb25lKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHB1c2hTZWxlY3Rpb25Ub0hpc3Rvcnkoc2VsLCBkZXN0KSB7XHJcbiAgICB2YXIgdG9wID0gbHN0KGRlc3QpO1xyXG4gICAgaWYgKCEodG9wICYmIHRvcC5yYW5nZXMgJiYgdG9wLmVxdWFscyhzZWwpKSlcclxuICAgICAgZGVzdC5wdXNoKHNlbCk7XHJcbiAgfVxyXG5cclxuICAvLyBVc2VkIHRvIHN0b3JlIG1hcmtlZCBzcGFuIGluZm9ybWF0aW9uIGluIHRoZSBoaXN0b3J5LlxyXG4gIGZ1bmN0aW9uIGF0dGFjaExvY2FsU3BhbnMoZG9jLCBjaGFuZ2UsIGZyb20sIHRvKSB7XHJcbiAgICB2YXIgZXhpc3RpbmcgPSBjaGFuZ2VbXCJzcGFuc19cIiArIGRvYy5pZF0sIG4gPSAwO1xyXG4gICAgZG9jLml0ZXIoTWF0aC5tYXgoZG9jLmZpcnN0LCBmcm9tKSwgTWF0aC5taW4oZG9jLmZpcnN0ICsgZG9jLnNpemUsIHRvKSwgZnVuY3Rpb24obGluZSkge1xyXG4gICAgICBpZiAobGluZS5tYXJrZWRTcGFucylcclxuICAgICAgICAoZXhpc3RpbmcgfHwgKGV4aXN0aW5nID0gY2hhbmdlW1wic3BhbnNfXCIgKyBkb2MuaWRdID0ge30pKVtuXSA9IGxpbmUubWFya2VkU3BhbnM7XHJcbiAgICAgICsrbjtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gV2hlbiB1bi9yZS1kb2luZyByZXN0b3JlcyB0ZXh0IGNvbnRhaW5pbmcgbWFya2VkIHNwYW5zLCB0aG9zZVxyXG4gIC8vIHRoYXQgaGF2ZSBiZWVuIGV4cGxpY2l0bHkgY2xlYXJlZCBzaG91bGQgbm90IGJlIHJlc3RvcmVkLlxyXG4gIGZ1bmN0aW9uIHJlbW92ZUNsZWFyZWRTcGFucyhzcGFucykge1xyXG4gICAgaWYgKCFzcGFucykgcmV0dXJuIG51bGw7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgb3V0OyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgaWYgKHNwYW5zW2ldLm1hcmtlci5leHBsaWNpdGx5Q2xlYXJlZCkgeyBpZiAoIW91dCkgb3V0ID0gc3BhbnMuc2xpY2UoMCwgaSk7IH1cclxuICAgICAgZWxzZSBpZiAob3V0KSBvdXQucHVzaChzcGFuc1tpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gIW91dCA/IHNwYW5zIDogb3V0Lmxlbmd0aCA/IG91dCA6IG51bGw7XHJcbiAgfVxyXG5cclxuICAvLyBSZXRyaWV2ZSBhbmQgZmlsdGVyIHRoZSBvbGQgbWFya2VkIHNwYW5zIHN0b3JlZCBpbiBhIGNoYW5nZSBldmVudC5cclxuICBmdW5jdGlvbiBnZXRPbGRTcGFucyhkb2MsIGNoYW5nZSkge1xyXG4gICAgdmFyIGZvdW5kID0gY2hhbmdlW1wic3BhbnNfXCIgKyBkb2MuaWRdO1xyXG4gICAgaWYgKCFmb3VuZCkgcmV0dXJuIG51bGw7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbncgPSBbXTsgaSA8IGNoYW5nZS50ZXh0Lmxlbmd0aDsgKytpKVxyXG4gICAgICBudy5wdXNoKHJlbW92ZUNsZWFyZWRTcGFucyhmb3VuZFtpXSkpO1xyXG4gICAgcmV0dXJuIG53O1xyXG4gIH1cclxuXHJcbiAgLy8gVXNlZCBib3RoIHRvIHByb3ZpZGUgYSBKU09OLXNhZmUgb2JqZWN0IGluIC5nZXRIaXN0b3J5LCBhbmQsIHdoZW5cclxuICAvLyBkZXRhY2hpbmcgYSBkb2N1bWVudCwgdG8gc3BsaXQgdGhlIGhpc3RvcnkgaW4gdHdvXHJcbiAgZnVuY3Rpb24gY29weUhpc3RvcnlBcnJheShldmVudHMsIG5ld0dyb3VwLCBpbnN0YW50aWF0ZVNlbCkge1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGNvcHkgPSBbXTsgaSA8IGV2ZW50cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICB2YXIgZXZlbnQgPSBldmVudHNbaV07XHJcbiAgICAgIGlmIChldmVudC5yYW5nZXMpIHtcclxuICAgICAgICBjb3B5LnB1c2goaW5zdGFudGlhdGVTZWwgPyBTZWxlY3Rpb24ucHJvdG90eXBlLmRlZXBDb3B5LmNhbGwoZXZlbnQpIDogZXZlbnQpO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBjaGFuZ2VzID0gZXZlbnQuY2hhbmdlcywgbmV3Q2hhbmdlcyA9IFtdO1xyXG4gICAgICBjb3B5LnB1c2goe2NoYW5nZXM6IG5ld0NoYW5nZXN9KTtcclxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGFuZ2VzLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbal0sIG07XHJcbiAgICAgICAgbmV3Q2hhbmdlcy5wdXNoKHtmcm9tOiBjaGFuZ2UuZnJvbSwgdG86IGNoYW5nZS50bywgdGV4dDogY2hhbmdlLnRleHR9KTtcclxuICAgICAgICBpZiAobmV3R3JvdXApIGZvciAodmFyIHByb3AgaW4gY2hhbmdlKSBpZiAobSA9IHByb3AubWF0Y2goL15zcGFuc18oXFxkKykkLykpIHtcclxuICAgICAgICAgIGlmIChpbmRleE9mKG5ld0dyb3VwLCBOdW1iZXIobVsxXSkpID4gLTEpIHtcclxuICAgICAgICAgICAgbHN0KG5ld0NoYW5nZXMpW3Byb3BdID0gY2hhbmdlW3Byb3BdO1xyXG4gICAgICAgICAgICBkZWxldGUgY2hhbmdlW3Byb3BdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvcHk7XHJcbiAgfVxyXG5cclxuICAvLyBSZWJhc2luZy9yZXNldHRpbmcgaGlzdG9yeSB0byBkZWFsIHdpdGggZXh0ZXJuYWxseS1zb3VyY2VkIGNoYW5nZXNcclxuXHJcbiAgZnVuY3Rpb24gcmViYXNlSGlzdFNlbFNpbmdsZShwb3MsIGZyb20sIHRvLCBkaWZmKSB7XHJcbiAgICBpZiAodG8gPCBwb3MubGluZSkge1xyXG4gICAgICBwb3MubGluZSArPSBkaWZmO1xyXG4gICAgfSBlbHNlIGlmIChmcm9tIDwgcG9zLmxpbmUpIHtcclxuICAgICAgcG9zLmxpbmUgPSBmcm9tO1xyXG4gICAgICBwb3MuY2ggPSAwO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gVHJpZXMgdG8gcmViYXNlIGFuIGFycmF5IG9mIGhpc3RvcnkgZXZlbnRzIGdpdmVuIGEgY2hhbmdlIGluIHRoZVxyXG4gIC8vIGRvY3VtZW50LiBJZiB0aGUgY2hhbmdlIHRvdWNoZXMgdGhlIHNhbWUgbGluZXMgYXMgdGhlIGV2ZW50LCB0aGVcclxuICAvLyBldmVudCwgYW5kIGV2ZXJ5dGhpbmcgJ2JlaGluZCcgaXQsIGlzIGRpc2NhcmRlZC4gSWYgdGhlIGNoYW5nZSBpc1xyXG4gIC8vIGJlZm9yZSB0aGUgZXZlbnQsIHRoZSBldmVudCdzIHBvc2l0aW9ucyBhcmUgdXBkYXRlZC4gVXNlcyBhXHJcbiAgLy8gY29weS1vbi13cml0ZSBzY2hlbWUgZm9yIHRoZSBwb3NpdGlvbnMsIHRvIGF2b2lkIGhhdmluZyB0b1xyXG4gIC8vIHJlYWxsb2NhdGUgdGhlbSBhbGwgb24gZXZlcnkgcmViYXNlLCBidXQgYWxzbyBhdm9pZCBwcm9ibGVtcyB3aXRoXHJcbiAgLy8gc2hhcmVkIHBvc2l0aW9uIG9iamVjdHMgYmVpbmcgdW5zYWZlbHkgdXBkYXRlZC5cclxuICBmdW5jdGlvbiByZWJhc2VIaXN0QXJyYXkoYXJyYXksIGZyb20sIHRvLCBkaWZmKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIHZhciBzdWIgPSBhcnJheVtpXSwgb2sgPSB0cnVlO1xyXG4gICAgICBpZiAoc3ViLnJhbmdlcykge1xyXG4gICAgICAgIGlmICghc3ViLmNvcGllZCkgeyBzdWIgPSBhcnJheVtpXSA9IHN1Yi5kZWVwQ29weSgpOyBzdWIuY29waWVkID0gdHJ1ZTsgfVxyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3ViLnJhbmdlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgcmViYXNlSGlzdFNlbFNpbmdsZShzdWIucmFuZ2VzW2pdLmFuY2hvciwgZnJvbSwgdG8sIGRpZmYpO1xyXG4gICAgICAgICAgcmViYXNlSGlzdFNlbFNpbmdsZShzdWIucmFuZ2VzW2pdLmhlYWQsIGZyb20sIHRvLCBkaWZmKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdWIuY2hhbmdlcy5sZW5ndGg7ICsraikge1xyXG4gICAgICAgIHZhciBjdXIgPSBzdWIuY2hhbmdlc1tqXTtcclxuICAgICAgICBpZiAodG8gPCBjdXIuZnJvbS5saW5lKSB7XHJcbiAgICAgICAgICBjdXIuZnJvbSA9IFBvcyhjdXIuZnJvbS5saW5lICsgZGlmZiwgY3VyLmZyb20uY2gpO1xyXG4gICAgICAgICAgY3VyLnRvID0gUG9zKGN1ci50by5saW5lICsgZGlmZiwgY3VyLnRvLmNoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGZyb20gPD0gY3VyLnRvLmxpbmUpIHtcclxuICAgICAgICAgIG9rID0gZmFsc2U7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFvaykge1xyXG4gICAgICAgIGFycmF5LnNwbGljZSgwLCBpICsgMSk7XHJcbiAgICAgICAgaSA9IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlYmFzZUhpc3QoaGlzdCwgY2hhbmdlKSB7XHJcbiAgICB2YXIgZnJvbSA9IGNoYW5nZS5mcm9tLmxpbmUsIHRvID0gY2hhbmdlLnRvLmxpbmUsIGRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAodG8gLSBmcm9tKSAtIDE7XHJcbiAgICByZWJhc2VIaXN0QXJyYXkoaGlzdC5kb25lLCBmcm9tLCB0bywgZGlmZik7XHJcbiAgICByZWJhc2VIaXN0QXJyYXkoaGlzdC51bmRvbmUsIGZyb20sIHRvLCBkaWZmKTtcclxuICB9XHJcblxyXG4gIC8vIEVWRU5UIFVUSUxJVElFU1xyXG5cclxuICAvLyBEdWUgdG8gdGhlIGZhY3QgdGhhdCB3ZSBzdGlsbCBzdXBwb3J0IGp1cmFzc2ljIElFIHZlcnNpb25zLCBzb21lXHJcbiAgLy8gY29tcGF0aWJpbGl0eSB3cmFwcGVycyBhcmUgbmVlZGVkLlxyXG5cclxuICB2YXIgZV9wcmV2ZW50RGVmYXVsdCA9IENvZGVNaXJyb3IuZV9wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKGUpIHtcclxuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICBlbHNlIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuICB9O1xyXG4gIHZhciBlX3N0b3BQcm9wYWdhdGlvbiA9IENvZGVNaXJyb3IuZV9zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbihlKSB7XHJcbiAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICBlbHNlIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICB9O1xyXG4gIGZ1bmN0aW9uIGVfZGVmYXVsdFByZXZlbnRlZChlKSB7XHJcbiAgICByZXR1cm4gZS5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBlLmRlZmF1bHRQcmV2ZW50ZWQgOiBlLnJldHVyblZhbHVlID09IGZhbHNlO1xyXG4gIH1cclxuICB2YXIgZV9zdG9wID0gQ29kZU1pcnJvci5lX3N0b3AgPSBmdW5jdGlvbihlKSB7ZV9wcmV2ZW50RGVmYXVsdChlKTsgZV9zdG9wUHJvcGFnYXRpb24oZSk7fTtcclxuXHJcbiAgZnVuY3Rpb24gZV90YXJnZXQoZSkge3JldHVybiBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7fVxyXG4gIGZ1bmN0aW9uIGVfYnV0dG9uKGUpIHtcclxuICAgIHZhciBiID0gZS53aGljaDtcclxuICAgIGlmIChiID09IG51bGwpIHtcclxuICAgICAgaWYgKGUuYnV0dG9uICYgMSkgYiA9IDE7XHJcbiAgICAgIGVsc2UgaWYgKGUuYnV0dG9uICYgMikgYiA9IDM7XHJcbiAgICAgIGVsc2UgaWYgKGUuYnV0dG9uICYgNCkgYiA9IDI7XHJcbiAgICB9XHJcbiAgICBpZiAobWFjICYmIGUuY3RybEtleSAmJiBiID09IDEpIGIgPSAzO1xyXG4gICAgcmV0dXJuIGI7XHJcbiAgfVxyXG5cclxuICAvLyBFVkVOVCBIQU5ETElOR1xyXG5cclxuICAvLyBMaWdodHdlaWdodCBldmVudCBmcmFtZXdvcmsuIG9uL29mZiBhbHNvIHdvcmsgb24gRE9NIG5vZGVzLFxyXG4gIC8vIHJlZ2lzdGVyaW5nIG5hdGl2ZSBET00gaGFuZGxlcnMuXHJcblxyXG4gIHZhciBvbiA9IENvZGVNaXJyb3Iub24gPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlLCBmKSB7XHJcbiAgICBpZiAoZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKVxyXG4gICAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xyXG4gICAgZWxzZSBpZiAoZW1pdHRlci5hdHRhY2hFdmVudClcclxuICAgICAgZW1pdHRlci5hdHRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBmKTtcclxuICAgIGVsc2Uge1xyXG4gICAgICB2YXIgbWFwID0gZW1pdHRlci5faGFuZGxlcnMgfHwgKGVtaXR0ZXIuX2hhbmRsZXJzID0ge30pO1xyXG4gICAgICB2YXIgYXJyID0gbWFwW3R5cGVdIHx8IChtYXBbdHlwZV0gPSBbXSk7XHJcbiAgICAgIGFyci5wdXNoKGYpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHZhciBvZmYgPSBDb2RlTWlycm9yLm9mZiA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUsIGYpIHtcclxuICAgIGlmIChlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIpXHJcbiAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmLCBmYWxzZSk7XHJcbiAgICBlbHNlIGlmIChlbWl0dGVyLmRldGFjaEV2ZW50KVxyXG4gICAgICBlbWl0dGVyLmRldGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGYpO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgIHZhciBhcnIgPSBlbWl0dGVyLl9oYW5kbGVycyAmJiBlbWl0dGVyLl9oYW5kbGVyc1t0eXBlXTtcclxuICAgICAgaWYgKCFhcnIpIHJldHVybjtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgaWYgKGFycltpXSA9PSBmKSB7IGFyci5zcGxpY2UoaSwgMSk7IGJyZWFrOyB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdmFyIHNpZ25hbCA9IENvZGVNaXJyb3Iuc2lnbmFsID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSAvKiwgdmFsdWVzLi4uKi8pIHtcclxuICAgIHZhciBhcnIgPSBlbWl0dGVyLl9oYW5kbGVycyAmJiBlbWl0dGVyLl9oYW5kbGVyc1t0eXBlXTtcclxuICAgIGlmICghYXJyKSByZXR1cm47XHJcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkgYXJyW2ldLmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gIH07XHJcblxyXG4gIHZhciBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzID0gbnVsbDtcclxuXHJcbiAgLy8gT2Z0ZW4sIHdlIHdhbnQgdG8gc2lnbmFsIGV2ZW50cyBhdCBhIHBvaW50IHdoZXJlIHdlIGFyZSBpbiB0aGVcclxuICAvLyBtaWRkbGUgb2Ygc29tZSB3b3JrLCBidXQgZG9uJ3Qgd2FudCB0aGUgaGFuZGxlciB0byBzdGFydCBjYWxsaW5nXHJcbiAgLy8gb3RoZXIgbWV0aG9kcyBvbiB0aGUgZWRpdG9yLCB3aGljaCBtaWdodCBiZSBpbiBhbiBpbmNvbnNpc3RlbnRcclxuICAvLyBzdGF0ZSBvciBzaW1wbHkgbm90IGV4cGVjdCBhbnkgb3RoZXIgZXZlbnRzIHRvIGhhcHBlbi5cclxuICAvLyBzaWduYWxMYXRlciBsb29rcyB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgaGFuZGxlcnMsIGFuZCBzY2hlZHVsZXNcclxuICAvLyB0aGVtIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGxhc3Qgb3BlcmF0aW9uIGVuZHMsIG9yLCBpZiBub1xyXG4gIC8vIG9wZXJhdGlvbiBpcyBhY3RpdmUsIHdoZW4gYSB0aW1lb3V0IGZpcmVzLlxyXG4gIGZ1bmN0aW9uIHNpZ25hbExhdGVyKGVtaXR0ZXIsIHR5cGUgLyosIHZhbHVlcy4uLiovKSB7XHJcbiAgICB2YXIgYXJyID0gZW1pdHRlci5faGFuZGxlcnMgJiYgZW1pdHRlci5faGFuZGxlcnNbdHlwZV07XHJcbiAgICBpZiAoIWFycikgcmV0dXJuO1xyXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLCBsaXN0O1xyXG4gICAgaWYgKG9wZXJhdGlvbkdyb3VwKSB7XHJcbiAgICAgIGxpc3QgPSBvcGVyYXRpb25Hcm91cC5kZWxheWVkQ2FsbGJhY2tzO1xyXG4gICAgfSBlbHNlIGlmIChvcnBoYW5EZWxheWVkQ2FsbGJhY2tzKSB7XHJcbiAgICAgIGxpc3QgPSBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGlzdCA9IG9ycGhhbkRlbGF5ZWRDYWxsYmFja3MgPSBbXTtcclxuICAgICAgc2V0VGltZW91dChmaXJlT3JwaGFuRGVsYXllZCwgMCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBibmQoZikge3JldHVybiBmdW5jdGlvbigpe2YuYXBwbHkobnVsbCwgYXJncyk7fTt9O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpXHJcbiAgICAgIGxpc3QucHVzaChibmQoYXJyW2ldKSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmaXJlT3JwaGFuRGVsYXllZCgpIHtcclxuICAgIHZhciBkZWxheWVkID0gb3JwaGFuRGVsYXllZENhbGxiYWNrcztcclxuICAgIG9ycGhhbkRlbGF5ZWRDYWxsYmFja3MgPSBudWxsO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxheWVkLmxlbmd0aDsgKytpKSBkZWxheWVkW2ldKCk7XHJcbiAgfVxyXG5cclxuICAvLyBUaGUgRE9NIGV2ZW50cyB0aGF0IENvZGVNaXJyb3IgaGFuZGxlcyBjYW4gYmUgb3ZlcnJpZGRlbiBieVxyXG4gIC8vIHJlZ2lzdGVyaW5nIGEgKG5vbi1ET00pIGhhbmRsZXIgb24gdGhlIGVkaXRvciBmb3IgdGhlIGV2ZW50IG5hbWUsXHJcbiAgLy8gYW5kIHByZXZlbnREZWZhdWx0LWluZyB0aGUgZXZlbnQgaW4gdGhhdCBoYW5kbGVyLlxyXG4gIGZ1bmN0aW9uIHNpZ25hbERPTUV2ZW50KGNtLCBlLCBvdmVycmlkZSkge1xyXG4gICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXHJcbiAgICAgIGUgPSB7dHlwZTogZSwgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkgeyB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlOyB9fTtcclxuICAgIHNpZ25hbChjbSwgb3ZlcnJpZGUgfHwgZS50eXBlLCBjbSwgZSk7XHJcbiAgICByZXR1cm4gZV9kZWZhdWx0UHJldmVudGVkKGUpIHx8IGUuY29kZW1pcnJvcklnbm9yZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNpZ25hbEN1cnNvckFjdGl2aXR5KGNtKSB7XHJcbiAgICB2YXIgYXJyID0gY20uX2hhbmRsZXJzICYmIGNtLl9oYW5kbGVycy5jdXJzb3JBY3Rpdml0eTtcclxuICAgIGlmICghYXJyKSByZXR1cm47XHJcbiAgICB2YXIgc2V0ID0gY20uY3VyT3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycyB8fCAoY20uY3VyT3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycyA9IFtdKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSBpZiAoaW5kZXhPZihzZXQsIGFycltpXSkgPT0gLTEpXHJcbiAgICAgIHNldC5wdXNoKGFycltpXSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBoYXNIYW5kbGVyKGVtaXR0ZXIsIHR5cGUpIHtcclxuICAgIHZhciBhcnIgPSBlbWl0dGVyLl9oYW5kbGVycyAmJiBlbWl0dGVyLl9oYW5kbGVyc1t0eXBlXTtcclxuICAgIHJldHVybiBhcnIgJiYgYXJyLmxlbmd0aCA+IDA7XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgb24gYW5kIG9mZiBtZXRob2RzIHRvIGEgY29uc3RydWN0b3IncyBwcm90b3R5cGUsIHRvIG1ha2VcclxuICAvLyByZWdpc3RlcmluZyBldmVudHMgb24gc3VjaCBvYmplY3RzIG1vcmUgY29udmVuaWVudC5cclxuICBmdW5jdGlvbiBldmVudE1peGluKGN0b3IpIHtcclxuICAgIGN0b3IucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgZikge29uKHRoaXMsIHR5cGUsIGYpO307XHJcbiAgICBjdG9yLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbih0eXBlLCBmKSB7b2ZmKHRoaXMsIHR5cGUsIGYpO307XHJcbiAgfVxyXG5cclxuICAvLyBNSVNDIFVUSUxJVElFU1xyXG5cclxuICAvLyBOdW1iZXIgb2YgcGl4ZWxzIGFkZGVkIHRvIHNjcm9sbGVyIGFuZCBzaXplciB0byBoaWRlIHNjcm9sbGJhclxyXG4gIHZhciBzY3JvbGxlckdhcCA9IDMwO1xyXG5cclxuICAvLyBSZXR1cm5lZCBvciB0aHJvd24gYnkgdmFyaW91cyBwcm90b2NvbHMgdG8gc2lnbmFsICdJJ20gbm90XHJcbiAgLy8gaGFuZGxpbmcgdGhpcycuXHJcbiAgdmFyIFBhc3MgPSBDb2RlTWlycm9yLlBhc3MgPSB7dG9TdHJpbmc6IGZ1bmN0aW9uKCl7cmV0dXJuIFwiQ29kZU1pcnJvci5QYXNzXCI7fX07XHJcblxyXG4gIC8vIFJldXNlZCBvcHRpb24gb2JqZWN0cyBmb3Igc2V0U2VsZWN0aW9uICYgZnJpZW5kc1xyXG4gIHZhciBzZWxfZG9udFNjcm9sbCA9IHtzY3JvbGw6IGZhbHNlfSwgc2VsX21vdXNlID0ge29yaWdpbjogXCIqbW91c2VcIn0sIHNlbF9tb3ZlID0ge29yaWdpbjogXCIrbW92ZVwifTtcclxuXHJcbiAgZnVuY3Rpb24gRGVsYXllZCgpIHt0aGlzLmlkID0gbnVsbDt9XHJcbiAgRGVsYXllZC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obXMsIGYpIHtcclxuICAgIGNsZWFyVGltZW91dCh0aGlzLmlkKTtcclxuICAgIHRoaXMuaWQgPSBzZXRUaW1lb3V0KGYsIG1zKTtcclxuICB9O1xyXG5cclxuICAvLyBDb3VudHMgdGhlIGNvbHVtbiBvZmZzZXQgaW4gYSBzdHJpbmcsIHRha2luZyB0YWJzIGludG8gYWNjb3VudC5cclxuICAvLyBVc2VkIG1vc3RseSB0byBmaW5kIGluZGVudGF0aW9uLlxyXG4gIHZhciBjb3VudENvbHVtbiA9IENvZGVNaXJyb3IuY291bnRDb2x1bW4gPSBmdW5jdGlvbihzdHJpbmcsIGVuZCwgdGFiU2l6ZSwgc3RhcnRJbmRleCwgc3RhcnRWYWx1ZSkge1xyXG4gICAgaWYgKGVuZCA9PSBudWxsKSB7XHJcbiAgICAgIGVuZCA9IHN0cmluZy5zZWFyY2goL1teXFxzXFx1MDBhMF0vKTtcclxuICAgICAgaWYgKGVuZCA9PSAtMSkgZW5kID0gc3RyaW5nLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4IHx8IDAsIG4gPSBzdGFydFZhbHVlIHx8IDA7Oykge1xyXG4gICAgICB2YXIgbmV4dFRhYiA9IHN0cmluZy5pbmRleE9mKFwiXFx0XCIsIGkpO1xyXG4gICAgICBpZiAobmV4dFRhYiA8IDAgfHwgbmV4dFRhYiA+PSBlbmQpXHJcbiAgICAgICAgcmV0dXJuIG4gKyAoZW5kIC0gaSk7XHJcbiAgICAgIG4gKz0gbmV4dFRhYiAtIGk7XHJcbiAgICAgIG4gKz0gdGFiU2l6ZSAtIChuICUgdGFiU2l6ZSk7XHJcbiAgICAgIGkgPSBuZXh0VGFiICsgMTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBUaGUgaW52ZXJzZSBvZiBjb3VudENvbHVtbiAtLSBmaW5kIHRoZSBvZmZzZXQgdGhhdCBjb3JyZXNwb25kcyB0b1xyXG4gIC8vIGEgcGFydGljdWxhciBjb2x1bW4uXHJcbiAgZnVuY3Rpb24gZmluZENvbHVtbihzdHJpbmcsIGdvYWwsIHRhYlNpemUpIHtcclxuICAgIGZvciAodmFyIHBvcyA9IDAsIGNvbCA9IDA7Oykge1xyXG4gICAgICB2YXIgbmV4dFRhYiA9IHN0cmluZy5pbmRleE9mKFwiXFx0XCIsIHBvcyk7XHJcbiAgICAgIGlmIChuZXh0VGFiID09IC0xKSBuZXh0VGFiID0gc3RyaW5nLmxlbmd0aDtcclxuICAgICAgdmFyIHNraXBwZWQgPSBuZXh0VGFiIC0gcG9zO1xyXG4gICAgICBpZiAobmV4dFRhYiA9PSBzdHJpbmcubGVuZ3RoIHx8IGNvbCArIHNraXBwZWQgPj0gZ29hbClcclxuICAgICAgICByZXR1cm4gcG9zICsgTWF0aC5taW4oc2tpcHBlZCwgZ29hbCAtIGNvbCk7XHJcbiAgICAgIGNvbCArPSBuZXh0VGFiIC0gcG9zO1xyXG4gICAgICBjb2wgKz0gdGFiU2l6ZSAtIChjb2wgJSB0YWJTaXplKTtcclxuICAgICAgcG9zID0gbmV4dFRhYiArIDE7XHJcbiAgICAgIGlmIChjb2wgPj0gZ29hbCkgcmV0dXJuIHBvcztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBzcGFjZVN0cnMgPSBbXCJcIl07XHJcbiAgZnVuY3Rpb24gc3BhY2VTdHIobikge1xyXG4gICAgd2hpbGUgKHNwYWNlU3Rycy5sZW5ndGggPD0gbilcclxuICAgICAgc3BhY2VTdHJzLnB1c2gobHN0KHNwYWNlU3RycykgKyBcIiBcIik7XHJcbiAgICByZXR1cm4gc3BhY2VTdHJzW25dO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbHN0KGFycikgeyByZXR1cm4gYXJyW2Fyci5sZW5ndGgtMV07IH1cclxuXHJcbiAgdmFyIHNlbGVjdElucHV0ID0gZnVuY3Rpb24obm9kZSkgeyBub2RlLnNlbGVjdCgpOyB9O1xyXG4gIGlmIChpb3MpIC8vIE1vYmlsZSBTYWZhcmkgYXBwYXJlbnRseSBoYXMgYSBidWcgd2hlcmUgc2VsZWN0KCkgaXMgYnJva2VuLlxyXG4gICAgc2VsZWN0SW5wdXQgPSBmdW5jdGlvbihub2RlKSB7IG5vZGUuc2VsZWN0aW9uU3RhcnQgPSAwOyBub2RlLnNlbGVjdGlvbkVuZCA9IG5vZGUudmFsdWUubGVuZ3RoOyB9O1xyXG4gIGVsc2UgaWYgKGllKSAvLyBTdXBwcmVzcyBteXN0ZXJpb3VzIElFMTAgZXJyb3JzXHJcbiAgICBzZWxlY3RJbnB1dCA9IGZ1bmN0aW9uKG5vZGUpIHsgdHJ5IHsgbm9kZS5zZWxlY3QoKTsgfSBjYXRjaChfZSkge30gfTtcclxuXHJcbiAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgZWx0KSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKVxyXG4gICAgICBpZiAoYXJyYXlbaV0gPT0gZWx0KSByZXR1cm4gaTtcclxuICAgIHJldHVybiAtMTtcclxuICB9XHJcbiAgZnVuY3Rpb24gbWFwKGFycmF5LCBmKSB7XHJcbiAgICB2YXIgb3V0ID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSBvdXRbaV0gPSBmKGFycmF5W2ldLCBpKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBub3RoaW5nKCkge31cclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlT2JqKGJhc2UsIHByb3BzKSB7XHJcbiAgICB2YXIgaW5zdDtcclxuICAgIGlmIChPYmplY3QuY3JlYXRlKSB7XHJcbiAgICAgIGluc3QgPSBPYmplY3QuY3JlYXRlKGJhc2UpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbm90aGluZy5wcm90b3R5cGUgPSBiYXNlO1xyXG4gICAgICBpbnN0ID0gbmV3IG5vdGhpbmcoKTtcclxuICAgIH1cclxuICAgIGlmIChwcm9wcykgY29weU9iaihwcm9wcywgaW5zdCk7XHJcbiAgICByZXR1cm4gaW5zdDtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBjb3B5T2JqKG9iaiwgdGFyZ2V0LCBvdmVyd3JpdGUpIHtcclxuICAgIGlmICghdGFyZ2V0KSB0YXJnZXQgPSB7fTtcclxuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKVxyXG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApICYmIChvdmVyd3JpdGUgIT09IGZhbHNlIHx8ICF0YXJnZXQuaGFzT3duUHJvcGVydHkocHJvcCkpKVxyXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IG9ialtwcm9wXTtcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBiaW5kKGYpIHtcclxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgIHJldHVybiBmdW5jdGlvbigpe3JldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MpO307XHJcbiAgfVxyXG5cclxuICB2YXIgbm9uQVNDSUlTaW5nbGVDYXNlV29yZENoYXIgPSAvW1xcdTAwZGZcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUzMDQwLVxcdTMwOWZcXHUzMGEwLVxcdTMwZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhYzAwLVxcdWQ3YWZdLztcclxuICB2YXIgaXNXb3JkQ2hhckJhc2ljID0gQ29kZU1pcnJvci5pc1dvcmRDaGFyID0gZnVuY3Rpb24oY2gpIHtcclxuICAgIHJldHVybiAvXFx3Ly50ZXN0KGNoKSB8fCBjaCA+IFwiXFx4ODBcIiAmJlxyXG4gICAgICAoY2gudG9VcHBlckNhc2UoKSAhPSBjaC50b0xvd2VyQ2FzZSgpIHx8IG5vbkFTQ0lJU2luZ2xlQ2FzZVdvcmRDaGFyLnRlc3QoY2gpKTtcclxuICB9O1xyXG4gIGZ1bmN0aW9uIGlzV29yZENoYXIoY2gsIGhlbHBlcikge1xyXG4gICAgaWYgKCFoZWxwZXIpIHJldHVybiBpc1dvcmRDaGFyQmFzaWMoY2gpO1xyXG4gICAgaWYgKGhlbHBlci5zb3VyY2UuaW5kZXhPZihcIlxcXFx3XCIpID4gLTEgJiYgaXNXb3JkQ2hhckJhc2ljKGNoKSkgcmV0dXJuIHRydWU7XHJcbiAgICByZXR1cm4gaGVscGVyLnRlc3QoY2gpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcclxuICAgIGZvciAodmFyIG4gaW4gb2JqKSBpZiAob2JqLmhhc093blByb3BlcnR5KG4pICYmIG9ialtuXSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvLyBFeHRlbmRpbmcgdW5pY29kZSBjaGFyYWN0ZXJzLiBBIHNlcmllcyBvZiBhIG5vbi1leHRlbmRpbmcgY2hhciArXHJcbiAgLy8gYW55IG51bWJlciBvZiBleHRlbmRpbmcgY2hhcnMgaXMgdHJlYXRlZCBhcyBhIHNpbmdsZSB1bml0IGFzIGZhclxyXG4gIC8vIGFzIGVkaXRpbmcgYW5kIG1lYXN1cmluZyBpcyBjb25jZXJuZWQuIFRoaXMgaXMgbm90IGZ1bGx5IGNvcnJlY3QsXHJcbiAgLy8gc2luY2Ugc29tZSBzY3JpcHRzL2ZvbnRzL2Jyb3dzZXJzIGFsc28gdHJlYXQgb3RoZXIgY29uZmlndXJhdGlvbnNcclxuICAvLyBvZiBjb2RlIHBvaW50cyBhcyBhIGdyb3VwLlxyXG4gIHZhciBleHRlbmRpbmdDaGFycyA9IC9bXFx1MDMwMC1cXHUwMzZmXFx1MDQ4My1cXHUwNDg5XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDY0Yi1cXHUwNjVlXFx1MDY3MFxcdTA2ZDYtXFx1MDZkY1xcdTA2ZGUtXFx1MDZlNFxcdTA2ZTdcXHUwNmU4XFx1MDZlYS1cXHUwNmVkXFx1MDcxMVxcdTA3MzAtXFx1MDc0YVxcdTA3YTYtXFx1MDdiMFxcdTA3ZWItXFx1MDdmM1xcdTA4MTYtXFx1MDgxOVxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA5MDAtXFx1MDkwMlxcdTA5M2NcXHUwOTQxLVxcdTA5NDhcXHUwOTRkXFx1MDk1MS1cXHUwOTU1XFx1MDk2MlxcdTA5NjNcXHUwOTgxXFx1MDliY1xcdTA5YmVcXHUwOWMxLVxcdTA5YzRcXHUwOWNkXFx1MDlkN1xcdTA5ZTJcXHUwOWUzXFx1MGEwMVxcdTBhMDJcXHUwYTNjXFx1MGE0MVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTcwXFx1MGE3MVxcdTBhNzVcXHUwYTgxXFx1MGE4MlxcdTBhYmNcXHUwYWMxLVxcdTBhYzVcXHUwYWM3XFx1MGFjOFxcdTBhY2RcXHUwYWUyXFx1MGFlM1xcdTBiMDFcXHUwYjNjXFx1MGIzZVxcdTBiM2ZcXHUwYjQxLVxcdTBiNDRcXHUwYjRkXFx1MGI1NlxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiODJcXHUwYmJlXFx1MGJjMFxcdTBiY2RcXHUwYmQ3XFx1MGMzZS1cXHUwYzQwXFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyXFx1MGM2M1xcdTBjYmNcXHUwY2JmXFx1MGNjMlxcdTBjYzZcXHUwY2NjXFx1MGNjZFxcdTBjZDVcXHUwY2Q2XFx1MGNlMlxcdTBjZTNcXHUwZDNlXFx1MGQ0MS1cXHUwZDQ0XFx1MGQ0ZFxcdTBkNTdcXHUwZDYyXFx1MGQ2M1xcdTBkY2FcXHUwZGNmXFx1MGRkMi1cXHUwZGQ0XFx1MGRkNlxcdTBkZGZcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGViMVxcdTBlYjQtXFx1MGViOVxcdTBlYmJcXHUwZWJjXFx1MGVjOC1cXHUwZWNkXFx1MGYxOFxcdTBmMTlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjcxLVxcdTBmN2VcXHUwZjgwLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOTAtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJkLVxcdTEwMzBcXHUxMDMyLVxcdTEwMzdcXHUxMDM5XFx1MTAzYVxcdTEwM2RcXHUxMDNlXFx1MTA1OFxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDcxLVxcdTEwNzRcXHUxMDgyXFx1MTA4NVxcdTEwODZcXHUxMDhkXFx1MTA5ZFxcdTEzNWZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNy1cXHUxN2JkXFx1MTdjNlxcdTE3YzktXFx1MTdkM1xcdTE3ZGRcXHUxODBiLVxcdTE4MGRcXHUxOGE5XFx1MTkyMC1cXHUxOTIyXFx1MTkyN1xcdTE5MjhcXHUxOTMyXFx1MTkzOS1cXHUxOTNiXFx1MWExN1xcdTFhMThcXHUxYTU2XFx1MWE1OC1cXHUxYTVlXFx1MWE2MFxcdTFhNjJcXHUxYTY1LVxcdTFhNmNcXHUxYTczLVxcdTFhN2NcXHUxYTdmXFx1MWIwMC1cXHUxYjAzXFx1MWIzNFxcdTFiMzYtXFx1MWIzYVxcdTFiM2NcXHUxYjQyXFx1MWI2Yi1cXHUxYjczXFx1MWI4MFxcdTFiODFcXHUxYmEyLVxcdTFiYTVcXHUxYmE4XFx1MWJhOVxcdTFjMmMtXFx1MWMzM1xcdTFjMzZcXHUxYzM3XFx1MWNkMC1cXHUxY2QyXFx1MWNkNC1cXHUxY2UwXFx1MWNlMi1cXHUxY2U4XFx1MWNlZFxcdTFkYzAtXFx1MWRlNlxcdTFkZmQtXFx1MWRmZlxcdTIwMGNcXHUyMDBkXFx1MjBkMC1cXHUyMGYwXFx1MmNlZi1cXHUyY2YxXFx1MmRlMC1cXHUyZGZmXFx1MzAyYS1cXHUzMDJmXFx1MzA5OVxcdTMwOWFcXHVhNjZmLVxcdWE2NzJcXHVhNjdjXFx1YTY3ZFxcdWE2ZjBcXHVhNmYxXFx1YTgwMlxcdWE4MDZcXHVhODBiXFx1YTgyNVxcdWE4MjZcXHVhOGM0XFx1YThlMC1cXHVhOGYxXFx1YTkyNi1cXHVhOTJkXFx1YTk0Ny1cXHVhOTUxXFx1YTk4MC1cXHVhOTgyXFx1YTliM1xcdWE5YjYtXFx1YTliOVxcdWE5YmNcXHVhYTI5LVxcdWFhMmVcXHVhYTMxXFx1YWEzMlxcdWFhMzVcXHVhYTM2XFx1YWE0M1xcdWFhNGNcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYmU1XFx1YWJlOFxcdWFiZWRcXHVkYzAwLVxcdWRmZmZcXHVmYjFlXFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTI2XFx1ZmY5ZVxcdWZmOWZdLztcclxuICBmdW5jdGlvbiBpc0V4dGVuZGluZ0NoYXIoY2gpIHsgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkgPj0gNzY4ICYmIGV4dGVuZGluZ0NoYXJzLnRlc3QoY2gpOyB9XHJcblxyXG4gIC8vIERPTSBVVElMSVRJRVNcclxuXHJcbiAgZnVuY3Rpb24gZWx0KHRhZywgY29udGVudCwgY2xhc3NOYW1lLCBzdHlsZSkge1xyXG4gICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XHJcbiAgICBpZiAoY2xhc3NOYW1lKSBlLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcclxuICAgIGlmIChzdHlsZSkgZS5zdHlsZS5jc3NUZXh0ID0gc3R5bGU7XHJcbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT0gXCJzdHJpbmdcIikgZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjb250ZW50KSk7XHJcbiAgICBlbHNlIGlmIChjb250ZW50KSBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnQubGVuZ3RoOyArK2kpIGUuYXBwZW5kQ2hpbGQoY29udGVudFtpXSk7XHJcbiAgICByZXR1cm4gZTtcclxuICB9XHJcblxyXG4gIHZhciByYW5nZTtcclxuICBpZiAoZG9jdW1lbnQuY3JlYXRlUmFuZ2UpIHJhbmdlID0gZnVuY3Rpb24obm9kZSwgc3RhcnQsIGVuZCwgZW5kTm9kZSkge1xyXG4gICAgdmFyIHIgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xyXG4gICAgci5zZXRFbmQoZW5kTm9kZSB8fCBub2RlLCBlbmQpO1xyXG4gICAgci5zZXRTdGFydChub2RlLCBzdGFydCk7XHJcbiAgICByZXR1cm4gcjtcclxuICB9O1xyXG4gIGVsc2UgcmFuZ2UgPSBmdW5jdGlvbihub2RlLCBzdGFydCwgZW5kKSB7XHJcbiAgICB2YXIgciA9IGRvY3VtZW50LmJvZHkuY3JlYXRlVGV4dFJhbmdlKCk7XHJcbiAgICB0cnkgeyByLm1vdmVUb0VsZW1lbnRUZXh0KG5vZGUucGFyZW50Tm9kZSk7IH1cclxuICAgIGNhdGNoKGUpIHsgcmV0dXJuIHI7IH1cclxuICAgIHIuY29sbGFwc2UodHJ1ZSk7XHJcbiAgICByLm1vdmVFbmQoXCJjaGFyYWN0ZXJcIiwgZW5kKTtcclxuICAgIHIubW92ZVN0YXJ0KFwiY2hhcmFjdGVyXCIsIHN0YXJ0KTtcclxuICAgIHJldHVybiByO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuKGUpIHtcclxuICAgIGZvciAodmFyIGNvdW50ID0gZS5jaGlsZE5vZGVzLmxlbmd0aDsgY291bnQgPiAwOyAtLWNvdW50KVxyXG4gICAgICBlLnJlbW92ZUNoaWxkKGUuZmlyc3RDaGlsZCk7XHJcbiAgICByZXR1cm4gZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuQW5kQWRkKHBhcmVudCwgZSkge1xyXG4gICAgcmV0dXJuIHJlbW92ZUNoaWxkcmVuKHBhcmVudCkuYXBwZW5kQ2hpbGQoZSk7XHJcbiAgfVxyXG5cclxuICB2YXIgY29udGFpbnMgPSBDb2RlTWlycm9yLmNvbnRhaW5zID0gZnVuY3Rpb24ocGFyZW50LCBjaGlsZCkge1xyXG4gICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMpIC8vIEFuZHJvaWQgYnJvd3NlciBhbHdheXMgcmV0dXJucyBmYWxzZSB3aGVuIGNoaWxkIGlzIGEgdGV4dG5vZGVcclxuICAgICAgY2hpbGQgPSBjaGlsZC5wYXJlbnROb2RlO1xyXG4gICAgaWYgKHBhcmVudC5jb250YWlucylcclxuICAgICAgcmV0dXJuIHBhcmVudC5jb250YWlucyhjaGlsZCk7XHJcbiAgICBkbyB7XHJcbiAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxMSkgY2hpbGQgPSBjaGlsZC5ob3N0O1xyXG4gICAgICBpZiAoY2hpbGQgPT0gcGFyZW50KSByZXR1cm4gdHJ1ZTtcclxuICAgIH0gd2hpbGUgKGNoaWxkID0gY2hpbGQucGFyZW50Tm9kZSk7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gYWN0aXZlRWx0KCkgeyByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDsgfVxyXG4gIC8vIE9sZGVyIHZlcnNpb25zIG9mIElFIHRocm93cyB1bnNwZWNpZmllZCBlcnJvciB3aGVuIHRvdWNoaW5nXHJcbiAgLy8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbiBzb21lIGNhc2VzIChkdXJpbmcgbG9hZGluZywgaW4gaWZyYW1lKVxyXG4gIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEpIGFjdGl2ZUVsdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdHJ5IHsgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7IH1cclxuICAgIGNhdGNoKGUpIHsgcmV0dXJuIGRvY3VtZW50LmJvZHk7IH1cclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBjbGFzc1Rlc3QoY2xzKSB7IHJldHVybiBuZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIgKyBjbHMgKyBcIig/OiR8XFxcXHMpXFxcXHMqXCIpOyB9XHJcbiAgdmFyIHJtQ2xhc3MgPSBDb2RlTWlycm9yLnJtQ2xhc3MgPSBmdW5jdGlvbihub2RlLCBjbHMpIHtcclxuICAgIHZhciBjdXJyZW50ID0gbm9kZS5jbGFzc05hbWU7XHJcbiAgICB2YXIgbWF0Y2ggPSBjbGFzc1Rlc3QoY2xzKS5leGVjKGN1cnJlbnQpO1xyXG4gICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgIHZhciBhZnRlciA9IGN1cnJlbnQuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xyXG4gICAgICBub2RlLmNsYXNzTmFtZSA9IGN1cnJlbnQuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgKGFmdGVyID8gbWF0Y2hbMV0gKyBhZnRlciA6IFwiXCIpO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgdmFyIGFkZENsYXNzID0gQ29kZU1pcnJvci5hZGRDbGFzcyA9IGZ1bmN0aW9uKG5vZGUsIGNscykge1xyXG4gICAgdmFyIGN1cnJlbnQgPSBub2RlLmNsYXNzTmFtZTtcclxuICAgIGlmICghY2xhc3NUZXN0KGNscykudGVzdChjdXJyZW50KSkgbm9kZS5jbGFzc05hbWUgKz0gKGN1cnJlbnQgPyBcIiBcIiA6IFwiXCIpICsgY2xzO1xyXG4gIH07XHJcbiAgZnVuY3Rpb24gam9pbkNsYXNzZXMoYSwgYikge1xyXG4gICAgdmFyIGFzID0gYS5zcGxpdChcIiBcIik7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFzLmxlbmd0aDsgaSsrKVxyXG4gICAgICBpZiAoYXNbaV0gJiYgIWNsYXNzVGVzdChhc1tpXSkudGVzdChiKSkgYiArPSBcIiBcIiArIGFzW2ldO1xyXG4gICAgcmV0dXJuIGI7XHJcbiAgfVxyXG5cclxuICAvLyBXSU5ET1ctV0lERSBFVkVOVFNcclxuXHJcbiAgLy8gVGhlc2UgbXVzdCBiZSBoYW5kbGVkIGNhcmVmdWxseSwgYmVjYXVzZSBuYWl2ZWx5IHJlZ2lzdGVyaW5nIGFcclxuICAvLyBoYW5kbGVyIGZvciBlYWNoIGVkaXRvciB3aWxsIGNhdXNlIHRoZSBlZGl0b3JzIHRvIG5ldmVyIGJlXHJcbiAgLy8gZ2FyYmFnZSBjb2xsZWN0ZWQuXHJcblxyXG4gIGZ1bmN0aW9uIGZvckVhY2hDb2RlTWlycm9yKGYpIHtcclxuICAgIGlmICghZG9jdW1lbnQuYm9keS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSByZXR1cm47XHJcbiAgICB2YXIgYnlDbGFzcyA9IGRvY3VtZW50LmJvZHkuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIkNvZGVNaXJyb3JcIik7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5Q2xhc3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGNtID0gYnlDbGFzc1tpXS5Db2RlTWlycm9yO1xyXG4gICAgICBpZiAoY20pIGYoY20pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIGdsb2JhbHNSZWdpc3RlcmVkID0gZmFsc2U7XHJcbiAgZnVuY3Rpb24gZW5zdXJlR2xvYmFsSGFuZGxlcnMoKSB7XHJcbiAgICBpZiAoZ2xvYmFsc1JlZ2lzdGVyZWQpIHJldHVybjtcclxuICAgIHJlZ2lzdGVyR2xvYmFsSGFuZGxlcnMoKTtcclxuICAgIGdsb2JhbHNSZWdpc3RlcmVkID0gdHJ1ZTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcmVnaXN0ZXJHbG9iYWxIYW5kbGVycygpIHtcclxuICAgIC8vIFdoZW4gdGhlIHdpbmRvdyByZXNpemVzLCB3ZSBuZWVkIHRvIHJlZnJlc2ggYWN0aXZlIGVkaXRvcnMuXHJcbiAgICB2YXIgcmVzaXplVGltZXI7XHJcbiAgICBvbih3aW5kb3csIFwicmVzaXplXCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAocmVzaXplVGltZXIgPT0gbnVsbCkgcmVzaXplVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJlc2l6ZVRpbWVyID0gbnVsbDtcclxuICAgICAgICBmb3JFYWNoQ29kZU1pcnJvcihvblJlc2l6ZSk7XHJcbiAgICAgIH0sIDEwMCk7XHJcbiAgICB9KTtcclxuICAgIC8vIFdoZW4gdGhlIHdpbmRvdyBsb3NlcyBmb2N1cywgd2Ugd2FudCB0byBzaG93IHRoZSBlZGl0b3IgYXMgYmx1cnJlZFxyXG4gICAgb24od2luZG93LCBcImJsdXJcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgIGZvckVhY2hDb2RlTWlycm9yKG9uQmx1cik7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIEZFQVRVUkUgREVURUNUSU9OXHJcblxyXG4gIC8vIERldGVjdCBkcmFnLWFuZC1kcm9wXHJcbiAgdmFyIGRyYWdBbmREcm9wID0gZnVuY3Rpb24oKSB7XHJcbiAgICAvLyBUaGVyZSBpcyAqc29tZSoga2luZCBvZiBkcmFnLWFuZC1kcm9wIHN1cHBvcnQgaW4gSUU2LTgsIGJ1dCBJXHJcbiAgICAvLyBjb3VsZG4ndCBnZXQgaXQgdG8gd29yayB5ZXQuXHJcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIHJldHVybiBmYWxzZTtcclxuICAgIHZhciBkaXYgPSBlbHQoJ2RpdicpO1xyXG4gICAgcmV0dXJuIFwiZHJhZ2dhYmxlXCIgaW4gZGl2IHx8IFwiZHJhZ0Ryb3BcIiBpbiBkaXY7XHJcbiAgfSgpO1xyXG5cclxuICB2YXIgendzcFN1cHBvcnRlZDtcclxuICBmdW5jdGlvbiB6ZXJvV2lkdGhFbGVtZW50KG1lYXN1cmUpIHtcclxuICAgIGlmICh6d3NwU3VwcG9ydGVkID09IG51bGwpIHtcclxuICAgICAgdmFyIHRlc3QgPSBlbHQoXCJzcGFuXCIsIFwiXFx1MjAwYlwiKTtcclxuICAgICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQobWVhc3VyZSwgZWx0KFwic3BhblwiLCBbdGVzdCwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJ4XCIpXSkpO1xyXG4gICAgICBpZiAobWVhc3VyZS5maXJzdENoaWxkLm9mZnNldEhlaWdodCAhPSAwKVxyXG4gICAgICAgIHp3c3BTdXBwb3J0ZWQgPSB0ZXN0Lm9mZnNldFdpZHRoIDw9IDEgJiYgdGVzdC5vZmZzZXRIZWlnaHQgPiAyICYmICEoaWUgJiYgaWVfdmVyc2lvbiA8IDgpO1xyXG4gICAgfVxyXG4gICAgdmFyIG5vZGUgPSB6d3NwU3VwcG9ydGVkID8gZWx0KFwic3BhblwiLCBcIlxcdTIwMGJcIikgOlxyXG4gICAgICBlbHQoXCJzcGFuXCIsIFwiXFx1MDBhMFwiLCBudWxsLCBcImRpc3BsYXk6IGlubGluZS1ibG9jazsgd2lkdGg6IDFweDsgbWFyZ2luLXJpZ2h0OiAtMXB4XCIpO1xyXG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIsIFwiXCIpO1xyXG4gICAgcmV0dXJuIG5vZGU7XHJcbiAgfVxyXG5cclxuICAvLyBGZWF0dXJlLWRldGVjdCBJRSdzIGNydW1teSBjbGllbnQgcmVjdCByZXBvcnRpbmcgZm9yIGJpZGkgdGV4dFxyXG4gIHZhciBiYWRCaWRpUmVjdHM7XHJcbiAgZnVuY3Rpb24gaGFzQmFkQmlkaVJlY3RzKG1lYXN1cmUpIHtcclxuICAgIGlmIChiYWRCaWRpUmVjdHMgIT0gbnVsbCkgcmV0dXJuIGJhZEJpZGlSZWN0cztcclxuICAgIHZhciB0eHQgPSByZW1vdmVDaGlsZHJlbkFuZEFkZChtZWFzdXJlLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIkFcXHUwNjJlQVwiKSk7XHJcbiAgICB2YXIgcjAgPSByYW5nZSh0eHQsIDAsIDEpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgaWYgKCFyMCB8fCByMC5sZWZ0ID09IHIwLnJpZ2h0KSByZXR1cm4gZmFsc2U7IC8vIFNhZmFyaSByZXR1cm5zIG51bGwgaW4gc29tZSBjYXNlcyAoIzI3ODApXHJcbiAgICB2YXIgcjEgPSByYW5nZSh0eHQsIDEsIDIpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgcmV0dXJuIGJhZEJpZGlSZWN0cyA9IChyMS5yaWdodCAtIHIwLnJpZ2h0IDwgMyk7XHJcbiAgfVxyXG5cclxuICAvLyBTZWUgaWYgXCJcIi5zcGxpdCBpcyB0aGUgYnJva2VuIElFIHZlcnNpb24sIGlmIHNvLCBwcm92aWRlIGFuXHJcbiAgLy8gYWx0ZXJuYXRpdmUgd2F5IHRvIHNwbGl0IGxpbmVzLlxyXG4gIHZhciBzcGxpdExpbmVzID0gQ29kZU1pcnJvci5zcGxpdExpbmVzID0gXCJcXG5cXG5iXCIuc3BsaXQoL1xcbi8pLmxlbmd0aCAhPSAzID8gZnVuY3Rpb24oc3RyaW5nKSB7XHJcbiAgICB2YXIgcG9zID0gMCwgcmVzdWx0ID0gW10sIGwgPSBzdHJpbmcubGVuZ3RoO1xyXG4gICAgd2hpbGUgKHBvcyA8PSBsKSB7XHJcbiAgICAgIHZhciBubCA9IHN0cmluZy5pbmRleE9mKFwiXFxuXCIsIHBvcyk7XHJcbiAgICAgIGlmIChubCA9PSAtMSkgbmwgPSBzdHJpbmcubGVuZ3RoO1xyXG4gICAgICB2YXIgbGluZSA9IHN0cmluZy5zbGljZShwb3MsIHN0cmluZy5jaGFyQXQobmwgLSAxKSA9PSBcIlxcclwiID8gbmwgLSAxIDogbmwpO1xyXG4gICAgICB2YXIgcnQgPSBsaW5lLmluZGV4T2YoXCJcXHJcIik7XHJcbiAgICAgIGlmIChydCAhPSAtMSkge1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKGxpbmUuc2xpY2UoMCwgcnQpKTtcclxuICAgICAgICBwb3MgKz0gcnQgKyAxO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKGxpbmUpO1xyXG4gICAgICAgIHBvcyA9IG5sICsgMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9IDogZnVuY3Rpb24oc3RyaW5nKXtyZXR1cm4gc3RyaW5nLnNwbGl0KC9cXHJcXG4/fFxcbi8pO307XHJcblxyXG4gIHZhciBoYXNTZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uID8gZnVuY3Rpb24odGUpIHtcclxuICAgIHRyeSB7IHJldHVybiB0ZS5zZWxlY3Rpb25TdGFydCAhPSB0ZS5zZWxlY3Rpb25FbmQ7IH1cclxuICAgIGNhdGNoKGUpIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgfSA6IGZ1bmN0aW9uKHRlKSB7XHJcbiAgICB0cnkge3ZhciByYW5nZSA9IHRlLm93bmVyRG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7fVxyXG4gICAgY2F0Y2goZSkge31cclxuICAgIGlmICghcmFuZ2UgfHwgcmFuZ2UucGFyZW50RWxlbWVudCgpICE9IHRlKSByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gcmFuZ2UuY29tcGFyZUVuZFBvaW50cyhcIlN0YXJ0VG9FbmRcIiwgcmFuZ2UpICE9IDA7XHJcbiAgfTtcclxuXHJcbiAgdmFyIGhhc0NvcHlFdmVudCA9IChmdW5jdGlvbigpIHtcclxuICAgIHZhciBlID0gZWx0KFwiZGl2XCIpO1xyXG4gICAgaWYgKFwib25jb3B5XCIgaW4gZSkgcmV0dXJuIHRydWU7XHJcbiAgICBlLnNldEF0dHJpYnV0ZShcIm9uY29weVwiLCBcInJldHVybjtcIik7XHJcbiAgICByZXR1cm4gdHlwZW9mIGUub25jb3B5ID09IFwiZnVuY3Rpb25cIjtcclxuICB9KSgpO1xyXG5cclxuICB2YXIgYmFkWm9vbWVkUmVjdHMgPSBudWxsO1xyXG4gIGZ1bmN0aW9uIGhhc0JhZFpvb21lZFJlY3RzKG1lYXN1cmUpIHtcclxuICAgIGlmIChiYWRab29tZWRSZWN0cyAhPSBudWxsKSByZXR1cm4gYmFkWm9vbWVkUmVjdHM7XHJcbiAgICB2YXIgbm9kZSA9IHJlbW92ZUNoaWxkcmVuQW5kQWRkKG1lYXN1cmUsIGVsdChcInNwYW5cIiwgXCJ4XCIpKTtcclxuICAgIHZhciBub3JtYWwgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgdmFyIGZyb21SYW5nZSA9IHJhbmdlKG5vZGUsIDAsIDEpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgcmV0dXJuIGJhZFpvb21lZFJlY3RzID0gTWF0aC5hYnMobm9ybWFsLmxlZnQgLSBmcm9tUmFuZ2UubGVmdCkgPiAxO1xyXG4gIH1cclxuXHJcbiAgLy8gS0VZIE5BTUVTXHJcblxyXG4gIHZhciBrZXlOYW1lcyA9IHszOiBcIkVudGVyXCIsIDg6IFwiQmFja3NwYWNlXCIsIDk6IFwiVGFiXCIsIDEzOiBcIkVudGVyXCIsIDE2OiBcIlNoaWZ0XCIsIDE3OiBcIkN0cmxcIiwgMTg6IFwiQWx0XCIsXHJcbiAgICAgICAgICAgICAgICAgIDE5OiBcIlBhdXNlXCIsIDIwOiBcIkNhcHNMb2NrXCIsIDI3OiBcIkVzY1wiLCAzMjogXCJTcGFjZVwiLCAzMzogXCJQYWdlVXBcIiwgMzQ6IFwiUGFnZURvd25cIiwgMzU6IFwiRW5kXCIsXHJcbiAgICAgICAgICAgICAgICAgIDM2OiBcIkhvbWVcIiwgMzc6IFwiTGVmdFwiLCAzODogXCJVcFwiLCAzOTogXCJSaWdodFwiLCA0MDogXCJEb3duXCIsIDQ0OiBcIlByaW50U2NyblwiLCA0NTogXCJJbnNlcnRcIixcclxuICAgICAgICAgICAgICAgICAgNDY6IFwiRGVsZXRlXCIsIDU5OiBcIjtcIiwgNjE6IFwiPVwiLCA5MTogXCJNb2RcIiwgOTI6IFwiTW9kXCIsIDkzOiBcIk1vZFwiLCAxMDc6IFwiPVwiLCAxMDk6IFwiLVwiLCAxMjc6IFwiRGVsZXRlXCIsXHJcbiAgICAgICAgICAgICAgICAgIDE3MzogXCItXCIsIDE4NjogXCI7XCIsIDE4NzogXCI9XCIsIDE4ODogXCIsXCIsIDE4OTogXCItXCIsIDE5MDogXCIuXCIsIDE5MTogXCIvXCIsIDE5MjogXCJgXCIsIDIxOTogXCJbXCIsIDIyMDogXCJcXFxcXCIsXHJcbiAgICAgICAgICAgICAgICAgIDIyMTogXCJdXCIsIDIyMjogXCInXCIsIDYzMjMyOiBcIlVwXCIsIDYzMjMzOiBcIkRvd25cIiwgNjMyMzQ6IFwiTGVmdFwiLCA2MzIzNTogXCJSaWdodFwiLCA2MzI3MjogXCJEZWxldGVcIixcclxuICAgICAgICAgICAgICAgICAgNjMyNzM6IFwiSG9tZVwiLCA2MzI3NTogXCJFbmRcIiwgNjMyNzY6IFwiUGFnZVVwXCIsIDYzMjc3OiBcIlBhZ2VEb3duXCIsIDYzMzAyOiBcIkluc2VydFwifTtcclxuICBDb2RlTWlycm9yLmtleU5hbWVzID0ga2V5TmFtZXM7XHJcbiAgKGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gTnVtYmVyIGtleXNcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykga2V5TmFtZXNbaSArIDQ4XSA9IGtleU5hbWVzW2kgKyA5Nl0gPSBTdHJpbmcoaSk7XHJcbiAgICAvLyBBbHBoYWJldGljIGtleXNcclxuICAgIGZvciAodmFyIGkgPSA2NTsgaSA8PSA5MDsgaSsrKSBrZXlOYW1lc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XHJcbiAgICAvLyBGdW5jdGlvbiBrZXlzXHJcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSAxMjsgaSsrKSBrZXlOYW1lc1tpICsgMTExXSA9IGtleU5hbWVzW2kgKyA2MzIzNV0gPSBcIkZcIiArIGk7XHJcbiAgfSkoKTtcclxuXHJcbiAgLy8gQklESSBIRUxQRVJTXHJcblxyXG4gIGZ1bmN0aW9uIGl0ZXJhdGVCaWRpU2VjdGlvbnMob3JkZXIsIGZyb20sIHRvLCBmKSB7XHJcbiAgICBpZiAoIW9yZGVyKSByZXR1cm4gZihmcm9tLCB0bywgXCJsdHJcIik7XHJcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXIubGVuZ3RoOyArK2kpIHtcclxuICAgICAgdmFyIHBhcnQgPSBvcmRlcltpXTtcclxuICAgICAgaWYgKHBhcnQuZnJvbSA8IHRvICYmIHBhcnQudG8gPiBmcm9tIHx8IGZyb20gPT0gdG8gJiYgcGFydC50byA9PSBmcm9tKSB7XHJcbiAgICAgICAgZihNYXRoLm1heChwYXJ0LmZyb20sIGZyb20pLCBNYXRoLm1pbihwYXJ0LnRvLCB0byksIHBhcnQubGV2ZWwgPT0gMSA/IFwicnRsXCIgOiBcImx0clwiKTtcclxuICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghZm91bmQpIGYoZnJvbSwgdG8sIFwibHRyXCIpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYmlkaUxlZnQocGFydCkgeyByZXR1cm4gcGFydC5sZXZlbCAlIDIgPyBwYXJ0LnRvIDogcGFydC5mcm9tOyB9XHJcbiAgZnVuY3Rpb24gYmlkaVJpZ2h0KHBhcnQpIHsgcmV0dXJuIHBhcnQubGV2ZWwgJSAyID8gcGFydC5mcm9tIDogcGFydC50bzsgfVxyXG5cclxuICBmdW5jdGlvbiBsaW5lTGVmdChsaW5lKSB7IHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmUpOyByZXR1cm4gb3JkZXIgPyBiaWRpTGVmdChvcmRlclswXSkgOiAwOyB9XHJcbiAgZnVuY3Rpb24gbGluZVJpZ2h0KGxpbmUpIHtcclxuICAgIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmUpO1xyXG4gICAgaWYgKCFvcmRlcikgcmV0dXJuIGxpbmUudGV4dC5sZW5ndGg7XHJcbiAgICByZXR1cm4gYmlkaVJpZ2h0KGxzdChvcmRlcikpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbGluZVN0YXJ0KGNtLCBsaW5lTikge1xyXG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgbGluZU4pO1xyXG4gICAgdmFyIHZpc3VhbCA9IHZpc3VhbExpbmUobGluZSk7XHJcbiAgICBpZiAodmlzdWFsICE9IGxpbmUpIGxpbmVOID0gbGluZU5vKHZpc3VhbCk7XHJcbiAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcih2aXN1YWwpO1xyXG4gICAgdmFyIGNoID0gIW9yZGVyID8gMCA6IG9yZGVyWzBdLmxldmVsICUgMiA/IGxpbmVSaWdodCh2aXN1YWwpIDogbGluZUxlZnQodmlzdWFsKTtcclxuICAgIHJldHVybiBQb3MobGluZU4sIGNoKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gbGluZUVuZChjbSwgbGluZU4pIHtcclxuICAgIHZhciBtZXJnZWQsIGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgbGluZU4pO1xyXG4gICAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdEVuZChsaW5lKSkge1xyXG4gICAgICBsaW5lID0gbWVyZ2VkLmZpbmQoMSwgdHJ1ZSkubGluZTtcclxuICAgICAgbGluZU4gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZSk7XHJcbiAgICB2YXIgY2ggPSAhb3JkZXIgPyBsaW5lLnRleHQubGVuZ3RoIDogb3JkZXJbMF0ubGV2ZWwgJSAyID8gbGluZUxlZnQobGluZSkgOiBsaW5lUmlnaHQobGluZSk7XHJcbiAgICByZXR1cm4gUG9zKGxpbmVOID09IG51bGwgPyBsaW5lTm8obGluZSkgOiBsaW5lTiwgY2gpO1xyXG4gIH1cclxuICBmdW5jdGlvbiBsaW5lU3RhcnRTbWFydChjbSwgcG9zKSB7XHJcbiAgICB2YXIgc3RhcnQgPSBsaW5lU3RhcnQoY20sIHBvcy5saW5lKTtcclxuICAgIHZhciBsaW5lID0gZ2V0TGluZShjbS5kb2MsIHN0YXJ0LmxpbmUpO1xyXG4gICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZSk7XHJcbiAgICBpZiAoIW9yZGVyIHx8IG9yZGVyWzBdLmxldmVsID09IDApIHtcclxuICAgICAgdmFyIGZpcnN0Tm9uV1MgPSBNYXRoLm1heCgwLCBsaW5lLnRleHQuc2VhcmNoKC9cXFMvKSk7XHJcbiAgICAgIHZhciBpbldTID0gcG9zLmxpbmUgPT0gc3RhcnQubGluZSAmJiBwb3MuY2ggPD0gZmlyc3ROb25XUyAmJiBwb3MuY2g7XHJcbiAgICAgIHJldHVybiBQb3Moc3RhcnQubGluZSwgaW5XUyA/IDAgOiBmaXJzdE5vbldTKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdGFydDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNvbXBhcmVCaWRpTGV2ZWwob3JkZXIsIGEsIGIpIHtcclxuICAgIHZhciBsaW5lZGlyID0gb3JkZXJbMF0ubGV2ZWw7XHJcbiAgICBpZiAoYSA9PSBsaW5lZGlyKSByZXR1cm4gdHJ1ZTtcclxuICAgIGlmIChiID09IGxpbmVkaXIpIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiBhIDwgYjtcclxuICB9XHJcbiAgdmFyIGJpZGlPdGhlcjtcclxuICBmdW5jdGlvbiBnZXRCaWRpUGFydEF0KG9yZGVyLCBwb3MpIHtcclxuICAgIGJpZGlPdGhlciA9IG51bGw7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgZm91bmQ7IGkgPCBvcmRlci5sZW5ndGg7ICsraSkge1xyXG4gICAgICB2YXIgY3VyID0gb3JkZXJbaV07XHJcbiAgICAgIGlmIChjdXIuZnJvbSA8IHBvcyAmJiBjdXIudG8gPiBwb3MpIHJldHVybiBpO1xyXG4gICAgICBpZiAoKGN1ci5mcm9tID09IHBvcyB8fCBjdXIudG8gPT0gcG9zKSkge1xyXG4gICAgICAgIGlmIChmb3VuZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICBmb3VuZCA9IGk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjb21wYXJlQmlkaUxldmVsKG9yZGVyLCBjdXIubGV2ZWwsIG9yZGVyW2ZvdW5kXS5sZXZlbCkpIHtcclxuICAgICAgICAgIGlmIChjdXIuZnJvbSAhPSBjdXIudG8pIGJpZGlPdGhlciA9IGZvdW5kO1xyXG4gICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmIChjdXIuZnJvbSAhPSBjdXIudG8pIGJpZGlPdGhlciA9IGk7XHJcbiAgICAgICAgICByZXR1cm4gZm91bmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZm91bmQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBtb3ZlSW5MaW5lKGxpbmUsIHBvcywgZGlyLCBieVVuaXQpIHtcclxuICAgIGlmICghYnlVbml0KSByZXR1cm4gcG9zICsgZGlyO1xyXG4gICAgZG8gcG9zICs9IGRpcjtcclxuICAgIHdoaWxlIChwb3MgPiAwICYmIGlzRXh0ZW5kaW5nQ2hhcihsaW5lLnRleHQuY2hhckF0KHBvcykpKTtcclxuICAgIHJldHVybiBwb3M7XHJcbiAgfVxyXG5cclxuICAvLyBUaGlzIGlzIG5lZWRlZCBpbiBvcmRlciB0byBtb3ZlICd2aXN1YWxseScgdGhyb3VnaCBiaS1kaXJlY3Rpb25hbFxyXG4gIC8vIHRleHQgLS0gaS5lLiwgcHJlc3NpbmcgbGVmdCBzaG91bGQgbWFrZSB0aGUgY3Vyc29yIGdvIGxlZnQsIGV2ZW5cclxuICAvLyB3aGVuIGluIFJUTCB0ZXh0LiBUaGUgdHJpY2t5IHBhcnQgaXMgdGhlICdqdW1wcycsIHdoZXJlIFJUTCBhbmRcclxuICAvLyBMVFIgdGV4dCB0b3VjaCBlYWNoIG90aGVyLiBUaGlzIG9mdGVuIHJlcXVpcmVzIHRoZSBjdXJzb3Igb2Zmc2V0XHJcbiAgLy8gdG8gbW92ZSBtb3JlIHRoYW4gb25lIHVuaXQsIGluIG9yZGVyIHRvIHZpc3VhbGx5IG1vdmUgb25lIHVuaXQuXHJcbiAgZnVuY3Rpb24gbW92ZVZpc3VhbGx5KGxpbmUsIHN0YXJ0LCBkaXIsIGJ5VW5pdCkge1xyXG4gICAgdmFyIGJpZGkgPSBnZXRPcmRlcihsaW5lKTtcclxuICAgIGlmICghYmlkaSkgcmV0dXJuIG1vdmVMb2dpY2FsbHkobGluZSwgc3RhcnQsIGRpciwgYnlVbml0KTtcclxuICAgIHZhciBwb3MgPSBnZXRCaWRpUGFydEF0KGJpZGksIHN0YXJ0KSwgcGFydCA9IGJpZGlbcG9zXTtcclxuICAgIHZhciB0YXJnZXQgPSBtb3ZlSW5MaW5lKGxpbmUsIHN0YXJ0LCBwYXJ0LmxldmVsICUgMiA/IC1kaXIgOiBkaXIsIGJ5VW5pdCk7XHJcblxyXG4gICAgZm9yICg7Oykge1xyXG4gICAgICBpZiAodGFyZ2V0ID4gcGFydC5mcm9tICYmIHRhcmdldCA8IHBhcnQudG8pIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgIGlmICh0YXJnZXQgPT0gcGFydC5mcm9tIHx8IHRhcmdldCA9PSBwYXJ0LnRvKSB7XHJcbiAgICAgICAgaWYgKGdldEJpZGlQYXJ0QXQoYmlkaSwgdGFyZ2V0KSA9PSBwb3MpIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgICAgcGFydCA9IGJpZGlbcG9zICs9IGRpcl07XHJcbiAgICAgICAgcmV0dXJuIChkaXIgPiAwKSA9PSBwYXJ0LmxldmVsICUgMiA/IHBhcnQudG8gOiBwYXJ0LmZyb207XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcGFydCA9IGJpZGlbcG9zICs9IGRpcl07XHJcbiAgICAgICAgaWYgKCFwYXJ0KSByZXR1cm4gbnVsbDtcclxuICAgICAgICBpZiAoKGRpciA+IDApID09IHBhcnQubGV2ZWwgJSAyKVxyXG4gICAgICAgICAgdGFyZ2V0ID0gbW92ZUluTGluZShsaW5lLCBwYXJ0LnRvLCAtMSwgYnlVbml0KTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICB0YXJnZXQgPSBtb3ZlSW5MaW5lKGxpbmUsIHBhcnQuZnJvbSwgMSwgYnlVbml0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbW92ZUxvZ2ljYWxseShsaW5lLCBzdGFydCwgZGlyLCBieVVuaXQpIHtcclxuICAgIHZhciB0YXJnZXQgPSBzdGFydCArIGRpcjtcclxuICAgIGlmIChieVVuaXQpIHdoaWxlICh0YXJnZXQgPiAwICYmIGlzRXh0ZW5kaW5nQ2hhcihsaW5lLnRleHQuY2hhckF0KHRhcmdldCkpKSB0YXJnZXQgKz0gZGlyO1xyXG4gICAgcmV0dXJuIHRhcmdldCA8IDAgfHwgdGFyZ2V0ID4gbGluZS50ZXh0Lmxlbmd0aCA/IG51bGwgOiB0YXJnZXQ7XHJcbiAgfVxyXG5cclxuICAvLyBCaWRpcmVjdGlvbmFsIG9yZGVyaW5nIGFsZ29yaXRobVxyXG4gIC8vIFNlZSBodHRwOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjkvdHI5LTEzLmh0bWwgZm9yIHRoZSBhbGdvcml0aG1cclxuICAvLyB0aGF0IHRoaXMgKHBhcnRpYWxseSkgaW1wbGVtZW50cy5cclxuXHJcbiAgLy8gT25lLWNoYXIgY29kZXMgdXNlZCBmb3IgY2hhcmFjdGVyIHR5cGVzOlxyXG4gIC8vIEwgKEwpOiAgIExlZnQtdG8tUmlnaHRcclxuICAvLyBSIChSKTogICBSaWdodC10by1MZWZ0XHJcbiAgLy8gciAoQUwpOiAgUmlnaHQtdG8tTGVmdCBBcmFiaWNcclxuICAvLyAxIChFTik6ICBFdXJvcGVhbiBOdW1iZXJcclxuICAvLyArIChFUyk6ICBFdXJvcGVhbiBOdW1iZXIgU2VwYXJhdG9yXHJcbiAgLy8gJSAoRVQpOiAgRXVyb3BlYW4gTnVtYmVyIFRlcm1pbmF0b3JcclxuICAvLyBuIChBTik6ICBBcmFiaWMgTnVtYmVyXHJcbiAgLy8gLCAoQ1MpOiAgQ29tbW9uIE51bWJlciBTZXBhcmF0b3JcclxuICAvLyBtIChOU00pOiBOb24tU3BhY2luZyBNYXJrXHJcbiAgLy8gYiAoQk4pOiAgQm91bmRhcnkgTmV1dHJhbFxyXG4gIC8vIHMgKEIpOiAgIFBhcmFncmFwaCBTZXBhcmF0b3JcclxuICAvLyB0IChTKTogICBTZWdtZW50IFNlcGFyYXRvclxyXG4gIC8vIHcgKFdTKTogIFdoaXRlc3BhY2VcclxuICAvLyBOIChPTik6ICBPdGhlciBOZXV0cmFsc1xyXG5cclxuICAvLyBSZXR1cm5zIG51bGwgaWYgY2hhcmFjdGVycyBhcmUgb3JkZXJlZCBhcyB0aGV5IGFwcGVhclxyXG4gIC8vIChsZWZ0LXRvLXJpZ2h0KSwgb3IgYW4gYXJyYXkgb2Ygc2VjdGlvbnMgKHtmcm9tLCB0bywgbGV2ZWx9XHJcbiAgLy8gb2JqZWN0cykgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgb2NjdXIgdmlzdWFsbHkuXHJcbiAgdmFyIGJpZGlPcmRlcmluZyA9IChmdW5jdGlvbigpIHtcclxuICAgIC8vIENoYXJhY3RlciB0eXBlcyBmb3IgY29kZXBvaW50cyAwIHRvIDB4ZmZcclxuICAgIHZhciBsb3dUeXBlcyA9IFwiYmJiYmJiYmJidHN0d3NiYmJiYmJiYmJiYmJiYnNzc3R3Tk4lJSVOTk5OTk4sTixOMTExMTExMTExMU5OTk5OTk5MTExMTExMTExMTExMTExMTExMTExMTExMTE5OTk5OTkxMTExMTExMTExMTExMTExMTExMTExMTExMTk5OTmJiYmJiYnNiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYixOJSUlJU5OTk5MTk5OTk4lJTExTkxOTk4xTE5OTk5OTExMTExMTExMTExMTExMTExMTExMTExOTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTE5cIjtcclxuICAgIC8vIENoYXJhY3RlciB0eXBlcyBmb3IgY29kZXBvaW50cyAweDYwMCB0byAweDZmZlxyXG4gICAgdmFyIGFyYWJpY1R5cGVzID0gXCJycnJycnJycnJycnIsck5ObW1tbW1tcnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJtbW1tbW1tbW1tbW1tbXJycnJycnJubm5ubm5ubm5uJW5ucnJybXJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJybW1tbW1tbW1tbW1tbW1tbW1tbU5tbW1tXCI7XHJcbiAgICBmdW5jdGlvbiBjaGFyVHlwZShjb2RlKSB7XHJcbiAgICAgIGlmIChjb2RlIDw9IDB4ZjcpIHJldHVybiBsb3dUeXBlcy5jaGFyQXQoY29kZSk7XHJcbiAgICAgIGVsc2UgaWYgKDB4NTkwIDw9IGNvZGUgJiYgY29kZSA8PSAweDVmNCkgcmV0dXJuIFwiUlwiO1xyXG4gICAgICBlbHNlIGlmICgweDYwMCA8PSBjb2RlICYmIGNvZGUgPD0gMHg2ZWQpIHJldHVybiBhcmFiaWNUeXBlcy5jaGFyQXQoY29kZSAtIDB4NjAwKTtcclxuICAgICAgZWxzZSBpZiAoMHg2ZWUgPD0gY29kZSAmJiBjb2RlIDw9IDB4OGFjKSByZXR1cm4gXCJyXCI7XHJcbiAgICAgIGVsc2UgaWYgKDB4MjAwMCA8PSBjb2RlICYmIGNvZGUgPD0gMHgyMDBiKSByZXR1cm4gXCJ3XCI7XHJcbiAgICAgIGVsc2UgaWYgKGNvZGUgPT0gMHgyMDBjKSByZXR1cm4gXCJiXCI7XHJcbiAgICAgIGVsc2UgcmV0dXJuIFwiTFwiO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBiaWRpUkUgPSAvW1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTA3MDAtXFx1MDhhY10vO1xyXG4gICAgdmFyIGlzTmV1dHJhbCA9IC9bc3R3Tl0vLCBpc1N0cm9uZyA9IC9bTFJyXS8sIGNvdW50c0FzTGVmdCA9IC9bTGIxbl0vLCBjb3VudHNBc051bSA9IC9bMW5dLztcclxuICAgIC8vIEJyb3dzZXJzIHNlZW0gdG8gYWx3YXlzIHRyZWF0IHRoZSBib3VuZGFyaWVzIG9mIGJsb2NrIGVsZW1lbnRzIGFzIGJlaW5nIEwuXHJcbiAgICB2YXIgb3V0ZXJUeXBlID0gXCJMXCI7XHJcblxyXG4gICAgZnVuY3Rpb24gQmlkaVNwYW4obGV2ZWwsIGZyb20sIHRvKSB7XHJcbiAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcclxuICAgICAgdGhpcy5mcm9tID0gZnJvbTsgdGhpcy50byA9IHRvO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgaWYgKCFiaWRpUkUudGVzdChzdHIpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIHZhciBsZW4gPSBzdHIubGVuZ3RoLCB0eXBlcyA9IFtdO1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgdHlwZTsgaSA8IGxlbjsgKytpKVxyXG4gICAgICAgIHR5cGVzLnB1c2godHlwZSA9IGNoYXJUeXBlKHN0ci5jaGFyQ29kZUF0KGkpKSk7XHJcblxyXG4gICAgICAvLyBXMS4gRXhhbWluZSBlYWNoIG5vbi1zcGFjaW5nIG1hcmsgKE5TTSkgaW4gdGhlIGxldmVsIHJ1biwgYW5kXHJcbiAgICAgIC8vIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgTlNNIHRvIHRoZSB0eXBlIG9mIHRoZSBwcmV2aW91c1xyXG4gICAgICAvLyBjaGFyYWN0ZXIuIElmIHRoZSBOU00gaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsZXZlbCBydW4sIGl0IHdpbGxcclxuICAgICAgLy8gZ2V0IHRoZSB0eXBlIG9mIHNvci5cclxuICAgICAgZm9yICh2YXIgaSA9IDAsIHByZXYgPSBvdXRlclR5cGU7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAgIHZhciB0eXBlID0gdHlwZXNbaV07XHJcbiAgICAgICAgaWYgKHR5cGUgPT0gXCJtXCIpIHR5cGVzW2ldID0gcHJldjtcclxuICAgICAgICBlbHNlIHByZXYgPSB0eXBlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBXMi4gU2VhcmNoIGJhY2t3YXJkcyBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXJcclxuICAgICAgLy8gdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBBTCwgb3Igc29yKSBpcyBmb3VuZC4gSWYgYW5cclxuICAgICAgLy8gQUwgaXMgZm91bmQsIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEFyYWJpY1xyXG4gICAgICAvLyBudW1iZXIuXHJcbiAgICAgIC8vIFczLiBDaGFuZ2UgYWxsIEFMcyB0byBSLlxyXG4gICAgICBmb3IgKHZhciBpID0gMCwgY3VyID0gb3V0ZXJUeXBlOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2ldO1xyXG4gICAgICAgIGlmICh0eXBlID09IFwiMVwiICYmIGN1ciA9PSBcInJcIikgdHlwZXNbaV0gPSBcIm5cIjtcclxuICAgICAgICBlbHNlIGlmIChpc1N0cm9uZy50ZXN0KHR5cGUpKSB7IGN1ciA9IHR5cGU7IGlmICh0eXBlID09IFwiclwiKSB0eXBlc1tpXSA9IFwiUlwiOyB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFc0LiBBIHNpbmdsZSBFdXJvcGVhbiBzZXBhcmF0b3IgYmV0d2VlbiB0d28gRXVyb3BlYW4gbnVtYmVyc1xyXG4gICAgICAvLyBjaGFuZ2VzIHRvIGEgRXVyb3BlYW4gbnVtYmVyLiBBIHNpbmdsZSBjb21tb24gc2VwYXJhdG9yIGJldHdlZW5cclxuICAgICAgLy8gdHdvIG51bWJlcnMgb2YgdGhlIHNhbWUgdHlwZSBjaGFuZ2VzIHRvIHRoYXQgdHlwZS5cclxuICAgICAgZm9yICh2YXIgaSA9IDEsIHByZXYgPSB0eXBlc1swXTsgaSA8IGxlbiAtIDE7ICsraSkge1xyXG4gICAgICAgIHZhciB0eXBlID0gdHlwZXNbaV07XHJcbiAgICAgICAgaWYgKHR5cGUgPT0gXCIrXCIgJiYgcHJldiA9PSBcIjFcIiAmJiB0eXBlc1tpKzFdID09IFwiMVwiKSB0eXBlc1tpXSA9IFwiMVwiO1xyXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCIsXCIgJiYgcHJldiA9PSB0eXBlc1tpKzFdICYmXHJcbiAgICAgICAgICAgICAgICAgKHByZXYgPT0gXCIxXCIgfHwgcHJldiA9PSBcIm5cIikpIHR5cGVzW2ldID0gcHJldjtcclxuICAgICAgICBwcmV2ID0gdHlwZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVzUuIEEgc2VxdWVuY2Ugb2YgRXVyb3BlYW4gdGVybWluYXRvcnMgYWRqYWNlbnQgdG8gRXVyb3BlYW5cclxuICAgICAgLy8gbnVtYmVycyBjaGFuZ2VzIHRvIGFsbCBFdXJvcGVhbiBudW1iZXJzLlxyXG4gICAgICAvLyBXNi4gT3RoZXJ3aXNlLCBzZXBhcmF0b3JzIGFuZCB0ZXJtaW5hdG9ycyBjaGFuZ2UgdG8gT3RoZXJcclxuICAgICAgLy8gTmV1dHJhbC5cclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAgIHZhciB0eXBlID0gdHlwZXNbaV07XHJcbiAgICAgICAgaWYgKHR5cGUgPT0gXCIsXCIpIHR5cGVzW2ldID0gXCJOXCI7XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PSBcIiVcIikge1xyXG4gICAgICAgICAgZm9yICh2YXIgZW5kID0gaSArIDE7IGVuZCA8IGxlbiAmJiB0eXBlc1tlbmRdID09IFwiJVwiOyArK2VuZCkge31cclxuICAgICAgICAgIHZhciByZXBsYWNlID0gKGkgJiYgdHlwZXNbaS0xXSA9PSBcIiFcIikgfHwgKGVuZCA8IGxlbiAmJiB0eXBlc1tlbmRdID09IFwiMVwiKSA/IFwiMVwiIDogXCJOXCI7XHJcbiAgICAgICAgICBmb3IgKHZhciBqID0gaTsgaiA8IGVuZDsgKytqKSB0eXBlc1tqXSA9IHJlcGxhY2U7XHJcbiAgICAgICAgICBpID0gZW5kIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFc3LiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxyXG4gICAgICAvLyB1bnRpbCB0aGUgZmlyc3Qgc3Ryb25nIHR5cGUgKFIsIEwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuIEwgaXNcclxuICAgICAgLy8gZm91bmQsIHRoZW4gY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gTC5cclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGN1ciA9IG91dGVyVHlwZTsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlc1tpXTtcclxuICAgICAgICBpZiAoY3VyID09IFwiTFwiICYmIHR5cGUgPT0gXCIxXCIpIHR5cGVzW2ldID0gXCJMXCI7XHJcbiAgICAgICAgZWxzZSBpZiAoaXNTdHJvbmcudGVzdCh0eXBlKSkgY3VyID0gdHlwZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTjEuIEEgc2VxdWVuY2Ugb2YgbmV1dHJhbHMgdGFrZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGVcclxuICAgICAgLy8gc3Vycm91bmRpbmcgc3Ryb25nIHRleHQgaWYgdGhlIHRleHQgb24gYm90aCBzaWRlcyBoYXMgdGhlIHNhbWVcclxuICAgICAgLy8gZGlyZWN0aW9uLiBFdXJvcGVhbiBhbmQgQXJhYmljIG51bWJlcnMgYWN0IGFzIGlmIHRoZXkgd2VyZSBSIGluXHJcbiAgICAgIC8vIHRlcm1zIG9mIHRoZWlyIGluZmx1ZW5jZSBvbiBuZXV0cmFscy4gU3RhcnQtb2YtbGV2ZWwtcnVuIChzb3IpXHJcbiAgICAgIC8vIGFuZCBlbmQtb2YtbGV2ZWwtcnVuIChlb3IpIGFyZSB1c2VkIGF0IGxldmVsIHJ1biBib3VuZGFyaWVzLlxyXG4gICAgICAvLyBOMi4gQW55IHJlbWFpbmluZyBuZXV0cmFscyB0YWtlIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uLlxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgICAgaWYgKGlzTmV1dHJhbC50ZXN0KHR5cGVzW2ldKSkge1xyXG4gICAgICAgICAgZm9yICh2YXIgZW5kID0gaSArIDE7IGVuZCA8IGxlbiAmJiBpc05ldXRyYWwudGVzdCh0eXBlc1tlbmRdKTsgKytlbmQpIHt9XHJcbiAgICAgICAgICB2YXIgYmVmb3JlID0gKGkgPyB0eXBlc1tpLTFdIDogb3V0ZXJUeXBlKSA9PSBcIkxcIjtcclxuICAgICAgICAgIHZhciBhZnRlciA9IChlbmQgPCBsZW4gPyB0eXBlc1tlbmRdIDogb3V0ZXJUeXBlKSA9PSBcIkxcIjtcclxuICAgICAgICAgIHZhciByZXBsYWNlID0gYmVmb3JlIHx8IGFmdGVyID8gXCJMXCIgOiBcIlJcIjtcclxuICAgICAgICAgIGZvciAodmFyIGogPSBpOyBqIDwgZW5kOyArK2opIHR5cGVzW2pdID0gcmVwbGFjZTtcclxuICAgICAgICAgIGkgPSBlbmQgLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSGVyZSB3ZSBkZXBhcnQgZnJvbSB0aGUgZG9jdW1lbnRlZCBhbGdvcml0aG0sIGluIG9yZGVyIHRvIGF2b2lkXHJcbiAgICAgIC8vIGJ1aWxkaW5nIHVwIGFuIGFjdHVhbCBsZXZlbHMgYXJyYXkuIFNpbmNlIHRoZXJlIGFyZSBvbmx5IHRocmVlXHJcbiAgICAgIC8vIGxldmVscyAoMCwgMSwgMikgaW4gYW4gaW1wbGVtZW50YXRpb24gdGhhdCBkb2Vzbid0IHRha2VcclxuICAgICAgLy8gZXhwbGljaXQgZW1iZWRkaW5nIGludG8gYWNjb3VudCwgd2UgY2FuIGJ1aWxkIHVwIHRoZSBvcmRlciBvblxyXG4gICAgICAvLyB0aGUgZmx5LCB3aXRob3V0IGZvbGxvd2luZyB0aGUgbGV2ZWwtYmFzZWQgYWxnb3JpdGhtLlxyXG4gICAgICB2YXIgb3JkZXIgPSBbXSwgbTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgaWYgKGNvdW50c0FzTGVmdC50ZXN0KHR5cGVzW2ldKSkge1xyXG4gICAgICAgICAgdmFyIHN0YXJ0ID0gaTtcclxuICAgICAgICAgIGZvciAoKytpOyBpIDwgbGVuICYmIGNvdW50c0FzTGVmdC50ZXN0KHR5cGVzW2ldKTsgKytpKSB7fVxyXG4gICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oMCwgc3RhcnQsIGkpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFyIHBvcyA9IGksIGF0ID0gb3JkZXIubGVuZ3RoO1xyXG4gICAgICAgICAgZm9yICgrK2k7IGkgPCBsZW4gJiYgdHlwZXNbaV0gIT0gXCJMXCI7ICsraSkge31cclxuICAgICAgICAgIGZvciAodmFyIGogPSBwb3M7IGogPCBpOykge1xyXG4gICAgICAgICAgICBpZiAoY291bnRzQXNOdW0udGVzdCh0eXBlc1tqXSkpIHtcclxuICAgICAgICAgICAgICBpZiAocG9zIDwgaikgb3JkZXIuc3BsaWNlKGF0LCAwLCBuZXcgQmlkaVNwYW4oMSwgcG9zLCBqKSk7XHJcbiAgICAgICAgICAgICAgdmFyIG5zdGFydCA9IGo7XHJcbiAgICAgICAgICAgICAgZm9yICgrK2o7IGogPCBpICYmIGNvdW50c0FzTnVtLnRlc3QodHlwZXNbal0pOyArK2opIHt9XHJcbiAgICAgICAgICAgICAgb3JkZXIuc3BsaWNlKGF0LCAwLCBuZXcgQmlkaVNwYW4oMiwgbnN0YXJ0LCBqKSk7XHJcbiAgICAgICAgICAgICAgcG9zID0gajtcclxuICAgICAgICAgICAgfSBlbHNlICsrajtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChwb3MgPCBpKSBvcmRlci5zcGxpY2UoYXQsIDAsIG5ldyBCaWRpU3BhbigxLCBwb3MsIGkpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG9yZGVyWzBdLmxldmVsID09IDEgJiYgKG0gPSBzdHIubWF0Y2goL15cXHMrLykpKSB7XHJcbiAgICAgICAgb3JkZXJbMF0uZnJvbSA9IG1bMF0ubGVuZ3RoO1xyXG4gICAgICAgIG9yZGVyLnVuc2hpZnQobmV3IEJpZGlTcGFuKDAsIDAsIG1bMF0ubGVuZ3RoKSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGxzdChvcmRlcikubGV2ZWwgPT0gMSAmJiAobSA9IHN0ci5tYXRjaCgvXFxzKyQvKSkpIHtcclxuICAgICAgICBsc3Qob3JkZXIpLnRvIC09IG1bMF0ubGVuZ3RoO1xyXG4gICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKDAsIGxlbiAtIG1bMF0ubGVuZ3RoLCBsZW4pKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAob3JkZXJbMF0ubGV2ZWwgIT0gbHN0KG9yZGVyKS5sZXZlbClcclxuICAgICAgICBvcmRlci5wdXNoKG5ldyBCaWRpU3BhbihvcmRlclswXS5sZXZlbCwgbGVuLCBsZW4pKTtcclxuXHJcbiAgICAgIHJldHVybiBvcmRlcjtcclxuICAgIH07XHJcbiAgfSkoKTtcclxuXHJcbiAgLy8gVEhFIEVORFxyXG5cclxuICBDb2RlTWlycm9yLnZlcnNpb24gPSBcIjUuMS4xXCI7XHJcblxyXG4gIHJldHVybiBDb2RlTWlycm9yO1xyXG59KTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./codemirror/lib/codemirror.js\n");

/***/ }),

/***/ "./codemirror/overlay.js":
/*!*******************************!*\
  !*** ./codemirror/overlay.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n// Utility function that allows modes to be combined. The mode given\r\n// as the base argument takes care of most of the normal mode\r\n// functionality, but a second (typically simple) mode is used, which\r\n// can override the style of text. Both modes get to parse all of the\r\n// text, but when both assign a non-null style to a piece of code, the\r\n// overlay wins, unless the combine argument was true and not overridden,\r\n// or state.overlay.combineTokens was true, in which case the styles are\r\n// combined.\r\n\r\n(function(mod) {\r\n  if (true) // CommonJS\r\n    mod(__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../lib/codemirror'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\r\n  else {}\r\n})(function(CodeMirror) {\r\n\"use strict\";\r\n\r\nCodeMirror.overlayMode = function(base, overlay, combine) {\r\n  return {\r\n    startState: function() {\r\n      return {\r\n        base: CodeMirror.startState(base),\r\n        overlay: CodeMirror.startState(overlay),\r\n        basePos: 0, baseCur: null,\r\n        overlayPos: 0, overlayCur: null,\r\n        streamSeen: null\r\n      };\r\n    },\r\n    copyState: function(state) {\r\n      return {\r\n        base: CodeMirror.copyState(base, state.base),\r\n        overlay: CodeMirror.copyState(overlay, state.overlay),\r\n        basePos: state.basePos, baseCur: null,\r\n        overlayPos: state.overlayPos, overlayCur: null\r\n      };\r\n    },\r\n\r\n    token: function(stream, state) {\r\n      if (stream != state.streamSeen ||\r\n          Math.min(state.basePos, state.overlayPos) < stream.start) {\r\n        state.streamSeen = stream;\r\n        state.basePos = state.overlayPos = stream.start;\r\n      }\r\n\r\n      if (stream.start == state.basePos) {\r\n        state.baseCur = base.token(stream, state.base);\r\n        state.basePos = stream.pos;\r\n      }\r\n      if (stream.start == state.overlayPos) {\r\n        stream.pos = stream.start;\r\n        state.overlayCur = overlay.token(stream, state.overlay);\r\n        state.overlayPos = stream.pos;\r\n      }\r\n      stream.pos = Math.min(state.basePos, state.overlayPos);\r\n\r\n      // state.overlay.combineTokens always takes precedence over combine,\r\n      // unless set to null\r\n      if (state.overlayCur == null) return state.baseCur;\r\n      else if (state.baseCur != null &&\r\n               state.overlay.combineTokens ||\r\n               combine && state.overlay.combineTokens == null)\r\n        return state.baseCur + \" \" + state.overlayCur;\r\n      else return state.overlayCur;\r\n    },\r\n\r\n    indent: base.indent && function(state, textAfter) {\r\n      return base.indent(state.base, textAfter);\r\n    },\r\n    electricChars: base.electricChars,\r\n\r\n    innerMode: function(state) { return {state: state.base, mode: base}; },\r\n\r\n    blankLine: function(state) {\r\n      if (base.blankLine) base.blankLine(state.base);\r\n      if (overlay.blankLine) overlay.blankLine(state.overlay);\r\n    }\r\n  };\r\n};\r\n\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb2RlbWlycm9yL292ZXJsYXkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb2RlbWlycm9yL292ZXJsYXkuanM/OWQxMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xyXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cDovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcclxuXHJcbi8vIFV0aWxpdHkgZnVuY3Rpb24gdGhhdCBhbGxvd3MgbW9kZXMgdG8gYmUgY29tYmluZWQuIFRoZSBtb2RlIGdpdmVuXHJcbi8vIGFzIHRoZSBiYXNlIGFyZ3VtZW50IHRha2VzIGNhcmUgb2YgbW9zdCBvZiB0aGUgbm9ybWFsIG1vZGVcclxuLy8gZnVuY3Rpb25hbGl0eSwgYnV0IGEgc2Vjb25kICh0eXBpY2FsbHkgc2ltcGxlKSBtb2RlIGlzIHVzZWQsIHdoaWNoXHJcbi8vIGNhbiBvdmVycmlkZSB0aGUgc3R5bGUgb2YgdGV4dC4gQm90aCBtb2RlcyBnZXQgdG8gcGFyc2UgYWxsIG9mIHRoZVxyXG4vLyB0ZXh0LCBidXQgd2hlbiBib3RoIGFzc2lnbiBhIG5vbi1udWxsIHN0eWxlIHRvIGEgcGllY2Ugb2YgY29kZSwgdGhlXHJcbi8vIG92ZXJsYXkgd2lucywgdW5sZXNzIHRoZSBjb21iaW5lIGFyZ3VtZW50IHdhcyB0cnVlIGFuZCBub3Qgb3ZlcnJpZGRlbixcclxuLy8gb3Igc3RhdGUub3ZlcmxheS5jb21iaW5lVG9rZW5zIHdhcyB0cnVlLCBpbiB3aGljaCBjYXNlIHRoZSBzdHlsZXMgYXJlXHJcbi8vIGNvbWJpbmVkLlxyXG5cclxuKGZ1bmN0aW9uKG1vZCkge1xyXG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcclxuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xyXG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxyXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xyXG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcclxuICAgIG1vZChDb2RlTWlycm9yKTtcclxufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbkNvZGVNaXJyb3Iub3ZlcmxheU1vZGUgPSBmdW5jdGlvbihiYXNlLCBvdmVybGF5LCBjb21iaW5lKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGJhc2U6IENvZGVNaXJyb3Iuc3RhcnRTdGF0ZShiYXNlKSxcclxuICAgICAgICBvdmVybGF5OiBDb2RlTWlycm9yLnN0YXJ0U3RhdGUob3ZlcmxheSksXHJcbiAgICAgICAgYmFzZVBvczogMCwgYmFzZUN1cjogbnVsbCxcclxuICAgICAgICBvdmVybGF5UG9zOiAwLCBvdmVybGF5Q3VyOiBudWxsLFxyXG4gICAgICAgIHN0cmVhbVNlZW46IG51bGxcclxuICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBjb3B5U3RhdGU6IGZ1bmN0aW9uKHN0YXRlKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgYmFzZTogQ29kZU1pcnJvci5jb3B5U3RhdGUoYmFzZSwgc3RhdGUuYmFzZSksXHJcbiAgICAgICAgb3ZlcmxheTogQ29kZU1pcnJvci5jb3B5U3RhdGUob3ZlcmxheSwgc3RhdGUub3ZlcmxheSksXHJcbiAgICAgICAgYmFzZVBvczogc3RhdGUuYmFzZVBvcywgYmFzZUN1cjogbnVsbCxcclxuICAgICAgICBvdmVybGF5UG9zOiBzdGF0ZS5vdmVybGF5UG9zLCBvdmVybGF5Q3VyOiBudWxsXHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XHJcbiAgICAgIGlmIChzdHJlYW0gIT0gc3RhdGUuc3RyZWFtU2VlbiB8fFxyXG4gICAgICAgICAgTWF0aC5taW4oc3RhdGUuYmFzZVBvcywgc3RhdGUub3ZlcmxheVBvcykgPCBzdHJlYW0uc3RhcnQpIHtcclxuICAgICAgICBzdGF0ZS5zdHJlYW1TZWVuID0gc3RyZWFtO1xyXG4gICAgICAgIHN0YXRlLmJhc2VQb3MgPSBzdGF0ZS5vdmVybGF5UG9zID0gc3RyZWFtLnN0YXJ0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc3RyZWFtLnN0YXJ0ID09IHN0YXRlLmJhc2VQb3MpIHtcclxuICAgICAgICBzdGF0ZS5iYXNlQ3VyID0gYmFzZS50b2tlbihzdHJlYW0sIHN0YXRlLmJhc2UpO1xyXG4gICAgICAgIHN0YXRlLmJhc2VQb3MgPSBzdHJlYW0ucG9zO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzdHJlYW0uc3RhcnQgPT0gc3RhdGUub3ZlcmxheVBvcykge1xyXG4gICAgICAgIHN0cmVhbS5wb3MgPSBzdHJlYW0uc3RhcnQ7XHJcbiAgICAgICAgc3RhdGUub3ZlcmxheUN1ciA9IG92ZXJsYXkudG9rZW4oc3RyZWFtLCBzdGF0ZS5vdmVybGF5KTtcclxuICAgICAgICBzdGF0ZS5vdmVybGF5UG9zID0gc3RyZWFtLnBvcztcclxuICAgICAgfVxyXG4gICAgICBzdHJlYW0ucG9zID0gTWF0aC5taW4oc3RhdGUuYmFzZVBvcywgc3RhdGUub3ZlcmxheVBvcyk7XHJcblxyXG4gICAgICAvLyBzdGF0ZS5vdmVybGF5LmNvbWJpbmVUb2tlbnMgYWx3YXlzIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBjb21iaW5lLFxyXG4gICAgICAvLyB1bmxlc3Mgc2V0IHRvIG51bGxcclxuICAgICAgaWYgKHN0YXRlLm92ZXJsYXlDdXIgPT0gbnVsbCkgcmV0dXJuIHN0YXRlLmJhc2VDdXI7XHJcbiAgICAgIGVsc2UgaWYgKHN0YXRlLmJhc2VDdXIgIT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICBzdGF0ZS5vdmVybGF5LmNvbWJpbmVUb2tlbnMgfHxcclxuICAgICAgICAgICAgICAgY29tYmluZSAmJiBzdGF0ZS5vdmVybGF5LmNvbWJpbmVUb2tlbnMgPT0gbnVsbClcclxuICAgICAgICByZXR1cm4gc3RhdGUuYmFzZUN1ciArIFwiIFwiICsgc3RhdGUub3ZlcmxheUN1cjtcclxuICAgICAgZWxzZSByZXR1cm4gc3RhdGUub3ZlcmxheUN1cjtcclxuICAgIH0sXHJcblxyXG4gICAgaW5kZW50OiBiYXNlLmluZGVudCAmJiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyKSB7XHJcbiAgICAgIHJldHVybiBiYXNlLmluZGVudChzdGF0ZS5iYXNlLCB0ZXh0QWZ0ZXIpO1xyXG4gICAgfSxcclxuICAgIGVsZWN0cmljQ2hhcnM6IGJhc2UuZWxlY3RyaWNDaGFycyxcclxuXHJcbiAgICBpbm5lck1vZGU6IGZ1bmN0aW9uKHN0YXRlKSB7IHJldHVybiB7c3RhdGU6IHN0YXRlLmJhc2UsIG1vZGU6IGJhc2V9OyB9LFxyXG5cclxuICAgIGJsYW5rTGluZTogZnVuY3Rpb24oc3RhdGUpIHtcclxuICAgICAgaWYgKGJhc2UuYmxhbmtMaW5lKSBiYXNlLmJsYW5rTGluZShzdGF0ZS5iYXNlKTtcclxuICAgICAgaWYgKG92ZXJsYXkuYmxhbmtMaW5lKSBvdmVybGF5LmJsYW5rTGluZShzdGF0ZS5vdmVybGF5KTtcclxuICAgIH1cclxuICB9O1xyXG59O1xyXG5cclxufSk7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./codemirror/overlay.js\n");

/***/ }),

/***/ "./lib/highlight.pack.js":
/*!*******************************!*\
  !*** ./lib/highlight.pack.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function(e){ true?e(exports):(undefined)}(function(e){function n(e){return e.replace(/&/gm,\"&amp;\").replace(/</gm,\"&lt;\").replace(/>/gm,\"&gt;\")}function t(e){return e.nodeName.toLowerCase()}function r(e,n){var t=e&&e.exec(n);return t&&0==t.index}function a(e){var n=(e.className+\" \"+(e.parentNode?e.parentNode.className:\"\")).split(/\\s+/);return n=n.map(function(e){return e.replace(/^lang(uage)?-/,\"\")}),n.filter(function(e){return N(e)||/no(-?)highlight/.test(e)})[0]}function o(e,n){var t={};for(var r in e)t[r]=e[r];if(n)for(var r in n)t[r]=n[r];return t}function i(e){var n=[];return function r(e,a){for(var o=e.firstChild;o;o=o.nextSibling)3==o.nodeType?a+=o.nodeValue.length:1==o.nodeType&&(n.push({event:\"start\",offset:a,node:o}),a=r(o,a),t(o).match(/br|hr|img|input/)||n.push({event:\"stop\",offset:a,node:o}));return a}(e,0),n}function c(e,r,a){function o(){return e.length&&r.length?e[0].offset!=r[0].offset?e[0].offset<r[0].offset?e:r:\"start\"==r[0].event?e:r:e.length?e:r}function i(e){function r(e){return\" \"+e.nodeName+'=\"'+n(e.value)+'\"'}l+=\"<\"+t(e)+Array.prototype.map.call(e.attributes,r).join(\"\")+\">\"}function c(e){l+=\"</\"+t(e)+\">\"}function u(e){(\"start\"==e.event?i:c)(e.node)}for(var s=0,l=\"\",f=[];e.length||r.length;){var g=o();if(l+=n(a.substr(s,g[0].offset-s)),s=g[0].offset,g==e){f.reverse().forEach(c);do u(g.splice(0,1)[0]),g=o();while(g==e&&g.length&&g[0].offset==s);f.reverse().forEach(i)}else\"start\"==g[0].event?f.push(g[0].node):f.pop(),u(g.splice(0,1)[0])}return l+n(a.substr(s))}function u(e){function n(e){return e&&e.source||e}function t(t,r){return RegExp(n(t),\"m\"+(e.cI?\"i\":\"\")+(r?\"g\":\"\"))}function r(a,i){if(!a.compiled){if(a.compiled=!0,a.k=a.k||a.bK,a.k){var c={},u=function(n,t){e.cI&&(t=t.toLowerCase()),t.split(\" \").forEach(function(e){var t=e.split(\"|\");c[t[0]]=[n,t[1]?Number(t[1]):1]})};\"string\"==typeof a.k?u(\"keyword\",a.k):Object.keys(a.k).forEach(function(e){u(e,a.k[e])}),a.k=c}a.lR=t(a.l||/\\b[A-Za-z0-9_]+\\b/,!0),i&&(a.bK&&(a.b=\"\\\\b(\"+a.bK.split(\" \").join(\"|\")+\")\\\\b\"),a.b||(a.b=/\\B|\\b/),a.bR=t(a.b),a.e||a.eW||(a.e=/\\B|\\b/),a.e&&(a.eR=t(a.e)),a.tE=n(a.e)||\"\",a.eW&&i.tE&&(a.tE+=(a.e?\"|\":\"\")+i.tE)),a.i&&(a.iR=t(a.i)),void 0===a.r&&(a.r=1),a.c||(a.c=[]);var s=[];a.c.forEach(function(e){e.v?e.v.forEach(function(n){s.push(o(e,n))}):s.push(\"self\"==e?a:e)}),a.c=s,a.c.forEach(function(e){r(e,a)}),a.starts&&r(a.starts,i);var l=a.c.map(function(e){return e.bK?\"\\\\.?(\"+e.b+\")\\\\.?\":e.b}).concat([a.tE,a.i]).map(n).filter(Boolean);a.t=l.length?t(l.join(\"|\"),!0):{exec:function(){return null}}}}r(e)}function s(e,t,a,o){function i(e,n){for(var t=0;t<n.c.length;t++)if(r(n.c[t].bR,e))return n.c[t]}function c(e,n){return r(e.eR,n)?e:e.eW?c(e.parent,n):void 0}function f(e,n){return!a&&r(n.iR,e)}function g(e,n){var t=x.cI?n[0].toLowerCase():n[0];return e.k.hasOwnProperty(t)&&e.k[t]}function p(e,n,t,r){var a=r?\"\":E.classPrefix,o='<span class=\"'+a,i=t?\"\":\"</span>\";return o+=e+'\">',o+n+i}function d(){if(!w.k)return n(y);var e=\"\",t=0;w.lR.lastIndex=0;for(var r=w.lR.exec(y);r;){e+=n(y.substr(t,r.index-t));var a=g(w,r);a?(B+=a[1],e+=p(a[0],n(r[0]))):e+=n(r[0]),t=w.lR.lastIndex,r=w.lR.exec(y)}return e+n(y.substr(t))}function h(){if(w.sL&&!R[w.sL])return n(y);var e=w.sL?s(w.sL,y,!0,L[w.sL]):l(y);return w.r>0&&(B+=e.r),\"continuous\"==w.subLanguageMode&&(L[w.sL]=e.top),p(e.language,e.value,!1,!0)}function v(){return void 0!==w.sL?h():d()}function b(e,t){var r=e.cN?p(e.cN,\"\",!0):\"\";e.rB?(M+=r,y=\"\"):e.eB?(M+=n(t)+r,y=\"\"):(M+=r,y=t),w=Object.create(e,{parent:{value:w}})}function m(e,t){if(y+=e,void 0===t)return M+=v(),0;var r=i(t,w);if(r)return M+=v(),b(r,t),r.rB?0:t.length;var a=c(w,t);if(a){var o=w;o.rE||o.eE||(y+=t),M+=v();do w.cN&&(M+=\"</span>\"),B+=w.r,w=w.parent;while(w!=a.parent);return o.eE&&(M+=n(t)),y=\"\",a.starts&&b(a.starts,\"\"),o.rE?0:t.length}if(f(t,w))throw new Error('Illegal lexeme \"'+t+'\" for mode \"'+(w.cN||\"<unnamed>\")+'\"');return y+=t,t.length||1}var x=N(e);if(!x)throw new Error('Unknown language: \"'+e+'\"');u(x);for(var w=o||x,L={},M=\"\",k=w;k!=x;k=k.parent)k.cN&&(M=p(k.cN,\"\",!0)+M);var y=\"\",B=0;try{for(var C,j,I=0;;){if(w.t.lastIndex=I,C=w.t.exec(t),!C)break;j=m(t.substr(I,C.index-I),C[0]),I=C.index+j}m(t.substr(I));for(var k=w;k.parent;k=k.parent)k.cN&&(M+=\"</span>\");return{r:B,value:M,language:e,top:w}}catch(A){if(-1!=A.message.indexOf(\"Illegal\"))return{r:0,value:n(t)};throw A}}function l(e,t){t=t||E.languages||Object.keys(R);var r={r:0,value:n(e)},a=r;return t.forEach(function(n){if(N(n)){var t=s(n,e,!1);t.language=n,t.r>a.r&&(a=t),t.r>r.r&&(a=r,r=t)}}),a.language&&(r.second_best=a),r}function f(e){return E.tabReplace&&(e=e.replace(/^((<[^>]+>|\\t)+)/gm,function(e,n){return n.replace(/\\t/g,E.tabReplace)})),E.useBR&&(e=e.replace(/\\n/g,\"<br>\")),e}function g(e,n,t){var r=n?x[n]:t,a=[e.trim()];return e.match(/(\\s|^)hljs(\\s|$)/)||a.push(\"hljs\"),r&&a.push(r),a.join(\" \").trim()}function p(e){var n=a(e);if(!/no(-?)highlight/.test(n)){var t;E.useBR?(t=document.createElementNS(\"http://www.w3.org/1999/xhtml\",\"div\"),t.innerHTML=e.innerHTML.replace(/\\n/g,\"\").replace(/<br[ \\/]*>/g,\"\\n\")):t=e;var r=t.textContent,o=n?s(n,r,!0):l(r),u=i(t);if(u.length){var p=document.createElementNS(\"http://www.w3.org/1999/xhtml\",\"div\");p.innerHTML=o.value,o.value=c(u,i(p),r)}o.value=f(o.value),e.innerHTML=o.value,e.className=g(e.className,n,o.language),e.result={language:o.language,re:o.r},o.second_best&&(e.second_best={language:o.second_best.language,re:o.second_best.r})}}function d(e){E=o(E,e)}function h(){if(!h.called){h.called=!0;var e=document.querySelectorAll(\"pre code\");Array.prototype.forEach.call(e,p)}}function v(){addEventListener(\"DOMContentLoaded\",h,!1),addEventListener(\"load\",h,!1)}function b(n,t){var r=R[n]=t(e);r.aliases&&r.aliases.forEach(function(e){x[e]=n})}function m(){return Object.keys(R)}function N(e){return R[e]||R[x[e]]}var E={classPrefix:\"hljs-\",tabReplace:null,useBR:!1,languages:void 0},R={},x={};return e.highlight=s,e.highlightAuto=l,e.fixMarkup=f,e.highlightBlock=p,e.configure=d,e.initHighlighting=h,e.initHighlightingOnLoad=v,e.registerLanguage=b,e.listLanguages=m,e.getLanguage=N,e.inherit=o,e.IR=\"[a-zA-Z][a-zA-Z0-9_]*\",e.UIR=\"[a-zA-Z_][a-zA-Z0-9_]*\",e.NR=\"\\\\b\\\\d+(\\\\.\\\\d+)?\",e.CNR=\"(\\\\b0[xX][a-fA-F0-9]+|(\\\\b\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)([eE][-+]?\\\\d+)?)\",e.BNR=\"\\\\b(0b[01]+)\",e.RSR=\"!|!=|!==|%|%=|&|&&|&=|\\\\*|\\\\*=|\\\\+|\\\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\\\?|\\\\[|\\\\{|\\\\(|\\\\^|\\\\^=|\\\\||\\\\|=|\\\\|\\\\||~\",e.BE={b:\"\\\\\\\\[\\\\s\\\\S]\",r:0},e.ASM={cN:\"string\",b:\"'\",e:\"'\",i:\"\\\\n\",c:[e.BE]},e.QSM={cN:\"string\",b:'\"',e:'\"',i:\"\\\\n\",c:[e.BE]},e.PWM={b:/\\b(a|an|the|are|I|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such)\\b/},e.CLCM={cN:\"comment\",b:\"//\",e:\"$\",c:[e.PWM]},e.CBCM={cN:\"comment\",b:\"/\\\\*\",e:\"\\\\*/\",c:[e.PWM]},e.HCM={cN:\"comment\",b:\"#\",e:\"$\",c:[e.PWM]},e.NM={cN:\"number\",b:e.NR,r:0},e.CNM={cN:\"number\",b:e.CNR,r:0},e.BNM={cN:\"number\",b:e.BNR,r:0},e.CSSNM={cN:\"number\",b:e.NR+\"(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?\",r:0},e.RM={cN:\"regexp\",b:/\\//,e:/\\/[gimuy]*/,i:/\\n/,c:[e.BE,{b:/\\[/,e:/\\]/,r:0,c:[e.BE]}]},e.TM={cN:\"title\",b:e.IR,r:0},e.UTM={cN:\"title\",b:e.UIR,r:0},e});hljs.registerLanguage(\"coffeescript\",function(e){var c={keyword:\"in if for while finally new do return else break catch instanceof throw try this switch continue typeof delete debugger super then unless until loop of by when and or is isnt not\",literal:\"true false null undefined yes no on off\",reserved:\"case default function var void with const let enum export import native __hasProp __extends __slice __bind __indexOf\",built_in:\"npm require console print module global window document\"},n=\"[A-Za-z$_][0-9A-Za-z$_]*\",t={cN:\"subst\",b:/#\\{/,e:/}/,k:c},r=[e.BNM,e.inherit(e.CNM,{starts:{e:\"(\\\\s*/)?\",r:0}}),{cN:\"string\",v:[{b:/'''/,e:/'''/,c:[e.BE]},{b:/'/,e:/'/,c:[e.BE]},{b:/\"\"\"/,e:/\"\"\"/,c:[e.BE,t]},{b:/\"/,e:/\"/,c:[e.BE,t]}]},{cN:\"regexp\",v:[{b:\"///\",e:\"///\",c:[t,e.HCM]},{b:\"//[gim]*\",r:0},{b:/\\/(?![ *])(\\\\\\/|.)*?\\/[gim]*(?=\\W|$)/}]},{cN:\"property\",b:\"@\"+n},{b:\"`\",e:\"`\",eB:!0,eE:!0,sL:\"javascript\"}];t.c=r;var i=e.inherit(e.TM,{b:n}),s=\"(\\\\(.*\\\\))?\\\\s*\\\\B[-=]>\",o={cN:\"params\",b:\"\\\\([^\\\\(]\",rB:!0,c:[{b:/\\(/,e:/\\)/,k:c,c:[\"self\"].concat(r)}]};return{aliases:[\"coffee\",\"cson\",\"iced\"],k:c,i:/\\/\\*/,c:r.concat([{cN:\"comment\",b:\"###\",e:\"###\",c:[e.PWM]},e.HCM,{cN:\"function\",b:\"^\\\\s*\"+n+\"\\\\s*=\\\\s*\"+s,e:\"[-=]>\",rB:!0,c:[i,o]},{b:/[:\\(,=]\\s*/,r:0,c:[{cN:\"function\",b:s,e:\"[-=]>\",rB:!0,c:[o]}]},{cN:\"class\",bK:\"class\",e:\"$\",i:/[:=\"\\[\\]]/,c:[{bK:\"extends\",eW:!0,i:/[:=\"\\[\\]]/,c:[i]},i]},{cN:\"attribute\",b:n+\":\",e:\":\",rB:!0,rE:!0,r:0}])}});hljs.registerLanguage(\"apache\",function(e){var r={cN:\"number\",b:\"[\\\\$%]\\\\d+\"};return{aliases:[\"apacheconf\"],cI:!0,c:[e.HCM,{cN:\"tag\",b:\"</?\",e:\">\"},{cN:\"keyword\",b:/\\w+/,r:0,k:{common:\"order deny allow setenv rewriterule rewriteengine rewritecond documentroot sethandler errordocument loadmodule options header listen serverroot servername\"},starts:{e:/$/,r:0,k:{literal:\"on off all\"},c:[{cN:\"sqbracket\",b:\"\\\\s\\\\[\",e:\"\\\\]$\"},{cN:\"cbracket\",b:\"[\\\\$%]\\\\{\",e:\"\\\\}\",c:[\"self\",r]},r,e.QSM]}}],i:/\\S/}});hljs.registerLanguage(\"http\",function(){return{i:\"\\\\S\",c:[{cN:\"status\",b:\"^HTTP/[0-9\\\\.]+\",e:\"$\",c:[{cN:\"number\",b:\"\\\\b\\\\d{3}\\\\b\"}]},{cN:\"request\",b:\"^[A-Z]+ (.*?) HTTP/[0-9\\\\.]+$\",rB:!0,e:\"$\",c:[{cN:\"string\",b:\" \",e:\" \",eB:!0,eE:!0}]},{cN:\"attribute\",b:\"^\\\\w\",e:\": \",eE:!0,i:\"\\\\n|\\\\s|=\",starts:{cN:\"string\",e:\"$\"}},{b:\"\\\\n\\\\n\",starts:{sL:\"\",eW:!0}}]}});hljs.registerLanguage(\"cs\",function(e){var r=\"abstract as base bool break byte case catch char checked const continue decimal default delegate do double else enum event explicit extern false finally fixed float for foreach goto if implicit in int interface internal is lock long null object operator out override params private protected public readonly ref sbyte sealed short sizeof stackalloc static string struct switch this true try typeof uint ulong unchecked unsafe ushort using virtual volatile void while async protected public private internal ascending descending from get group into join let orderby partial select set value var where yield\",t=e.IR+\"(<\"+e.IR+\">)?\";return{aliases:[\"csharp\"],k:r,i:/::/,c:[{cN:\"comment\",b:\"///\",e:\"$\",rB:!0,c:[{cN:\"xmlDocTag\",v:[{b:\"///\",r:0},{b:\"<!--|-->\"},{b:\"</?\",e:\">\"}]}]},e.CLCM,e.CBCM,{cN:\"preprocessor\",b:\"#\",e:\"$\",k:\"if else elif endif define undef warning error line region endregion pragma checksum\"},{cN:\"string\",b:'@\"',e:'\"',c:[{b:'\"\"'}]},e.ASM,e.QSM,e.CNM,{bK:\"class namespace interface\",e:/[{;=]/,i:/[^\\s:]/,c:[e.TM,e.CLCM,e.CBCM]},{bK:\"new return throw await\",r:0},{cN:\"function\",b:\"(\"+t+\"\\\\s+)+\"+e.IR+\"\\\\s*\\\\(\",rB:!0,e:/[{;=]/,eE:!0,k:r,c:[{b:e.IR+\"\\\\s*\\\\(\",rB:!0,c:[e.TM],r:0},{cN:\"params\",b:/\\(/,e:/\\)/,k:r,r:0,c:[e.ASM,e.QSM,e.CNM,e.CBCM]},e.CLCM,e.CBCM]}]}});hljs.registerLanguage(\"java\",function(e){var a=e.UIR+\"(<\"+e.UIR+\">)?\",t=\"false synchronized int abstract float private char boolean static null if const for true while long strictfp finally protected import native final void enum else break transient catch instanceof byte super volatile case assert short package default double public try this switch continue throws protected public private\",c=\"(\\\\b(0b[01_]+)|\\\\b0[xX][a-fA-F0-9_]+|(\\\\b[\\\\d_]+(\\\\.[\\\\d_]*)?|\\\\.[\\\\d_]+)([eE][-+]?\\\\d+)?)[lLfF]?\",r={cN:\"number\",b:c,r:0};return{aliases:[\"jsp\"],k:t,i:/<\\//,c:[{cN:\"javadoc\",b:\"/\\\\*\\\\*\",e:\"\\\\*/\",r:0,c:[{cN:\"javadoctag\",b:\"(^|\\\\s)@[A-Za-z]+\"}]},e.CLCM,e.CBCM,e.ASM,e.QSM,{cN:\"class\",bK:\"class interface\",e:/[{;=]/,eE:!0,k:\"class interface\",i:/[:\"\\[\\]]/,c:[{bK:\"extends implements\"},e.UTM]},{bK:\"new throw return\",r:0},{cN:\"function\",b:\"(\"+a+\"\\\\s+)+\"+e.UIR+\"\\\\s*\\\\(\",rB:!0,e:/[{;=]/,eE:!0,k:t,c:[{b:e.UIR+\"\\\\s*\\\\(\",rB:!0,r:0,c:[e.UTM]},{cN:\"params\",b:/\\(/,e:/\\)/,k:t,r:0,c:[e.ASM,e.QSM,e.CNM,e.CBCM]},e.CLCM,e.CBCM]},r,{cN:\"annotation\",b:\"@[A-Za-z]+\"}]}});hljs.registerLanguage(\"sql\",function(e){var t={cN:\"comment\",b:\"--\",e:\"$\"};return{cI:!0,i:/[<>]/,c:[{cN:\"operator\",bK:\"begin end start commit rollback savepoint lock alter create drop rename call delete do handler insert load replace select truncate update set show pragma grant merge describe use explain help declare prepare execute deallocate savepoint release unlock purge reset change stop analyze cache flush optimize repair kill install uninstall checksum restore check backup\",e:/;/,eW:!0,k:{keyword:\"abs absolute acos action add adddate addtime aes_decrypt aes_encrypt after aggregate all allocate alter analyze and any are as asc ascii asin assertion at atan atan2 atn2 authorization authors avg backup before begin benchmark between bin binlog bit_and bit_count bit_length bit_or bit_xor both by cache call cascade cascaded case cast catalog ceil ceiling chain change changed char_length character_length charindex charset check checksum checksum_agg choose close coalesce coercibility collate collation collationproperty column columns columns_updated commit compress concat concat_ws concurrent connect connection connection_id consistent constraint constraints continue contributors conv convert convert_tz corresponding cos cot count count_big crc32 create cross cume_dist curdate current current_date current_time current_timestamp current_user cursor curtime data database databases datalength date_add date_format date_sub dateadd datediff datefromparts datename datepart datetime2fromparts datetimeoffsetfromparts day dayname dayofmonth dayofweek dayofyear deallocate declare decode default deferrable deferred degrees delayed delete des_decrypt des_encrypt des_key_file desc describe descriptor diagnostics difference disconnect distinct distinctrow div do domain double drop dumpfile each else elt enclosed encode encrypt end end-exec engine engines eomonth errors escape escaped event eventdata events except exception exec execute exists exp explain export_set extended external extract fast fetch field fields find_in_set first first_value floor flush for force foreign format found found_rows from from_base64 from_days from_unixtime full function get get_format get_lock getdate getutcdate global go goto grant grants greatest group group_concat grouping grouping_id gtid_subset gtid_subtract handler having help hex high_priority hosts hour ident_current ident_incr ident_seed identified identity if ifnull ignore iif ilike immediate in index indicator inet6_aton inet6_ntoa inet_aton inet_ntoa infile initially inner innodb input insert install instr intersect into is is_free_lock is_ipv4 is_ipv4_compat is_ipv4_mapped is_not is_not_null is_used_lock isdate isnull isolation join key kill language last last_day last_insert_id last_value lcase lead leading least leaves left len lenght level like limit lines ln load load_file local localtime localtimestamp locate lock log log10 log2 logfile logs low_priority lower lpad ltrim make_set makedate maketime master master_pos_wait match matched max md5 medium merge microsecond mid min minute mod mode module month monthname mutex name_const names national natural nchar next no no_write_to_binlog not now nullif nvarchar oct octet_length of old_password on only open optimize option optionally or ord order outer outfile output pad parse partial partition password patindex percent_rank percentile_cont percentile_disc period_add period_diff pi plugin position pow power pragma precision prepare preserve primary prior privileges procedure procedure_analyze processlist profile profiles public publishingservername purge quarter query quick quote quotename radians rand read references regexp relative relaylog release release_lock rename repair repeat replace replicate reset restore restrict return returns reverse revoke right rlike rollback rollup round row row_count rows rpad rtrim savepoint schema scroll sec_to_time second section select serializable server session session_user set sha sha1 sha2 share show sign sin size slave sleep smalldatetimefromparts snapshot some soname soundex sounds_like space sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result sql_variant_property sqlstate sqrt square start starting status std stddev stddev_pop stddev_samp stdev stdevp stop str str_to_date straight_join strcmp string stuff subdate substr substring subtime subtring_index sum switchoffset sysdate sysdatetime sysdatetimeoffset system_user sysutcdatetime table tables tablespace tan temporary terminated tertiary_weights then time time_format time_to_sec timediff timefromparts timestamp timestampadd timestampdiff timezone_hour timezone_minute to to_base64 to_days to_seconds todatetimeoffset trailing transaction translation trigger trigger_nestlevel triggers trim truncate try_cast try_convert try_parse ucase uncompress uncompressed_length unhex unicode uninstall union unique unix_timestamp unknown unlock update upgrade upped upper usage use user user_resources using utc_date utc_time utc_timestamp uuid uuid_short validate_password_strength value values var var_pop var_samp variables variance varp version view warnings week weekday weekofyear weight_string when whenever where with work write xml xor year yearweek zon\",literal:\"true false null\",built_in:\"array bigint binary bit blob boolean char character date dec decimal float int integer interval number numeric real serial smallint varchar varying int8 serial8 text\"},c:[{cN:\"string\",b:\"'\",e:\"'\",c:[e.BE,{b:\"''\"}]},{cN:\"string\",b:'\"',e:'\"',c:[e.BE,{b:'\"\"'}]},{cN:\"string\",b:\"`\",e:\"`\",c:[e.BE]},e.CNM,e.CBCM,t]},e.CBCM,t]}});hljs.registerLanguage(\"nginx\",function(e){var r={cN:\"variable\",v:[{b:/\\$\\d+/},{b:/\\$\\{/,e:/}/},{b:\"[\\\\$\\\\@]\"+e.UIR}]},b={eW:!0,l:\"[a-z/_]+\",k:{built_in:\"on off yes no true false none blocked debug info notice warn error crit select break last permanent redirect kqueue rtsig epoll poll /dev/poll\"},r:0,i:\"=>\",c:[e.HCM,{cN:\"string\",c:[e.BE,r],v:[{b:/\"/,e:/\"/},{b:/'/,e:/'/}]},{cN:\"url\",b:\"([a-z]+):/\",e:\"\\\\s\",eW:!0,eE:!0,c:[r]},{cN:\"regexp\",c:[e.BE,r],v:[{b:\"\\\\s\\\\^\",e:\"\\\\s|{|;\",rE:!0},{b:\"~\\\\*?\\\\s+\",e:\"\\\\s|{|;\",rE:!0},{b:\"\\\\*(\\\\.[a-z\\\\-]+)+\"},{b:\"([a-z\\\\-]+\\\\.)+\\\\*\"}]},{cN:\"number\",b:\"\\\\b\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}(:\\\\d{1,5})?\\\\b\"},{cN:\"number\",b:\"\\\\b\\\\d+[kKmMgGdshdwy]*\\\\b\",r:0},r]};return{aliases:[\"nginxconf\"],c:[e.HCM,{b:e.UIR+\"\\\\s\",e:\";|{\",rB:!0,c:[{cN:\"title\",b:e.UIR,starts:b}],r:0}],i:\"[^\\\\s\\\\}]\"}});hljs.registerLanguage(\"xml\",function(){var t=\"[A-Za-z0-9\\\\._:-]+\",e={b:/<\\?(php)?(?!\\w)/,e:/\\?>/,sL:\"php\",subLanguageMode:\"continuous\"},c={eW:!0,i:/</,r:0,c:[e,{cN:\"attribute\",b:t,r:0},{b:\"=\",r:0,c:[{cN:\"value\",c:[e],v:[{b:/\"/,e:/\"/},{b:/'/,e:/'/},{b:/[^\\s\\/>]+/}]}]}]};return{aliases:[\"html\",\"xhtml\",\"rss\",\"atom\",\"xsl\",\"plist\"],cI:!0,c:[{cN:\"doctype\",b:\"<!DOCTYPE\",e:\">\",r:10,c:[{b:\"\\\\[\",e:\"\\\\]\"}]},{cN:\"comment\",b:\"<!--\",e:\"-->\",r:10},{cN:\"cdata\",b:\"<\\\\!\\\\[CDATA\\\\[\",e:\"\\\\]\\\\]>\",r:10},{cN:\"tag\",b:\"<style(?=\\\\s|>|$)\",e:\">\",k:{title:\"style\"},c:[c],starts:{e:\"</style>\",rE:!0,sL:\"css\"}},{cN:\"tag\",b:\"<script(?=\\\\s|>|$)\",e:\">\",k:{title:\"script\"},c:[c],starts:{e:\"</script>\",rE:!0,sL:\"javascript\"}},e,{cN:\"pi\",b:/<\\?\\w+/,e:/\\?>/,r:10},{cN:\"tag\",b:\"</?\",e:\"/?>\",c:[{cN:\"title\",b:/[^ \\/><\\n\\t]+/,r:0},c]}]}});hljs.registerLanguage(\"diff\",function(){return{aliases:[\"patch\"],c:[{cN:\"chunk\",r:10,v:[{b:/^\\@\\@ +\\-\\d+,\\d+ +\\+\\d+,\\d+ +\\@\\@$/},{b:/^\\*\\*\\* +\\d+,\\d+ +\\*\\*\\*\\*$/},{b:/^\\-\\-\\- +\\d+,\\d+ +\\-\\-\\-\\-$/}]},{cN:\"header\",v:[{b:/Index: /,e:/$/},{b:/=====/,e:/=====$/},{b:/^\\-\\-\\-/,e:/$/},{b:/^\\*{3} /,e:/$/},{b:/^\\+\\+\\+/,e:/$/},{b:/\\*{5}/,e:/\\*{5}$/}]},{cN:\"addition\",b:\"^\\\\+\",e:\"$\"},{cN:\"deletion\",b:\"^\\\\-\",e:\"$\"},{cN:\"change\",b:\"^\\\\!\",e:\"$\"}]}});hljs.registerLanguage(\"javascript\",function(r){return{aliases:[\"js\"],k:{keyword:\"in if for while finally var new function do return void else break catch instanceof with throw case default try this switch continue typeof delete let yield const class\",literal:\"true false null undefined NaN Infinity\",built_in:\"eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Error EvalError InternalError RangeError ReferenceError StopIteration SyntaxError TypeError URIError Number Math Date String RegExp Array Float32Array Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array Uint8Array Uint8ClampedArray ArrayBuffer DataView JSON Intl arguments require module console window document\"},c:[{cN:\"pi\",r:10,v:[{b:/^\\s*('|\")use strict('|\")/},{b:/^\\s*('|\")use asm('|\")/}]},r.ASM,r.QSM,r.CLCM,r.CBCM,r.CNM,{b:\"(\"+r.RSR+\"|\\\\b(case|return|throw)\\\\b)\\\\s*\",k:\"return throw case\",c:[r.CLCM,r.CBCM,r.RM,{b:/</,e:/>;/,r:0,sL:\"xml\"}],r:0},{cN:\"function\",bK:\"function\",e:/\\{/,eE:!0,c:[r.inherit(r.TM,{b:/[A-Za-z$_][0-9A-Za-z$_]*/}),{cN:\"params\",b:/\\(/,e:/\\)/,c:[r.CLCM,r.CBCM],i:/[\"'\\(]/}],i:/\\[|%/},{b:/\\$[(.]/},{b:\"\\\\.\"+r.IR,r:0}]}});hljs.registerLanguage(\"bash\",function(e){var t={cN:\"variable\",v:[{b:/\\$[\\w\\d#@][\\w\\d_]*/},{b:/\\$\\{(.*?)\\}/}]},s={cN:\"string\",b:/\"/,e:/\"/,c:[e.BE,t,{cN:\"variable\",b:/\\$\\(/,e:/\\)/,c:[e.BE]}]},a={cN:\"string\",b:/'/,e:/'/};return{aliases:[\"sh\",\"zsh\"],l:/-?[a-z\\.]+/,k:{keyword:\"if then else elif fi for while in do done case esac function\",literal:\"true false\",built_in:\"break cd continue eval exec exit export getopts hash pwd readonly return shift test times trap umask unset alias bind builtin caller command declare echo enable help let local logout mapfile printf read readarray source type typeset ulimit unalias set shopt autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate fc fg float functions getcap getln history integer jobs kill limit log noglob popd print pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof zpty zregexparse zsocket zstyle ztcp\",operator:\"-ne -eq -lt -gt -f -d -e -s -l -a\"},c:[{cN:\"shebang\",b:/^#![^\\n]+sh\\s*$/,r:10},{cN:\"function\",b:/\\w[\\w\\d_]*\\s*\\(\\s*\\)\\s*\\{/,rB:!0,c:[e.inherit(e.TM,{b:/\\w[\\w\\d_]*/})],r:0},e.HCM,e.NM,s,a,t]}});hljs.registerLanguage(\"objectivec\",function(e){var t={keyword:\"int float while char export sizeof typedef const struct for union unsigned long volatile static bool mutable if do return goto void enum else break extern asm case short default double register explicit signed typename this switch continue wchar_t inline readonly assign readwrite self @synchronized id typeof nonatomic super unichar IBOutlet IBAction strong weak copy in out inout bycopy byref oneway __strong __weak __block __autoreleasing @private @protected @public @try @property @end @throw @catch @finally @autoreleasepool @synthesize @dynamic @selector @optional @required\",literal:\"false true FALSE TRUE nil YES NO NULL\",built_in:\"NSString NSData NSDictionary CGRect CGPoint UIButton UILabel UITextView UIWebView MKMapView NSView NSViewController NSWindow NSWindowController NSSet NSUUID NSIndexSet UISegmentedControl NSObject UITableViewDelegate UITableViewDataSource NSThread UIActivityIndicator UITabbar UIToolBar UIBarButtonItem UIImageView NSAutoreleasePool UITableView BOOL NSInteger CGFloat NSException NSLog NSMutableString NSMutableArray NSMutableDictionary NSURL NSIndexPath CGSize UITableViewCell UIView UIViewController UINavigationBar UINavigationController UITabBarController UIPopoverController UIPopoverControllerDelegate UIImage NSNumber UISearchBar NSFetchedResultsController NSFetchedResultsChangeType UIScrollView UIScrollViewDelegate UIEdgeInsets UIColor UIFont UIApplication NSNotFound NSNotificationCenter NSNotification UILocalNotification NSBundle NSFileManager NSTimeInterval NSDate NSCalendar NSUserDefaults UIWindow NSRange NSArray NSError NSURLRequest NSURLConnection NSURLSession NSURLSessionDataTask NSURLSessionDownloadTask NSURLSessionUploadTask NSURLResponseUIInterfaceOrientation MPMoviePlayerController dispatch_once_t dispatch_queue_t dispatch_sync dispatch_async dispatch_once\"},o=/[a-zA-Z@][a-zA-Z0-9_]*/,a=\"@interface @class @protocol @implementation\";return{aliases:[\"m\",\"mm\",\"objc\",\"obj-c\"],k:t,l:o,i:\"</\",c:[e.CLCM,e.CBCM,e.CNM,e.QSM,{cN:\"string\",v:[{b:'@\"',e:'\"',i:\"\\\\n\",c:[e.BE]},{b:\"'\",e:\"[^\\\\\\\\]'\",i:\"[^\\\\\\\\][^']\"}]},{cN:\"preprocessor\",b:\"#\",e:\"$\",c:[{cN:\"title\",v:[{b:'\"',e:'\"'},{b:\"<\",e:\">\"}]}]},{cN:\"class\",b:\"(\"+a.split(\" \").join(\"|\")+\")\\\\b\",e:\"({|$)\",eE:!0,k:a,l:o,c:[e.UTM]},{cN:\"variable\",b:\"\\\\.\"+e.UIR,r:0}]}});hljs.registerLanguage(\"markdown\",function(){return{aliases:[\"md\",\"mkdown\",\"mkd\"],c:[{cN:\"header\",v:[{b:\"^#{1,6}\",e:\"$\"},{b:\"^.+?\\\\n[=-]{2,}$\"}]},{b:\"<\",e:\">\",sL:\"xml\",r:0},{cN:\"bullet\",b:\"^([*+-]|(\\\\d+\\\\.))\\\\s+\"},{cN:\"strong\",b:\"[*_]{2}.+?[*_]{2}\"},{cN:\"emphasis\",v:[{b:\"\\\\*.+?\\\\*\"},{b:\"_.+?_\",r:0}]},{cN:\"blockquote\",b:\"^>\\\\s+\",e:\"$\"},{cN:\"code\",v:[{b:\"`.+?`\"},{b:\"^( {4}|\t)\",e:\"$\",r:0}]},{cN:\"horizontal_rule\",b:\"^[-\\\\*]{3,}\",e:\"$\"},{b:\"\\\\[.+?\\\\][\\\\(\\\\[].*?[\\\\)\\\\]]\",rB:!0,c:[{cN:\"link_label\",b:\"\\\\[\",e:\"\\\\]\",eB:!0,rE:!0,r:0},{cN:\"link_url\",b:\"\\\\]\\\\(\",e:\"\\\\)\",eB:!0,eE:!0},{cN:\"link_reference\",b:\"\\\\]\\\\[\",e:\"\\\\]\",eB:!0,eE:!0}],r:10},{b:\"^\\\\[.+\\\\]:\",rB:!0,c:[{cN:\"link_reference\",b:\"\\\\[\",e:\"\\\\]:\",eB:!0,eE:!0,starts:{cN:\"link_url\",e:\"$\"}}]}]}});hljs.registerLanguage(\"json\",function(e){var t={literal:\"true false null\"},i=[e.QSM,e.CNM],l={cN:\"value\",e:\",\",eW:!0,eE:!0,c:i,k:t},c={b:\"{\",e:\"}\",c:[{cN:\"attribute\",b:'\\\\s*\"',e:'\"\\\\s*:\\\\s*',eB:!0,eE:!0,c:[e.BE],i:\"\\\\n\",starts:l}],i:\"\\\\S\"},n={b:\"\\\\[\",e:\"\\\\]\",c:[e.inherit(l,{cN:null})],i:\"\\\\S\"};return i.splice(i.length,0,c,n),{c:i,k:t,i:\"\\\\S\"}});hljs.registerLanguage(\"python\",function(e){var r={cN:\"prompt\",b:/^(>>>|\\.\\.\\.) /},b={cN:\"string\",c:[e.BE],v:[{b:/(u|b)?r?'''/,e:/'''/,c:[r],r:10},{b:/(u|b)?r?\"\"\"/,e:/\"\"\"/,c:[r],r:10},{b:/(u|r|ur)'/,e:/'/,r:10},{b:/(u|r|ur)\"/,e:/\"/,r:10},{b:/(b|br)'/,e:/'/},{b:/(b|br)\"/,e:/\"/},e.ASM,e.QSM]},l={cN:\"number\",r:0,v:[{b:e.BNR+\"[lLjJ]?\"},{b:\"\\\\b(0o[0-7]+)[lLjJ]?\"},{b:e.CNR+\"[lLjJ]?\"}]},c={cN:\"params\",b:/\\(/,e:/\\)/,c:[\"self\",r,l,b]};return{aliases:[\"py\",\"gyp\"],k:{keyword:\"and elif is global as in if from raise for except finally print import pass return exec else break not with class assert yield try while continue del or def lambda nonlocal|10 None True False\",built_in:\"Ellipsis NotImplemented\"},i:/(<\\/|->|\\?)/,c:[r,l,b,e.HCM,{v:[{cN:\"function\",bK:\"def\",r:10},{cN:\"class\",bK:\"class\"}],e:/:/,i:/[${=;\\n]/,c:[e.UTM,c]},{cN:\"decorator\",b:/@/,e:/$/},{b:/\\b(print|exec)\\(/}]}});hljs.registerLanguage(\"ruby\",function(e){var b=\"[a-zA-Z_]\\\\w*[!?=]?|[-+~]\\\\@|<<|>>|=~|===?|<=>|[<>]=?|\\\\*\\\\*|[-/+%^&*~`|]|\\\\[\\\\]=?\",r=\"and false then defined module in return redo if BEGIN retry end for true self when next until do begin unless END rescue nil else break undef not super class case require yield alias while ensure elsif or include attr_reader attr_writer attr_accessor\",c={cN:\"yardoctag\",b:\"@[A-Za-z]+\"},a={cN:\"value\",b:\"#<\",e:\">\"},s={cN:\"comment\",v:[{b:\"#\",e:\"$\",c:[c]},{b:\"^\\\\=begin\",e:\"^\\\\=end\",c:[c],r:10},{b:\"^__END__\",e:\"\\\\n$\"}]},n={cN:\"subst\",b:\"#\\\\{\",e:\"}\",k:r},t={cN:\"string\",c:[e.BE,n],v:[{b:/'/,e:/'/},{b:/\"/,e:/\"/},{b:/`/,e:/`/},{b:\"%[qQwWx]?\\\\(\",e:\"\\\\)\"},{b:\"%[qQwWx]?\\\\[\",e:\"\\\\]\"},{b:\"%[qQwWx]?{\",e:\"}\"},{b:\"%[qQwWx]?<\",e:\">\"},{b:\"%[qQwWx]?/\",e:\"/\"},{b:\"%[qQwWx]?%\",e:\"%\"},{b:\"%[qQwWx]?-\",e:\"-\"},{b:\"%[qQwWx]?\\\\|\",e:\"\\\\|\"},{b:/\\B\\?(\\\\\\d{1,3}|\\\\x[A-Fa-f0-9]{1,2}|\\\\u[A-Fa-f0-9]{4}|\\\\?\\S)\\b/}]},i={cN:\"params\",b:\"\\\\(\",e:\"\\\\)\",k:r},d=[t,a,s,{cN:\"class\",bK:\"class module\",e:\"$|;\",i:/=/,c:[e.inherit(e.TM,{b:\"[A-Za-z_]\\\\w*(::\\\\w+)*(\\\\?|\\\\!)?\"}),{cN:\"inheritance\",b:\"<\\\\s*\",c:[{cN:\"parent\",b:\"(\"+e.IR+\"::)?\"+e.IR}]},s]},{cN:\"function\",bK:\"def\",e:\" |$|;\",r:0,c:[e.inherit(e.TM,{b:b}),i,s]},{cN:\"constant\",b:\"(::)?(\\\\b[A-Z]\\\\w*(::)?)+\",r:0},{cN:\"symbol\",b:e.UIR+\"(\\\\!|\\\\?)?:\",r:0},{cN:\"symbol\",b:\":\",c:[t,{b:b}],r:0},{cN:\"number\",b:\"(\\\\b0[0-7_]+)|(\\\\b0x[0-9a-fA-F_]+)|(\\\\b[1-9][0-9_]*(\\\\.[0-9_]+)?)|[0_]\\\\b\",r:0},{cN:\"variable\",b:\"(\\\\$\\\\W)|((\\\\$|\\\\@\\\\@?)(\\\\w+))\"},{b:\"(\"+e.RSR+\")\\\\s*\",c:[a,s,{cN:\"regexp\",c:[e.BE,n],i:/\\n/,v:[{b:\"/\",e:\"/[a-z]*\"},{b:\"%r{\",e:\"}[a-z]*\"},{b:\"%r\\\\(\",e:\"\\\\)[a-z]*\"},{b:\"%r!\",e:\"![a-z]*\"},{b:\"%r\\\\[\",e:\"\\\\][a-z]*\"}]}],r:0}];n.c=d,i.c=d;var l=\"[>?]>\",u=\"[\\\\w#]+\\\\(\\\\w+\\\\):\\\\d+:\\\\d+>\",N=\"(\\\\w+-)?\\\\d+\\\\.\\\\d+\\\\.\\\\d(p\\\\d+)?[^>]+>\",o=[{b:/^\\s*=>/,cN:\"status\",starts:{e:\"$\",c:d}},{cN:\"prompt\",b:\"^(\"+l+\"|\"+u+\"|\"+N+\")\",starts:{e:\"$\",c:d}}];return{aliases:[\"rb\",\"gemspec\",\"podspec\",\"thor\",\"irb\"],k:r,c:[s].concat(o).concat(d)}});hljs.registerLanguage(\"cpp\",function(t){var i={keyword:\"false int float while private char catch export virtual operator sizeof dynamic_cast|10 typedef const_cast|10 const struct for static_cast|10 union namespace unsigned long volatile static protected bool template mutable if public friend do goto auto void enum else break extern using true class asm case typeid short reinterpret_cast|10 default double register explicit signed typename try this switch continue wchar_t inline delete alignof char16_t char32_t constexpr decltype noexcept nullptr static_assert thread_local restrict _Bool complex _Complex _Imaginaryintmax_t uintmax_t int8_t uint8_t int16_t uint16_t int32_t uint32_t  int64_t uint64_tint_least8_t uint_least8_t int_least16_t uint_least16_t int_least32_t uint_least32_tint_least64_t uint_least64_t int_fast8_t uint_fast8_t int_fast16_t uint_fast16_t int_fast32_tuint_fast32_t int_fast64_t uint_fast64_t intptr_t uintptr_t atomic_bool atomic_char atomic_scharatomic_uchar atomic_short atomic_ushort atomic_int atomic_uint atomic_long atomic_ulong atomic_llongatomic_ullong atomic_wchar_t atomic_char16_t atomic_char32_t atomic_intmax_t atomic_uintmax_tatomic_intptr_t atomic_uintptr_t atomic_size_t atomic_ptrdiff_t atomic_int_least8_t atomic_int_least16_tatomic_int_least32_t atomic_int_least64_t atomic_uint_least8_t atomic_uint_least16_t atomic_uint_least32_tatomic_uint_least64_t atomic_int_fast8_t atomic_int_fast16_t atomic_int_fast32_t atomic_int_fast64_tatomic_uint_fast8_t atomic_uint_fast16_t atomic_uint_fast32_t atomic_uint_fast64_t\",built_in:\"std string cin cout cerr clog stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap array shared_ptr abort abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf\"};return{aliases:[\"c\",\"h\",\"c++\",\"h++\"],k:i,i:\"</\",c:[t.CLCM,t.CBCM,t.QSM,{cN:\"string\",b:\"'\\\\\\\\?.\",e:\"'\",i:\".\"},{cN:\"number\",b:\"\\\\b(\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)(u|U|l|L|ul|UL|f|F)\"},t.CNM,{cN:\"preprocessor\",b:\"#\",e:\"$\",k:\"if else elif endif define undef warning error line pragma\",c:[{b:'include\\\\s*[<\"]',e:'[>\"]',k:\"include\",i:\"\\\\n\"},t.CLCM]},{cN:\"stl_container\",b:\"\\\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\\\s*<\",e:\">\",k:i,c:[\"self\"]},{b:t.IR+\"::\"},{bK:\"new throw return\",r:0},{cN:\"function\",b:\"(\"+t.IR+\"\\\\s+)+\"+t.IR+\"\\\\s*\\\\(\",rB:!0,e:/[{;=]/,eE:!0,k:i,c:[{b:t.IR+\"\\\\s*\\\\(\",rB:!0,c:[t.TM],r:0},{cN:\"params\",b:/\\(/,e:/\\)/,k:i,r:0,c:[t.CBCM]},t.CLCM,t.CBCM]}]}});hljs.registerLanguage(\"css\",function(e){var c=\"[a-zA-Z-][a-zA-Z0-9_-]*\",a={cN:\"function\",b:c+\"\\\\(\",rB:!0,eE:!0,e:\"\\\\(\"};return{cI:!0,i:\"[=/|']\",c:[e.CBCM,{cN:\"id\",b:\"\\\\#[A-Za-z0-9_-]+\"},{cN:\"class\",b:\"\\\\.[A-Za-z0-9_-]+\",r:0},{cN:\"attr_selector\",b:\"\\\\[\",e:\"\\\\]\",i:\"$\"},{cN:\"pseudo\",b:\":(:)?[a-zA-Z0-9\\\\_\\\\-\\\\+\\\\(\\\\)\\\\\\\"\\\\']+\"},{cN:\"at_rule\",b:\"@(font-face|page)\",l:\"[a-z-]+\",k:\"font-face page\"},{cN:\"at_rule\",b:\"@\",e:\"[{;]\",c:[{cN:\"keyword\",b:/\\S+/},{b:/\\s/,eW:!0,eE:!0,r:0,c:[a,e.ASM,e.QSM,e.CSSNM]}]},{cN:\"tag\",b:c,r:0},{cN:\"rules\",b:\"{\",e:\"}\",i:\"[^\\\\s]\",r:0,c:[e.CBCM,{cN:\"rule\",b:\"[^\\\\s]\",rB:!0,e:\";\",eW:!0,c:[{cN:\"attribute\",b:\"[A-Z\\\\_\\\\.\\\\-]+\",e:\":\",eE:!0,i:\"[^\\\\s]\",starts:{cN:\"value\",eW:!0,eE:!0,c:[a,e.CSSNM,e.QSM,e.ASM,e.CBCM,{cN:\"hexcolor\",b:\"#[0-9A-Fa-f]+\"},{cN:\"important\",b:\"!important\"}]}}]}]}]}});hljs.registerLanguage(\"php\",function(e){var c={cN:\"variable\",b:\"\\\\$+[a-zA-Z_-][a-zA-Z0-9_-]*\"},i={cN:\"preprocessor\",b:/<\\?(php)?|\\?>/},a={cN:\"string\",c:[e.BE,i],v:[{b:'b\"',e:'\"'},{b:\"b'\",e:\"'\"},e.inherit(e.ASM,{i:null}),e.inherit(e.QSM,{i:null})]},n={v:[e.BNM,e.CNM]};return{aliases:[\"php3\",\"php4\",\"php5\",\"php6\"],cI:!0,k:\"and include_once list abstract global private echo interface as static endswitch array null if endwhile or const for endforeach self var while isset public protected exit foreach throw elseif include __FILE__ empty require_once do xor return parent clone use __CLASS__ __LINE__ else break print eval new catch __METHOD__ case exception default die require __FUNCTION__ enddeclare final try switch continue endfor endif declare unset true false trait goto instanceof insteadof __DIR__ __NAMESPACE__ yield finally\",c:[e.CLCM,e.HCM,{cN:\"comment\",b:\"/\\\\*\",e:\"\\\\*/\",c:[{cN:\"phpdoc\",b:\"\\\\s@[A-Za-z]+\"},i]},{cN:\"comment\",b:\"__halt_compiler.+?;\",eW:!0,k:\"__halt_compiler\",l:e.UIR},{cN:\"string\",b:\"<<<['\\\"]?\\\\w+['\\\"]?$\",e:\"^\\\\w+;\",c:[e.BE]},i,c,{b:/->+[a-zA-Z_\\x7f-\\xff][a-zA-Z0-9_\\x7f-\\xff]*/},{cN:\"function\",bK:\"function\",e:/[;{]/,eE:!0,i:\"\\\\$|\\\\[|%\",c:[e.UTM,{cN:\"params\",b:\"\\\\(\",e:\"\\\\)\",c:[\"self\",c,e.CBCM,a,n]}]},{cN:\"class\",bK:\"class interface\",e:\"{\",eE:!0,i:/[:\\(\\$\"]/,c:[{bK:\"extends implements\"},e.UTM]},{bK:\"namespace\",e:\";\",i:/[\\.']/,c:[e.UTM]},{bK:\"use\",e:\";\",c:[e.UTM]},{b:\"=>\"},a,n]}});hljs.registerLanguage(\"perl\",function(e){var t=\"getpwent getservent quotemeta msgrcv scalar kill dbmclose undef lc ma syswrite tr send umask sysopen shmwrite vec qx utime local oct semctl localtime readpipe do return format read sprintf dbmopen pop getpgrp not getpwnam rewinddir qqfileno qw endprotoent wait sethostent bless s|0 opendir continue each sleep endgrent shutdown dump chomp connect getsockname die socketpair close flock exists index shmgetsub for endpwent redo lstat msgctl setpgrp abs exit select print ref gethostbyaddr unshift fcntl syscall goto getnetbyaddr join gmtime symlink semget splice x|0 getpeername recv log setsockopt cos last reverse gethostbyname getgrnam study formline endhostent times chop length gethostent getnetent pack getprotoent getservbyname rand mkdir pos chmod y|0 substr endnetent printf next open msgsnd readdir use unlink getsockopt getpriority rindex wantarray hex system getservbyport endservent int chr untie rmdir prototype tell listen fork shmread ucfirst setprotoent else sysseek link getgrgid shmctl waitpid unpack getnetbyname reset chdir grep split require caller lcfirst until warn while values shift telldir getpwuid my getprotobynumber delete and sort uc defined srand accept package seekdir getprotobyname semop our rename seek if q|0 chroot sysread setpwent no crypt getc chown sqrt write setnetent setpriority foreach tie sin msgget map stat getlogin unless elsif truncate exec keys glob tied closedirioctl socket readlink eval xor readline binmode setservent eof ord bind alarm pipe atan2 getgrent exp time push setgrent gt lt or ne m|0 break given say state when\",r={cN:\"subst\",b:\"[$@]\\\\{\",e:\"\\\\}\",k:t},s={b:\"->{\",e:\"}\"},n={cN:\"variable\",v:[{b:/\\$\\d/},{b:/[\\$\\%\\@](\\^\\w\\b|#\\w+(\\:\\:\\w+)*|{\\w+}|\\w+(\\:\\:\\w*)*)/},{b:/[\\$\\%\\@][^\\s\\w{]/,r:0}]},o={cN:\"comment\",b:\"^(__END__|__DATA__)\",e:\"\\\\n$\",r:5},i=[e.BE,r,n],c=[n,e.HCM,o,{cN:\"comment\",b:\"^\\\\=\\\\w\",e:\"\\\\=cut\",eW:!0},s,{cN:\"string\",c:i,v:[{b:\"q[qwxr]?\\\\s*\\\\(\",e:\"\\\\)\",r:5},{b:\"q[qwxr]?\\\\s*\\\\[\",e:\"\\\\]\",r:5},{b:\"q[qwxr]?\\\\s*\\\\{\",e:\"\\\\}\",r:5},{b:\"q[qwxr]?\\\\s*\\\\|\",e:\"\\\\|\",r:5},{b:\"q[qwxr]?\\\\s*\\\\<\",e:\"\\\\>\",r:5},{b:\"qw\\\\s+q\",e:\"q\",r:5},{b:\"'\",e:\"'\",c:[e.BE]},{b:'\"',e:'\"'},{b:\"`\",e:\"`\",c:[e.BE]},{b:\"{\\\\w+}\",c:[],r:0},{b:\"-?\\\\w+\\\\s*\\\\=\\\\>\",c:[],r:0}]},{cN:\"number\",b:\"(\\\\b0[0-7_]+)|(\\\\b0x[0-9a-fA-F_]+)|(\\\\b[1-9][0-9_]*(\\\\.[0-9_]+)?)|[0_]\\\\b\",r:0},{b:\"(\\\\/\\\\/|\"+e.RSR+\"|\\\\b(split|return|print|reverse|grep)\\\\b)\\\\s*\",k:\"split return print reverse grep\",r:0,c:[e.HCM,o,{cN:\"regexp\",b:\"(s|tr|y)/(\\\\\\\\.|[^/])*/(\\\\\\\\.|[^/])*/[a-z]*\",r:10},{cN:\"regexp\",b:\"(m|qr)?/\",e:\"/[a-z]*\",c:[e.BE],r:0}]},{cN:\"sub\",bK:\"sub\",e:\"(\\\\s*\\\\(.*?\\\\))?[;{]\",r:5},{cN:\"operator\",b:\"-\\\\w\\\\b\",r:0}];return r.c=c,s.c=c,{aliases:[\"pl\"],k:t,c:c}});hljs.registerLanguage(\"ini\",function(e){return{cI:!0,i:/\\S/,c:[{cN:\"comment\",b:\";\",e:\"$\"},{cN:\"title\",b:\"^\\\\[\",e:\"\\\\]\"},{cN:\"setting\",b:\"^[a-z0-9\\\\[\\\\]_-]+[ \\\\t]*=[ \\\\t]*\",e:\"$\",c:[{cN:\"value\",eW:!0,k:\"on off true false yes no\",c:[e.QSM,e.NM],r:0}]}]}});hljs.registerLanguage(\"makefile\",function(e){var a={cN:\"variable\",b:/\\$\\(/,e:/\\)/,c:[e.BE]};return{aliases:[\"mk\",\"mak\"],c:[e.HCM,{b:/^\\w+\\s*\\W*=/,rB:!0,r:0,starts:{cN:\"constant\",e:/\\s*\\W*=/,eE:!0,starts:{e:/$/,r:0,c:[a]}}},{cN:\"title\",b:/^[\\w]+:\\s*$/},{cN:\"phony\",b:/^\\.PHONY:/,e:/$/,k:\".PHONY\",l:/[\\.\\w]+/},{b:/^\\t+/,e:/$/,r:0,c:[e.QSM,a]}]}});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvaGlnaGxpZ2h0LnBhY2suanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvaGlnaGxpZ2h0LnBhY2suanM/NjhmNCJdLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGV4cG9ydHM/ZShleHBvcnRzKTood2luZG93LmhsanM9ZSh7fSksXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kJiZkZWZpbmUoW10sZnVuY3Rpb24oKXtyZXR1cm4gd2luZG93LmhsanN9KSl9KGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIG4oZSl7cmV0dXJuIGUucmVwbGFjZSgvJi9nbSxcIiZhbXA7XCIpLnJlcGxhY2UoLzwvZ20sXCImbHQ7XCIpLnJlcGxhY2UoLz4vZ20sXCImZ3Q7XCIpfWZ1bmN0aW9uIHQoZSl7cmV0dXJuIGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKX1mdW5jdGlvbiByKGUsbil7dmFyIHQ9ZSYmZS5leGVjKG4pO3JldHVybiB0JiYwPT10LmluZGV4fWZ1bmN0aW9uIGEoZSl7dmFyIG49KGUuY2xhc3NOYW1lK1wiIFwiKyhlLnBhcmVudE5vZGU/ZS5wYXJlbnROb2RlLmNsYXNzTmFtZTpcIlwiKSkuc3BsaXQoL1xccysvKTtyZXR1cm4gbj1uLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5yZXBsYWNlKC9ebGFuZyh1YWdlKT8tLyxcIlwiKX0pLG4uZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBOKGUpfHwvbm8oLT8paGlnaGxpZ2h0Ly50ZXN0KGUpfSlbMF19ZnVuY3Rpb24gbyhlLG4pe3ZhciB0PXt9O2Zvcih2YXIgciBpbiBlKXRbcl09ZVtyXTtpZihuKWZvcih2YXIgciBpbiBuKXRbcl09bltyXTtyZXR1cm4gdH1mdW5jdGlvbiBpKGUpe3ZhciBuPVtdO3JldHVybiBmdW5jdGlvbiByKGUsYSl7Zm9yKHZhciBvPWUuZmlyc3RDaGlsZDtvO289by5uZXh0U2libGluZykzPT1vLm5vZGVUeXBlP2ErPW8ubm9kZVZhbHVlLmxlbmd0aDoxPT1vLm5vZGVUeXBlJiYobi5wdXNoKHtldmVudDpcInN0YXJ0XCIsb2Zmc2V0OmEsbm9kZTpvfSksYT1yKG8sYSksdChvKS5tYXRjaCgvYnJ8aHJ8aW1nfGlucHV0Lyl8fG4ucHVzaCh7ZXZlbnQ6XCJzdG9wXCIsb2Zmc2V0OmEsbm9kZTpvfSkpO3JldHVybiBhfShlLDApLG59ZnVuY3Rpb24gYyhlLHIsYSl7ZnVuY3Rpb24gbygpe3JldHVybiBlLmxlbmd0aCYmci5sZW5ndGg/ZVswXS5vZmZzZXQhPXJbMF0ub2Zmc2V0P2VbMF0ub2Zmc2V0PHJbMF0ub2Zmc2V0P2U6cjpcInN0YXJ0XCI9PXJbMF0uZXZlbnQ/ZTpyOmUubGVuZ3RoP2U6cn1mdW5jdGlvbiBpKGUpe2Z1bmN0aW9uIHIoZSl7cmV0dXJuXCIgXCIrZS5ub2RlTmFtZSsnPVwiJytuKGUudmFsdWUpKydcIid9bCs9XCI8XCIrdChlKStBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoZS5hdHRyaWJ1dGVzLHIpLmpvaW4oXCJcIikrXCI+XCJ9ZnVuY3Rpb24gYyhlKXtsKz1cIjwvXCIrdChlKStcIj5cIn1mdW5jdGlvbiB1KGUpeyhcInN0YXJ0XCI9PWUuZXZlbnQ/aTpjKShlLm5vZGUpfWZvcih2YXIgcz0wLGw9XCJcIixmPVtdO2UubGVuZ3RofHxyLmxlbmd0aDspe3ZhciBnPW8oKTtpZihsKz1uKGEuc3Vic3RyKHMsZ1swXS5vZmZzZXQtcykpLHM9Z1swXS5vZmZzZXQsZz09ZSl7Zi5yZXZlcnNlKCkuZm9yRWFjaChjKTtkbyB1KGcuc3BsaWNlKDAsMSlbMF0pLGc9bygpO3doaWxlKGc9PWUmJmcubGVuZ3RoJiZnWzBdLm9mZnNldD09cyk7Zi5yZXZlcnNlKCkuZm9yRWFjaChpKX1lbHNlXCJzdGFydFwiPT1nWzBdLmV2ZW50P2YucHVzaChnWzBdLm5vZGUpOmYucG9wKCksdShnLnNwbGljZSgwLDEpWzBdKX1yZXR1cm4gbCtuKGEuc3Vic3RyKHMpKX1mdW5jdGlvbiB1KGUpe2Z1bmN0aW9uIG4oZSl7cmV0dXJuIGUmJmUuc291cmNlfHxlfWZ1bmN0aW9uIHQodCxyKXtyZXR1cm4gUmVnRXhwKG4odCksXCJtXCIrKGUuY0k/XCJpXCI6XCJcIikrKHI/XCJnXCI6XCJcIikpfWZ1bmN0aW9uIHIoYSxpKXtpZighYS5jb21waWxlZCl7aWYoYS5jb21waWxlZD0hMCxhLms9YS5rfHxhLmJLLGEuayl7dmFyIGM9e30sdT1mdW5jdGlvbihuLHQpe2UuY0kmJih0PXQudG9Mb3dlckNhc2UoKSksdC5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1lLnNwbGl0KFwifFwiKTtjW3RbMF1dPVtuLHRbMV0/TnVtYmVyKHRbMV0pOjFdfSl9O1wic3RyaW5nXCI9PXR5cGVvZiBhLms/dShcImtleXdvcmRcIixhLmspOk9iamVjdC5rZXlzKGEuaykuZm9yRWFjaChmdW5jdGlvbihlKXt1KGUsYS5rW2VdKX0pLGEuaz1jfWEubFI9dChhLmx8fC9cXGJbQS1aYS16MC05X10rXFxiLywhMCksaSYmKGEuYksmJihhLmI9XCJcXFxcYihcIithLmJLLnNwbGl0KFwiIFwiKS5qb2luKFwifFwiKStcIilcXFxcYlwiKSxhLmJ8fChhLmI9L1xcQnxcXGIvKSxhLmJSPXQoYS5iKSxhLmV8fGEuZVd8fChhLmU9L1xcQnxcXGIvKSxhLmUmJihhLmVSPXQoYS5lKSksYS50RT1uKGEuZSl8fFwiXCIsYS5lVyYmaS50RSYmKGEudEUrPShhLmU/XCJ8XCI6XCJcIikraS50RSkpLGEuaSYmKGEuaVI9dChhLmkpKSx2b2lkIDA9PT1hLnImJihhLnI9MSksYS5jfHwoYS5jPVtdKTt2YXIgcz1bXTthLmMuZm9yRWFjaChmdW5jdGlvbihlKXtlLnY/ZS52LmZvckVhY2goZnVuY3Rpb24obil7cy5wdXNoKG8oZSxuKSl9KTpzLnB1c2goXCJzZWxmXCI9PWU/YTplKX0pLGEuYz1zLGEuYy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3IoZSxhKX0pLGEuc3RhcnRzJiZyKGEuc3RhcnRzLGkpO3ZhciBsPWEuYy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuYks/XCJcXFxcLj8oXCIrZS5iK1wiKVxcXFwuP1wiOmUuYn0pLmNvbmNhdChbYS50RSxhLmldKS5tYXAobikuZmlsdGVyKEJvb2xlYW4pO2EudD1sLmxlbmd0aD90KGwuam9pbihcInxcIiksITApOntleGVjOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9fX19cihlKX1mdW5jdGlvbiBzKGUsdCxhLG8pe2Z1bmN0aW9uIGkoZSxuKXtmb3IodmFyIHQ9MDt0PG4uYy5sZW5ndGg7dCsrKWlmKHIobi5jW3RdLmJSLGUpKXJldHVybiBuLmNbdF19ZnVuY3Rpb24gYyhlLG4pe3JldHVybiByKGUuZVIsbik/ZTplLmVXP2MoZS5wYXJlbnQsbik6dm9pZCAwfWZ1bmN0aW9uIGYoZSxuKXtyZXR1cm4hYSYmcihuLmlSLGUpfWZ1bmN0aW9uIGcoZSxuKXt2YXIgdD14LmNJP25bMF0udG9Mb3dlckNhc2UoKTpuWzBdO3JldHVybiBlLmsuaGFzT3duUHJvcGVydHkodCkmJmUua1t0XX1mdW5jdGlvbiBwKGUsbix0LHIpe3ZhciBhPXI/XCJcIjpFLmNsYXNzUHJlZml4LG89JzxzcGFuIGNsYXNzPVwiJythLGk9dD9cIlwiOlwiPC9zcGFuPlwiO3JldHVybiBvKz1lKydcIj4nLG8rbitpfWZ1bmN0aW9uIGQoKXtpZighdy5rKXJldHVybiBuKHkpO3ZhciBlPVwiXCIsdD0wO3cubFIubGFzdEluZGV4PTA7Zm9yKHZhciByPXcubFIuZXhlYyh5KTtyOyl7ZSs9bih5LnN1YnN0cih0LHIuaW5kZXgtdCkpO3ZhciBhPWcodyxyKTthPyhCKz1hWzFdLGUrPXAoYVswXSxuKHJbMF0pKSk6ZSs9bihyWzBdKSx0PXcubFIubGFzdEluZGV4LHI9dy5sUi5leGVjKHkpfXJldHVybiBlK24oeS5zdWJzdHIodCkpfWZ1bmN0aW9uIGgoKXtpZih3LnNMJiYhUlt3LnNMXSlyZXR1cm4gbih5KTt2YXIgZT13LnNMP3Mody5zTCx5LCEwLExbdy5zTF0pOmwoeSk7cmV0dXJuIHcucj4wJiYoQis9ZS5yKSxcImNvbnRpbnVvdXNcIj09dy5zdWJMYW5ndWFnZU1vZGUmJihMW3cuc0xdPWUudG9wKSxwKGUubGFuZ3VhZ2UsZS52YWx1ZSwhMSwhMCl9ZnVuY3Rpb24gdigpe3JldHVybiB2b2lkIDAhPT13LnNMP2goKTpkKCl9ZnVuY3Rpb24gYihlLHQpe3ZhciByPWUuY04/cChlLmNOLFwiXCIsITApOlwiXCI7ZS5yQj8oTSs9cix5PVwiXCIpOmUuZUI/KE0rPW4odCkrcix5PVwiXCIpOihNKz1yLHk9dCksdz1PYmplY3QuY3JlYXRlKGUse3BhcmVudDp7dmFsdWU6d319KX1mdW5jdGlvbiBtKGUsdCl7aWYoeSs9ZSx2b2lkIDA9PT10KXJldHVybiBNKz12KCksMDt2YXIgcj1pKHQsdyk7aWYocilyZXR1cm4gTSs9digpLGIocix0KSxyLnJCPzA6dC5sZW5ndGg7dmFyIGE9Yyh3LHQpO2lmKGEpe3ZhciBvPXc7by5yRXx8by5lRXx8KHkrPXQpLE0rPXYoKTtkbyB3LmNOJiYoTSs9XCI8L3NwYW4+XCIpLEIrPXcucix3PXcucGFyZW50O3doaWxlKHchPWEucGFyZW50KTtyZXR1cm4gby5lRSYmKE0rPW4odCkpLHk9XCJcIixhLnN0YXJ0cyYmYihhLnN0YXJ0cyxcIlwiKSxvLnJFPzA6dC5sZW5ndGh9aWYoZih0LHcpKXRocm93IG5ldyBFcnJvcignSWxsZWdhbCBsZXhlbWUgXCInK3QrJ1wiIGZvciBtb2RlIFwiJysody5jTnx8XCI8dW5uYW1lZD5cIikrJ1wiJyk7cmV0dXJuIHkrPXQsdC5sZW5ndGh8fDF9dmFyIHg9TihlKTtpZigheCl0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGFuZ3VhZ2U6IFwiJytlKydcIicpO3UoeCk7Zm9yKHZhciB3PW98fHgsTD17fSxNPVwiXCIsaz13O2shPXg7az1rLnBhcmVudClrLmNOJiYoTT1wKGsuY04sXCJcIiwhMCkrTSk7dmFyIHk9XCJcIixCPTA7dHJ5e2Zvcih2YXIgQyxqLEk9MDs7KXtpZih3LnQubGFzdEluZGV4PUksQz13LnQuZXhlYyh0KSwhQylicmVhaztqPW0odC5zdWJzdHIoSSxDLmluZGV4LUkpLENbMF0pLEk9Qy5pbmRleCtqfW0odC5zdWJzdHIoSSkpO2Zvcih2YXIgaz13O2sucGFyZW50O2s9ay5wYXJlbnQpay5jTiYmKE0rPVwiPC9zcGFuPlwiKTtyZXR1cm57cjpCLHZhbHVlOk0sbGFuZ3VhZ2U6ZSx0b3A6d319Y2F0Y2goQSl7aWYoLTEhPUEubWVzc2FnZS5pbmRleE9mKFwiSWxsZWdhbFwiKSlyZXR1cm57cjowLHZhbHVlOm4odCl9O3Rocm93IEF9fWZ1bmN0aW9uIGwoZSx0KXt0PXR8fEUubGFuZ3VhZ2VzfHxPYmplY3Qua2V5cyhSKTt2YXIgcj17cjowLHZhbHVlOm4oZSl9LGE9cjtyZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uKG4pe2lmKE4obikpe3ZhciB0PXMobixlLCExKTt0Lmxhbmd1YWdlPW4sdC5yPmEuciYmKGE9dCksdC5yPnIuciYmKGE9cixyPXQpfX0pLGEubGFuZ3VhZ2UmJihyLnNlY29uZF9iZXN0PWEpLHJ9ZnVuY3Rpb24gZihlKXtyZXR1cm4gRS50YWJSZXBsYWNlJiYoZT1lLnJlcGxhY2UoL14oKDxbXj5dKz58XFx0KSspL2dtLGZ1bmN0aW9uKGUsbil7cmV0dXJuIG4ucmVwbGFjZSgvXFx0L2csRS50YWJSZXBsYWNlKX0pKSxFLnVzZUJSJiYoZT1lLnJlcGxhY2UoL1xcbi9nLFwiPGJyPlwiKSksZX1mdW5jdGlvbiBnKGUsbix0KXt2YXIgcj1uP3hbbl06dCxhPVtlLnRyaW0oKV07cmV0dXJuIGUubWF0Y2goLyhcXHN8XilobGpzKFxcc3wkKS8pfHxhLnB1c2goXCJobGpzXCIpLHImJmEucHVzaChyKSxhLmpvaW4oXCIgXCIpLnRyaW0oKX1mdW5jdGlvbiBwKGUpe3ZhciBuPWEoZSk7aWYoIS9ubygtPyloaWdobGlnaHQvLnRlc3Qobikpe3ZhciB0O0UudXNlQlI/KHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLFwiZGl2XCIpLHQuaW5uZXJIVE1MPWUuaW5uZXJIVE1MLnJlcGxhY2UoL1xcbi9nLFwiXCIpLnJlcGxhY2UoLzxiclsgXFwvXSo+L2csXCJcXG5cIikpOnQ9ZTt2YXIgcj10LnRleHRDb250ZW50LG89bj9zKG4sciwhMCk6bChyKSx1PWkodCk7aWYodS5sZW5ndGgpe3ZhciBwPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIixcImRpdlwiKTtwLmlubmVySFRNTD1vLnZhbHVlLG8udmFsdWU9Yyh1LGkocCkscil9by52YWx1ZT1mKG8udmFsdWUpLGUuaW5uZXJIVE1MPW8udmFsdWUsZS5jbGFzc05hbWU9ZyhlLmNsYXNzTmFtZSxuLG8ubGFuZ3VhZ2UpLGUucmVzdWx0PXtsYW5ndWFnZTpvLmxhbmd1YWdlLHJlOm8ucn0sby5zZWNvbmRfYmVzdCYmKGUuc2Vjb25kX2Jlc3Q9e2xhbmd1YWdlOm8uc2Vjb25kX2Jlc3QubGFuZ3VhZ2UscmU6by5zZWNvbmRfYmVzdC5yfSl9fWZ1bmN0aW9uIGQoZSl7RT1vKEUsZSl9ZnVuY3Rpb24gaCgpe2lmKCFoLmNhbGxlZCl7aC5jYWxsZWQ9ITA7dmFyIGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcInByZSBjb2RlXCIpO0FycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZSxwKX19ZnVuY3Rpb24gdigpe2FkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsaCwhMSksYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixoLCExKX1mdW5jdGlvbiBiKG4sdCl7dmFyIHI9UltuXT10KGUpO3IuYWxpYXNlcyYmci5hbGlhc2VzLmZvckVhY2goZnVuY3Rpb24oZSl7eFtlXT1ufSl9ZnVuY3Rpb24gbSgpe3JldHVybiBPYmplY3Qua2V5cyhSKX1mdW5jdGlvbiBOKGUpe3JldHVybiBSW2VdfHxSW3hbZV1dfXZhciBFPXtjbGFzc1ByZWZpeDpcImhsanMtXCIsdGFiUmVwbGFjZTpudWxsLHVzZUJSOiExLGxhbmd1YWdlczp2b2lkIDB9LFI9e30seD17fTtyZXR1cm4gZS5oaWdobGlnaHQ9cyxlLmhpZ2hsaWdodEF1dG89bCxlLmZpeE1hcmt1cD1mLGUuaGlnaGxpZ2h0QmxvY2s9cCxlLmNvbmZpZ3VyZT1kLGUuaW5pdEhpZ2hsaWdodGluZz1oLGUuaW5pdEhpZ2hsaWdodGluZ09uTG9hZD12LGUucmVnaXN0ZXJMYW5ndWFnZT1iLGUubGlzdExhbmd1YWdlcz1tLGUuZ2V0TGFuZ3VhZ2U9TixlLmluaGVyaXQ9byxlLklSPVwiW2EtekEtWl1bYS16QS1aMC05X10qXCIsZS5VSVI9XCJbYS16QS1aX11bYS16QS1aMC05X10qXCIsZS5OUj1cIlxcXFxiXFxcXGQrKFxcXFwuXFxcXGQrKT9cIixlLkNOUj1cIihcXFxcYjBbeFhdW2EtZkEtRjAtOV0rfChcXFxcYlxcXFxkKyhcXFxcLlxcXFxkKik/fFxcXFwuXFxcXGQrKShbZUVdWy0rXT9cXFxcZCspPylcIixlLkJOUj1cIlxcXFxiKDBiWzAxXSspXCIsZS5SU1I9XCIhfCE9fCE9PXwlfCU9fCZ8JiZ8Jj18XFxcXCp8XFxcXCo9fFxcXFwrfFxcXFwrPXwsfC18LT18Lz18L3w6fDt8PDx8PDw9fDw9fDx8PT09fD09fD18Pj4+PXw+Pj18Pj18Pj4+fD4+fD58XFxcXD98XFxcXFt8XFxcXHt8XFxcXCh8XFxcXF58XFxcXF49fFxcXFx8fFxcXFx8PXxcXFxcfFxcXFx8fH5cIixlLkJFPXtiOlwiXFxcXFxcXFxbXFxcXHNcXFxcU11cIixyOjB9LGUuQVNNPXtjTjpcInN0cmluZ1wiLGI6XCInXCIsZTpcIidcIixpOlwiXFxcXG5cIixjOltlLkJFXX0sZS5RU009e2NOOlwic3RyaW5nXCIsYjonXCInLGU6J1wiJyxpOlwiXFxcXG5cIixjOltlLkJFXX0sZS5QV009e2I6L1xcYihhfGFufHRoZXxhcmV8SXxJJ218aXNuJ3R8ZG9uJ3R8ZG9lc24ndHx3b24ndHxidXR8anVzdHxzaG91bGR8cHJldHR5fHNpbXBseXxlbm91Z2h8Z29ubmF8Z29pbmd8d3RmfHNvfHN1Y2gpXFxiL30sZS5DTENNPXtjTjpcImNvbW1lbnRcIixiOlwiLy9cIixlOlwiJFwiLGM6W2UuUFdNXX0sZS5DQkNNPXtjTjpcImNvbW1lbnRcIixiOlwiL1xcXFwqXCIsZTpcIlxcXFwqL1wiLGM6W2UuUFdNXX0sZS5IQ009e2NOOlwiY29tbWVudFwiLGI6XCIjXCIsZTpcIiRcIixjOltlLlBXTV19LGUuTk09e2NOOlwibnVtYmVyXCIsYjplLk5SLHI6MH0sZS5DTk09e2NOOlwibnVtYmVyXCIsYjplLkNOUixyOjB9LGUuQk5NPXtjTjpcIm51bWJlclwiLGI6ZS5CTlIscjowfSxlLkNTU05NPXtjTjpcIm51bWJlclwiLGI6ZS5OUitcIiglfGVtfGV4fGNofHJlbXx2d3x2aHx2bWlufHZtYXh8Y218bW18aW58cHR8cGN8cHh8ZGVnfGdyYWR8cmFkfHR1cm58c3xtc3xIenxrSHp8ZHBpfGRwY218ZHBweCk/XCIscjowfSxlLlJNPXtjTjpcInJlZ2V4cFwiLGI6L1xcLy8sZTovXFwvW2dpbXV5XSovLGk6L1xcbi8sYzpbZS5CRSx7YjovXFxbLyxlOi9cXF0vLHI6MCxjOltlLkJFXX1dfSxlLlRNPXtjTjpcInRpdGxlXCIsYjplLklSLHI6MH0sZS5VVE09e2NOOlwidGl0bGVcIixiOmUuVUlSLHI6MH0sZX0pO2hsanMucmVnaXN0ZXJMYW5ndWFnZShcImNvZmZlZXNjcmlwdFwiLGZ1bmN0aW9uKGUpe3ZhciBjPXtrZXl3b3JkOlwiaW4gaWYgZm9yIHdoaWxlIGZpbmFsbHkgbmV3IGRvIHJldHVybiBlbHNlIGJyZWFrIGNhdGNoIGluc3RhbmNlb2YgdGhyb3cgdHJ5IHRoaXMgc3dpdGNoIGNvbnRpbnVlIHR5cGVvZiBkZWxldGUgZGVidWdnZXIgc3VwZXIgdGhlbiB1bmxlc3MgdW50aWwgbG9vcCBvZiBieSB3aGVuIGFuZCBvciBpcyBpc250IG5vdFwiLGxpdGVyYWw6XCJ0cnVlIGZhbHNlIG51bGwgdW5kZWZpbmVkIHllcyBubyBvbiBvZmZcIixyZXNlcnZlZDpcImNhc2UgZGVmYXVsdCBmdW5jdGlvbiB2YXIgdm9pZCB3aXRoIGNvbnN0IGxldCBlbnVtIGV4cG9ydCBpbXBvcnQgbmF0aXZlIF9faGFzUHJvcCBfX2V4dGVuZHMgX19zbGljZSBfX2JpbmQgX19pbmRleE9mXCIsYnVpbHRfaW46XCJucG0gcmVxdWlyZSBjb25zb2xlIHByaW50IG1vZHVsZSBnbG9iYWwgd2luZG93IGRvY3VtZW50XCJ9LG49XCJbQS1aYS16JF9dWzAtOUEtWmEteiRfXSpcIix0PXtjTjpcInN1YnN0XCIsYjovI1xcey8sZTovfS8sazpjfSxyPVtlLkJOTSxlLmluaGVyaXQoZS5DTk0se3N0YXJ0czp7ZTpcIihcXFxccyovKT9cIixyOjB9fSkse2NOOlwic3RyaW5nXCIsdjpbe2I6LycnJy8sZTovJycnLyxjOltlLkJFXX0se2I6LycvLGU6LycvLGM6W2UuQkVdfSx7YjovXCJcIlwiLyxlOi9cIlwiXCIvLGM6W2UuQkUsdF19LHtiOi9cIi8sZTovXCIvLGM6W2UuQkUsdF19XX0se2NOOlwicmVnZXhwXCIsdjpbe2I6XCIvLy9cIixlOlwiLy8vXCIsYzpbdCxlLkhDTV19LHtiOlwiLy9bZ2ltXSpcIixyOjB9LHtiOi9cXC8oPyFbICpdKShcXFxcXFwvfC4pKj9cXC9bZ2ltXSooPz1cXFd8JCkvfV19LHtjTjpcInByb3BlcnR5XCIsYjpcIkBcIitufSx7YjpcImBcIixlOlwiYFwiLGVCOiEwLGVFOiEwLHNMOlwiamF2YXNjcmlwdFwifV07dC5jPXI7dmFyIGk9ZS5pbmhlcml0KGUuVE0se2I6bn0pLHM9XCIoXFxcXCguKlxcXFwpKT9cXFxccypcXFxcQlstPV0+XCIsbz17Y046XCJwYXJhbXNcIixiOlwiXFxcXChbXlxcXFwoXVwiLHJCOiEwLGM6W3tiOi9cXCgvLGU6L1xcKS8sazpjLGM6W1wic2VsZlwiXS5jb25jYXQocil9XX07cmV0dXJue2FsaWFzZXM6W1wiY29mZmVlXCIsXCJjc29uXCIsXCJpY2VkXCJdLGs6YyxpOi9cXC9cXCovLGM6ci5jb25jYXQoW3tjTjpcImNvbW1lbnRcIixiOlwiIyMjXCIsZTpcIiMjI1wiLGM6W2UuUFdNXX0sZS5IQ00se2NOOlwiZnVuY3Rpb25cIixiOlwiXlxcXFxzKlwiK24rXCJcXFxccyo9XFxcXHMqXCIrcyxlOlwiWy09XT5cIixyQjohMCxjOltpLG9dfSx7YjovWzpcXCgsPV1cXHMqLyxyOjAsYzpbe2NOOlwiZnVuY3Rpb25cIixiOnMsZTpcIlstPV0+XCIsckI6ITAsYzpbb119XX0se2NOOlwiY2xhc3NcIixiSzpcImNsYXNzXCIsZTpcIiRcIixpOi9bOj1cIlxcW1xcXV0vLGM6W3tiSzpcImV4dGVuZHNcIixlVzohMCxpOi9bOj1cIlxcW1xcXV0vLGM6W2ldfSxpXX0se2NOOlwiYXR0cmlidXRlXCIsYjpuK1wiOlwiLGU6XCI6XCIsckI6ITAsckU6ITAscjowfV0pfX0pO2hsanMucmVnaXN0ZXJMYW5ndWFnZShcImFwYWNoZVwiLGZ1bmN0aW9uKGUpe3ZhciByPXtjTjpcIm51bWJlclwiLGI6XCJbXFxcXCQlXVxcXFxkK1wifTtyZXR1cm57YWxpYXNlczpbXCJhcGFjaGVjb25mXCJdLGNJOiEwLGM6W2UuSENNLHtjTjpcInRhZ1wiLGI6XCI8Lz9cIixlOlwiPlwifSx7Y046XCJrZXl3b3JkXCIsYjovXFx3Ky8scjowLGs6e2NvbW1vbjpcIm9yZGVyIGRlbnkgYWxsb3cgc2V0ZW52IHJld3JpdGVydWxlIHJld3JpdGVlbmdpbmUgcmV3cml0ZWNvbmQgZG9jdW1lbnRyb290IHNldGhhbmRsZXIgZXJyb3Jkb2N1bWVudCBsb2FkbW9kdWxlIG9wdGlvbnMgaGVhZGVyIGxpc3RlbiBzZXJ2ZXJyb290IHNlcnZlcm5hbWVcIn0sc3RhcnRzOntlOi8kLyxyOjAsazp7bGl0ZXJhbDpcIm9uIG9mZiBhbGxcIn0sYzpbe2NOOlwic3FicmFja2V0XCIsYjpcIlxcXFxzXFxcXFtcIixlOlwiXFxcXF0kXCJ9LHtjTjpcImNicmFja2V0XCIsYjpcIltcXFxcJCVdXFxcXHtcIixlOlwiXFxcXH1cIixjOltcInNlbGZcIixyXX0scixlLlFTTV19fV0saTovXFxTL319KTtobGpzLnJlZ2lzdGVyTGFuZ3VhZ2UoXCJodHRwXCIsZnVuY3Rpb24oKXtyZXR1cm57aTpcIlxcXFxTXCIsYzpbe2NOOlwic3RhdHVzXCIsYjpcIl5IVFRQL1swLTlcXFxcLl0rXCIsZTpcIiRcIixjOlt7Y046XCJudW1iZXJcIixiOlwiXFxcXGJcXFxcZHszfVxcXFxiXCJ9XX0se2NOOlwicmVxdWVzdFwiLGI6XCJeW0EtWl0rICguKj8pIEhUVFAvWzAtOVxcXFwuXSskXCIsckI6ITAsZTpcIiRcIixjOlt7Y046XCJzdHJpbmdcIixiOlwiIFwiLGU6XCIgXCIsZUI6ITAsZUU6ITB9XX0se2NOOlwiYXR0cmlidXRlXCIsYjpcIl5cXFxcd1wiLGU6XCI6IFwiLGVFOiEwLGk6XCJcXFxcbnxcXFxcc3w9XCIsc3RhcnRzOntjTjpcInN0cmluZ1wiLGU6XCIkXCJ9fSx7YjpcIlxcXFxuXFxcXG5cIixzdGFydHM6e3NMOlwiXCIsZVc6ITB9fV19fSk7aGxqcy5yZWdpc3Rlckxhbmd1YWdlKFwiY3NcIixmdW5jdGlvbihlKXt2YXIgcj1cImFic3RyYWN0IGFzIGJhc2UgYm9vbCBicmVhayBieXRlIGNhc2UgY2F0Y2ggY2hhciBjaGVja2VkIGNvbnN0IGNvbnRpbnVlIGRlY2ltYWwgZGVmYXVsdCBkZWxlZ2F0ZSBkbyBkb3VibGUgZWxzZSBlbnVtIGV2ZW50IGV4cGxpY2l0IGV4dGVybiBmYWxzZSBmaW5hbGx5IGZpeGVkIGZsb2F0IGZvciBmb3JlYWNoIGdvdG8gaWYgaW1wbGljaXQgaW4gaW50IGludGVyZmFjZSBpbnRlcm5hbCBpcyBsb2NrIGxvbmcgbnVsbCBvYmplY3Qgb3BlcmF0b3Igb3V0IG92ZXJyaWRlIHBhcmFtcyBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgcmVhZG9ubHkgcmVmIHNieXRlIHNlYWxlZCBzaG9ydCBzaXplb2Ygc3RhY2thbGxvYyBzdGF0aWMgc3RyaW5nIHN0cnVjdCBzd2l0Y2ggdGhpcyB0cnVlIHRyeSB0eXBlb2YgdWludCB1bG9uZyB1bmNoZWNrZWQgdW5zYWZlIHVzaG9ydCB1c2luZyB2aXJ0dWFsIHZvbGF0aWxlIHZvaWQgd2hpbGUgYXN5bmMgcHJvdGVjdGVkIHB1YmxpYyBwcml2YXRlIGludGVybmFsIGFzY2VuZGluZyBkZXNjZW5kaW5nIGZyb20gZ2V0IGdyb3VwIGludG8gam9pbiBsZXQgb3JkZXJieSBwYXJ0aWFsIHNlbGVjdCBzZXQgdmFsdWUgdmFyIHdoZXJlIHlpZWxkXCIsdD1lLklSK1wiKDxcIitlLklSK1wiPik/XCI7cmV0dXJue2FsaWFzZXM6W1wiY3NoYXJwXCJdLGs6cixpOi86Oi8sYzpbe2NOOlwiY29tbWVudFwiLGI6XCIvLy9cIixlOlwiJFwiLHJCOiEwLGM6W3tjTjpcInhtbERvY1RhZ1wiLHY6W3tiOlwiLy8vXCIscjowfSx7YjpcIjwhLS18LS0+XCJ9LHtiOlwiPC8/XCIsZTpcIj5cIn1dfV19LGUuQ0xDTSxlLkNCQ00se2NOOlwicHJlcHJvY2Vzc29yXCIsYjpcIiNcIixlOlwiJFwiLGs6XCJpZiBlbHNlIGVsaWYgZW5kaWYgZGVmaW5lIHVuZGVmIHdhcm5pbmcgZXJyb3IgbGluZSByZWdpb24gZW5kcmVnaW9uIHByYWdtYSBjaGVja3N1bVwifSx7Y046XCJzdHJpbmdcIixiOidAXCInLGU6J1wiJyxjOlt7YjonXCJcIid9XX0sZS5BU00sZS5RU00sZS5DTk0se2JLOlwiY2xhc3MgbmFtZXNwYWNlIGludGVyZmFjZVwiLGU6L1t7Oz1dLyxpOi9bXlxcczpdLyxjOltlLlRNLGUuQ0xDTSxlLkNCQ01dfSx7Yks6XCJuZXcgcmV0dXJuIHRocm93IGF3YWl0XCIscjowfSx7Y046XCJmdW5jdGlvblwiLGI6XCIoXCIrdCtcIlxcXFxzKykrXCIrZS5JUitcIlxcXFxzKlxcXFwoXCIsckI6ITAsZTovW3s7PV0vLGVFOiEwLGs6cixjOlt7YjplLklSK1wiXFxcXHMqXFxcXChcIixyQjohMCxjOltlLlRNXSxyOjB9LHtjTjpcInBhcmFtc1wiLGI6L1xcKC8sZTovXFwpLyxrOnIscjowLGM6W2UuQVNNLGUuUVNNLGUuQ05NLGUuQ0JDTV19LGUuQ0xDTSxlLkNCQ01dfV19fSk7aGxqcy5yZWdpc3Rlckxhbmd1YWdlKFwiamF2YVwiLGZ1bmN0aW9uKGUpe3ZhciBhPWUuVUlSK1wiKDxcIitlLlVJUitcIj4pP1wiLHQ9XCJmYWxzZSBzeW5jaHJvbml6ZWQgaW50IGFic3RyYWN0IGZsb2F0IHByaXZhdGUgY2hhciBib29sZWFuIHN0YXRpYyBudWxsIGlmIGNvbnN0IGZvciB0cnVlIHdoaWxlIGxvbmcgc3RyaWN0ZnAgZmluYWxseSBwcm90ZWN0ZWQgaW1wb3J0IG5hdGl2ZSBmaW5hbCB2b2lkIGVudW0gZWxzZSBicmVhayB0cmFuc2llbnQgY2F0Y2ggaW5zdGFuY2VvZiBieXRlIHN1cGVyIHZvbGF0aWxlIGNhc2UgYXNzZXJ0IHNob3J0IHBhY2thZ2UgZGVmYXVsdCBkb3VibGUgcHVibGljIHRyeSB0aGlzIHN3aXRjaCBjb250aW51ZSB0aHJvd3MgcHJvdGVjdGVkIHB1YmxpYyBwcml2YXRlXCIsYz1cIihcXFxcYigwYlswMV9dKyl8XFxcXGIwW3hYXVthLWZBLUYwLTlfXSt8KFxcXFxiW1xcXFxkX10rKFxcXFwuW1xcXFxkX10qKT98XFxcXC5bXFxcXGRfXSspKFtlRV1bLStdP1xcXFxkKyk/KVtsTGZGXT9cIixyPXtjTjpcIm51bWJlclwiLGI6YyxyOjB9O3JldHVybnthbGlhc2VzOltcImpzcFwiXSxrOnQsaTovPFxcLy8sYzpbe2NOOlwiamF2YWRvY1wiLGI6XCIvXFxcXCpcXFxcKlwiLGU6XCJcXFxcKi9cIixyOjAsYzpbe2NOOlwiamF2YWRvY3RhZ1wiLGI6XCIoXnxcXFxccylAW0EtWmEtel0rXCJ9XX0sZS5DTENNLGUuQ0JDTSxlLkFTTSxlLlFTTSx7Y046XCJjbGFzc1wiLGJLOlwiY2xhc3MgaW50ZXJmYWNlXCIsZTovW3s7PV0vLGVFOiEwLGs6XCJjbGFzcyBpbnRlcmZhY2VcIixpOi9bOlwiXFxbXFxdXS8sYzpbe2JLOlwiZXh0ZW5kcyBpbXBsZW1lbnRzXCJ9LGUuVVRNXX0se2JLOlwibmV3IHRocm93IHJldHVyblwiLHI6MH0se2NOOlwiZnVuY3Rpb25cIixiOlwiKFwiK2ErXCJcXFxccyspK1wiK2UuVUlSK1wiXFxcXHMqXFxcXChcIixyQjohMCxlOi9bezs9XS8sZUU6ITAsazp0LGM6W3tiOmUuVUlSK1wiXFxcXHMqXFxcXChcIixyQjohMCxyOjAsYzpbZS5VVE1dfSx7Y046XCJwYXJhbXNcIixiOi9cXCgvLGU6L1xcKS8sazp0LHI6MCxjOltlLkFTTSxlLlFTTSxlLkNOTSxlLkNCQ01dfSxlLkNMQ00sZS5DQkNNXX0scix7Y046XCJhbm5vdGF0aW9uXCIsYjpcIkBbQS1aYS16XStcIn1dfX0pO2hsanMucmVnaXN0ZXJMYW5ndWFnZShcInNxbFwiLGZ1bmN0aW9uKGUpe3ZhciB0PXtjTjpcImNvbW1lbnRcIixiOlwiLS1cIixlOlwiJFwifTtyZXR1cm57Y0k6ITAsaTovWzw+XS8sYzpbe2NOOlwib3BlcmF0b3JcIixiSzpcImJlZ2luIGVuZCBzdGFydCBjb21taXQgcm9sbGJhY2sgc2F2ZXBvaW50IGxvY2sgYWx0ZXIgY3JlYXRlIGRyb3AgcmVuYW1lIGNhbGwgZGVsZXRlIGRvIGhhbmRsZXIgaW5zZXJ0IGxvYWQgcmVwbGFjZSBzZWxlY3QgdHJ1bmNhdGUgdXBkYXRlIHNldCBzaG93IHByYWdtYSBncmFudCBtZXJnZSBkZXNjcmliZSB1c2UgZXhwbGFpbiBoZWxwIGRlY2xhcmUgcHJlcGFyZSBleGVjdXRlIGRlYWxsb2NhdGUgc2F2ZXBvaW50IHJlbGVhc2UgdW5sb2NrIHB1cmdlIHJlc2V0IGNoYW5nZSBzdG9wIGFuYWx5emUgY2FjaGUgZmx1c2ggb3B0aW1pemUgcmVwYWlyIGtpbGwgaW5zdGFsbCB1bmluc3RhbGwgY2hlY2tzdW0gcmVzdG9yZSBjaGVjayBiYWNrdXBcIixlOi87LyxlVzohMCxrOntrZXl3b3JkOlwiYWJzIGFic29sdXRlIGFjb3MgYWN0aW9uIGFkZCBhZGRkYXRlIGFkZHRpbWUgYWVzX2RlY3J5cHQgYWVzX2VuY3J5cHQgYWZ0ZXIgYWdncmVnYXRlIGFsbCBhbGxvY2F0ZSBhbHRlciBhbmFseXplIGFuZCBhbnkgYXJlIGFzIGFzYyBhc2NpaSBhc2luIGFzc2VydGlvbiBhdCBhdGFuIGF0YW4yIGF0bjIgYXV0aG9yaXphdGlvbiBhdXRob3JzIGF2ZyBiYWNrdXAgYmVmb3JlIGJlZ2luIGJlbmNobWFyayBiZXR3ZWVuIGJpbiBiaW5sb2cgYml0X2FuZCBiaXRfY291bnQgYml0X2xlbmd0aCBiaXRfb3IgYml0X3hvciBib3RoIGJ5IGNhY2hlIGNhbGwgY2FzY2FkZSBjYXNjYWRlZCBjYXNlIGNhc3QgY2F0YWxvZyBjZWlsIGNlaWxpbmcgY2hhaW4gY2hhbmdlIGNoYW5nZWQgY2hhcl9sZW5ndGggY2hhcmFjdGVyX2xlbmd0aCBjaGFyaW5kZXggY2hhcnNldCBjaGVjayBjaGVja3N1bSBjaGVja3N1bV9hZ2cgY2hvb3NlIGNsb3NlIGNvYWxlc2NlIGNvZXJjaWJpbGl0eSBjb2xsYXRlIGNvbGxhdGlvbiBjb2xsYXRpb25wcm9wZXJ0eSBjb2x1bW4gY29sdW1ucyBjb2x1bW5zX3VwZGF0ZWQgY29tbWl0IGNvbXByZXNzIGNvbmNhdCBjb25jYXRfd3MgY29uY3VycmVudCBjb25uZWN0IGNvbm5lY3Rpb24gY29ubmVjdGlvbl9pZCBjb25zaXN0ZW50IGNvbnN0cmFpbnQgY29uc3RyYWludHMgY29udGludWUgY29udHJpYnV0b3JzIGNvbnYgY29udmVydCBjb252ZXJ0X3R6IGNvcnJlc3BvbmRpbmcgY29zIGNvdCBjb3VudCBjb3VudF9iaWcgY3JjMzIgY3JlYXRlIGNyb3NzIGN1bWVfZGlzdCBjdXJkYXRlIGN1cnJlbnQgY3VycmVudF9kYXRlIGN1cnJlbnRfdGltZSBjdXJyZW50X3RpbWVzdGFtcCBjdXJyZW50X3VzZXIgY3Vyc29yIGN1cnRpbWUgZGF0YSBkYXRhYmFzZSBkYXRhYmFzZXMgZGF0YWxlbmd0aCBkYXRlX2FkZCBkYXRlX2Zvcm1hdCBkYXRlX3N1YiBkYXRlYWRkIGRhdGVkaWZmIGRhdGVmcm9tcGFydHMgZGF0ZW5hbWUgZGF0ZXBhcnQgZGF0ZXRpbWUyZnJvbXBhcnRzIGRhdGV0aW1lb2Zmc2V0ZnJvbXBhcnRzIGRheSBkYXluYW1lIGRheW9mbW9udGggZGF5b2Z3ZWVrIGRheW9meWVhciBkZWFsbG9jYXRlIGRlY2xhcmUgZGVjb2RlIGRlZmF1bHQgZGVmZXJyYWJsZSBkZWZlcnJlZCBkZWdyZWVzIGRlbGF5ZWQgZGVsZXRlIGRlc19kZWNyeXB0IGRlc19lbmNyeXB0IGRlc19rZXlfZmlsZSBkZXNjIGRlc2NyaWJlIGRlc2NyaXB0b3IgZGlhZ25vc3RpY3MgZGlmZmVyZW5jZSBkaXNjb25uZWN0IGRpc3RpbmN0IGRpc3RpbmN0cm93IGRpdiBkbyBkb21haW4gZG91YmxlIGRyb3AgZHVtcGZpbGUgZWFjaCBlbHNlIGVsdCBlbmNsb3NlZCBlbmNvZGUgZW5jcnlwdCBlbmQgZW5kLWV4ZWMgZW5naW5lIGVuZ2luZXMgZW9tb250aCBlcnJvcnMgZXNjYXBlIGVzY2FwZWQgZXZlbnQgZXZlbnRkYXRhIGV2ZW50cyBleGNlcHQgZXhjZXB0aW9uIGV4ZWMgZXhlY3V0ZSBleGlzdHMgZXhwIGV4cGxhaW4gZXhwb3J0X3NldCBleHRlbmRlZCBleHRlcm5hbCBleHRyYWN0IGZhc3QgZmV0Y2ggZmllbGQgZmllbGRzIGZpbmRfaW5fc2V0IGZpcnN0IGZpcnN0X3ZhbHVlIGZsb29yIGZsdXNoIGZvciBmb3JjZSBmb3JlaWduIGZvcm1hdCBmb3VuZCBmb3VuZF9yb3dzIGZyb20gZnJvbV9iYXNlNjQgZnJvbV9kYXlzIGZyb21fdW5peHRpbWUgZnVsbCBmdW5jdGlvbiBnZXQgZ2V0X2Zvcm1hdCBnZXRfbG9jayBnZXRkYXRlIGdldHV0Y2RhdGUgZ2xvYmFsIGdvIGdvdG8gZ3JhbnQgZ3JhbnRzIGdyZWF0ZXN0IGdyb3VwIGdyb3VwX2NvbmNhdCBncm91cGluZyBncm91cGluZ19pZCBndGlkX3N1YnNldCBndGlkX3N1YnRyYWN0IGhhbmRsZXIgaGF2aW5nIGhlbHAgaGV4IGhpZ2hfcHJpb3JpdHkgaG9zdHMgaG91ciBpZGVudF9jdXJyZW50IGlkZW50X2luY3IgaWRlbnRfc2VlZCBpZGVudGlmaWVkIGlkZW50aXR5IGlmIGlmbnVsbCBpZ25vcmUgaWlmIGlsaWtlIGltbWVkaWF0ZSBpbiBpbmRleCBpbmRpY2F0b3IgaW5ldDZfYXRvbiBpbmV0Nl9udG9hIGluZXRfYXRvbiBpbmV0X250b2EgaW5maWxlIGluaXRpYWxseSBpbm5lciBpbm5vZGIgaW5wdXQgaW5zZXJ0IGluc3RhbGwgaW5zdHIgaW50ZXJzZWN0IGludG8gaXMgaXNfZnJlZV9sb2NrIGlzX2lwdjQgaXNfaXB2NF9jb21wYXQgaXNfaXB2NF9tYXBwZWQgaXNfbm90IGlzX25vdF9udWxsIGlzX3VzZWRfbG9jayBpc2RhdGUgaXNudWxsIGlzb2xhdGlvbiBqb2luIGtleSBraWxsIGxhbmd1YWdlIGxhc3QgbGFzdF9kYXkgbGFzdF9pbnNlcnRfaWQgbGFzdF92YWx1ZSBsY2FzZSBsZWFkIGxlYWRpbmcgbGVhc3QgbGVhdmVzIGxlZnQgbGVuIGxlbmdodCBsZXZlbCBsaWtlIGxpbWl0IGxpbmVzIGxuIGxvYWQgbG9hZF9maWxlIGxvY2FsIGxvY2FsdGltZSBsb2NhbHRpbWVzdGFtcCBsb2NhdGUgbG9jayBsb2cgbG9nMTAgbG9nMiBsb2dmaWxlIGxvZ3MgbG93X3ByaW9yaXR5IGxvd2VyIGxwYWQgbHRyaW0gbWFrZV9zZXQgbWFrZWRhdGUgbWFrZXRpbWUgbWFzdGVyIG1hc3Rlcl9wb3Nfd2FpdCBtYXRjaCBtYXRjaGVkIG1heCBtZDUgbWVkaXVtIG1lcmdlIG1pY3Jvc2Vjb25kIG1pZCBtaW4gbWludXRlIG1vZCBtb2RlIG1vZHVsZSBtb250aCBtb250aG5hbWUgbXV0ZXggbmFtZV9jb25zdCBuYW1lcyBuYXRpb25hbCBuYXR1cmFsIG5jaGFyIG5leHQgbm8gbm9fd3JpdGVfdG9fYmlubG9nIG5vdCBub3cgbnVsbGlmIG52YXJjaGFyIG9jdCBvY3RldF9sZW5ndGggb2Ygb2xkX3Bhc3N3b3JkIG9uIG9ubHkgb3BlbiBvcHRpbWl6ZSBvcHRpb24gb3B0aW9uYWxseSBvciBvcmQgb3JkZXIgb3V0ZXIgb3V0ZmlsZSBvdXRwdXQgcGFkIHBhcnNlIHBhcnRpYWwgcGFydGl0aW9uIHBhc3N3b3JkIHBhdGluZGV4IHBlcmNlbnRfcmFuayBwZXJjZW50aWxlX2NvbnQgcGVyY2VudGlsZV9kaXNjIHBlcmlvZF9hZGQgcGVyaW9kX2RpZmYgcGkgcGx1Z2luIHBvc2l0aW9uIHBvdyBwb3dlciBwcmFnbWEgcHJlY2lzaW9uIHByZXBhcmUgcHJlc2VydmUgcHJpbWFyeSBwcmlvciBwcml2aWxlZ2VzIHByb2NlZHVyZSBwcm9jZWR1cmVfYW5hbHl6ZSBwcm9jZXNzbGlzdCBwcm9maWxlIHByb2ZpbGVzIHB1YmxpYyBwdWJsaXNoaW5nc2VydmVybmFtZSBwdXJnZSBxdWFydGVyIHF1ZXJ5IHF1aWNrIHF1b3RlIHF1b3RlbmFtZSByYWRpYW5zIHJhbmQgcmVhZCByZWZlcmVuY2VzIHJlZ2V4cCByZWxhdGl2ZSByZWxheWxvZyByZWxlYXNlIHJlbGVhc2VfbG9jayByZW5hbWUgcmVwYWlyIHJlcGVhdCByZXBsYWNlIHJlcGxpY2F0ZSByZXNldCByZXN0b3JlIHJlc3RyaWN0IHJldHVybiByZXR1cm5zIHJldmVyc2UgcmV2b2tlIHJpZ2h0IHJsaWtlIHJvbGxiYWNrIHJvbGx1cCByb3VuZCByb3cgcm93X2NvdW50IHJvd3MgcnBhZCBydHJpbSBzYXZlcG9pbnQgc2NoZW1hIHNjcm9sbCBzZWNfdG9fdGltZSBzZWNvbmQgc2VjdGlvbiBzZWxlY3Qgc2VyaWFsaXphYmxlIHNlcnZlciBzZXNzaW9uIHNlc3Npb25fdXNlciBzZXQgc2hhIHNoYTEgc2hhMiBzaGFyZSBzaG93IHNpZ24gc2luIHNpemUgc2xhdmUgc2xlZXAgc21hbGxkYXRldGltZWZyb21wYXJ0cyBzbmFwc2hvdCBzb21lIHNvbmFtZSBzb3VuZGV4IHNvdW5kc19saWtlIHNwYWNlIHNxbCBzcWxfYmlnX3Jlc3VsdCBzcWxfYnVmZmVyX3Jlc3VsdCBzcWxfY2FjaGUgc3FsX2NhbGNfZm91bmRfcm93cyBzcWxfbm9fY2FjaGUgc3FsX3NtYWxsX3Jlc3VsdCBzcWxfdmFyaWFudF9wcm9wZXJ0eSBzcWxzdGF0ZSBzcXJ0IHNxdWFyZSBzdGFydCBzdGFydGluZyBzdGF0dXMgc3RkIHN0ZGRldiBzdGRkZXZfcG9wIHN0ZGRldl9zYW1wIHN0ZGV2IHN0ZGV2cCBzdG9wIHN0ciBzdHJfdG9fZGF0ZSBzdHJhaWdodF9qb2luIHN0cmNtcCBzdHJpbmcgc3R1ZmYgc3ViZGF0ZSBzdWJzdHIgc3Vic3RyaW5nIHN1YnRpbWUgc3VidHJpbmdfaW5kZXggc3VtIHN3aXRjaG9mZnNldCBzeXNkYXRlIHN5c2RhdGV0aW1lIHN5c2RhdGV0aW1lb2Zmc2V0IHN5c3RlbV91c2VyIHN5c3V0Y2RhdGV0aW1lIHRhYmxlIHRhYmxlcyB0YWJsZXNwYWNlIHRhbiB0ZW1wb3JhcnkgdGVybWluYXRlZCB0ZXJ0aWFyeV93ZWlnaHRzIHRoZW4gdGltZSB0aW1lX2Zvcm1hdCB0aW1lX3RvX3NlYyB0aW1lZGlmZiB0aW1lZnJvbXBhcnRzIHRpbWVzdGFtcCB0aW1lc3RhbXBhZGQgdGltZXN0YW1wZGlmZiB0aW1lem9uZV9ob3VyIHRpbWV6b25lX21pbnV0ZSB0byB0b19iYXNlNjQgdG9fZGF5cyB0b19zZWNvbmRzIHRvZGF0ZXRpbWVvZmZzZXQgdHJhaWxpbmcgdHJhbnNhY3Rpb24gdHJhbnNsYXRpb24gdHJpZ2dlciB0cmlnZ2VyX25lc3RsZXZlbCB0cmlnZ2VycyB0cmltIHRydW5jYXRlIHRyeV9jYXN0IHRyeV9jb252ZXJ0IHRyeV9wYXJzZSB1Y2FzZSB1bmNvbXByZXNzIHVuY29tcHJlc3NlZF9sZW5ndGggdW5oZXggdW5pY29kZSB1bmluc3RhbGwgdW5pb24gdW5pcXVlIHVuaXhfdGltZXN0YW1wIHVua25vd24gdW5sb2NrIHVwZGF0ZSB1cGdyYWRlIHVwcGVkIHVwcGVyIHVzYWdlIHVzZSB1c2VyIHVzZXJfcmVzb3VyY2VzIHVzaW5nIHV0Y19kYXRlIHV0Y190aW1lIHV0Y190aW1lc3RhbXAgdXVpZCB1dWlkX3Nob3J0IHZhbGlkYXRlX3Bhc3N3b3JkX3N0cmVuZ3RoIHZhbHVlIHZhbHVlcyB2YXIgdmFyX3BvcCB2YXJfc2FtcCB2YXJpYWJsZXMgdmFyaWFuY2UgdmFycCB2ZXJzaW9uIHZpZXcgd2FybmluZ3Mgd2VlayB3ZWVrZGF5IHdlZWtvZnllYXIgd2VpZ2h0X3N0cmluZyB3aGVuIHdoZW5ldmVyIHdoZXJlIHdpdGggd29yayB3cml0ZSB4bWwgeG9yIHllYXIgeWVhcndlZWsgem9uXCIsbGl0ZXJhbDpcInRydWUgZmFsc2UgbnVsbFwiLGJ1aWx0X2luOlwiYXJyYXkgYmlnaW50IGJpbmFyeSBiaXQgYmxvYiBib29sZWFuIGNoYXIgY2hhcmFjdGVyIGRhdGUgZGVjIGRlY2ltYWwgZmxvYXQgaW50IGludGVnZXIgaW50ZXJ2YWwgbnVtYmVyIG51bWVyaWMgcmVhbCBzZXJpYWwgc21hbGxpbnQgdmFyY2hhciB2YXJ5aW5nIGludDggc2VyaWFsOCB0ZXh0XCJ9LGM6W3tjTjpcInN0cmluZ1wiLGI6XCInXCIsZTpcIidcIixjOltlLkJFLHtiOlwiJydcIn1dfSx7Y046XCJzdHJpbmdcIixiOidcIicsZTonXCInLGM6W2UuQkUse2I6J1wiXCInfV19LHtjTjpcInN0cmluZ1wiLGI6XCJgXCIsZTpcImBcIixjOltlLkJFXX0sZS5DTk0sZS5DQkNNLHRdfSxlLkNCQ00sdF19fSk7aGxqcy5yZWdpc3Rlckxhbmd1YWdlKFwibmdpbnhcIixmdW5jdGlvbihlKXt2YXIgcj17Y046XCJ2YXJpYWJsZVwiLHY6W3tiOi9cXCRcXGQrL30se2I6L1xcJFxcey8sZTovfS99LHtiOlwiW1xcXFwkXFxcXEBdXCIrZS5VSVJ9XX0sYj17ZVc6ITAsbDpcIlthLXovX10rXCIsazp7YnVpbHRfaW46XCJvbiBvZmYgeWVzIG5vIHRydWUgZmFsc2Ugbm9uZSBibG9ja2VkIGRlYnVnIGluZm8gbm90aWNlIHdhcm4gZXJyb3IgY3JpdCBzZWxlY3QgYnJlYWsgbGFzdCBwZXJtYW5lbnQgcmVkaXJlY3Qga3F1ZXVlIHJ0c2lnIGVwb2xsIHBvbGwgL2Rldi9wb2xsXCJ9LHI6MCxpOlwiPT5cIixjOltlLkhDTSx7Y046XCJzdHJpbmdcIixjOltlLkJFLHJdLHY6W3tiOi9cIi8sZTovXCIvfSx7YjovJy8sZTovJy99XX0se2NOOlwidXJsXCIsYjpcIihbYS16XSspOi9cIixlOlwiXFxcXHNcIixlVzohMCxlRTohMCxjOltyXX0se2NOOlwicmVnZXhwXCIsYzpbZS5CRSxyXSx2Olt7YjpcIlxcXFxzXFxcXF5cIixlOlwiXFxcXHN8e3w7XCIsckU6ITB9LHtiOlwiflxcXFwqP1xcXFxzK1wiLGU6XCJcXFxcc3x7fDtcIixyRTohMH0se2I6XCJcXFxcKihcXFxcLlthLXpcXFxcLV0rKStcIn0se2I6XCIoW2EtelxcXFwtXStcXFxcLikrXFxcXCpcIn1dfSx7Y046XCJudW1iZXJcIixiOlwiXFxcXGJcXFxcZHsxLDN9XFxcXC5cXFxcZHsxLDN9XFxcXC5cXFxcZHsxLDN9XFxcXC5cXFxcZHsxLDN9KDpcXFxcZHsxLDV9KT9cXFxcYlwifSx7Y046XCJudW1iZXJcIixiOlwiXFxcXGJcXFxcZCtba0ttTWdHZHNoZHd5XSpcXFxcYlwiLHI6MH0scl19O3JldHVybnthbGlhc2VzOltcIm5naW54Y29uZlwiXSxjOltlLkhDTSx7YjplLlVJUitcIlxcXFxzXCIsZTpcIjt8e1wiLHJCOiEwLGM6W3tjTjpcInRpdGxlXCIsYjplLlVJUixzdGFydHM6Yn1dLHI6MH1dLGk6XCJbXlxcXFxzXFxcXH1dXCJ9fSk7aGxqcy5yZWdpc3Rlckxhbmd1YWdlKFwieG1sXCIsZnVuY3Rpb24oKXt2YXIgdD1cIltBLVphLXowLTlcXFxcLl86LV0rXCIsZT17YjovPFxcPyhwaHApPyg/IVxcdykvLGU6L1xcPz4vLHNMOlwicGhwXCIsc3ViTGFuZ3VhZ2VNb2RlOlwiY29udGludW91c1wifSxjPXtlVzohMCxpOi88LyxyOjAsYzpbZSx7Y046XCJhdHRyaWJ1dGVcIixiOnQscjowfSx7YjpcIj1cIixyOjAsYzpbe2NOOlwidmFsdWVcIixjOltlXSx2Olt7YjovXCIvLGU6L1wiL30se2I6LycvLGU6LycvfSx7YjovW15cXHNcXC8+XSsvfV19XX1dfTtyZXR1cm57YWxpYXNlczpbXCJodG1sXCIsXCJ4aHRtbFwiLFwicnNzXCIsXCJhdG9tXCIsXCJ4c2xcIixcInBsaXN0XCJdLGNJOiEwLGM6W3tjTjpcImRvY3R5cGVcIixiOlwiPCFET0NUWVBFXCIsZTpcIj5cIixyOjEwLGM6W3tiOlwiXFxcXFtcIixlOlwiXFxcXF1cIn1dfSx7Y046XCJjb21tZW50XCIsYjpcIjwhLS1cIixlOlwiLS0+XCIscjoxMH0se2NOOlwiY2RhdGFcIixiOlwiPFxcXFwhXFxcXFtDREFUQVxcXFxbXCIsZTpcIlxcXFxdXFxcXF0+XCIscjoxMH0se2NOOlwidGFnXCIsYjpcIjxzdHlsZSg/PVxcXFxzfD58JClcIixlOlwiPlwiLGs6e3RpdGxlOlwic3R5bGVcIn0sYzpbY10sc3RhcnRzOntlOlwiPC9zdHlsZT5cIixyRTohMCxzTDpcImNzc1wifX0se2NOOlwidGFnXCIsYjpcIjxzY3JpcHQoPz1cXFxcc3w+fCQpXCIsZTpcIj5cIixrOnt0aXRsZTpcInNjcmlwdFwifSxjOltjXSxzdGFydHM6e2U6XCI8L3NjcmlwdD5cIixyRTohMCxzTDpcImphdmFzY3JpcHRcIn19LGUse2NOOlwicGlcIixiOi88XFw/XFx3Ky8sZTovXFw/Pi8scjoxMH0se2NOOlwidGFnXCIsYjpcIjwvP1wiLGU6XCIvPz5cIixjOlt7Y046XCJ0aXRsZVwiLGI6L1teIFxcLz48XFxuXFx0XSsvLHI6MH0sY119XX19KTtobGpzLnJlZ2lzdGVyTGFuZ3VhZ2UoXCJkaWZmXCIsZnVuY3Rpb24oKXtyZXR1cm57YWxpYXNlczpbXCJwYXRjaFwiXSxjOlt7Y046XCJjaHVua1wiLHI6MTAsdjpbe2I6L15cXEBcXEAgK1xcLVxcZCssXFxkKyArXFwrXFxkKyxcXGQrICtcXEBcXEAkL30se2I6L15cXCpcXCpcXCogK1xcZCssXFxkKyArXFwqXFwqXFwqXFwqJC99LHtiOi9eXFwtXFwtXFwtICtcXGQrLFxcZCsgK1xcLVxcLVxcLVxcLSQvfV19LHtjTjpcImhlYWRlclwiLHY6W3tiOi9JbmRleDogLyxlOi8kL30se2I6Lz09PT09LyxlOi89PT09PSQvfSx7YjovXlxcLVxcLVxcLS8sZTovJC99LHtiOi9eXFwqezN9IC8sZTovJC99LHtiOi9eXFwrXFwrXFwrLyxlOi8kL30se2I6L1xcKns1fS8sZTovXFwqezV9JC99XX0se2NOOlwiYWRkaXRpb25cIixiOlwiXlxcXFwrXCIsZTpcIiRcIn0se2NOOlwiZGVsZXRpb25cIixiOlwiXlxcXFwtXCIsZTpcIiRcIn0se2NOOlwiY2hhbmdlXCIsYjpcIl5cXFxcIVwiLGU6XCIkXCJ9XX19KTtobGpzLnJlZ2lzdGVyTGFuZ3VhZ2UoXCJqYXZhc2NyaXB0XCIsZnVuY3Rpb24ocil7cmV0dXJue2FsaWFzZXM6W1wianNcIl0sazp7a2V5d29yZDpcImluIGlmIGZvciB3aGlsZSBmaW5hbGx5IHZhciBuZXcgZnVuY3Rpb24gZG8gcmV0dXJuIHZvaWQgZWxzZSBicmVhayBjYXRjaCBpbnN0YW5jZW9mIHdpdGggdGhyb3cgY2FzZSBkZWZhdWx0IHRyeSB0aGlzIHN3aXRjaCBjb250aW51ZSB0eXBlb2YgZGVsZXRlIGxldCB5aWVsZCBjb25zdCBjbGFzc1wiLGxpdGVyYWw6XCJ0cnVlIGZhbHNlIG51bGwgdW5kZWZpbmVkIE5hTiBJbmZpbml0eVwiLGJ1aWx0X2luOlwiZXZhbCBpc0Zpbml0ZSBpc05hTiBwYXJzZUZsb2F0IHBhcnNlSW50IGRlY29kZVVSSSBkZWNvZGVVUklDb21wb25lbnQgZW5jb2RlVVJJIGVuY29kZVVSSUNvbXBvbmVudCBlc2NhcGUgdW5lc2NhcGUgT2JqZWN0IEZ1bmN0aW9uIEJvb2xlYW4gRXJyb3IgRXZhbEVycm9yIEludGVybmFsRXJyb3IgUmFuZ2VFcnJvciBSZWZlcmVuY2VFcnJvciBTdG9wSXRlcmF0aW9uIFN5bnRheEVycm9yIFR5cGVFcnJvciBVUklFcnJvciBOdW1iZXIgTWF0aCBEYXRlIFN0cmluZyBSZWdFeHAgQXJyYXkgRmxvYXQzMkFycmF5IEZsb2F0NjRBcnJheSBJbnQxNkFycmF5IEludDMyQXJyYXkgSW50OEFycmF5IFVpbnQxNkFycmF5IFVpbnQzMkFycmF5IFVpbnQ4QXJyYXkgVWludDhDbGFtcGVkQXJyYXkgQXJyYXlCdWZmZXIgRGF0YVZpZXcgSlNPTiBJbnRsIGFyZ3VtZW50cyByZXF1aXJlIG1vZHVsZSBjb25zb2xlIHdpbmRvdyBkb2N1bWVudFwifSxjOlt7Y046XCJwaVwiLHI6MTAsdjpbe2I6L15cXHMqKCd8XCIpdXNlIHN0cmljdCgnfFwiKS99LHtiOi9eXFxzKignfFwiKXVzZSBhc20oJ3xcIikvfV19LHIuQVNNLHIuUVNNLHIuQ0xDTSxyLkNCQ00sci5DTk0se2I6XCIoXCIrci5SU1IrXCJ8XFxcXGIoY2FzZXxyZXR1cm58dGhyb3cpXFxcXGIpXFxcXHMqXCIsazpcInJldHVybiB0aHJvdyBjYXNlXCIsYzpbci5DTENNLHIuQ0JDTSxyLlJNLHtiOi88LyxlOi8+Oy8scjowLHNMOlwieG1sXCJ9XSxyOjB9LHtjTjpcImZ1bmN0aW9uXCIsYks6XCJmdW5jdGlvblwiLGU6L1xcey8sZUU6ITAsYzpbci5pbmhlcml0KHIuVE0se2I6L1tBLVphLXokX11bMC05QS1aYS16JF9dKi99KSx7Y046XCJwYXJhbXNcIixiOi9cXCgvLGU6L1xcKS8sYzpbci5DTENNLHIuQ0JDTV0saTovW1wiJ1xcKF0vfV0saTovXFxbfCUvfSx7YjovXFwkWyguXS99LHtiOlwiXFxcXC5cIityLklSLHI6MH1dfX0pO2hsanMucmVnaXN0ZXJMYW5ndWFnZShcImJhc2hcIixmdW5jdGlvbihlKXt2YXIgdD17Y046XCJ2YXJpYWJsZVwiLHY6W3tiOi9cXCRbXFx3XFxkI0BdW1xcd1xcZF9dKi99LHtiOi9cXCRcXHsoLio/KVxcfS99XX0scz17Y046XCJzdHJpbmdcIixiOi9cIi8sZTovXCIvLGM6W2UuQkUsdCx7Y046XCJ2YXJpYWJsZVwiLGI6L1xcJFxcKC8sZTovXFwpLyxjOltlLkJFXX1dfSxhPXtjTjpcInN0cmluZ1wiLGI6LycvLGU6LycvfTtyZXR1cm57YWxpYXNlczpbXCJzaFwiLFwienNoXCJdLGw6Ly0/W2EtelxcLl0rLyxrOntrZXl3b3JkOlwiaWYgdGhlbiBlbHNlIGVsaWYgZmkgZm9yIHdoaWxlIGluIGRvIGRvbmUgY2FzZSBlc2FjIGZ1bmN0aW9uXCIsbGl0ZXJhbDpcInRydWUgZmFsc2VcIixidWlsdF9pbjpcImJyZWFrIGNkIGNvbnRpbnVlIGV2YWwgZXhlYyBleGl0IGV4cG9ydCBnZXRvcHRzIGhhc2ggcHdkIHJlYWRvbmx5IHJldHVybiBzaGlmdCB0ZXN0IHRpbWVzIHRyYXAgdW1hc2sgdW5zZXQgYWxpYXMgYmluZCBidWlsdGluIGNhbGxlciBjb21tYW5kIGRlY2xhcmUgZWNobyBlbmFibGUgaGVscCBsZXQgbG9jYWwgbG9nb3V0IG1hcGZpbGUgcHJpbnRmIHJlYWQgcmVhZGFycmF5IHNvdXJjZSB0eXBlIHR5cGVzZXQgdWxpbWl0IHVuYWxpYXMgc2V0IHNob3B0IGF1dG9sb2FkIGJnIGJpbmRrZXkgYnllIGNhcCBjaGRpciBjbG9uZSBjb21wYXJndW1lbnRzIGNvbXBjYWxsIGNvbXBjdGwgY29tcGRlc2NyaWJlIGNvbXBmaWxlcyBjb21wZ3JvdXBzIGNvbXBxdW90ZSBjb21wdGFncyBjb21wdHJ5IGNvbXB2YWx1ZXMgZGlycyBkaXNhYmxlIGRpc293biBlY2hvdGMgZWNob3RpIGVtdWxhdGUgZmMgZmcgZmxvYXQgZnVuY3Rpb25zIGdldGNhcCBnZXRsbiBoaXN0b3J5IGludGVnZXIgam9icyBraWxsIGxpbWl0IGxvZyBub2dsb2IgcG9wZCBwcmludCBwdXNoZCBwdXNobG4gcmVoYXNoIHNjaGVkIHNldGNhcCBzZXRvcHQgc3RhdCBzdXNwZW5kIHR0eWN0bCB1bmZ1bmN0aW9uIHVuaGFzaCB1bmxpbWl0IHVuc2V0b3B0IHZhcmVkIHdhaXQgd2hlbmNlIHdoZXJlIHdoaWNoIHpjb21waWxlIHpmb3JtYXQgemZ0cCB6bGUgem1vZGxvYWQgenBhcnNlb3B0cyB6cHJvZiB6cHR5IHpyZWdleHBhcnNlIHpzb2NrZXQgenN0eWxlIHp0Y3BcIixvcGVyYXRvcjpcIi1uZSAtZXEgLWx0IC1ndCAtZiAtZCAtZSAtcyAtbCAtYVwifSxjOlt7Y046XCJzaGViYW5nXCIsYjovXiMhW15cXG5dK3NoXFxzKiQvLHI6MTB9LHtjTjpcImZ1bmN0aW9uXCIsYjovXFx3W1xcd1xcZF9dKlxccypcXChcXHMqXFwpXFxzKlxcey8sckI6ITAsYzpbZS5pbmhlcml0KGUuVE0se2I6L1xcd1tcXHdcXGRfXSovfSldLHI6MH0sZS5IQ00sZS5OTSxzLGEsdF19fSk7aGxqcy5yZWdpc3Rlckxhbmd1YWdlKFwib2JqZWN0aXZlY1wiLGZ1bmN0aW9uKGUpe3ZhciB0PXtrZXl3b3JkOlwiaW50IGZsb2F0IHdoaWxlIGNoYXIgZXhwb3J0IHNpemVvZiB0eXBlZGVmIGNvbnN0IHN0cnVjdCBmb3IgdW5pb24gdW5zaWduZWQgbG9uZyB2b2xhdGlsZSBzdGF0aWMgYm9vbCBtdXRhYmxlIGlmIGRvIHJldHVybiBnb3RvIHZvaWQgZW51bSBlbHNlIGJyZWFrIGV4dGVybiBhc20gY2FzZSBzaG9ydCBkZWZhdWx0IGRvdWJsZSByZWdpc3RlciBleHBsaWNpdCBzaWduZWQgdHlwZW5hbWUgdGhpcyBzd2l0Y2ggY29udGludWUgd2NoYXJfdCBpbmxpbmUgcmVhZG9ubHkgYXNzaWduIHJlYWR3cml0ZSBzZWxmIEBzeW5jaHJvbml6ZWQgaWQgdHlwZW9mIG5vbmF0b21pYyBzdXBlciB1bmljaGFyIElCT3V0bGV0IElCQWN0aW9uIHN0cm9uZyB3ZWFrIGNvcHkgaW4gb3V0IGlub3V0IGJ5Y29weSBieXJlZiBvbmV3YXkgX19zdHJvbmcgX193ZWFrIF9fYmxvY2sgX19hdXRvcmVsZWFzaW5nIEBwcml2YXRlIEBwcm90ZWN0ZWQgQHB1YmxpYyBAdHJ5IEBwcm9wZXJ0eSBAZW5kIEB0aHJvdyBAY2F0Y2ggQGZpbmFsbHkgQGF1dG9yZWxlYXNlcG9vbCBAc3ludGhlc2l6ZSBAZHluYW1pYyBAc2VsZWN0b3IgQG9wdGlvbmFsIEByZXF1aXJlZFwiLGxpdGVyYWw6XCJmYWxzZSB0cnVlIEZBTFNFIFRSVUUgbmlsIFlFUyBOTyBOVUxMXCIsYnVpbHRfaW46XCJOU1N0cmluZyBOU0RhdGEgTlNEaWN0aW9uYXJ5IENHUmVjdCBDR1BvaW50IFVJQnV0dG9uIFVJTGFiZWwgVUlUZXh0VmlldyBVSVdlYlZpZXcgTUtNYXBWaWV3IE5TVmlldyBOU1ZpZXdDb250cm9sbGVyIE5TV2luZG93IE5TV2luZG93Q29udHJvbGxlciBOU1NldCBOU1VVSUQgTlNJbmRleFNldCBVSVNlZ21lbnRlZENvbnRyb2wgTlNPYmplY3QgVUlUYWJsZVZpZXdEZWxlZ2F0ZSBVSVRhYmxlVmlld0RhdGFTb3VyY2UgTlNUaHJlYWQgVUlBY3Rpdml0eUluZGljYXRvciBVSVRhYmJhciBVSVRvb2xCYXIgVUlCYXJCdXR0b25JdGVtIFVJSW1hZ2VWaWV3IE5TQXV0b3JlbGVhc2VQb29sIFVJVGFibGVWaWV3IEJPT0wgTlNJbnRlZ2VyIENHRmxvYXQgTlNFeGNlcHRpb24gTlNMb2cgTlNNdXRhYmxlU3RyaW5nIE5TTXV0YWJsZUFycmF5IE5TTXV0YWJsZURpY3Rpb25hcnkgTlNVUkwgTlNJbmRleFBhdGggQ0dTaXplIFVJVGFibGVWaWV3Q2VsbCBVSVZpZXcgVUlWaWV3Q29udHJvbGxlciBVSU5hdmlnYXRpb25CYXIgVUlOYXZpZ2F0aW9uQ29udHJvbGxlciBVSVRhYkJhckNvbnRyb2xsZXIgVUlQb3BvdmVyQ29udHJvbGxlciBVSVBvcG92ZXJDb250cm9sbGVyRGVsZWdhdGUgVUlJbWFnZSBOU051bWJlciBVSVNlYXJjaEJhciBOU0ZldGNoZWRSZXN1bHRzQ29udHJvbGxlciBOU0ZldGNoZWRSZXN1bHRzQ2hhbmdlVHlwZSBVSVNjcm9sbFZpZXcgVUlTY3JvbGxWaWV3RGVsZWdhdGUgVUlFZGdlSW5zZXRzIFVJQ29sb3IgVUlGb250IFVJQXBwbGljYXRpb24gTlNOb3RGb3VuZCBOU05vdGlmaWNhdGlvbkNlbnRlciBOU05vdGlmaWNhdGlvbiBVSUxvY2FsTm90aWZpY2F0aW9uIE5TQnVuZGxlIE5TRmlsZU1hbmFnZXIgTlNUaW1lSW50ZXJ2YWwgTlNEYXRlIE5TQ2FsZW5kYXIgTlNVc2VyRGVmYXVsdHMgVUlXaW5kb3cgTlNSYW5nZSBOU0FycmF5IE5TRXJyb3IgTlNVUkxSZXF1ZXN0IE5TVVJMQ29ubmVjdGlvbiBOU1VSTFNlc3Npb24gTlNVUkxTZXNzaW9uRGF0YVRhc2sgTlNVUkxTZXNzaW9uRG93bmxvYWRUYXNrIE5TVVJMU2Vzc2lvblVwbG9hZFRhc2sgTlNVUkxSZXNwb25zZVVJSW50ZXJmYWNlT3JpZW50YXRpb24gTVBNb3ZpZVBsYXllckNvbnRyb2xsZXIgZGlzcGF0Y2hfb25jZV90IGRpc3BhdGNoX3F1ZXVlX3QgZGlzcGF0Y2hfc3luYyBkaXNwYXRjaF9hc3luYyBkaXNwYXRjaF9vbmNlXCJ9LG89L1thLXpBLVpAXVthLXpBLVowLTlfXSovLGE9XCJAaW50ZXJmYWNlIEBjbGFzcyBAcHJvdG9jb2wgQGltcGxlbWVudGF0aW9uXCI7cmV0dXJue2FsaWFzZXM6W1wibVwiLFwibW1cIixcIm9iamNcIixcIm9iai1jXCJdLGs6dCxsOm8saTpcIjwvXCIsYzpbZS5DTENNLGUuQ0JDTSxlLkNOTSxlLlFTTSx7Y046XCJzdHJpbmdcIix2Olt7YjonQFwiJyxlOidcIicsaTpcIlxcXFxuXCIsYzpbZS5CRV19LHtiOlwiJ1wiLGU6XCJbXlxcXFxcXFxcXSdcIixpOlwiW15cXFxcXFxcXF1bXiddXCJ9XX0se2NOOlwicHJlcHJvY2Vzc29yXCIsYjpcIiNcIixlOlwiJFwiLGM6W3tjTjpcInRpdGxlXCIsdjpbe2I6J1wiJyxlOidcIid9LHtiOlwiPFwiLGU6XCI+XCJ9XX1dfSx7Y046XCJjbGFzc1wiLGI6XCIoXCIrYS5zcGxpdChcIiBcIikuam9pbihcInxcIikrXCIpXFxcXGJcIixlOlwiKHt8JClcIixlRTohMCxrOmEsbDpvLGM6W2UuVVRNXX0se2NOOlwidmFyaWFibGVcIixiOlwiXFxcXC5cIitlLlVJUixyOjB9XX19KTtobGpzLnJlZ2lzdGVyTGFuZ3VhZ2UoXCJtYXJrZG93blwiLGZ1bmN0aW9uKCl7cmV0dXJue2FsaWFzZXM6W1wibWRcIixcIm1rZG93blwiLFwibWtkXCJdLGM6W3tjTjpcImhlYWRlclwiLHY6W3tiOlwiXiN7MSw2fVwiLGU6XCIkXCJ9LHtiOlwiXi4rP1xcXFxuWz0tXXsyLH0kXCJ9XX0se2I6XCI8XCIsZTpcIj5cIixzTDpcInhtbFwiLHI6MH0se2NOOlwiYnVsbGV0XCIsYjpcIl4oWyorLV18KFxcXFxkK1xcXFwuKSlcXFxccytcIn0se2NOOlwic3Ryb25nXCIsYjpcIlsqX117Mn0uKz9bKl9dezJ9XCJ9LHtjTjpcImVtcGhhc2lzXCIsdjpbe2I6XCJcXFxcKi4rP1xcXFwqXCJ9LHtiOlwiXy4rP19cIixyOjB9XX0se2NOOlwiYmxvY2txdW90ZVwiLGI6XCJePlxcXFxzK1wiLGU6XCIkXCJ9LHtjTjpcImNvZGVcIix2Olt7YjpcImAuKz9gXCJ9LHtiOlwiXiggezR9fFx0KVwiLGU6XCIkXCIscjowfV19LHtjTjpcImhvcml6b250YWxfcnVsZVwiLGI6XCJeWy1cXFxcKl17Myx9XCIsZTpcIiRcIn0se2I6XCJcXFxcWy4rP1xcXFxdW1xcXFwoXFxcXFtdLio/W1xcXFwpXFxcXF1dXCIsckI6ITAsYzpbe2NOOlwibGlua19sYWJlbFwiLGI6XCJcXFxcW1wiLGU6XCJcXFxcXVwiLGVCOiEwLHJFOiEwLHI6MH0se2NOOlwibGlua191cmxcIixiOlwiXFxcXF1cXFxcKFwiLGU6XCJcXFxcKVwiLGVCOiEwLGVFOiEwfSx7Y046XCJsaW5rX3JlZmVyZW5jZVwiLGI6XCJcXFxcXVxcXFxbXCIsZTpcIlxcXFxdXCIsZUI6ITAsZUU6ITB9XSxyOjEwfSx7YjpcIl5cXFxcWy4rXFxcXF06XCIsckI6ITAsYzpbe2NOOlwibGlua19yZWZlcmVuY2VcIixiOlwiXFxcXFtcIixlOlwiXFxcXF06XCIsZUI6ITAsZUU6ITAsc3RhcnRzOntjTjpcImxpbmtfdXJsXCIsZTpcIiRcIn19XX1dfX0pO2hsanMucmVnaXN0ZXJMYW5ndWFnZShcImpzb25cIixmdW5jdGlvbihlKXt2YXIgdD17bGl0ZXJhbDpcInRydWUgZmFsc2UgbnVsbFwifSxpPVtlLlFTTSxlLkNOTV0sbD17Y046XCJ2YWx1ZVwiLGU6XCIsXCIsZVc6ITAsZUU6ITAsYzppLGs6dH0sYz17YjpcIntcIixlOlwifVwiLGM6W3tjTjpcImF0dHJpYnV0ZVwiLGI6J1xcXFxzKlwiJyxlOidcIlxcXFxzKjpcXFxccyonLGVCOiEwLGVFOiEwLGM6W2UuQkVdLGk6XCJcXFxcblwiLHN0YXJ0czpsfV0saTpcIlxcXFxTXCJ9LG49e2I6XCJcXFxcW1wiLGU6XCJcXFxcXVwiLGM6W2UuaW5oZXJpdChsLHtjTjpudWxsfSldLGk6XCJcXFxcU1wifTtyZXR1cm4gaS5zcGxpY2UoaS5sZW5ndGgsMCxjLG4pLHtjOmksazp0LGk6XCJcXFxcU1wifX0pO2hsanMucmVnaXN0ZXJMYW5ndWFnZShcInB5dGhvblwiLGZ1bmN0aW9uKGUpe3ZhciByPXtjTjpcInByb21wdFwiLGI6L14oPj4+fFxcLlxcLlxcLikgL30sYj17Y046XCJzdHJpbmdcIixjOltlLkJFXSx2Olt7YjovKHV8Yik/cj8nJycvLGU6LycnJy8sYzpbcl0scjoxMH0se2I6Lyh1fGIpP3I/XCJcIlwiLyxlOi9cIlwiXCIvLGM6W3JdLHI6MTB9LHtiOi8odXxyfHVyKScvLGU6LycvLHI6MTB9LHtiOi8odXxyfHVyKVwiLyxlOi9cIi8scjoxMH0se2I6LyhifGJyKScvLGU6LycvfSx7YjovKGJ8YnIpXCIvLGU6L1wiL30sZS5BU00sZS5RU01dfSxsPXtjTjpcIm51bWJlclwiLHI6MCx2Olt7YjplLkJOUitcIltsTGpKXT9cIn0se2I6XCJcXFxcYigwb1swLTddKylbbExqSl0/XCJ9LHtiOmUuQ05SK1wiW2xMakpdP1wifV19LGM9e2NOOlwicGFyYW1zXCIsYjovXFwoLyxlOi9cXCkvLGM6W1wic2VsZlwiLHIsbCxiXX07cmV0dXJue2FsaWFzZXM6W1wicHlcIixcImd5cFwiXSxrOntrZXl3b3JkOlwiYW5kIGVsaWYgaXMgZ2xvYmFsIGFzIGluIGlmIGZyb20gcmFpc2UgZm9yIGV4Y2VwdCBmaW5hbGx5IHByaW50IGltcG9ydCBwYXNzIHJldHVybiBleGVjIGVsc2UgYnJlYWsgbm90IHdpdGggY2xhc3MgYXNzZXJ0IHlpZWxkIHRyeSB3aGlsZSBjb250aW51ZSBkZWwgb3IgZGVmIGxhbWJkYSBub25sb2NhbHwxMCBOb25lIFRydWUgRmFsc2VcIixidWlsdF9pbjpcIkVsbGlwc2lzIE5vdEltcGxlbWVudGVkXCJ9LGk6Lyg8XFwvfC0+fFxcPykvLGM6W3IsbCxiLGUuSENNLHt2Olt7Y046XCJmdW5jdGlvblwiLGJLOlwiZGVmXCIscjoxMH0se2NOOlwiY2xhc3NcIixiSzpcImNsYXNzXCJ9XSxlOi86LyxpOi9bJHs9O1xcbl0vLGM6W2UuVVRNLGNdfSx7Y046XCJkZWNvcmF0b3JcIixiOi9ALyxlOi8kL30se2I6L1xcYihwcmludHxleGVjKVxcKC99XX19KTtobGpzLnJlZ2lzdGVyTGFuZ3VhZ2UoXCJydWJ5XCIsZnVuY3Rpb24oZSl7dmFyIGI9XCJbYS16QS1aX11cXFxcdypbIT89XT98Wy0rfl1cXFxcQHw8PHw+Pnw9fnw9PT0/fDw9PnxbPD5dPT98XFxcXCpcXFxcKnxbLS8rJV4mKn5gfF18XFxcXFtcXFxcXT0/XCIscj1cImFuZCBmYWxzZSB0aGVuIGRlZmluZWQgbW9kdWxlIGluIHJldHVybiByZWRvIGlmIEJFR0lOIHJldHJ5IGVuZCBmb3IgdHJ1ZSBzZWxmIHdoZW4gbmV4dCB1bnRpbCBkbyBiZWdpbiB1bmxlc3MgRU5EIHJlc2N1ZSBuaWwgZWxzZSBicmVhayB1bmRlZiBub3Qgc3VwZXIgY2xhc3MgY2FzZSByZXF1aXJlIHlpZWxkIGFsaWFzIHdoaWxlIGVuc3VyZSBlbHNpZiBvciBpbmNsdWRlIGF0dHJfcmVhZGVyIGF0dHJfd3JpdGVyIGF0dHJfYWNjZXNzb3JcIixjPXtjTjpcInlhcmRvY3RhZ1wiLGI6XCJAW0EtWmEtel0rXCJ9LGE9e2NOOlwidmFsdWVcIixiOlwiIzxcIixlOlwiPlwifSxzPXtjTjpcImNvbW1lbnRcIix2Olt7YjpcIiNcIixlOlwiJFwiLGM6W2NdfSx7YjpcIl5cXFxcPWJlZ2luXCIsZTpcIl5cXFxcPWVuZFwiLGM6W2NdLHI6MTB9LHtiOlwiXl9fRU5EX19cIixlOlwiXFxcXG4kXCJ9XX0sbj17Y046XCJzdWJzdFwiLGI6XCIjXFxcXHtcIixlOlwifVwiLGs6cn0sdD17Y046XCJzdHJpbmdcIixjOltlLkJFLG5dLHY6W3tiOi8nLyxlOi8nL30se2I6L1wiLyxlOi9cIi99LHtiOi9gLyxlOi9gL30se2I6XCIlW3FRd1d4XT9cXFxcKFwiLGU6XCJcXFxcKVwifSx7YjpcIiVbcVF3V3hdP1xcXFxbXCIsZTpcIlxcXFxdXCJ9LHtiOlwiJVtxUXdXeF0/e1wiLGU6XCJ9XCJ9LHtiOlwiJVtxUXdXeF0/PFwiLGU6XCI+XCJ9LHtiOlwiJVtxUXdXeF0/L1wiLGU6XCIvXCJ9LHtiOlwiJVtxUXdXeF0/JVwiLGU6XCIlXCJ9LHtiOlwiJVtxUXdXeF0/LVwiLGU6XCItXCJ9LHtiOlwiJVtxUXdXeF0/XFxcXHxcIixlOlwiXFxcXHxcIn0se2I6L1xcQlxcPyhcXFxcXFxkezEsM318XFxcXHhbQS1GYS1mMC05XXsxLDJ9fFxcXFx1W0EtRmEtZjAtOV17NH18XFxcXD9cXFMpXFxiL31dfSxpPXtjTjpcInBhcmFtc1wiLGI6XCJcXFxcKFwiLGU6XCJcXFxcKVwiLGs6cn0sZD1bdCxhLHMse2NOOlwiY2xhc3NcIixiSzpcImNsYXNzIG1vZHVsZVwiLGU6XCIkfDtcIixpOi89LyxjOltlLmluaGVyaXQoZS5UTSx7YjpcIltBLVphLXpfXVxcXFx3Kig6OlxcXFx3KykqKFxcXFw/fFxcXFwhKT9cIn0pLHtjTjpcImluaGVyaXRhbmNlXCIsYjpcIjxcXFxccypcIixjOlt7Y046XCJwYXJlbnRcIixiOlwiKFwiK2UuSVIrXCI6Oik/XCIrZS5JUn1dfSxzXX0se2NOOlwiZnVuY3Rpb25cIixiSzpcImRlZlwiLGU6XCIgfCR8O1wiLHI6MCxjOltlLmluaGVyaXQoZS5UTSx7YjpifSksaSxzXX0se2NOOlwiY29uc3RhbnRcIixiOlwiKDo6KT8oXFxcXGJbQS1aXVxcXFx3Kig6Oik/KStcIixyOjB9LHtjTjpcInN5bWJvbFwiLGI6ZS5VSVIrXCIoXFxcXCF8XFxcXD8pPzpcIixyOjB9LHtjTjpcInN5bWJvbFwiLGI6XCI6XCIsYzpbdCx7YjpifV0scjowfSx7Y046XCJudW1iZXJcIixiOlwiKFxcXFxiMFswLTdfXSspfChcXFxcYjB4WzAtOWEtZkEtRl9dKyl8KFxcXFxiWzEtOV1bMC05X10qKFxcXFwuWzAtOV9dKyk/KXxbMF9dXFxcXGJcIixyOjB9LHtjTjpcInZhcmlhYmxlXCIsYjpcIihcXFxcJFxcXFxXKXwoKFxcXFwkfFxcXFxAXFxcXEA/KShcXFxcdyspKVwifSx7YjpcIihcIitlLlJTUitcIilcXFxccypcIixjOlthLHMse2NOOlwicmVnZXhwXCIsYzpbZS5CRSxuXSxpOi9cXG4vLHY6W3tiOlwiL1wiLGU6XCIvW2Etel0qXCJ9LHtiOlwiJXJ7XCIsZTpcIn1bYS16XSpcIn0se2I6XCIlclxcXFwoXCIsZTpcIlxcXFwpW2Etel0qXCJ9LHtiOlwiJXIhXCIsZTpcIiFbYS16XSpcIn0se2I6XCIlclxcXFxbXCIsZTpcIlxcXFxdW2Etel0qXCJ9XX1dLHI6MH1dO24uYz1kLGkuYz1kO3ZhciBsPVwiWz4/XT5cIix1PVwiW1xcXFx3I10rXFxcXChcXFxcdytcXFxcKTpcXFxcZCs6XFxcXGQrPlwiLE49XCIoXFxcXHcrLSk/XFxcXGQrXFxcXC5cXFxcZCtcXFxcLlxcXFxkKHBcXFxcZCspP1tePl0rPlwiLG89W3tiOi9eXFxzKj0+LyxjTjpcInN0YXR1c1wiLHN0YXJ0czp7ZTpcIiRcIixjOmR9fSx7Y046XCJwcm9tcHRcIixiOlwiXihcIitsK1wifFwiK3UrXCJ8XCIrTitcIilcIixzdGFydHM6e2U6XCIkXCIsYzpkfX1dO3JldHVybnthbGlhc2VzOltcInJiXCIsXCJnZW1zcGVjXCIsXCJwb2RzcGVjXCIsXCJ0aG9yXCIsXCJpcmJcIl0sazpyLGM6W3NdLmNvbmNhdChvKS5jb25jYXQoZCl9fSk7aGxqcy5yZWdpc3Rlckxhbmd1YWdlKFwiY3BwXCIsZnVuY3Rpb24odCl7dmFyIGk9e2tleXdvcmQ6XCJmYWxzZSBpbnQgZmxvYXQgd2hpbGUgcHJpdmF0ZSBjaGFyIGNhdGNoIGV4cG9ydCB2aXJ0dWFsIG9wZXJhdG9yIHNpemVvZiBkeW5hbWljX2Nhc3R8MTAgdHlwZWRlZiBjb25zdF9jYXN0fDEwIGNvbnN0IHN0cnVjdCBmb3Igc3RhdGljX2Nhc3R8MTAgdW5pb24gbmFtZXNwYWNlIHVuc2lnbmVkIGxvbmcgdm9sYXRpbGUgc3RhdGljIHByb3RlY3RlZCBib29sIHRlbXBsYXRlIG11dGFibGUgaWYgcHVibGljIGZyaWVuZCBkbyBnb3RvIGF1dG8gdm9pZCBlbnVtIGVsc2UgYnJlYWsgZXh0ZXJuIHVzaW5nIHRydWUgY2xhc3MgYXNtIGNhc2UgdHlwZWlkIHNob3J0IHJlaW50ZXJwcmV0X2Nhc3R8MTAgZGVmYXVsdCBkb3VibGUgcmVnaXN0ZXIgZXhwbGljaXQgc2lnbmVkIHR5cGVuYW1lIHRyeSB0aGlzIHN3aXRjaCBjb250aW51ZSB3Y2hhcl90IGlubGluZSBkZWxldGUgYWxpZ25vZiBjaGFyMTZfdCBjaGFyMzJfdCBjb25zdGV4cHIgZGVjbHR5cGUgbm9leGNlcHQgbnVsbHB0ciBzdGF0aWNfYXNzZXJ0IHRocmVhZF9sb2NhbCByZXN0cmljdCBfQm9vbCBjb21wbGV4IF9Db21wbGV4IF9JbWFnaW5hcnlpbnRtYXhfdCB1aW50bWF4X3QgaW50OF90IHVpbnQ4X3QgaW50MTZfdCB1aW50MTZfdCBpbnQzMl90IHVpbnQzMl90ICBpbnQ2NF90IHVpbnQ2NF90aW50X2xlYXN0OF90IHVpbnRfbGVhc3Q4X3QgaW50X2xlYXN0MTZfdCB1aW50X2xlYXN0MTZfdCBpbnRfbGVhc3QzMl90IHVpbnRfbGVhc3QzMl90aW50X2xlYXN0NjRfdCB1aW50X2xlYXN0NjRfdCBpbnRfZmFzdDhfdCB1aW50X2Zhc3Q4X3QgaW50X2Zhc3QxNl90IHVpbnRfZmFzdDE2X3QgaW50X2Zhc3QzMl90dWludF9mYXN0MzJfdCBpbnRfZmFzdDY0X3QgdWludF9mYXN0NjRfdCBpbnRwdHJfdCB1aW50cHRyX3QgYXRvbWljX2Jvb2wgYXRvbWljX2NoYXIgYXRvbWljX3NjaGFyYXRvbWljX3VjaGFyIGF0b21pY19zaG9ydCBhdG9taWNfdXNob3J0IGF0b21pY19pbnQgYXRvbWljX3VpbnQgYXRvbWljX2xvbmcgYXRvbWljX3Vsb25nIGF0b21pY19sbG9uZ2F0b21pY191bGxvbmcgYXRvbWljX3djaGFyX3QgYXRvbWljX2NoYXIxNl90IGF0b21pY19jaGFyMzJfdCBhdG9taWNfaW50bWF4X3QgYXRvbWljX3VpbnRtYXhfdGF0b21pY19pbnRwdHJfdCBhdG9taWNfdWludHB0cl90IGF0b21pY19zaXplX3QgYXRvbWljX3B0cmRpZmZfdCBhdG9taWNfaW50X2xlYXN0OF90IGF0b21pY19pbnRfbGVhc3QxNl90YXRvbWljX2ludF9sZWFzdDMyX3QgYXRvbWljX2ludF9sZWFzdDY0X3QgYXRvbWljX3VpbnRfbGVhc3Q4X3QgYXRvbWljX3VpbnRfbGVhc3QxNl90IGF0b21pY191aW50X2xlYXN0MzJfdGF0b21pY191aW50X2xlYXN0NjRfdCBhdG9taWNfaW50X2Zhc3Q4X3QgYXRvbWljX2ludF9mYXN0MTZfdCBhdG9taWNfaW50X2Zhc3QzMl90IGF0b21pY19pbnRfZmFzdDY0X3RhdG9taWNfdWludF9mYXN0OF90IGF0b21pY191aW50X2Zhc3QxNl90IGF0b21pY191aW50X2Zhc3QzMl90IGF0b21pY191aW50X2Zhc3Q2NF90XCIsYnVpbHRfaW46XCJzdGQgc3RyaW5nIGNpbiBjb3V0IGNlcnIgY2xvZyBzdHJpbmdzdHJlYW0gaXN0cmluZ3N0cmVhbSBvc3RyaW5nc3RyZWFtIGF1dG9fcHRyIGRlcXVlIGxpc3QgcXVldWUgc3RhY2sgdmVjdG9yIG1hcCBzZXQgYml0c2V0IG11bHRpc2V0IG11bHRpbWFwIHVub3JkZXJlZF9zZXQgdW5vcmRlcmVkX21hcCB1bm9yZGVyZWRfbXVsdGlzZXQgdW5vcmRlcmVkX211bHRpbWFwIGFycmF5IHNoYXJlZF9wdHIgYWJvcnQgYWJzIGFjb3MgYXNpbiBhdGFuMiBhdGFuIGNhbGxvYyBjZWlsIGNvc2ggY29zIGV4aXQgZXhwIGZhYnMgZmxvb3IgZm1vZCBmcHJpbnRmIGZwdXRzIGZyZWUgZnJleHAgZnNjYW5mIGlzYWxudW0gaXNhbHBoYSBpc2NudHJsIGlzZGlnaXQgaXNncmFwaCBpc2xvd2VyIGlzcHJpbnQgaXNwdW5jdCBpc3NwYWNlIGlzdXBwZXIgaXN4ZGlnaXQgdG9sb3dlciB0b3VwcGVyIGxhYnMgbGRleHAgbG9nMTAgbG9nIG1hbGxvYyBtZW1jaHIgbWVtY21wIG1lbWNweSBtZW1zZXQgbW9kZiBwb3cgcHJpbnRmIHB1dGNoYXIgcHV0cyBzY2FuZiBzaW5oIHNpbiBzbnByaW50ZiBzcHJpbnRmIHNxcnQgc3NjYW5mIHN0cmNhdCBzdHJjaHIgc3RyY21wIHN0cmNweSBzdHJjc3BuIHN0cmxlbiBzdHJuY2F0IHN0cm5jbXAgc3RybmNweSBzdHJwYnJrIHN0cnJjaHIgc3Ryc3BuIHN0cnN0ciB0YW5oIHRhbiB2ZnByaW50ZiB2cHJpbnRmIHZzcHJpbnRmXCJ9O3JldHVybnthbGlhc2VzOltcImNcIixcImhcIixcImMrK1wiLFwiaCsrXCJdLGs6aSxpOlwiPC9cIixjOlt0LkNMQ00sdC5DQkNNLHQuUVNNLHtjTjpcInN0cmluZ1wiLGI6XCInXFxcXFxcXFw/LlwiLGU6XCInXCIsaTpcIi5cIn0se2NOOlwibnVtYmVyXCIsYjpcIlxcXFxiKFxcXFxkKyhcXFxcLlxcXFxkKik/fFxcXFwuXFxcXGQrKSh1fFV8bHxMfHVsfFVMfGZ8RilcIn0sdC5DTk0se2NOOlwicHJlcHJvY2Vzc29yXCIsYjpcIiNcIixlOlwiJFwiLGs6XCJpZiBlbHNlIGVsaWYgZW5kaWYgZGVmaW5lIHVuZGVmIHdhcm5pbmcgZXJyb3IgbGluZSBwcmFnbWFcIixjOlt7YjonaW5jbHVkZVxcXFxzKls8XCJdJyxlOidbPlwiXScsazpcImluY2x1ZGVcIixpOlwiXFxcXG5cIn0sdC5DTENNXX0se2NOOlwic3RsX2NvbnRhaW5lclwiLGI6XCJcXFxcYihkZXF1ZXxsaXN0fHF1ZXVlfHN0YWNrfHZlY3RvcnxtYXB8c2V0fGJpdHNldHxtdWx0aXNldHxtdWx0aW1hcHx1bm9yZGVyZWRfbWFwfHVub3JkZXJlZF9zZXR8dW5vcmRlcmVkX211bHRpc2V0fHVub3JkZXJlZF9tdWx0aW1hcHxhcnJheSlcXFxccyo8XCIsZTpcIj5cIixrOmksYzpbXCJzZWxmXCJdfSx7Yjp0LklSK1wiOjpcIn0se2JLOlwibmV3IHRocm93IHJldHVyblwiLHI6MH0se2NOOlwiZnVuY3Rpb25cIixiOlwiKFwiK3QuSVIrXCJcXFxccyspK1wiK3QuSVIrXCJcXFxccypcXFxcKFwiLHJCOiEwLGU6L1t7Oz1dLyxlRTohMCxrOmksYzpbe2I6dC5JUitcIlxcXFxzKlxcXFwoXCIsckI6ITAsYzpbdC5UTV0scjowfSx7Y046XCJwYXJhbXNcIixiOi9cXCgvLGU6L1xcKS8sazppLHI6MCxjOlt0LkNCQ01dfSx0LkNMQ00sdC5DQkNNXX1dfX0pO2hsanMucmVnaXN0ZXJMYW5ndWFnZShcImNzc1wiLGZ1bmN0aW9uKGUpe3ZhciBjPVwiW2EtekEtWi1dW2EtekEtWjAtOV8tXSpcIixhPXtjTjpcImZ1bmN0aW9uXCIsYjpjK1wiXFxcXChcIixyQjohMCxlRTohMCxlOlwiXFxcXChcIn07cmV0dXJue2NJOiEwLGk6XCJbPS98J11cIixjOltlLkNCQ00se2NOOlwiaWRcIixiOlwiXFxcXCNbQS1aYS16MC05Xy1dK1wifSx7Y046XCJjbGFzc1wiLGI6XCJcXFxcLltBLVphLXowLTlfLV0rXCIscjowfSx7Y046XCJhdHRyX3NlbGVjdG9yXCIsYjpcIlxcXFxbXCIsZTpcIlxcXFxdXCIsaTpcIiRcIn0se2NOOlwicHNldWRvXCIsYjpcIjooOik/W2EtekEtWjAtOVxcXFxfXFxcXC1cXFxcK1xcXFwoXFxcXClcXFxcXFxcIlxcXFwnXStcIn0se2NOOlwiYXRfcnVsZVwiLGI6XCJAKGZvbnQtZmFjZXxwYWdlKVwiLGw6XCJbYS16LV0rXCIsazpcImZvbnQtZmFjZSBwYWdlXCJ9LHtjTjpcImF0X3J1bGVcIixiOlwiQFwiLGU6XCJbeztdXCIsYzpbe2NOOlwia2V5d29yZFwiLGI6L1xcUysvfSx7YjovXFxzLyxlVzohMCxlRTohMCxyOjAsYzpbYSxlLkFTTSxlLlFTTSxlLkNTU05NXX1dfSx7Y046XCJ0YWdcIixiOmMscjowfSx7Y046XCJydWxlc1wiLGI6XCJ7XCIsZTpcIn1cIixpOlwiW15cXFxcc11cIixyOjAsYzpbZS5DQkNNLHtjTjpcInJ1bGVcIixiOlwiW15cXFxcc11cIixyQjohMCxlOlwiO1wiLGVXOiEwLGM6W3tjTjpcImF0dHJpYnV0ZVwiLGI6XCJbQS1aXFxcXF9cXFxcLlxcXFwtXStcIixlOlwiOlwiLGVFOiEwLGk6XCJbXlxcXFxzXVwiLHN0YXJ0czp7Y046XCJ2YWx1ZVwiLGVXOiEwLGVFOiEwLGM6W2EsZS5DU1NOTSxlLlFTTSxlLkFTTSxlLkNCQ00se2NOOlwiaGV4Y29sb3JcIixiOlwiI1swLTlBLUZhLWZdK1wifSx7Y046XCJpbXBvcnRhbnRcIixiOlwiIWltcG9ydGFudFwifV19fV19XX1dfX0pO2hsanMucmVnaXN0ZXJMYW5ndWFnZShcInBocFwiLGZ1bmN0aW9uKGUpe3ZhciBjPXtjTjpcInZhcmlhYmxlXCIsYjpcIlxcXFwkK1thLXpBLVpffy3Dv11bYS16QS1aMC05X38tw79dKlwifSxpPXtjTjpcInByZXByb2Nlc3NvclwiLGI6LzxcXD8ocGhwKT98XFw/Pi99LGE9e2NOOlwic3RyaW5nXCIsYzpbZS5CRSxpXSx2Olt7YjonYlwiJyxlOidcIid9LHtiOlwiYidcIixlOlwiJ1wifSxlLmluaGVyaXQoZS5BU00se2k6bnVsbH0pLGUuaW5oZXJpdChlLlFTTSx7aTpudWxsfSldfSxuPXt2OltlLkJOTSxlLkNOTV19O3JldHVybnthbGlhc2VzOltcInBocDNcIixcInBocDRcIixcInBocDVcIixcInBocDZcIl0sY0k6ITAsazpcImFuZCBpbmNsdWRlX29uY2UgbGlzdCBhYnN0cmFjdCBnbG9iYWwgcHJpdmF0ZSBlY2hvIGludGVyZmFjZSBhcyBzdGF0aWMgZW5kc3dpdGNoIGFycmF5IG51bGwgaWYgZW5kd2hpbGUgb3IgY29uc3QgZm9yIGVuZGZvcmVhY2ggc2VsZiB2YXIgd2hpbGUgaXNzZXQgcHVibGljIHByb3RlY3RlZCBleGl0IGZvcmVhY2ggdGhyb3cgZWxzZWlmIGluY2x1ZGUgX19GSUxFX18gZW1wdHkgcmVxdWlyZV9vbmNlIGRvIHhvciByZXR1cm4gcGFyZW50IGNsb25lIHVzZSBfX0NMQVNTX18gX19MSU5FX18gZWxzZSBicmVhayBwcmludCBldmFsIG5ldyBjYXRjaCBfX01FVEhPRF9fIGNhc2UgZXhjZXB0aW9uIGRlZmF1bHQgZGllIHJlcXVpcmUgX19GVU5DVElPTl9fIGVuZGRlY2xhcmUgZmluYWwgdHJ5IHN3aXRjaCBjb250aW51ZSBlbmRmb3IgZW5kaWYgZGVjbGFyZSB1bnNldCB0cnVlIGZhbHNlIHRyYWl0IGdvdG8gaW5zdGFuY2VvZiBpbnN0ZWFkb2YgX19ESVJfXyBfX05BTUVTUEFDRV9fIHlpZWxkIGZpbmFsbHlcIixjOltlLkNMQ00sZS5IQ00se2NOOlwiY29tbWVudFwiLGI6XCIvXFxcXCpcIixlOlwiXFxcXCovXCIsYzpbe2NOOlwicGhwZG9jXCIsYjpcIlxcXFxzQFtBLVphLXpdK1wifSxpXX0se2NOOlwiY29tbWVudFwiLGI6XCJfX2hhbHRfY29tcGlsZXIuKz87XCIsZVc6ITAsazpcIl9faGFsdF9jb21waWxlclwiLGw6ZS5VSVJ9LHtjTjpcInN0cmluZ1wiLGI6XCI8PDxbJ1xcXCJdP1xcXFx3K1snXFxcIl0/JFwiLGU6XCJeXFxcXHcrO1wiLGM6W2UuQkVdfSxpLGMse2I6Ly0+K1thLXpBLVpfXFx4N2YtXFx4ZmZdW2EtekEtWjAtOV9cXHg3Zi1cXHhmZl0qL30se2NOOlwiZnVuY3Rpb25cIixiSzpcImZ1bmN0aW9uXCIsZTovWzt7XS8sZUU6ITAsaTpcIlxcXFwkfFxcXFxbfCVcIixjOltlLlVUTSx7Y046XCJwYXJhbXNcIixiOlwiXFxcXChcIixlOlwiXFxcXClcIixjOltcInNlbGZcIixjLGUuQ0JDTSxhLG5dfV19LHtjTjpcImNsYXNzXCIsYks6XCJjbGFzcyBpbnRlcmZhY2VcIixlOlwie1wiLGVFOiEwLGk6L1s6XFwoXFwkXCJdLyxjOlt7Yks6XCJleHRlbmRzIGltcGxlbWVudHNcIn0sZS5VVE1dfSx7Yks6XCJuYW1lc3BhY2VcIixlOlwiO1wiLGk6L1tcXC4nXS8sYzpbZS5VVE1dfSx7Yks6XCJ1c2VcIixlOlwiO1wiLGM6W2UuVVRNXX0se2I6XCI9PlwifSxhLG5dfX0pO2hsanMucmVnaXN0ZXJMYW5ndWFnZShcInBlcmxcIixmdW5jdGlvbihlKXt2YXIgdD1cImdldHB3ZW50IGdldHNlcnZlbnQgcXVvdGVtZXRhIG1zZ3JjdiBzY2FsYXIga2lsbCBkYm1jbG9zZSB1bmRlZiBsYyBtYSBzeXN3cml0ZSB0ciBzZW5kIHVtYXNrIHN5c29wZW4gc2htd3JpdGUgdmVjIHF4IHV0aW1lIGxvY2FsIG9jdCBzZW1jdGwgbG9jYWx0aW1lIHJlYWRwaXBlIGRvIHJldHVybiBmb3JtYXQgcmVhZCBzcHJpbnRmIGRibW9wZW4gcG9wIGdldHBncnAgbm90IGdldHB3bmFtIHJld2luZGRpciBxcWZpbGVubyBxdyBlbmRwcm90b2VudCB3YWl0IHNldGhvc3RlbnQgYmxlc3Mgc3wwIG9wZW5kaXIgY29udGludWUgZWFjaCBzbGVlcCBlbmRncmVudCBzaHV0ZG93biBkdW1wIGNob21wIGNvbm5lY3QgZ2V0c29ja25hbWUgZGllIHNvY2tldHBhaXIgY2xvc2UgZmxvY2sgZXhpc3RzIGluZGV4IHNobWdldHN1YiBmb3IgZW5kcHdlbnQgcmVkbyBsc3RhdCBtc2djdGwgc2V0cGdycCBhYnMgZXhpdCBzZWxlY3QgcHJpbnQgcmVmIGdldGhvc3RieWFkZHIgdW5zaGlmdCBmY250bCBzeXNjYWxsIGdvdG8gZ2V0bmV0YnlhZGRyIGpvaW4gZ210aW1lIHN5bWxpbmsgc2VtZ2V0IHNwbGljZSB4fDAgZ2V0cGVlcm5hbWUgcmVjdiBsb2cgc2V0c29ja29wdCBjb3MgbGFzdCByZXZlcnNlIGdldGhvc3RieW5hbWUgZ2V0Z3JuYW0gc3R1ZHkgZm9ybWxpbmUgZW5kaG9zdGVudCB0aW1lcyBjaG9wIGxlbmd0aCBnZXRob3N0ZW50IGdldG5ldGVudCBwYWNrIGdldHByb3RvZW50IGdldHNlcnZieW5hbWUgcmFuZCBta2RpciBwb3MgY2htb2QgeXwwIHN1YnN0ciBlbmRuZXRlbnQgcHJpbnRmIG5leHQgb3BlbiBtc2dzbmQgcmVhZGRpciB1c2UgdW5saW5rIGdldHNvY2tvcHQgZ2V0cHJpb3JpdHkgcmluZGV4IHdhbnRhcnJheSBoZXggc3lzdGVtIGdldHNlcnZieXBvcnQgZW5kc2VydmVudCBpbnQgY2hyIHVudGllIHJtZGlyIHByb3RvdHlwZSB0ZWxsIGxpc3RlbiBmb3JrIHNobXJlYWQgdWNmaXJzdCBzZXRwcm90b2VudCBlbHNlIHN5c3NlZWsgbGluayBnZXRncmdpZCBzaG1jdGwgd2FpdHBpZCB1bnBhY2sgZ2V0bmV0YnluYW1lIHJlc2V0IGNoZGlyIGdyZXAgc3BsaXQgcmVxdWlyZSBjYWxsZXIgbGNmaXJzdCB1bnRpbCB3YXJuIHdoaWxlIHZhbHVlcyBzaGlmdCB0ZWxsZGlyIGdldHB3dWlkIG15IGdldHByb3RvYnludW1iZXIgZGVsZXRlIGFuZCBzb3J0IHVjIGRlZmluZWQgc3JhbmQgYWNjZXB0IHBhY2thZ2Ugc2Vla2RpciBnZXRwcm90b2J5bmFtZSBzZW1vcCBvdXIgcmVuYW1lIHNlZWsgaWYgcXwwIGNocm9vdCBzeXNyZWFkIHNldHB3ZW50IG5vIGNyeXB0IGdldGMgY2hvd24gc3FydCB3cml0ZSBzZXRuZXRlbnQgc2V0cHJpb3JpdHkgZm9yZWFjaCB0aWUgc2luIG1zZ2dldCBtYXAgc3RhdCBnZXRsb2dpbiB1bmxlc3MgZWxzaWYgdHJ1bmNhdGUgZXhlYyBrZXlzIGdsb2IgdGllZCBjbG9zZWRpcmlvY3RsIHNvY2tldCByZWFkbGluayBldmFsIHhvciByZWFkbGluZSBiaW5tb2RlIHNldHNlcnZlbnQgZW9mIG9yZCBiaW5kIGFsYXJtIHBpcGUgYXRhbjIgZ2V0Z3JlbnQgZXhwIHRpbWUgcHVzaCBzZXRncmVudCBndCBsdCBvciBuZSBtfDAgYnJlYWsgZ2l2ZW4gc2F5IHN0YXRlIHdoZW5cIixyPXtjTjpcInN1YnN0XCIsYjpcIlskQF1cXFxce1wiLGU6XCJcXFxcfVwiLGs6dH0scz17YjpcIi0+e1wiLGU6XCJ9XCJ9LG49e2NOOlwidmFyaWFibGVcIix2Olt7YjovXFwkXFxkL30se2I6L1tcXCRcXCVcXEBdKFxcXlxcd1xcYnwjXFx3KyhcXDpcXDpcXHcrKSp8e1xcdyt9fFxcdysoXFw6XFw6XFx3KikqKS99LHtiOi9bXFwkXFwlXFxAXVteXFxzXFx3e10vLHI6MH1dfSxvPXtjTjpcImNvbW1lbnRcIixiOlwiXihfX0VORF9ffF9fREFUQV9fKVwiLGU6XCJcXFxcbiRcIixyOjV9LGk9W2UuQkUscixuXSxjPVtuLGUuSENNLG8se2NOOlwiY29tbWVudFwiLGI6XCJeXFxcXD1cXFxcd1wiLGU6XCJcXFxcPWN1dFwiLGVXOiEwfSxzLHtjTjpcInN0cmluZ1wiLGM6aSx2Olt7YjpcInFbcXd4cl0/XFxcXHMqXFxcXChcIixlOlwiXFxcXClcIixyOjV9LHtiOlwicVtxd3hyXT9cXFxccypcXFxcW1wiLGU6XCJcXFxcXVwiLHI6NX0se2I6XCJxW3F3eHJdP1xcXFxzKlxcXFx7XCIsZTpcIlxcXFx9XCIscjo1fSx7YjpcInFbcXd4cl0/XFxcXHMqXFxcXHxcIixlOlwiXFxcXHxcIixyOjV9LHtiOlwicVtxd3hyXT9cXFxccypcXFxcPFwiLGU6XCJcXFxcPlwiLHI6NX0se2I6XCJxd1xcXFxzK3FcIixlOlwicVwiLHI6NX0se2I6XCInXCIsZTpcIidcIixjOltlLkJFXX0se2I6J1wiJyxlOidcIid9LHtiOlwiYFwiLGU6XCJgXCIsYzpbZS5CRV19LHtiOlwie1xcXFx3K31cIixjOltdLHI6MH0se2I6XCItP1xcXFx3K1xcXFxzKlxcXFw9XFxcXD5cIixjOltdLHI6MH1dfSx7Y046XCJudW1iZXJcIixiOlwiKFxcXFxiMFswLTdfXSspfChcXFxcYjB4WzAtOWEtZkEtRl9dKyl8KFxcXFxiWzEtOV1bMC05X10qKFxcXFwuWzAtOV9dKyk/KXxbMF9dXFxcXGJcIixyOjB9LHtiOlwiKFxcXFwvXFxcXC98XCIrZS5SU1IrXCJ8XFxcXGIoc3BsaXR8cmV0dXJufHByaW50fHJldmVyc2V8Z3JlcClcXFxcYilcXFxccypcIixrOlwic3BsaXQgcmV0dXJuIHByaW50IHJldmVyc2UgZ3JlcFwiLHI6MCxjOltlLkhDTSxvLHtjTjpcInJlZ2V4cFwiLGI6XCIoc3x0cnx5KS8oXFxcXFxcXFwufFteL10pKi8oXFxcXFxcXFwufFteL10pKi9bYS16XSpcIixyOjEwfSx7Y046XCJyZWdleHBcIixiOlwiKG18cXIpPy9cIixlOlwiL1thLXpdKlwiLGM6W2UuQkVdLHI6MH1dfSx7Y046XCJzdWJcIixiSzpcInN1YlwiLGU6XCIoXFxcXHMqXFxcXCguKj9cXFxcKSk/Wzt7XVwiLHI6NX0se2NOOlwib3BlcmF0b3JcIixiOlwiLVxcXFx3XFxcXGJcIixyOjB9XTtyZXR1cm4gci5jPWMscy5jPWMse2FsaWFzZXM6W1wicGxcIl0sazp0LGM6Y319KTtobGpzLnJlZ2lzdGVyTGFuZ3VhZ2UoXCJpbmlcIixmdW5jdGlvbihlKXtyZXR1cm57Y0k6ITAsaTovXFxTLyxjOlt7Y046XCJjb21tZW50XCIsYjpcIjtcIixlOlwiJFwifSx7Y046XCJ0aXRsZVwiLGI6XCJeXFxcXFtcIixlOlwiXFxcXF1cIn0se2NOOlwic2V0dGluZ1wiLGI6XCJeW2EtejAtOVxcXFxbXFxcXF1fLV0rWyBcXFxcdF0qPVsgXFxcXHRdKlwiLGU6XCIkXCIsYzpbe2NOOlwidmFsdWVcIixlVzohMCxrOlwib24gb2ZmIHRydWUgZmFsc2UgeWVzIG5vXCIsYzpbZS5RU00sZS5OTV0scjowfV19XX19KTtobGpzLnJlZ2lzdGVyTGFuZ3VhZ2UoXCJtYWtlZmlsZVwiLGZ1bmN0aW9uKGUpe3ZhciBhPXtjTjpcInZhcmlhYmxlXCIsYjovXFwkXFwoLyxlOi9cXCkvLGM6W2UuQkVdfTtyZXR1cm57YWxpYXNlczpbXCJta1wiLFwibWFrXCJdLGM6W2UuSENNLHtiOi9eXFx3K1xccypcXFcqPS8sckI6ITAscjowLHN0YXJ0czp7Y046XCJjb25zdGFudFwiLGU6L1xccypcXFcqPS8sZUU6ITAsc3RhcnRzOntlOi8kLyxyOjAsYzpbYV19fX0se2NOOlwidGl0bGVcIixiOi9eW1xcd10rOlxccyokL30se2NOOlwicGhvbnlcIixiOi9eXFwuUEhPTlk6LyxlOi8kLyxrOlwiLlBIT05ZXCIsbDovW1xcLlxcd10rL30se2I6L15cXHQrLyxlOi8kLyxyOjAsYzpbZS5RU00sYV19XX19KTsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/highlight.pack.js\n");

/***/ }),

/***/ "./lib/markdown-it-footnote.js":
/*!*************************************!*\
  !*** ./lib/markdown-it-footnote.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var require;var require;/*! markdown-it-footnote 1.0.0 https://github.com//markdown-it/markdown-it-footnote @license MIT */(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\r\n// Process footnotes\r\n//\r\n'use strict';\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n// Renderer partials\r\n\r\nfunction _footnote_ref(tokens, idx) {\r\n  var n = Number(tokens[idx].meta.id + 1).toString();\r\n  var id = 'fnref' + n;\r\n  if (tokens[idx].meta.subId > 0) {\r\n    id += ':' + tokens[idx].meta.subId;\r\n  }\r\n  return '<sup class=\"footnote-ref\"><a href=\"#fn' + n + '\" id=\"' + id + '\">[' + n + ']</a></sup>';\r\n}\r\nfunction _footnote_block_open(tokens, idx, options) {\r\n  return (options.xhtmlOut ? '<hr class=\"footnotes-sep\" />\\n' : '<hr class=\"footnotes-sep\">\\n') +\r\n         '<section class=\"footnotes\">\\n' +\r\n         '<ol class=\"footnotes-list\">\\n';\r\n}\r\nfunction _footnote_block_close() {\r\n  return '</ol>\\n</section>\\n';\r\n}\r\nfunction _footnote_open(tokens, idx) {\r\n  var id = Number(tokens[idx].meta.id + 1).toString();\r\n  return '<li id=\"fn' + id + '\"  class=\"footnote-item\">';\r\n}\r\nfunction _footnote_close() {\r\n  return '</li>\\n';\r\n}\r\nfunction _footnote_anchor(tokens, idx) {\r\n  var n = Number(tokens[idx].meta.id + 1).toString();\r\n  var id = 'fnref' + n;\r\n  if (tokens[idx].meta.subId > 0) {\r\n    id += ':' + tokens[idx].meta.subId;\r\n  }\r\n  return ' <a href=\"#' + id + '\" class=\"footnote-backref\">\\u21a9</a>'; /*  */\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\nmodule.exports = function sub_plugin(md) {\r\n  var parseLinkLabel = md.helpers.parseLinkLabel;\r\n\r\n  md.renderer.rules.footnote_ref          = _footnote_ref;\r\n  md.renderer.rules.footnote_block_open   = _footnote_block_open;\r\n  md.renderer.rules.footnote_block_close  = _footnote_block_close;\r\n  md.renderer.rules.footnote_open         = _footnote_open;\r\n  md.renderer.rules.footnote_close        = _footnote_close;\r\n  md.renderer.rules.footnote_anchor       = _footnote_anchor;\r\n\r\n  // Process footnote block definition\r\n  function footnote_def(state, startLine, endLine, silent) {\r\n    var oldBMark, oldTShift, oldParentType, pos, label, token,\r\n        start = state.bMarks[startLine] + state.tShift[startLine],\r\n        max = state.eMarks[startLine];\r\n\r\n    // line should be at least 5 chars - \"[^x]:\"\r\n    if (start + 4 > max) { return false; }\r\n\r\n    if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }\r\n    if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }\r\n\r\n    for (pos = start + 2; pos < max; pos++) {\r\n      if (state.src.charCodeAt(pos) === 0x20) { return false; }\r\n      if (state.src.charCodeAt(pos) === 0x5D /* ] */) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (pos === start + 2) { return false; } // no empty footnote labels\r\n    if (pos + 1 >= max || state.src.charCodeAt(++pos) !== 0x3A /* : */) { return false; }\r\n    if (silent) { return true; }\r\n    pos++;\r\n\r\n    if (!state.env.footnotes) { state.env.footnotes = {}; }\r\n    if (!state.env.footnotes.refs) { state.env.footnotes.refs = {}; }\r\n    label = state.src.slice(start + 2, pos - 2);\r\n    state.env.footnotes.refs[':' + label] = -1;\r\n\r\n    token       = new state.Token('footnote_reference_open', '', 1);\r\n    token.meta  = { label: label };\r\n    token.level = state.level++;\r\n    state.tokens.push(token);\r\n\r\n    oldBMark = state.bMarks[startLine];\r\n    oldTShift = state.tShift[startLine];\r\n    oldParentType = state.parentType;\r\n    state.tShift[startLine] = state.skipSpaces(pos) - pos;\r\n    state.bMarks[startLine] = pos;\r\n    state.blkIndent += 4;\r\n    state.parentType = 'footnote';\r\n\r\n    if (state.tShift[startLine] < state.blkIndent) {\r\n      state.tShift[startLine] += state.blkIndent;\r\n      state.bMarks[startLine] -= state.blkIndent;\r\n    }\r\n\r\n    state.md.block.tokenize(state, startLine, endLine, true);\r\n\r\n    state.parentType = oldParentType;\r\n    state.blkIndent -= 4;\r\n    state.tShift[startLine] = oldTShift;\r\n    state.bMarks[startLine] = oldBMark;\r\n\r\n    token       = new state.Token('footnote_reference_close', '', -1);\r\n    token.level = --state.level;\r\n    state.tokens.push(token);\r\n\r\n    return true;\r\n  }\r\n\r\n  // Process inline footnotes (^[...])\r\n  function footnote_inline(state, silent) {\r\n    var labelStart,\r\n        labelEnd,\r\n        footnoteId,\r\n        oldLength,\r\n        token,\r\n        max = state.posMax,\r\n        start = state.pos;\r\n\r\n    if (start + 2 >= max) { return false; }\r\n    if (state.src.charCodeAt(start) !== 0x5E/* ^ */) { return false; }\r\n    if (state.src.charCodeAt(start + 1) !== 0x5B/* [ */) { return false; }\r\n\r\n    labelStart = start + 2;\r\n    labelEnd = parseLinkLabel(state, start + 1);\r\n\r\n    // parser failed to find ']', so it's not a valid note\r\n    if (labelEnd < 0) { return false; }\r\n\r\n    // We found the end of the link, and know for a fact it's a valid link;\r\n    // so all that's left to do is to call tokenizer.\r\n    //\r\n    if (!silent) {\r\n      if (!state.env.footnotes) { state.env.footnotes = {}; }\r\n      if (!state.env.footnotes.list) { state.env.footnotes.list = []; }\r\n      footnoteId = state.env.footnotes.list.length;\r\n\r\n      state.pos = labelStart;\r\n      state.posMax = labelEnd;\r\n\r\n      token      = state.push('footnote_ref', '', 0);\r\n      token.meta = { id: footnoteId };\r\n\r\n      oldLength = state.tokens.length;\r\n      state.md.inline.tokenize(state);\r\n      state.env.footnotes.list[footnoteId] = { tokens: state.tokens.splice(oldLength) };\r\n    }\r\n\r\n    state.pos = labelEnd + 1;\r\n    state.posMax = max;\r\n    return true;\r\n  }\r\n\r\n  // Process footnote references ([^...])\r\n  function footnote_ref(state, silent) {\r\n    var label,\r\n        pos,\r\n        footnoteId,\r\n        footnoteSubId,\r\n        token,\r\n        max = state.posMax,\r\n        start = state.pos;\r\n\r\n    // should be at least 4 chars - \"[^x]\"\r\n    if (start + 3 > max) { return false; }\r\n\r\n    if (!state.env.footnotes || !state.env.footnotes.refs) { return false; }\r\n    if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }\r\n    if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }\r\n\r\n    for (pos = start + 2; pos < max; pos++) {\r\n      if (state.src.charCodeAt(pos) === 0x20) { return false; }\r\n      if (state.src.charCodeAt(pos) === 0x0A) { return false; }\r\n      if (state.src.charCodeAt(pos) === 0x5D /* ] */) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (pos === start + 2) { return false; } // no empty footnote labels\r\n    if (pos >= max) { return false; }\r\n    pos++;\r\n\r\n    label = state.src.slice(start + 2, pos - 1);\r\n    if (typeof state.env.footnotes.refs[':' + label] === 'undefined') { return false; }\r\n\r\n    if (!silent) {\r\n      if (!state.env.footnotes.list) { state.env.footnotes.list = []; }\r\n\r\n      if (state.env.footnotes.refs[':' + label] < 0) {\r\n        footnoteId = state.env.footnotes.list.length;\r\n        state.env.footnotes.list[footnoteId] = { label: label, count: 0 };\r\n        state.env.footnotes.refs[':' + label] = footnoteId;\r\n      } else {\r\n        footnoteId = state.env.footnotes.refs[':' + label];\r\n      }\r\n\r\n      footnoteSubId = state.env.footnotes.list[footnoteId].count;\r\n      state.env.footnotes.list[footnoteId].count++;\r\n\r\n      token      = state.push('footnote_ref', '', 0);\r\n      token.meta = { id: footnoteId, subId: footnoteSubId };\r\n    }\r\n\r\n    state.pos = pos;\r\n    state.posMax = max;\r\n    return true;\r\n  }\r\n\r\n  // Glue footnote tokens to end of token stream\r\n  function footnote_tail(state) {\r\n    var i, l, j, t, lastParagraph, list, token, tokens, current, currentLabel,\r\n        insideRef = false,\r\n        refTokens = {};\r\n\r\n    if (!state.env.footnotes) { return; }\r\n\r\n    state.tokens = state.tokens.filter(function(tok) {\r\n      if (tok.type === 'footnote_reference_open') {\r\n        insideRef = true;\r\n        current = [];\r\n        currentLabel = tok.meta.label;\r\n        return false;\r\n      }\r\n      if (tok.type === 'footnote_reference_close') {\r\n        insideRef = false;\r\n        // prepend ':' to avoid conflict with Object.prototype members\r\n        refTokens[':' + currentLabel] = current;\r\n        return false;\r\n      }\r\n      if (insideRef) { current.push(tok); }\r\n      return !insideRef;\r\n    });\r\n\r\n    if (!state.env.footnotes.list) { return; }\r\n    list = state.env.footnotes.list;\r\n\r\n    token = new state.Token('footnote_block_open', '', 1);\r\n    state.tokens.push(token);\r\n\r\n    for (i = 0, l = list.length; i < l; i++) {\r\n      token      = new state.Token('footnote_open', '', 1);\r\n      token.meta = { id: i };\r\n      state.tokens.push(token);\r\n\r\n      if (list[i].tokens) {\r\n        tokens = [];\r\n\r\n        token          = new state.Token('paragraph_open', 'p', 1);\r\n        token.block    = true;\r\n        tokens.push(token);\r\n\r\n        token          = new state.Token('inline', '', 0);\r\n        token.children = list[i].tokens;\r\n        token.content  = '';\r\n        tokens.push(token);\r\n\r\n        token          = new state.Token('paragraph_close', 'p', -1);\r\n        token.block    = true;\r\n        tokens.push(token);\r\n\r\n      } else if (list[i].label) {\r\n        tokens = refTokens[':' + list[i].label];\r\n      }\r\n\r\n      state.tokens = state.tokens.concat(tokens);\r\n      if (state.tokens[state.tokens.length - 1].type === 'paragraph_close') {\r\n        lastParagraph = state.tokens.pop();\r\n      } else {\r\n        lastParagraph = null;\r\n      }\r\n\r\n      t = list[i].count > 0 ? list[i].count : 1;\r\n      for (j = 0; j < t; j++) {\r\n        token      = new state.Token('footnote_anchor', '', 0);\r\n        token.meta = { id: i, subId: j };\r\n        state.tokens.push(token);\r\n      }\r\n\r\n      if (lastParagraph) {\r\n        state.tokens.push(lastParagraph);\r\n      }\r\n\r\n      token = new state.Token('footnote_close', '', -1);\r\n      state.tokens.push(token);\r\n    }\r\n\r\n    token = new state.Token('footnote_block_close', '', -1);\r\n    state.tokens.push(token);\r\n  }\r\n\r\n  md.block.ruler.before('reference', 'footnote_def', footnote_def, { alt: [ 'paragraph', 'reference' ] });\r\n  md.inline.ruler.after('image', 'footnote_inline', footnote_inline);\r\n  md.inline.ruler.after('footnote_inline', 'footnote_ref', footnote_ref);\r\n  md.core.ruler.after('inline', 'footnote_tail', footnote_tail);\r\n};\r\n\r\n},{}]},{},[1])(1)\r\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvbWFya2Rvd24taXQtZm9vdG5vdGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvbWFya2Rvd24taXQtZm9vdG5vdGUuanM/OWY1NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbWFya2Rvd24taXQtZm9vdG5vdGUgMS4wLjAgaHR0cHM6Ly9naXRodWIuY29tLy9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC1mb290bm90ZSBAbGljZW5zZSBNSVQgKi8oZnVuY3Rpb24oZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiJiZ0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9ZigpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGYpfWVsc2V7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe2c9d2luZG93fWVsc2UgaWYodHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCIpe2c9Z2xvYmFsfWVsc2UgaWYodHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiKXtnPXNlbGZ9ZWxzZXtnPXRoaXN9Zy5tYXJrZG93bml0Rm9vdG5vdGUgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8vIFByb2Nlc3MgZm9vdG5vdGVzXHJcbi8vXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIFJlbmRlcmVyIHBhcnRpYWxzXHJcblxyXG5mdW5jdGlvbiBfZm9vdG5vdGVfcmVmKHRva2VucywgaWR4KSB7XHJcbiAgdmFyIG4gPSBOdW1iZXIodG9rZW5zW2lkeF0ubWV0YS5pZCArIDEpLnRvU3RyaW5nKCk7XHJcbiAgdmFyIGlkID0gJ2ZucmVmJyArIG47XHJcbiAgaWYgKHRva2Vuc1tpZHhdLm1ldGEuc3ViSWQgPiAwKSB7XHJcbiAgICBpZCArPSAnOicgKyB0b2tlbnNbaWR4XS5tZXRhLnN1YklkO1xyXG4gIH1cclxuICByZXR1cm4gJzxzdXAgY2xhc3M9XCJmb290bm90ZS1yZWZcIj48YSBocmVmPVwiI2ZuJyArIG4gKyAnXCIgaWQ9XCInICsgaWQgKyAnXCI+WycgKyBuICsgJ108L2E+PC9zdXA+JztcclxufVxyXG5mdW5jdGlvbiBfZm9vdG5vdGVfYmxvY2tfb3Blbih0b2tlbnMsIGlkeCwgb3B0aW9ucykge1xyXG4gIHJldHVybiAob3B0aW9ucy54aHRtbE91dCA/ICc8aHIgY2xhc3M9XCJmb290bm90ZXMtc2VwXCIgLz5cXG4nIDogJzxociBjbGFzcz1cImZvb3Rub3Rlcy1zZXBcIj5cXG4nKSArXHJcbiAgICAgICAgICc8c2VjdGlvbiBjbGFzcz1cImZvb3Rub3Rlc1wiPlxcbicgK1xyXG4gICAgICAgICAnPG9sIGNsYXNzPVwiZm9vdG5vdGVzLWxpc3RcIj5cXG4nO1xyXG59XHJcbmZ1bmN0aW9uIF9mb290bm90ZV9ibG9ja19jbG9zZSgpIHtcclxuICByZXR1cm4gJzwvb2w+XFxuPC9zZWN0aW9uPlxcbic7XHJcbn1cclxuZnVuY3Rpb24gX2Zvb3Rub3RlX29wZW4odG9rZW5zLCBpZHgpIHtcclxuICB2YXIgaWQgPSBOdW1iZXIodG9rZW5zW2lkeF0ubWV0YS5pZCArIDEpLnRvU3RyaW5nKCk7XHJcbiAgcmV0dXJuICc8bGkgaWQ9XCJmbicgKyBpZCArICdcIiAgY2xhc3M9XCJmb290bm90ZS1pdGVtXCI+JztcclxufVxyXG5mdW5jdGlvbiBfZm9vdG5vdGVfY2xvc2UoKSB7XHJcbiAgcmV0dXJuICc8L2xpPlxcbic7XHJcbn1cclxuZnVuY3Rpb24gX2Zvb3Rub3RlX2FuY2hvcih0b2tlbnMsIGlkeCkge1xyXG4gIHZhciBuID0gTnVtYmVyKHRva2Vuc1tpZHhdLm1ldGEuaWQgKyAxKS50b1N0cmluZygpO1xyXG4gIHZhciBpZCA9ICdmbnJlZicgKyBuO1xyXG4gIGlmICh0b2tlbnNbaWR4XS5tZXRhLnN1YklkID4gMCkge1xyXG4gICAgaWQgKz0gJzonICsgdG9rZW5zW2lkeF0ubWV0YS5zdWJJZDtcclxuICB9XHJcbiAgcmV0dXJuICcgPGEgaHJlZj1cIiMnICsgaWQgKyAnXCIgY2xhc3M9XCJmb290bm90ZS1iYWNrcmVmXCI+XFx1MjFhOTwvYT4nOyAvKiDihqkgKi9cclxufVxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN1Yl9wbHVnaW4obWQpIHtcclxuICB2YXIgcGFyc2VMaW5rTGFiZWwgPSBtZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsO1xyXG5cclxuICBtZC5yZW5kZXJlci5ydWxlcy5mb290bm90ZV9yZWYgICAgICAgICAgPSBfZm9vdG5vdGVfcmVmO1xyXG4gIG1kLnJlbmRlcmVyLnJ1bGVzLmZvb3Rub3RlX2Jsb2NrX29wZW4gICA9IF9mb290bm90ZV9ibG9ja19vcGVuO1xyXG4gIG1kLnJlbmRlcmVyLnJ1bGVzLmZvb3Rub3RlX2Jsb2NrX2Nsb3NlICA9IF9mb290bm90ZV9ibG9ja19jbG9zZTtcclxuICBtZC5yZW5kZXJlci5ydWxlcy5mb290bm90ZV9vcGVuICAgICAgICAgPSBfZm9vdG5vdGVfb3BlbjtcclxuICBtZC5yZW5kZXJlci5ydWxlcy5mb290bm90ZV9jbG9zZSAgICAgICAgPSBfZm9vdG5vdGVfY2xvc2U7XHJcbiAgbWQucmVuZGVyZXIucnVsZXMuZm9vdG5vdGVfYW5jaG9yICAgICAgID0gX2Zvb3Rub3RlX2FuY2hvcjtcclxuXHJcbiAgLy8gUHJvY2VzcyBmb290bm90ZSBibG9jayBkZWZpbml0aW9uXHJcbiAgZnVuY3Rpb24gZm9vdG5vdGVfZGVmKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xyXG4gICAgdmFyIG9sZEJNYXJrLCBvbGRUU2hpZnQsIG9sZFBhcmVudFR5cGUsIHBvcywgbGFiZWwsIHRva2VuLFxyXG4gICAgICAgIHN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcclxuICAgICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcclxuXHJcbiAgICAvLyBsaW5lIHNob3VsZCBiZSBhdCBsZWFzdCA1IGNoYXJzIC0gXCJbXnhdOlwiXHJcbiAgICBpZiAoc3RhcnQgKyA0ID4gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCkgIT09IDB4NUIvKiBbICovKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0ICsgMSkgIT09IDB4NUUvKiBeICovKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICAgIGZvciAocG9zID0gc3RhcnQgKyAyOyBwb3MgPCBtYXg7IHBvcysrKSB7XHJcbiAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDIwKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg1RCAvKiBdICovKSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAocG9zID09PSBzdGFydCArIDIpIHsgcmV0dXJuIGZhbHNlOyB9IC8vIG5vIGVtcHR5IGZvb3Rub3RlIGxhYmVsc1xyXG4gICAgaWYgKHBvcyArIDEgPj0gbWF4IHx8IHN0YXRlLnNyYy5jaGFyQ29kZUF0KCsrcG9zKSAhPT0gMHgzQSAvKiA6ICovKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG4gICAgcG9zKys7XHJcblxyXG4gICAgaWYgKCFzdGF0ZS5lbnYuZm9vdG5vdGVzKSB7IHN0YXRlLmVudi5mb290bm90ZXMgPSB7fTsgfVxyXG4gICAgaWYgKCFzdGF0ZS5lbnYuZm9vdG5vdGVzLnJlZnMpIHsgc3RhdGUuZW52LmZvb3Rub3Rlcy5yZWZzID0ge307IH1cclxuICAgIGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0ICsgMiwgcG9zIC0gMik7XHJcbiAgICBzdGF0ZS5lbnYuZm9vdG5vdGVzLnJlZnNbJzonICsgbGFiZWxdID0gLTE7XHJcblxyXG4gICAgdG9rZW4gICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2Zvb3Rub3RlX3JlZmVyZW5jZV9vcGVuJywgJycsIDEpO1xyXG4gICAgdG9rZW4ubWV0YSAgPSB7IGxhYmVsOiBsYWJlbCB9O1xyXG4gICAgdG9rZW4ubGV2ZWwgPSBzdGF0ZS5sZXZlbCsrO1xyXG4gICAgc3RhdGUudG9rZW5zLnB1c2godG9rZW4pO1xyXG5cclxuICAgIG9sZEJNYXJrID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XHJcbiAgICBvbGRUU2hpZnQgPSBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcclxuICAgIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xyXG4gICAgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPSBzdGF0ZS5za2lwU3BhY2VzKHBvcykgLSBwb3M7XHJcbiAgICBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSA9IHBvcztcclxuICAgIHN0YXRlLmJsa0luZGVudCArPSA0O1xyXG4gICAgc3RhdGUucGFyZW50VHlwZSA9ICdmb290bm90ZSc7XHJcblxyXG4gICAgaWYgKHN0YXRlLnRTaGlmdFtzdGFydExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7XHJcbiAgICAgIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdICs9IHN0YXRlLmJsa0luZGVudDtcclxuICAgICAgc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gLT0gc3RhdGUuYmxrSW5kZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlLm1kLmJsb2NrLnRva2VuaXplKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHRydWUpO1xyXG5cclxuICAgIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xyXG4gICAgc3RhdGUuYmxrSW5kZW50IC09IDQ7XHJcbiAgICBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSA9IG9sZFRTaGlmdDtcclxuICAgIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdID0gb2xkQk1hcms7XHJcblxyXG4gICAgdG9rZW4gICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2Zvb3Rub3RlX3JlZmVyZW5jZV9jbG9zZScsICcnLCAtMSk7XHJcbiAgICB0b2tlbi5sZXZlbCA9IC0tc3RhdGUubGV2ZWw7XHJcbiAgICBzdGF0ZS50b2tlbnMucHVzaCh0b2tlbik7XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvLyBQcm9jZXNzIGlubGluZSBmb290bm90ZXMgKF5bLi4uXSlcclxuICBmdW5jdGlvbiBmb290bm90ZV9pbmxpbmUoc3RhdGUsIHNpbGVudCkge1xyXG4gICAgdmFyIGxhYmVsU3RhcnQsXHJcbiAgICAgICAgbGFiZWxFbmQsXHJcbiAgICAgICAgZm9vdG5vdGVJZCxcclxuICAgICAgICBvbGRMZW5ndGgsXHJcbiAgICAgICAgdG9rZW4sXHJcbiAgICAgICAgbWF4ID0gc3RhdGUucG9zTWF4LFxyXG4gICAgICAgIHN0YXJ0ID0gc3RhdGUucG9zO1xyXG5cclxuICAgIGlmIChzdGFydCArIDIgPj0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KSAhPT0gMHg1RS8qIF4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQgKyAxKSAhPT0gMHg1Qi8qIFsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gICAgbGFiZWxTdGFydCA9IHN0YXJ0ICsgMjtcclxuICAgIGxhYmVsRW5kID0gcGFyc2VMaW5rTGFiZWwoc3RhdGUsIHN0YXJ0ICsgMSk7XHJcblxyXG4gICAgLy8gcGFyc2VyIGZhaWxlZCB0byBmaW5kICddJywgc28gaXQncyBub3QgYSB2YWxpZCBub3RlXHJcbiAgICBpZiAobGFiZWxFbmQgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICAgIC8vIFdlIGZvdW5kIHRoZSBlbmQgb2YgdGhlIGxpbmssIGFuZCBrbm93IGZvciBhIGZhY3QgaXQncyBhIHZhbGlkIGxpbms7XHJcbiAgICAvLyBzbyBhbGwgdGhhdCdzIGxlZnQgdG8gZG8gaXMgdG8gY2FsbCB0b2tlbml6ZXIuXHJcbiAgICAvL1xyXG4gICAgaWYgKCFzaWxlbnQpIHtcclxuICAgICAgaWYgKCFzdGF0ZS5lbnYuZm9vdG5vdGVzKSB7IHN0YXRlLmVudi5mb290bm90ZXMgPSB7fTsgfVxyXG4gICAgICBpZiAoIXN0YXRlLmVudi5mb290bm90ZXMubGlzdCkgeyBzdGF0ZS5lbnYuZm9vdG5vdGVzLmxpc3QgPSBbXTsgfVxyXG4gICAgICBmb290bm90ZUlkID0gc3RhdGUuZW52LmZvb3Rub3Rlcy5saXN0Lmxlbmd0aDtcclxuXHJcbiAgICAgIHN0YXRlLnBvcyA9IGxhYmVsU3RhcnQ7XHJcbiAgICAgIHN0YXRlLnBvc01heCA9IGxhYmVsRW5kO1xyXG5cclxuICAgICAgdG9rZW4gICAgICA9IHN0YXRlLnB1c2goJ2Zvb3Rub3RlX3JlZicsICcnLCAwKTtcclxuICAgICAgdG9rZW4ubWV0YSA9IHsgaWQ6IGZvb3Rub3RlSWQgfTtcclxuXHJcbiAgICAgIG9sZExlbmd0aCA9IHN0YXRlLnRva2Vucy5sZW5ndGg7XHJcbiAgICAgIHN0YXRlLm1kLmlubGluZS50b2tlbml6ZShzdGF0ZSk7XHJcbiAgICAgIHN0YXRlLmVudi5mb290bm90ZXMubGlzdFtmb290bm90ZUlkXSA9IHsgdG9rZW5zOiBzdGF0ZS50b2tlbnMuc3BsaWNlKG9sZExlbmd0aCkgfTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0ZS5wb3MgPSBsYWJlbEVuZCArIDE7XHJcbiAgICBzdGF0ZS5wb3NNYXggPSBtYXg7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIFByb2Nlc3MgZm9vdG5vdGUgcmVmZXJlbmNlcyAoW14uLi5dKVxyXG4gIGZ1bmN0aW9uIGZvb3Rub3RlX3JlZihzdGF0ZSwgc2lsZW50KSB7XHJcbiAgICB2YXIgbGFiZWwsXHJcbiAgICAgICAgcG9zLFxyXG4gICAgICAgIGZvb3Rub3RlSWQsXHJcbiAgICAgICAgZm9vdG5vdGVTdWJJZCxcclxuICAgICAgICB0b2tlbixcclxuICAgICAgICBtYXggPSBzdGF0ZS5wb3NNYXgsXHJcbiAgICAgICAgc3RhcnQgPSBzdGF0ZS5wb3M7XHJcblxyXG4gICAgLy8gc2hvdWxkIGJlIGF0IGxlYXN0IDQgY2hhcnMgLSBcIlteeF1cIlxyXG4gICAgaWYgKHN0YXJ0ICsgMyA+IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgICBpZiAoIXN0YXRlLmVudi5mb290bm90ZXMgfHwgIXN0YXRlLmVudi5mb290bm90ZXMucmVmcykgeyByZXR1cm4gZmFsc2U7IH1cclxuICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCkgIT09IDB4NUIvKiBbICovKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0ICsgMSkgIT09IDB4NUUvKiBeICovKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICAgIGZvciAocG9zID0gc3RhcnQgKyAyOyBwb3MgPCBtYXg7IHBvcysrKSB7XHJcbiAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDIwKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwQSkgeyByZXR1cm4gZmFsc2U7IH1cclxuICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NUQgLyogXSAqLykge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHBvcyA9PT0gc3RhcnQgKyAyKSB7IHJldHVybiBmYWxzZTsgfSAvLyBubyBlbXB0eSBmb290bm90ZSBsYWJlbHNcclxuICAgIGlmIChwb3MgPj0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgcG9zKys7XHJcblxyXG4gICAgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQgKyAyLCBwb3MgLSAxKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUuZW52LmZvb3Rub3Rlcy5yZWZzWyc6JyArIGxhYmVsXSA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gICAgaWYgKCFzaWxlbnQpIHtcclxuICAgICAgaWYgKCFzdGF0ZS5lbnYuZm9vdG5vdGVzLmxpc3QpIHsgc3RhdGUuZW52LmZvb3Rub3Rlcy5saXN0ID0gW107IH1cclxuXHJcbiAgICAgIGlmIChzdGF0ZS5lbnYuZm9vdG5vdGVzLnJlZnNbJzonICsgbGFiZWxdIDwgMCkge1xyXG4gICAgICAgIGZvb3Rub3RlSWQgPSBzdGF0ZS5lbnYuZm9vdG5vdGVzLmxpc3QubGVuZ3RoO1xyXG4gICAgICAgIHN0YXRlLmVudi5mb290bm90ZXMubGlzdFtmb290bm90ZUlkXSA9IHsgbGFiZWw6IGxhYmVsLCBjb3VudDogMCB9O1xyXG4gICAgICAgIHN0YXRlLmVudi5mb290bm90ZXMucmVmc1snOicgKyBsYWJlbF0gPSBmb290bm90ZUlkO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvb3Rub3RlSWQgPSBzdGF0ZS5lbnYuZm9vdG5vdGVzLnJlZnNbJzonICsgbGFiZWxdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb290bm90ZVN1YklkID0gc3RhdGUuZW52LmZvb3Rub3Rlcy5saXN0W2Zvb3Rub3RlSWRdLmNvdW50O1xyXG4gICAgICBzdGF0ZS5lbnYuZm9vdG5vdGVzLmxpc3RbZm9vdG5vdGVJZF0uY291bnQrKztcclxuXHJcbiAgICAgIHRva2VuICAgICAgPSBzdGF0ZS5wdXNoKCdmb290bm90ZV9yZWYnLCAnJywgMCk7XHJcbiAgICAgIHRva2VuLm1ldGEgPSB7IGlkOiBmb290bm90ZUlkLCBzdWJJZDogZm9vdG5vdGVTdWJJZCB9O1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlLnBvcyA9IHBvcztcclxuICAgIHN0YXRlLnBvc01heCA9IG1heDtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLy8gR2x1ZSBmb290bm90ZSB0b2tlbnMgdG8gZW5kIG9mIHRva2VuIHN0cmVhbVxyXG4gIGZ1bmN0aW9uIGZvb3Rub3RlX3RhaWwoc3RhdGUpIHtcclxuICAgIHZhciBpLCBsLCBqLCB0LCBsYXN0UGFyYWdyYXBoLCBsaXN0LCB0b2tlbiwgdG9rZW5zLCBjdXJyZW50LCBjdXJyZW50TGFiZWwsXHJcbiAgICAgICAgaW5zaWRlUmVmID0gZmFsc2UsXHJcbiAgICAgICAgcmVmVG9rZW5zID0ge307XHJcblxyXG4gICAgaWYgKCFzdGF0ZS5lbnYuZm9vdG5vdGVzKSB7IHJldHVybjsgfVxyXG5cclxuICAgIHN0YXRlLnRva2VucyA9IHN0YXRlLnRva2Vucy5maWx0ZXIoZnVuY3Rpb24odG9rKSB7XHJcbiAgICAgIGlmICh0b2sudHlwZSA9PT0gJ2Zvb3Rub3RlX3JlZmVyZW5jZV9vcGVuJykge1xyXG4gICAgICAgIGluc2lkZVJlZiA9IHRydWU7XHJcbiAgICAgICAgY3VycmVudCA9IFtdO1xyXG4gICAgICAgIGN1cnJlbnRMYWJlbCA9IHRvay5tZXRhLmxhYmVsO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodG9rLnR5cGUgPT09ICdmb290bm90ZV9yZWZlcmVuY2VfY2xvc2UnKSB7XHJcbiAgICAgICAgaW5zaWRlUmVmID0gZmFsc2U7XHJcbiAgICAgICAgLy8gcHJlcGVuZCAnOicgdG8gYXZvaWQgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIG1lbWJlcnNcclxuICAgICAgICByZWZUb2tlbnNbJzonICsgY3VycmVudExhYmVsXSA9IGN1cnJlbnQ7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpbnNpZGVSZWYpIHsgY3VycmVudC5wdXNoKHRvayk7IH1cclxuICAgICAgcmV0dXJuICFpbnNpZGVSZWY7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoIXN0YXRlLmVudi5mb290bm90ZXMubGlzdCkgeyByZXR1cm47IH1cclxuICAgIGxpc3QgPSBzdGF0ZS5lbnYuZm9vdG5vdGVzLmxpc3Q7XHJcblxyXG4gICAgdG9rZW4gPSBuZXcgc3RhdGUuVG9rZW4oJ2Zvb3Rub3RlX2Jsb2NrX29wZW4nLCAnJywgMSk7XHJcbiAgICBzdGF0ZS50b2tlbnMucHVzaCh0b2tlbik7XHJcblxyXG4gICAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIHRva2VuICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2Zvb3Rub3RlX29wZW4nLCAnJywgMSk7XHJcbiAgICAgIHRva2VuLm1ldGEgPSB7IGlkOiBpIH07XHJcbiAgICAgIHN0YXRlLnRva2Vucy5wdXNoKHRva2VuKTtcclxuXHJcbiAgICAgIGlmIChsaXN0W2ldLnRva2Vucykge1xyXG4gICAgICAgIHRva2VucyA9IFtdO1xyXG5cclxuICAgICAgICB0b2tlbiAgICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbigncGFyYWdyYXBoX29wZW4nLCAncCcsIDEpO1xyXG4gICAgICAgIHRva2VuLmJsb2NrICAgID0gdHJ1ZTtcclxuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XHJcblxyXG4gICAgICAgIHRva2VuICAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCdpbmxpbmUnLCAnJywgMCk7XHJcbiAgICAgICAgdG9rZW4uY2hpbGRyZW4gPSBsaXN0W2ldLnRva2VucztcclxuICAgICAgICB0b2tlbi5jb250ZW50ICA9ICcnO1xyXG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcclxuXHJcbiAgICAgICAgdG9rZW4gICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ3BhcmFncmFwaF9jbG9zZScsICdwJywgLTEpO1xyXG4gICAgICAgIHRva2VuLmJsb2NrICAgID0gdHJ1ZTtcclxuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XHJcblxyXG4gICAgICB9IGVsc2UgaWYgKGxpc3RbaV0ubGFiZWwpIHtcclxuICAgICAgICB0b2tlbnMgPSByZWZUb2tlbnNbJzonICsgbGlzdFtpXS5sYWJlbF07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0YXRlLnRva2VucyA9IHN0YXRlLnRva2Vucy5jb25jYXQodG9rZW5zKTtcclxuICAgICAgaWYgKHN0YXRlLnRva2Vuc1tzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMV0udHlwZSA9PT0gJ3BhcmFncmFwaF9jbG9zZScpIHtcclxuICAgICAgICBsYXN0UGFyYWdyYXBoID0gc3RhdGUudG9rZW5zLnBvcCgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxhc3RQYXJhZ3JhcGggPSBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0ID0gbGlzdFtpXS5jb3VudCA+IDAgPyBsaXN0W2ldLmNvdW50IDogMTtcclxuICAgICAgZm9yIChqID0gMDsgaiA8IHQ7IGorKykge1xyXG4gICAgICAgIHRva2VuICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2Zvb3Rub3RlX2FuY2hvcicsICcnLCAwKTtcclxuICAgICAgICB0b2tlbi5tZXRhID0geyBpZDogaSwgc3ViSWQ6IGogfTtcclxuICAgICAgICBzdGF0ZS50b2tlbnMucHVzaCh0b2tlbik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChsYXN0UGFyYWdyYXBoKSB7XHJcbiAgICAgICAgc3RhdGUudG9rZW5zLnB1c2gobGFzdFBhcmFncmFwaCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRva2VuID0gbmV3IHN0YXRlLlRva2VuKCdmb290bm90ZV9jbG9zZScsICcnLCAtMSk7XHJcbiAgICAgIHN0YXRlLnRva2Vucy5wdXNoKHRva2VuKTtcclxuICAgIH1cclxuXHJcbiAgICB0b2tlbiA9IG5ldyBzdGF0ZS5Ub2tlbignZm9vdG5vdGVfYmxvY2tfY2xvc2UnLCAnJywgLTEpO1xyXG4gICAgc3RhdGUudG9rZW5zLnB1c2godG9rZW4pO1xyXG4gIH1cclxuXHJcbiAgbWQuYmxvY2sucnVsZXIuYmVmb3JlKCdyZWZlcmVuY2UnLCAnZm9vdG5vdGVfZGVmJywgZm9vdG5vdGVfZGVmLCB7IGFsdDogWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScgXSB9KTtcclxuICBtZC5pbmxpbmUucnVsZXIuYWZ0ZXIoJ2ltYWdlJywgJ2Zvb3Rub3RlX2lubGluZScsIGZvb3Rub3RlX2lubGluZSk7XHJcbiAgbWQuaW5saW5lLnJ1bGVyLmFmdGVyKCdmb290bm90ZV9pbmxpbmUnLCAnZm9vdG5vdGVfcmVmJywgZm9vdG5vdGVfcmVmKTtcclxuICBtZC5jb3JlLnJ1bGVyLmFmdGVyKCdpbmxpbmUnLCAnZm9vdG5vdGVfdGFpbCcsIGZvb3Rub3RlX3RhaWwpO1xyXG59O1xyXG5cclxufSx7fV19LHt9LFsxXSkoMSlcclxufSk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/markdown-it-footnote.js\n");

/***/ }),

/***/ "./lib/markdown-it.js":
/*!****************************!*\
  !*** ./lib/markdown-it.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/*! markdown-it 4.1.1 https://github.com//markdown-it/markdown-it @license MIT */(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\r\n// HTML5 entities map: { name -> utf16string }\r\n//\r\n'use strict';\r\n\r\n/*eslint quotes:0*/\r\nmodule.exports = require('entities/maps/entities.json');\r\n\r\n},{\"entities/maps/entities.json\":52}],2:[function(require,module,exports){\r\n// List of valid html blocks names, accorting to commonmark spec\r\n// http://jgm.github.io/CommonMark/spec.html#html-blocks\r\n\r\n'use strict';\r\n\r\nvar html_blocks = {};\r\n\r\n[\r\n  'article',\r\n  'aside',\r\n  'button',\r\n  'blockquote',\r\n  'body',\r\n  'canvas',\r\n  'caption',\r\n  'col',\r\n  'colgroup',\r\n  'dd',\r\n  'div',\r\n  'dl',\r\n  'dt',\r\n  'embed',\r\n  'fieldset',\r\n  'figcaption',\r\n  'figure',\r\n  'footer',\r\n  'form',\r\n  'h1',\r\n  'h2',\r\n  'h3',\r\n  'h4',\r\n  'h5',\r\n  'h6',\r\n  'header',\r\n  'hgroup',\r\n  'hr',\r\n  'iframe',\r\n  'li',\r\n  'map',\r\n  'object',\r\n  'ol',\r\n  'output',\r\n  'p',\r\n  'pre',\r\n  'progress',\r\n  'script',\r\n  'section',\r\n  'style',\r\n  'table',\r\n  'tbody',\r\n  'td',\r\n  'textarea',\r\n  'tfoot',\r\n  'th',\r\n  'tr',\r\n  'thead',\r\n  'ul',\r\n  'video'\r\n].forEach(function (name) { html_blocks[name] = true; });\r\n\r\n\r\nmodule.exports = html_blocks;\r\n\r\n},{}],3:[function(require,module,exports){\r\n// Regexps to match html elements\r\n\r\n'use strict';\r\n\r\nvar attr_name     = '[a-zA-Z_:][a-zA-Z0-9:._-]*';\r\n\r\nvar unquoted      = '[^\"\\'=<>`\\\\x00-\\\\x20]+';\r\nvar single_quoted = \"'[^']*'\";\r\nvar double_quoted = '\"[^\"]*\"';\r\n\r\nvar attr_value  = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';\r\n\r\nvar attribute   = '(?:\\\\s+' + attr_name + '(?:\\\\s*=\\\\s*' + attr_value + ')?)';\r\n\r\nvar open_tag    = '<[A-Za-z][A-Za-z0-9\\\\-]*' + attribute + '*\\\\s*\\\\/?>';\r\n\r\nvar close_tag   = '<\\\\/[A-Za-z][A-Za-z0-9\\\\-]*\\\\s*>';\r\nvar comment     = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';\r\nvar processing  = '<[?].*?[?]>';\r\nvar declaration = '<![A-Z]+\\\\s+[^>]*>';\r\nvar cdata       = '<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>';\r\n\r\nvar HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment +\r\n                        '|' + processing + '|' + declaration + '|' + cdata + ')');\r\n\r\nmodule.exports.HTML_TAG_RE = HTML_TAG_RE;\r\n\r\n},{}],4:[function(require,module,exports){\r\n// List of valid url schemas, accorting to commonmark spec\r\n// http://jgm.github.io/CommonMark/spec.html#autolinks\r\n\r\n'use strict';\r\n\r\n\r\nmodule.exports = [\r\n  'coap',\r\n  'doi',\r\n  'javascript',\r\n  'aaa',\r\n  'aaas',\r\n  'about',\r\n  'acap',\r\n  'cap',\r\n  'cid',\r\n  'crid',\r\n  'data',\r\n  'dav',\r\n  'dict',\r\n  'dns',\r\n  'file',\r\n  'ftp',\r\n  'geo',\r\n  'go',\r\n  'gopher',\r\n  'h323',\r\n  'http',\r\n  'https',\r\n  'iax',\r\n  'icap',\r\n  'im',\r\n  'imap',\r\n  'info',\r\n  'ipp',\r\n  'iris',\r\n  'iris.beep',\r\n  'iris.xpc',\r\n  'iris.xpcs',\r\n  'iris.lwz',\r\n  'ldap',\r\n  'mailto',\r\n  'mid',\r\n  'msrp',\r\n  'msrps',\r\n  'mtqp',\r\n  'mupdate',\r\n  'news',\r\n  'nfs',\r\n  'ni',\r\n  'nih',\r\n  'nntp',\r\n  'opaquelocktoken',\r\n  'pop',\r\n  'pres',\r\n  'rtsp',\r\n  'service',\r\n  'session',\r\n  'shttp',\r\n  'sieve',\r\n  'sip',\r\n  'sips',\r\n  'sms',\r\n  'snmp',\r\n  'soap.beep',\r\n  'soap.beeps',\r\n  'tag',\r\n  'tel',\r\n  'telnet',\r\n  'tftp',\r\n  'thismessage',\r\n  'tn3270',\r\n  'tip',\r\n  'tv',\r\n  'urn',\r\n  'vemmi',\r\n  'ws',\r\n  'wss',\r\n  'xcon',\r\n  'xcon-userid',\r\n  'xmlrpc.beep',\r\n  'xmlrpc.beeps',\r\n  'xmpp',\r\n  'z39.50r',\r\n  'z39.50s',\r\n  'adiumxtra',\r\n  'afp',\r\n  'afs',\r\n  'aim',\r\n  'apt',\r\n  'attachment',\r\n  'aw',\r\n  'beshare',\r\n  'bitcoin',\r\n  'bolo',\r\n  'callto',\r\n  'chrome',\r\n  'chrome-extension',\r\n  'com-eventbrite-attendee',\r\n  'content',\r\n  'cvs',\r\n  'dlna-playsingle',\r\n  'dlna-playcontainer',\r\n  'dtn',\r\n  'dvb',\r\n  'ed2k',\r\n  'facetime',\r\n  'feed',\r\n  'finger',\r\n  'fish',\r\n  'gg',\r\n  'git',\r\n  'gizmoproject',\r\n  'gtalk',\r\n  'hcp',\r\n  'icon',\r\n  'ipn',\r\n  'irc',\r\n  'irc6',\r\n  'ircs',\r\n  'itms',\r\n  'jar',\r\n  'jms',\r\n  'keyparc',\r\n  'lastfm',\r\n  'ldaps',\r\n  'magnet',\r\n  'maps',\r\n  'market',\r\n  'message',\r\n  'mms',\r\n  'ms-help',\r\n  'msnim',\r\n  'mumble',\r\n  'mvn',\r\n  'notes',\r\n  'oid',\r\n  'palm',\r\n  'paparazzi',\r\n  'platform',\r\n  'proxy',\r\n  'psyc',\r\n  'query',\r\n  'res',\r\n  'resource',\r\n  'rmi',\r\n  'rsync',\r\n  'rtmp',\r\n  'secondlife',\r\n  'sftp',\r\n  'sgn',\r\n  'skype',\r\n  'smb',\r\n  'soldat',\r\n  'spotify',\r\n  'ssh',\r\n  'steam',\r\n  'svn',\r\n  'teamspeak',\r\n  'things',\r\n  'udp',\r\n  'unreal',\r\n  'ut2004',\r\n  'ventrilo',\r\n  'view-source',\r\n  'webcal',\r\n  'wtai',\r\n  'wyciwyg',\r\n  'xfire',\r\n  'xri',\r\n  'ymsgr'\r\n];\r\n\r\n},{}],5:[function(require,module,exports){\r\n// Utilities\r\n//\r\n'use strict';\r\n\r\n\r\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\r\n\r\nfunction isString(obj) { return _class(obj) === '[object String]'; }\r\n\r\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\nfunction has(object, key) {\r\n  return _hasOwnProperty.call(object, key);\r\n}\r\n\r\n// Merge objects\r\n//\r\nfunction assign(obj /*from1, from2, from3, ...*/) {\r\n  var sources = Array.prototype.slice.call(arguments, 1);\r\n\r\n  sources.forEach(function (source) {\r\n    if (!source) { return; }\r\n\r\n    if (typeof source !== 'object') {\r\n      throw new TypeError(source + 'must be object');\r\n    }\r\n\r\n    Object.keys(source).forEach(function (key) {\r\n      obj[key] = source[key];\r\n    });\r\n  });\r\n\r\n  return obj;\r\n}\r\n\r\n// Remove element from array and put another array at those position.\r\n// Useful for some operations with tokens\r\nfunction arrayReplaceAt(src, pos, newElements) {\r\n  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction isValidEntityCode(c) {\r\n  /*eslint no-bitwise:0*/\r\n  // broken sequence\r\n  if (c >= 0xD800 && c <= 0xDFFF) { return false; }\r\n  // never used\r\n  if (c >= 0xFDD0 && c <= 0xFDEF) { return false; }\r\n  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false; }\r\n  // control codes\r\n  if (c >= 0x00 && c <= 0x08) { return false; }\r\n  if (c === 0x0B) { return false; }\r\n  if (c >= 0x0E && c <= 0x1F) { return false; }\r\n  if (c >= 0x7F && c <= 0x9F) { return false; }\r\n  // out of range\r\n  if (c > 0x10FFFF) { return false; }\r\n  return true;\r\n}\r\n\r\nfunction fromCodePoint(c) {\r\n  /*eslint no-bitwise:0*/\r\n  if (c > 0xffff) {\r\n    c -= 0x10000;\r\n    var surrogate1 = 0xd800 + (c >> 10),\r\n        surrogate2 = 0xdc00 + (c & 0x3ff);\r\n\r\n    return String.fromCharCode(surrogate1, surrogate2);\r\n  }\r\n  return String.fromCharCode(c);\r\n}\r\n\r\n\r\nvar UNESCAPE_MD_RE  = /\\\\([!\"#$%&'()*+,\\-.\\/:;<=>?@[\\\\\\]^_`{|}~])/g;\r\nvar ENTITY_RE       = /&([a-z#][a-z0-9]{1,31});/gi;\r\nvar UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');\r\n\r\nvar DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;\r\n\r\nvar entities = require('./entities');\r\n\r\nfunction replaceEntityPattern(match, name) {\r\n  var code = 0;\r\n\r\n  if (has(entities, name)) {\r\n    return entities[name];\r\n  }\r\n\r\n  if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {\r\n    code = name[1].toLowerCase() === 'x' ?\r\n      parseInt(name.slice(2), 16)\r\n    :\r\n      parseInt(name.slice(1), 10);\r\n    if (isValidEntityCode(code)) {\r\n      return fromCodePoint(code);\r\n    }\r\n  }\r\n\r\n  return match;\r\n}\r\n\r\n/*function replaceEntities(str) {\r\n  if (str.indexOf('&') < 0) { return str; }\r\n\r\n  return str.replace(ENTITY_RE, replaceEntityPattern);\r\n}*/\r\n\r\nfunction unescapeMd(str) {\r\n  if (str.indexOf('\\\\') < 0) { return str; }\r\n  return str.replace(UNESCAPE_MD_RE, '$1');\r\n}\r\n\r\nfunction unescapeAll(str) {\r\n  if (str.indexOf('\\\\') < 0 && str.indexOf('&') < 0) { return str; }\r\n\r\n  return str.replace(UNESCAPE_ALL_RE, function(match, escaped, entity) {\r\n    if (escaped) { return escaped; }\r\n    return replaceEntityPattern(match, entity);\r\n  });\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar HTML_ESCAPE_TEST_RE = /[&<>\"]/;\r\nvar HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g;\r\nvar HTML_REPLACEMENTS = {\r\n  '&': '&amp;',\r\n  '<': '&lt;',\r\n  '>': '&gt;',\r\n  '\"': '&quot;'\r\n};\r\n\r\nfunction replaceUnsafeChar(ch) {\r\n  return HTML_REPLACEMENTS[ch];\r\n}\r\n\r\nfunction escapeHtml(str) {\r\n  if (HTML_ESCAPE_TEST_RE.test(str)) {\r\n    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);\r\n  }\r\n  return str;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar REGEXP_ESCAPE_RE = /[.?*+^$[\\]\\\\(){}|-]/g;\r\n\r\nfunction escapeRE (str) {\r\n  return str.replace(REGEXP_ESCAPE_RE, '\\\\$&');\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n// Zs (unicode class) || [\\t\\f\\v\\r\\n]\r\nfunction isWhiteSpace(code) {\r\n  if (code >= 0x2000 && code <= 0x200A) { return true; }\r\n  switch (code) {\r\n    case 0x09: // \\t\r\n    case 0x0A: // \\n\r\n    case 0x0B: // \\v\r\n    case 0x0C: // \\f\r\n    case 0x0D: // \\r\r\n    case 0x20:\r\n    case 0xA0:\r\n    case 0x1680:\r\n    case 0x202F:\r\n    case 0x205F:\r\n    case 0x3000:\r\n      return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n/*eslint-disable max-len*/\r\nvar UNICODE_PUNCT_RE = require('uc.micro/categories/P/regex');\r\n\r\n// Currently without astral characters support.\r\nfunction isPunctChar(char) {\r\n  return UNICODE_PUNCT_RE.test(char);\r\n}\r\n\r\n\r\n// Markdown ASCII punctuation characters.\r\n//\r\n// !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\r\n// http://spec.commonmark.org/0.15/#ascii-punctuation-character\r\n//\r\n// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.\r\n//\r\nfunction isMdAsciiPunct(ch) {\r\n  switch (ch) {\r\n    case 0x21/* ! */:\r\n    case 0x22/* \" */:\r\n    case 0x23/* # */:\r\n    case 0x24/* $ */:\r\n    case 0x25/* % */:\r\n    case 0x26/* & */:\r\n    case 0x27/* ' */:\r\n    case 0x28/* ( */:\r\n    case 0x29/* ) */:\r\n    case 0x2A/* * */:\r\n    case 0x2B/* + */:\r\n    case 0x2C/* , */:\r\n    case 0x2D/* - */:\r\n    case 0x2E/* . */:\r\n    case 0x2F/* / */:\r\n    case 0x3A/* : */:\r\n    case 0x3B/* ; */:\r\n    case 0x3C/* < */:\r\n    case 0x3D/* = */:\r\n    case 0x3E/* > */:\r\n    case 0x3F/* ? */:\r\n    case 0x40/* @ */:\r\n    case 0x5B/* [ */:\r\n    case 0x5C/* \\ */:\r\n    case 0x5D/* ] */:\r\n    case 0x5E/* ^ */:\r\n    case 0x5F/* _ */:\r\n    case 0x60/* ` */:\r\n    case 0x7B/* { */:\r\n    case 0x7C/* | */:\r\n    case 0x7D/* } */:\r\n    case 0x7E/* ~ */:\r\n      return true;\r\n    default:\r\n      return false;\r\n  }\r\n}\r\n\r\n// Hepler to unify [reference labels].\r\n//\r\nfunction normalizeReference(str) {\r\n  // use .toUpperCase() instead of .toLowerCase()\r\n  // here to avoid a conflict with Object.prototype\r\n  // members (most notably, `__proto__`)\r\n  return str.trim().replace(/\\s+/g, ' ').toUpperCase();\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n// Re-export libraries commonly used in both markdown-it and its plugins,\r\n// so plugins won't have to depend on them explicitly, which reduces their\r\n// bundled size (e.g. a browser build).\r\n//\r\nexports.lib                 = {};\r\nexports.lib.mdurl           = require('mdurl');\r\nexports.lib.ucmicro         = require('uc.micro');\r\n\r\nexports.assign              = assign;\r\nexports.isString            = isString;\r\nexports.has                 = has;\r\nexports.unescapeMd          = unescapeMd;\r\nexports.unescapeAll         = unescapeAll;\r\nexports.isValidEntityCode   = isValidEntityCode;\r\nexports.fromCodePoint       = fromCodePoint;\r\n// exports.replaceEntities     = replaceEntities;\r\nexports.escapeHtml          = escapeHtml;\r\nexports.arrayReplaceAt      = arrayReplaceAt;\r\nexports.isWhiteSpace        = isWhiteSpace;\r\nexports.isMdAsciiPunct      = isMdAsciiPunct;\r\nexports.isPunctChar         = isPunctChar;\r\nexports.escapeRE            = escapeRE;\r\nexports.normalizeReference  = normalizeReference;\r\n\r\n},{\"./entities\":1,\"mdurl\":58,\"uc.micro\":64,\"uc.micro/categories/P/regex\":62}],6:[function(require,module,exports){\r\n// Just a shortcut for bulk export\r\n'use strict';\r\n\r\n\r\nexports.parseLinkLabel       = require('./parse_link_label');\r\nexports.parseLinkDestination = require('./parse_link_destination');\r\nexports.parseLinkTitle       = require('./parse_link_title');\r\n\r\n},{\"./parse_link_destination\":7,\"./parse_link_label\":8,\"./parse_link_title\":9}],7:[function(require,module,exports){\r\n// Parse link destination\r\n//\r\n'use strict';\r\n\r\n\r\nvar unescapeAll   = require('../common/utils').unescapeAll;\r\n\r\n\r\nmodule.exports = function parseLinkDestination(str, pos, max) {\r\n  var code, level,\r\n      lines = 0,\r\n      start = pos,\r\n      result = {\r\n        ok: false,\r\n        pos: 0,\r\n        lines: 0,\r\n        str: ''\r\n      };\r\n\r\n  if (str.charCodeAt(pos) === 0x3C /* < */) {\r\n    pos++;\r\n    while (pos < max) {\r\n      code = str.charCodeAt(pos);\r\n      if (code === 0x0A /* \\n */) { return result; }\r\n      if (code === 0x3E /* > */) {\r\n        result.pos = pos + 1;\r\n        result.str = unescapeAll(str.slice(start + 1, pos));\r\n        result.ok = true;\r\n        return result;\r\n      }\r\n      if (code === 0x5C /* \\ */ && pos + 1 < max) {\r\n        pos += 2;\r\n        continue;\r\n      }\r\n\r\n      pos++;\r\n    }\r\n\r\n    // no closing '>'\r\n    return result;\r\n  }\r\n\r\n  // this should be ... } else { ... branch\r\n\r\n  level = 0;\r\n  while (pos < max) {\r\n    code = str.charCodeAt(pos);\r\n\r\n    if (code === 0x20) { break; }\r\n\r\n    // ascii control characters\r\n    if (code < 0x20 || code === 0x7F) { break; }\r\n\r\n    if (code === 0x5C /* \\ */ && pos + 1 < max) {\r\n      pos += 2;\r\n      continue;\r\n    }\r\n\r\n    if (code === 0x28 /* ( */) {\r\n      level++;\r\n      if (level > 1) { break; }\r\n    }\r\n\r\n    if (code === 0x29 /* ) */) {\r\n      level--;\r\n      if (level < 0) { break; }\r\n    }\r\n\r\n    pos++;\r\n  }\r\n\r\n  if (start === pos) { return result; }\r\n\r\n  result.str = unescapeAll(str.slice(start, pos));\r\n  result.lines = lines;\r\n  result.pos = pos;\r\n  result.ok = true;\r\n  return result;\r\n};\r\n\r\n},{\"../common/utils\":5}],8:[function(require,module,exports){\r\n// Parse link label\r\n//\r\n// this function assumes that first character (\"[\") already matches;\r\n// returns the end of the label\r\n//\r\n'use strict';\r\n\r\nmodule.exports = function parseLinkLabel(state, start, disableNested) {\r\n  var level, found, marker, prevPos,\r\n      labelEnd = -1,\r\n      max = state.posMax,\r\n      oldPos = state.pos;\r\n\r\n  state.pos = start + 1;\r\n  level = 1;\r\n\r\n  while (state.pos < max) {\r\n    marker = state.src.charCodeAt(state.pos);\r\n    if (marker === 0x5D /* ] */) {\r\n      level--;\r\n      if (level === 0) {\r\n        found = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    prevPos = state.pos;\r\n    state.md.inline.skipToken(state);\r\n    if (marker === 0x5B /* [ */) {\r\n      if (prevPos === state.pos - 1) {\r\n        // increase level if we find text `[`, which is not a part of any token\r\n        level++;\r\n      } else if (disableNested) {\r\n        state.pos = oldPos;\r\n        return -1;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (found) {\r\n    labelEnd = state.pos;\r\n  }\r\n\r\n  // restore old state\r\n  state.pos = oldPos;\r\n\r\n  return labelEnd;\r\n};\r\n\r\n},{}],9:[function(require,module,exports){\r\n// Parse link title\r\n//\r\n'use strict';\r\n\r\n\r\nvar unescapeAll = require('../common/utils').unescapeAll;\r\n\r\n\r\nmodule.exports = function parseLinkTitle(str, pos, max) {\r\n  var code,\r\n      marker,\r\n      lines = 0,\r\n      start = pos,\r\n      result = {\r\n        ok: false,\r\n        pos: 0,\r\n        lines: 0,\r\n        str: ''\r\n      };\r\n\r\n  if (pos >= max) { return result; }\r\n\r\n  marker = str.charCodeAt(pos);\r\n\r\n  if (marker !== 0x22 /* \" */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) { return result; }\r\n\r\n  pos++;\r\n\r\n  // if opening marker is \"(\", switch it to closing marker \")\"\r\n  if (marker === 0x28) { marker = 0x29; }\r\n\r\n  while (pos < max) {\r\n    code = str.charCodeAt(pos);\r\n    if (code === marker) {\r\n      result.pos = pos + 1;\r\n      result.lines = lines;\r\n      result.str = unescapeAll(str.slice(start + 1, pos));\r\n      result.ok = true;\r\n      return result;\r\n    } else if (code === 0x0A) {\r\n      lines++;\r\n    } else if (code === 0x5C /* \\ */ && pos + 1 < max) {\r\n      pos++;\r\n      if (str.charCodeAt(pos) === 0x0A) {\r\n        lines++;\r\n      }\r\n    }\r\n\r\n    pos++;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n},{\"../common/utils\":5}],10:[function(require,module,exports){\r\n// Main perser class\r\n\r\n'use strict';\r\n\r\n\r\nvar utils        = require('./common/utils');\r\nvar helpers      = require('./helpers');\r\nvar Renderer     = require('./renderer');\r\nvar ParserCore   = require('./parser_core');\r\nvar ParserBlock  = require('./parser_block');\r\nvar ParserInline = require('./parser_inline');\r\nvar LinkifyIt    = require('linkify-it');\r\nvar mdurl        = require('mdurl');\r\nvar punycode     = require('punycode');\r\n\r\n\r\nvar config = {\r\n  'default': require('./presets/default'),\r\n  zero: require('./presets/zero'),\r\n  commonmark: require('./presets/commonmark')\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n//\r\n// This validator does not pretend to functionality of full weight sanitizers.\r\n// It's a tradeoff between default security, simplicity and usability.\r\n// If you need different setup - override validator method as you wish. Or\r\n// replace it with dummy function and use external sanitizer.\r\n//\r\n\r\nvar BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;\r\nvar GOOD_DATA_RE = /^data:image\\/(gif|png|jpeg|webp);/;\r\n\r\nfunction validateLink(url) {\r\n  // url should be normalized at this point, and existing entities are decoded\r\n  var str = url.trim().toLowerCase();\r\n\r\n  return BAD_PROTO_RE.test(str) ? (GOOD_DATA_RE.test(str) ? true : false) : true;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\nvar RECODE_HOSTNAME_FOR = [ 'http:', 'https:', 'mailto:' ];\r\n\r\nfunction normalizeLink(url) {\r\n  var parsed = mdurl.parse(url, true);\r\n\r\n  if (parsed.hostname) {\r\n    // Encode hostnames in urls like:\r\n    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`\r\n    //\r\n    // We don't encode unknown schemas, because it's likely that we encode\r\n    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)\r\n    //\r\n    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {\r\n      try {\r\n        parsed.hostname = punycode.toASCII(parsed.hostname);\r\n      } catch(er) {}\r\n    }\r\n  }\r\n\r\n  return mdurl.encode(mdurl.format(parsed));\r\n}\r\n\r\nfunction normalizeLinkText(url) {\r\n  var parsed = mdurl.parse(url, true);\r\n\r\n  if (parsed.hostname) {\r\n    // Encode hostnames in urls like:\r\n    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`\r\n    //\r\n    // We don't encode unknown schemas, because it's likely that we encode\r\n    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)\r\n    //\r\n    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {\r\n      try {\r\n        parsed.hostname = punycode.toUnicode(parsed.hostname);\r\n      } catch(er) {}\r\n    }\r\n  }\r\n\r\n  return mdurl.decode(mdurl.format(parsed));\r\n}\r\n\r\n\r\n/**\r\n * class MarkdownIt\r\n *\r\n * Main parser/renderer class.\r\n *\r\n * ##### Usage\r\n *\r\n * ```javascript\r\n * // node.js, \"classic\" way:\r\n * var MarkdownIt = require('markdown-it'),\r\n *     md = new MarkdownIt();\r\n * var result = md.render('# markdown-it rulezz!');\r\n *\r\n * // node.js, the same, but with sugar:\r\n * var md = require('markdown-it')();\r\n * var result = md.render('# markdown-it rulezz!');\r\n *\r\n * // browser without AMD, added to \"window\" on script load\r\n * // Note, there are no dash.\r\n * var md = window.markdownit();\r\n * var result = md.render('# markdown-it rulezz!');\r\n * ```\r\n *\r\n * Single line rendering, without paragraph wrap:\r\n *\r\n * ```javascript\r\n * var md = require('markdown-it')();\r\n * var result = md.renderInline('__markdown-it__ rulezz!');\r\n * ```\r\n **/\r\n\r\n/**\r\n * new MarkdownIt([presetName, options])\r\n * - presetName (String): optional, `commonmark` / `zero`\r\n * - options (Object)\r\n *\r\n * Creates parser instanse with given config. Can be called without `new`.\r\n *\r\n * ##### presetName\r\n *\r\n * MarkdownIt provides named presets as a convenience to quickly\r\n * enable/disable active syntax rules and options for common use cases.\r\n *\r\n * - [\"commonmark\"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -\r\n *   configures parser to strict [CommonMark](http://commonmark.org/) mode.\r\n * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -\r\n *   similar to GFM, used when no preset name given. Enables all available rules,\r\n *   but still without html, typographer & autolinker.\r\n * - [\"zero\"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -\r\n *   all rules disabled. Useful to quickly setup your config via `.enable()`.\r\n *   For example, when you need only `bold` and `italic` markup and nothing else.\r\n *\r\n * ##### options:\r\n *\r\n * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!\r\n *   That's not safe! You may need external sanitizer to protect output from XSS.\r\n *   It's better to extend features via plugins, instead of enabling HTML.\r\n * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags\r\n *   (`<br />`). This is needed only for full CommonMark compatibility. In real\r\n *   world you will need HTML output.\r\n * - __breaks__ - `false`. Set `true` to convert `\\n` in paragraphs into `<br>`.\r\n * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.\r\n *   Can be useful for external highlighters.\r\n * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.\r\n * - __typographer__  - `false`. Set `true` to enable [some language-neutral\r\n *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +\r\n *   quotes beautification (smartquotes).\r\n * - __quotes__ - ``, string. Double + single quotes replacement pairs, when\r\n *   typographer enabled and smartquotes on. Set doubles to '' for Russian,\r\n *   '' for German.\r\n * - __highlight__ - `null`. Highlighter function for fenced code blocks.\r\n *   Highlighter `function (str, lang)` should return escaped HTML. It can also\r\n *   return empty string if the source was not changed and should be escaped externaly.\r\n *\r\n * ##### Example\r\n *\r\n * ```javascript\r\n * // commonmark mode\r\n * var md = require('markdown-it')('commonmark');\r\n *\r\n * // default mode\r\n * var md = require('markdown-it')();\r\n *\r\n * // enable everything\r\n * var md = require('markdown-it')({\r\n *   html: true,\r\n *   linkify: true,\r\n *   typographer: true\r\n * });\r\n * ```\r\n *\r\n * ##### Syntax highlighting\r\n *\r\n * ```js\r\n * var hljs = require('highlight.js') // https://highlightjs.org/\r\n *\r\n * var md = require('markdown-it')({\r\n *   highlight: function (str, lang) {\r\n *     if (lang && hljs.getLanguage(lang)) {\r\n *       try {\r\n *         return hljs.highlight(lang, str).value;\r\n *       } catch (__) {}\r\n *     }\r\n *\r\n *     try {\r\n *       return hljs.highlightAuto(str).value;\r\n *     } catch (__) {}\r\n *\r\n *     return ''; // use external default escaping\r\n *   }\r\n * });\r\n * ```\r\n **/\r\nfunction MarkdownIt(presetName, options) {\r\n  if (!(this instanceof MarkdownIt)) {\r\n    return new MarkdownIt(presetName, options);\r\n  }\r\n\r\n  if (!options) {\r\n    if (!utils.isString(presetName)) {\r\n      options = presetName || {};\r\n      presetName = 'default';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * MarkdownIt#inline -> ParserInline\r\n   *\r\n   * Instance of [[ParserInline]]. You may need it to add new rules when\r\n   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\r\n   * [[MarkdownIt.enable]].\r\n   **/\r\n  this.inline = new ParserInline();\r\n\r\n  /**\r\n   * MarkdownIt#block -> ParserBlock\r\n   *\r\n   * Instance of [[ParserBlock]]. You may need it to add new rules when\r\n   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\r\n   * [[MarkdownIt.enable]].\r\n   **/\r\n  this.block = new ParserBlock();\r\n\r\n  /**\r\n   * MarkdownIt#core -> Core\r\n   *\r\n   * Instance of [[Core]] chain executor. You may need it to add new rules when\r\n   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\r\n   * [[MarkdownIt.enable]].\r\n   **/\r\n  this.core = new ParserCore();\r\n\r\n  /**\r\n   * MarkdownIt#renderer -> Renderer\r\n   *\r\n   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering\r\n   * rules for new token types, generated by plugins.\r\n   *\r\n   * ##### Example\r\n   *\r\n   * ```javascript\r\n   * var md = require('markdown-it')();\r\n   *\r\n   * function myToken(tokens, idx, options, env, self) {\r\n   *   //...\r\n   *   return result;\r\n   * };\r\n   *\r\n   * md.renderer.rules['my_token'] = myToken\r\n   * ```\r\n   *\r\n   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).\r\n   **/\r\n  this.renderer = new Renderer();\r\n\r\n  /**\r\n   * MarkdownIt#linkify -> LinkifyIt\r\n   *\r\n   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.\r\n   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)\r\n   * rule.\r\n   **/\r\n  this.linkify = new LinkifyIt();\r\n\r\n  /**\r\n   * MarkdownIt#validateLink(url) -> Boolean\r\n   *\r\n   * Link validation function. CommonMark allows too much in links. By default\r\n   * we disable `javascript:` and `vbscript:` schemas. You can change this\r\n   * behaviour.\r\n   *\r\n   * ```javascript\r\n   * var md = require('markdown-it')();\r\n   * // enable everything\r\n   * md.validateLink = function () { return true; }\r\n   * ```\r\n   **/\r\n  this.validateLink = validateLink;\r\n\r\n  /**\r\n   * MarkdownIt#normalizeLink(url) -> String\r\n   *\r\n   * Function used to encode link url to a machine-readable format,\r\n   * which includes url-encoding, punycode, etc.\r\n   **/\r\n  this.normalizeLink = normalizeLink;\r\n\r\n  /**\r\n   * MarkdownIt#normalizeLinkText(url) -> String\r\n   *\r\n   * Function used to decode link url to a human-readable format`\r\n   **/\r\n  this.normalizeLinkText = normalizeLinkText;\r\n\r\n\r\n  // Expose utils & helpers for easy acces from plugins\r\n\r\n  /**\r\n   * MarkdownIt#utils -> utils\r\n   *\r\n   * Assorted utility functions, useful to write plugins. See details\r\n   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).\r\n   **/\r\n  this.utils = utils;\r\n\r\n  /**\r\n   * MarkdownIt#helpers -> helpers\r\n   *\r\n   * Link components parser functions, useful to write plugins. See details\r\n   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).\r\n   **/\r\n  this.helpers = helpers;\r\n\r\n\r\n  this.options = {};\r\n  this.configure(presetName);\r\n\r\n  if (options) { this.set(options); }\r\n}\r\n\r\n\r\n/** chainable\r\n * MarkdownIt.set(options)\r\n *\r\n * Set parser options (in the same format as in constructor). Probably, you\r\n * will never need it, but you can change options after constructor call.\r\n *\r\n * ##### Example\r\n *\r\n * ```javascript\r\n * var md = require('markdown-it')()\r\n *             .set({ html: true, breaks: true })\r\n *             .set({ typographer, true });\r\n * ```\r\n *\r\n * __Note:__ To achieve the best possible performance, don't modify a\r\n * `markdown-it` instance options on the fly. If you need multiple configurations\r\n * it's best to create multiple instances and initialize each with separate\r\n * config.\r\n **/\r\nMarkdownIt.prototype.set = function (options) {\r\n  utils.assign(this.options, options);\r\n  return this;\r\n};\r\n\r\n\r\n/** chainable, internal\r\n * MarkdownIt.configure(presets)\r\n *\r\n * Batch load of all options and compenent settings. This is internal method,\r\n * and you probably will not need it. But if you with - see available presets\r\n * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)\r\n *\r\n * We strongly recommend to use presets instead of direct config loads. That\r\n * will give better compatibility with next versions.\r\n **/\r\nMarkdownIt.prototype.configure = function (presets) {\r\n  var self = this, presetName;\r\n\r\n  if (utils.isString(presets)) {\r\n    presetName = presets;\r\n    presets = config[presetName];\r\n    if (!presets) { throw new Error('Wrong `markdown-it` preset \"' + presetName + '\", check name'); }\r\n  }\r\n\r\n  if (!presets) { throw new Error('Wrong `markdown-it` preset, can\\'t be empty'); }\r\n\r\n  if (presets.options) { self.set(presets.options); }\r\n\r\n  if (presets.components) {\r\n    Object.keys(presets.components).forEach(function (name) {\r\n      if (presets.components[name].rules) {\r\n        self[name].ruler.enableOnly(presets.components[name].rules);\r\n      }\r\n    });\r\n  }\r\n  return this;\r\n};\r\n\r\n\r\n/** chainable\r\n * MarkdownIt.enable(list, ignoreInvalid)\r\n * - list (String|Array): rule name or list of rule names to enable\r\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\r\n *\r\n * Enable list or rules. It will automatically find appropriate components,\r\n * containing rules with given names. If rule not found, and `ignoreInvalid`\r\n * not set - throws exception.\r\n *\r\n * ##### Example\r\n *\r\n * ```javascript\r\n * var md = require('markdown-it')()\r\n *             .enable(['sub', 'sup'])\r\n *             .disable('smartquotes');\r\n * ```\r\n **/\r\nMarkdownIt.prototype.enable = function (list, ignoreInvalid) {\r\n  var result = [];\r\n\r\n  if (!Array.isArray(list)) { list = [ list ]; }\r\n\r\n  [ 'core', 'block', 'inline' ].forEach(function (chain) {\r\n    result = result.concat(this[chain].ruler.enable(list, true));\r\n  }, this);\r\n\r\n  var missed = list.filter(function (name) { return result.indexOf(name) < 0; });\r\n\r\n  if (missed.length && !ignoreInvalid) {\r\n    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n\r\n/** chainable\r\n * MarkdownIt.disable(list, ignoreInvalid)\r\n * - list (String|Array): rule name or list of rule names to disable.\r\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\r\n *\r\n * The same as [[MarkdownIt.enable]], but turn specified rules off.\r\n **/\r\nMarkdownIt.prototype.disable = function (list, ignoreInvalid) {\r\n  var result = [];\r\n\r\n  if (!Array.isArray(list)) { list = [ list ]; }\r\n\r\n  [ 'core', 'block', 'inline' ].forEach(function (chain) {\r\n    result = result.concat(this[chain].ruler.disable(list, true));\r\n  }, this);\r\n\r\n  var missed = list.filter(function (name) { return result.indexOf(name) < 0; });\r\n\r\n  if (missed.length && !ignoreInvalid) {\r\n    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);\r\n  }\r\n  return this;\r\n};\r\n\r\n\r\n/** chainable\r\n * MarkdownIt.use(plugin, params)\r\n *\r\n * Load specified plugin with given params into current parser instance.\r\n * It's just a sugar to call `plugin(md, params)` with curring.\r\n *\r\n * ##### Example\r\n *\r\n * ```javascript\r\n * var iterator = require('markdown-it-for-inline');\r\n * var md = require('markdown-it')()\r\n *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {\r\n *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');\r\n *             });\r\n * ```\r\n **/\r\nMarkdownIt.prototype.use = function (plugin /*, params, ... */) {\r\n  var args = [ this ].concat(Array.prototype.slice.call(arguments, 1));\r\n  plugin.apply(plugin, args);\r\n  return this;\r\n};\r\n\r\n\r\n/** internal\r\n * MarkdownIt.parse(src, env) -> Array\r\n * - src (String): source string\r\n * - env (Object): environment sandbox\r\n *\r\n * Parse input string and returns list of block tokens (special token type\r\n * \"inline\" will contain list of inline tokens). You should not call this\r\n * method directly, until you write custom renderer (for example, to produce\r\n * AST).\r\n *\r\n * `env` is used to pass data between \"distributed\" rules and return additional\r\n * metadata like reference info, needed for for renderer. It also can be used to\r\n * inject data in specific cases. Usually, you will be ok to pass `{}`,\r\n * and then pass updated object to renderer.\r\n **/\r\nMarkdownIt.prototype.parse = function (src, env) {\r\n  var state = new this.core.State(src, this, env);\r\n\r\n  this.core.process(state);\r\n\r\n  return state.tokens;\r\n};\r\n\r\n\r\n/**\r\n * MarkdownIt.render(src [, env]) -> String\r\n * - src (String): source string\r\n * - env (Object): environment sandbox\r\n *\r\n * Render markdown string into html. It does all magic for you :).\r\n *\r\n * `env` can be used to inject additional metadata (`{}` by default).\r\n * But you will not need it with high probability. See also comment\r\n * in [[MarkdownIt.parse]].\r\n **/\r\nMarkdownIt.prototype.render = function (src, env) {\r\n  env = env || {};\r\n\r\n  return this.renderer.render(this.parse(src, env), this.options, env);\r\n};\r\n\r\n\r\n/** internal\r\n * MarkdownIt.parseInline(src, env) -> Array\r\n * - src (String): source string\r\n * - env (Object): environment sandbox\r\n *\r\n * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the\r\n * block tokens list with the single `inline` element, containing parsed inline\r\n * tokens in `children` property. Also updates `env` object.\r\n **/\r\nMarkdownIt.prototype.parseInline = function (src, env) {\r\n  var state = new this.core.State(src, this, env);\r\n\r\n  state.inlineMode = true;\r\n  this.core.process(state);\r\n\r\n  return state.tokens;\r\n};\r\n\r\n\r\n/**\r\n * MarkdownIt.renderInline(src [, env]) -> String\r\n * - src (String): source string\r\n * - env (Object): environment sandbox\r\n *\r\n * Similar to [[MarkdownIt.render]] but for single paragraph content. Result\r\n * will NOT be wrapped into `<p>` tags.\r\n **/\r\nMarkdownIt.prototype.renderInline = function (src, env) {\r\n  env = env || {};\r\n\r\n  return this.renderer.render(this.parseInline(src, env), this.options, env);\r\n};\r\n\r\n\r\nmodule.exports = MarkdownIt;\r\n\r\n},{\"./common/utils\":5,\"./helpers\":6,\"./parser_block\":11,\"./parser_core\":12,\"./parser_inline\":13,\"./presets/commonmark\":14,\"./presets/default\":15,\"./presets/zero\":16,\"./renderer\":17,\"linkify-it\":53,\"mdurl\":58,\"punycode\":51}],11:[function(require,module,exports){\r\n/** internal\r\n * class ParserBlock\r\n *\r\n * Block-level tokenizer.\r\n **/\r\n'use strict';\r\n\r\n\r\nvar Ruler           = require('./ruler');\r\n\r\n\r\nvar _rules = [\r\n  // First 2 params - rule name & source. Secondary array - list of rules,\r\n  // which can be terminated by this one.\r\n  [ 'code',       require('./rules_block/code') ],\r\n  [ 'fence',      require('./rules_block/fence'),      [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\r\n  [ 'blockquote', require('./rules_block/blockquote'), [ 'paragraph', 'reference', 'list' ] ],\r\n  [ 'hr',         require('./rules_block/hr'),         [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\r\n  [ 'list',       require('./rules_block/list'),       [ 'paragraph', 'reference', 'blockquote' ] ],\r\n  [ 'reference',  require('./rules_block/reference') ],\r\n  [ 'heading',    require('./rules_block/heading'),    [ 'paragraph', 'reference', 'blockquote' ] ],\r\n  [ 'lheading',   require('./rules_block/lheading') ],\r\n  [ 'html_block', require('./rules_block/html_block'), [ 'paragraph', 'reference', 'blockquote' ] ],\r\n  [ 'table',      require('./rules_block/table'),      [ 'paragraph', 'reference' ] ],\r\n  [ 'paragraph',  require('./rules_block/paragraph') ]\r\n];\r\n\r\n\r\n/**\r\n * new ParserBlock()\r\n **/\r\nfunction ParserBlock() {\r\n  /**\r\n   * ParserBlock#ruler -> Ruler\r\n   *\r\n   * [[Ruler]] instance. Keep configuration of block rules.\r\n   **/\r\n  this.ruler = new Ruler();\r\n\r\n  for (var i = 0; i < _rules.length; i++) {\r\n    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });\r\n  }\r\n}\r\n\r\n\r\n// Generate tokens for input range\r\n//\r\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\r\n  var ok, i,\r\n      rules = this.ruler.getRules(''),\r\n      len = rules.length,\r\n      line = startLine,\r\n      hasEmptyLines = false,\r\n      maxNesting = state.md.options.maxNesting;\r\n\r\n  while (line < endLine) {\r\n    state.line = line = state.skipEmptyLines(line);\r\n    if (line >= endLine) { break; }\r\n\r\n    // Termination condition for nested calls.\r\n    // Nested calls currently used for blockquotes & lists\r\n    if (state.tShift[line] < state.blkIndent) { break; }\r\n\r\n    // If nesting level exceeded - skip tail to the end. That's not ordinary\r\n    // situation and we should not care about content.\r\n    if (state.level >= maxNesting) {\r\n      state.line = endLine;\r\n      break;\r\n    }\r\n\r\n    // Try all possible rules.\r\n    // On success, rule should:\r\n    //\r\n    // - update `state.line`\r\n    // - update `state.tokens`\r\n    // - return true\r\n\r\n    for (i = 0; i < len; i++) {\r\n      ok = rules[i](state, line, endLine, false);\r\n      if (ok) { break; }\r\n    }\r\n\r\n    // set state.tight iff we had an empty line before current tag\r\n    // i.e. latest empty line should not count\r\n    state.tight = !hasEmptyLines;\r\n\r\n    // paragraph might \"eat\" one newline after it in nested lists\r\n    if (state.isEmpty(state.line - 1)) {\r\n      hasEmptyLines = true;\r\n    }\r\n\r\n    line = state.line;\r\n\r\n    if (line < endLine && state.isEmpty(line)) {\r\n      hasEmptyLines = true;\r\n      line++;\r\n\r\n      // two empty lines should stop the parser in list mode\r\n      if (line < endLine && state.parentType === 'list' && state.isEmpty(line)) { break; }\r\n      state.line = line;\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * ParserBlock.parse(str, md, env, outTokens)\r\n *\r\n * Process input string and push block tokens into `outTokens`\r\n **/\r\nParserBlock.prototype.parse = function (src, md, env, outTokens) {\r\n  var state;\r\n\r\n  if (!src) { return []; }\r\n\r\n  state = new this.State(src, md, env, outTokens);\r\n\r\n  this.tokenize(state, state.line, state.lineMax);\r\n};\r\n\r\n\r\nParserBlock.prototype.State = require('./rules_block/state_block');\r\n\r\n\r\nmodule.exports = ParserBlock;\r\n\r\n},{\"./ruler\":18,\"./rules_block/blockquote\":19,\"./rules_block/code\":20,\"./rules_block/fence\":21,\"./rules_block/heading\":22,\"./rules_block/hr\":23,\"./rules_block/html_block\":24,\"./rules_block/lheading\":25,\"./rules_block/list\":26,\"./rules_block/paragraph\":27,\"./rules_block/reference\":28,\"./rules_block/state_block\":29,\"./rules_block/table\":30}],12:[function(require,module,exports){\r\n/** internal\r\n * class Core\r\n *\r\n * Top-level rules executor. Glues block/inline parsers and does intermediate\r\n * transformations.\r\n **/\r\n'use strict';\r\n\r\n\r\nvar Ruler  = require('./ruler');\r\n\r\n\r\nvar _rules = [\r\n  [ 'normalize',      require('./rules_core/normalize')      ],\r\n  [ 'block',          require('./rules_core/block')          ],\r\n  [ 'inline',         require('./rules_core/inline')         ],\r\n  [ 'linkify',        require('./rules_core/linkify')        ],\r\n  [ 'replacements',   require('./rules_core/replacements')   ],\r\n  [ 'smartquotes',    require('./rules_core/smartquotes')    ]\r\n];\r\n\r\n\r\n/**\r\n * new Core()\r\n **/\r\nfunction Core() {\r\n  /**\r\n   * Core#ruler -> Ruler\r\n   *\r\n   * [[Ruler]] instance. Keep configuration of core rules.\r\n   **/\r\n  this.ruler = new Ruler();\r\n\r\n  for (var i = 0; i < _rules.length; i++) {\r\n    this.ruler.push(_rules[i][0], _rules[i][1]);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Core.process(state)\r\n *\r\n * Executes core chain rules.\r\n **/\r\nCore.prototype.process = function (state) {\r\n  var i, l, rules;\r\n\r\n  rules = this.ruler.getRules('');\r\n\r\n  for (i = 0, l = rules.length; i < l; i++) {\r\n    rules[i](state);\r\n  }\r\n};\r\n\r\nCore.prototype.State = require('./rules_core/state_core');\r\n\r\n\r\nmodule.exports = Core;\r\n\r\n},{\"./ruler\":18,\"./rules_core/block\":31,\"./rules_core/inline\":32,\"./rules_core/linkify\":33,\"./rules_core/normalize\":34,\"./rules_core/replacements\":35,\"./rules_core/smartquotes\":36,\"./rules_core/state_core\":37}],13:[function(require,module,exports){\r\n/** internal\r\n * class ParserInline\r\n *\r\n * Tokenizes paragraph content.\r\n **/\r\n'use strict';\r\n\r\n\r\nvar Ruler           = require('./ruler');\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n// Parser rules\r\n\r\nvar _rules = [\r\n  [ 'text',            require('./rules_inline/text') ],\r\n  [ 'newline',         require('./rules_inline/newline') ],\r\n  [ 'escape',          require('./rules_inline/escape') ],\r\n  [ 'backticks',       require('./rules_inline/backticks') ],\r\n  [ 'strikethrough',   require('./rules_inline/strikethrough') ],\r\n  [ 'emphasis',        require('./rules_inline/emphasis') ],\r\n  [ 'link',            require('./rules_inline/link') ],\r\n  [ 'image',           require('./rules_inline/image') ],\r\n  [ 'autolink',        require('./rules_inline/autolink') ],\r\n  [ 'html_inline',     require('./rules_inline/html_inline') ],\r\n  [ 'entity',          require('./rules_inline/entity') ]\r\n];\r\n\r\n\r\n/**\r\n * new ParserInline()\r\n **/\r\nfunction ParserInline() {\r\n  /**\r\n   * ParserInline#ruler -> Ruler\r\n   *\r\n   * [[Ruler]] instance. Keep configuration of inline rules.\r\n   **/\r\n  this.ruler = new Ruler();\r\n\r\n  for (var i = 0; i < _rules.length; i++) {\r\n    this.ruler.push(_rules[i][0], _rules[i][1]);\r\n  }\r\n}\r\n\r\n\r\n// Skip single token by running all rules in validation mode;\r\n// returns `true` if any rule reported success\r\n//\r\nParserInline.prototype.skipToken = function (state) {\r\n  var i, pos = state.pos,\r\n      rules = this.ruler.getRules(''),\r\n      len = rules.length,\r\n      maxNesting = state.md.options.maxNesting,\r\n      cache = state.cache;\r\n\r\n\r\n  if (typeof cache[pos] !== 'undefined') {\r\n    state.pos = cache[pos];\r\n    return;\r\n  }\r\n\r\n  /*istanbul ignore else*/\r\n  if (state.level < maxNesting) {\r\n    for (i = 0; i < len; i++) {\r\n      if (rules[i](state, true)) {\r\n        cache[pos] = state.pos;\r\n        return;\r\n      }\r\n    }\r\n  }\r\n\r\n  state.pos++;\r\n  cache[pos] = state.pos;\r\n};\r\n\r\n\r\n// Generate tokens for input range\r\n//\r\nParserInline.prototype.tokenize = function (state) {\r\n  var ok, i,\r\n      rules = this.ruler.getRules(''),\r\n      len = rules.length,\r\n      end = state.posMax,\r\n      maxNesting = state.md.options.maxNesting;\r\n\r\n  while (state.pos < end) {\r\n    // Try all possible rules.\r\n    // On success, rule should:\r\n    //\r\n    // - update `state.pos`\r\n    // - update `state.tokens`\r\n    // - return true\r\n\r\n    if (state.level < maxNesting) {\r\n      for (i = 0; i < len; i++) {\r\n        ok = rules[i](state, false);\r\n        if (ok) { break; }\r\n      }\r\n    }\r\n\r\n    if (ok) {\r\n      if (state.pos >= end) { break; }\r\n      continue;\r\n    }\r\n\r\n    state.pending += state.src[state.pos++];\r\n  }\r\n\r\n  if (state.pending) {\r\n    state.pushPending();\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * ParserInline.parse(str, md, env, outTokens)\r\n *\r\n * Process input string and push inline tokens into `outTokens`\r\n **/\r\nParserInline.prototype.parse = function (str, md, env, outTokens) {\r\n  var state = new this.State(str, md, env, outTokens);\r\n\r\n  this.tokenize(state);\r\n};\r\n\r\n\r\nParserInline.prototype.State = require('./rules_inline/state_inline');\r\n\r\n\r\nmodule.exports = ParserInline;\r\n\r\n},{\"./ruler\":18,\"./rules_inline/autolink\":38,\"./rules_inline/backticks\":39,\"./rules_inline/emphasis\":40,\"./rules_inline/entity\":41,\"./rules_inline/escape\":42,\"./rules_inline/html_inline\":43,\"./rules_inline/image\":44,\"./rules_inline/link\":45,\"./rules_inline/newline\":46,\"./rules_inline/state_inline\":47,\"./rules_inline/strikethrough\":48,\"./rules_inline/text\":49}],14:[function(require,module,exports){\r\n// Commonmark default options\r\n\r\n'use strict';\r\n\r\n\r\nmodule.exports = {\r\n  options: {\r\n    html:         true,         // Enable HTML tags in source\r\n    xhtmlOut:     true,         // Use '/' to close single tags (<br />)\r\n    breaks:       false,        // Convert '\\n' in paragraphs into <br>\r\n    langPrefix:   'language-',  // CSS language prefix for fenced blocks\r\n    linkify:      false,        // autoconvert URL-like texts to links\r\n\r\n    // Enable some language-neutral replacements + quotes beautification\r\n    typographer:  false,\r\n\r\n    // Double + single quotes replacement pairs, when typographer enabled,\r\n    // and smartquotes on. Set doubles to '' for Russian, '' for German.\r\n    quotes: '\\u201c\\u201d\\u2018\\u2019' /*  */,\r\n\r\n    // Highlighter function. Should return escaped HTML,\r\n    // or '' if input not changed\r\n    //\r\n    // function (/*str, lang*/) { return ''; }\r\n    //\r\n    highlight: null,\r\n\r\n    maxNesting:   20            // Internal protection, recursion limit\r\n  },\r\n\r\n  components: {\r\n\r\n    core: {\r\n      rules: [\r\n        'normalize',\r\n        'block',\r\n        'inline'\r\n      ]\r\n    },\r\n\r\n    block: {\r\n      rules: [\r\n        'blockquote',\r\n        'code',\r\n        'fence',\r\n        'heading',\r\n        'hr',\r\n        'html_block',\r\n        'lheading',\r\n        'list',\r\n        'reference',\r\n        'paragraph'\r\n      ]\r\n    },\r\n\r\n    inline: {\r\n      rules: [\r\n        'autolink',\r\n        'backticks',\r\n        'emphasis',\r\n        'entity',\r\n        'escape',\r\n        'html_inline',\r\n        'image',\r\n        'link',\r\n        'newline',\r\n        'text'\r\n      ]\r\n    }\r\n  }\r\n};\r\n\r\n},{}],15:[function(require,module,exports){\r\n// markdown-it default options\r\n\r\n'use strict';\r\n\r\n\r\nmodule.exports = {\r\n  options: {\r\n    html:         false,        // Enable HTML tags in source\r\n    xhtmlOut:     false,        // Use '/' to close single tags (<br />)\r\n    breaks:       false,        // Convert '\\n' in paragraphs into <br>\r\n    langPrefix:   'language-',  // CSS language prefix for fenced blocks\r\n    linkify:      false,        // autoconvert URL-like texts to links\r\n\r\n    // Enable some language-neutral replacements + quotes beautification\r\n    typographer:  false,\r\n\r\n    // Double + single quotes replacement pairs, when typographer enabled,\r\n    // and smartquotes on. Set doubles to '' for Russian, '' for German.\r\n    quotes: '\\u201c\\u201d\\u2018\\u2019' /*  */,\r\n\r\n    // Highlighter function. Should return escaped HTML,\r\n    // or '' if input not changed\r\n    //\r\n    // function (/*str, lang*/) { return ''; }\r\n    //\r\n    highlight: null,\r\n\r\n    maxNesting:   20            // Internal protection, recursion limit\r\n  },\r\n\r\n  components: {\r\n\r\n    core: {},\r\n    block: {},\r\n    inline: {}\r\n  }\r\n};\r\n\r\n},{}],16:[function(require,module,exports){\r\n// \"Zero\" preset, with nothing enabled. Useful for manual configuring of simple\r\n// modes. For example, to parse bold/italic only.\r\n\r\n'use strict';\r\n\r\n\r\nmodule.exports = {\r\n  options: {\r\n    html:         false,        // Enable HTML tags in source\r\n    xhtmlOut:     false,        // Use '/' to close single tags (<br />)\r\n    breaks:       false,        // Convert '\\n' in paragraphs into <br>\r\n    langPrefix:   'language-',  // CSS language prefix for fenced blocks\r\n    linkify:      false,        // autoconvert URL-like texts to links\r\n\r\n    // Enable some language-neutral replacements + quotes beautification\r\n    typographer:  false,\r\n\r\n    // Double + single quotes replacement pairs, when typographer enabled,\r\n    // and smartquotes on. Set doubles to '' for Russian, '' for German.\r\n    quotes: '\\u201c\\u201d\\u2018\\u2019' /*  */,\r\n\r\n    // Highlighter function. Should return escaped HTML,\r\n    // or '' if input not changed\r\n    //\r\n    // function (/*str, lang*/) { return ''; }\r\n    //\r\n    highlight: null,\r\n\r\n    maxNesting:   20            // Internal protection, recursion limit\r\n  },\r\n\r\n  components: {\r\n\r\n    core: {\r\n      rules: [\r\n        'normalize',\r\n        'block',\r\n        'inline'\r\n      ]\r\n    },\r\n\r\n    block: {\r\n      rules: [\r\n        'paragraph'\r\n      ]\r\n    },\r\n\r\n    inline: {\r\n      rules: [\r\n        'text'\r\n      ]\r\n    }\r\n  }\r\n};\r\n\r\n},{}],17:[function(require,module,exports){\r\n/**\r\n * class Renderer\r\n *\r\n * Generates HTML from parsed token stream. Each instance has independent\r\n * copy of rules. Those can be rewritten with ease. Also, you can add new\r\n * rules if you create plugin and adds new token types.\r\n **/\r\n'use strict';\r\n\r\n\r\nvar assign          = require('./common/utils').assign;\r\nvar unescapeAll     = require('./common/utils').unescapeAll;\r\nvar escapeHtml      = require('./common/utils').escapeHtml;\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar default_rules = {};\r\n\r\n\r\ndefault_rules.code_inline = function (tokens, idx /*, options, env */) {\r\n  return '<code>' + escapeHtml(tokens[idx].content) + '</code>';\r\n};\r\n\r\n\r\ndefault_rules.code_block = function (tokens, idx /*, options, env */) {\r\n  return '<pre><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\\n';\r\n};\r\n\r\n\r\ndefault_rules.fence = function (tokens, idx, options, env, self) {\r\n  var token = tokens[idx],\r\n      langName = '',\r\n      highlighted;\r\n\r\n  if (token.info) {\r\n    langName = unescapeAll(token.info.trim().split(/\\s+/g)[0]);\r\n    token.attrPush([ 'class', options.langPrefix + langName ]);\r\n  }\r\n\r\n  if (options.highlight) {\r\n    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);\r\n  } else {\r\n    highlighted = escapeHtml(token.content);\r\n  }\r\n\r\n  return  '<pre><code' + self.renderAttrs(token) + '>'\r\n        + highlighted\r\n        + '</code></pre>\\n';\r\n};\r\n\r\n\r\ndefault_rules.image = function (tokens, idx, options, env, self) {\r\n  var token = tokens[idx];\r\n\r\n  // \"alt\" attr MUST be set, even if empty. Because it's mandatory and\r\n  // should be placed on proper position for tests.\r\n  //\r\n  // Replace content with actual value\r\n\r\n  token.attrs[token.attrIndex('alt')][1] =\r\n    self.renderInlineAsText(token.children, options, env);\r\n\r\n  return self.renderToken(tokens, idx, options);\r\n};\r\n\r\n\r\ndefault_rules.hardbreak = function (tokens, idx, options /*, env */) {\r\n  return options.xhtmlOut ? '<br />\\n' : '<br>\\n';\r\n};\r\ndefault_rules.softbreak = function (tokens, idx, options /*, env */) {\r\n  return options.breaks ? (options.xhtmlOut ? '<br />\\n' : '<br>\\n') : '\\n';\r\n};\r\n\r\n\r\ndefault_rules.text = function (tokens, idx /*, options, env */) {\r\n  return escapeHtml(tokens[idx].content);\r\n};\r\n\r\n\r\ndefault_rules.html_block = function (tokens, idx /*, options, env */) {\r\n  return tokens[idx].content;\r\n};\r\ndefault_rules.html_inline = function (tokens, idx /*, options, env */) {\r\n  return tokens[idx].content;\r\n};\r\n\r\n\r\n/**\r\n * new Renderer()\r\n *\r\n * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.\r\n **/\r\nfunction Renderer() {\r\n\r\n  /**\r\n   * Renderer#rules -> Object\r\n   *\r\n   * Contains render rules for tokens. Can be updated and extended.\r\n   *\r\n   * ##### Example\r\n   *\r\n   * ```javascript\r\n   * var md = require('markdown-it')();\r\n   *\r\n   * md.renderer.rules.strong_open  = function () { return '<b>'; };\r\n   * md.renderer.rules.strong_close = function () { return '</b>'; };\r\n   *\r\n   * var result = md.renderInline(...);\r\n   * ```\r\n   *\r\n   * Each rule is called as independed static function with fixed signature:\r\n   *\r\n   * ```javascript\r\n   * function my_token_render(tokens, idx, options, env, renderer) {\r\n   *   // ...\r\n   *   return renderedHTML;\r\n   * }\r\n   * ```\r\n   *\r\n   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)\r\n   * for more details and examples.\r\n   **/\r\n  this.rules = assign({}, default_rules);\r\n}\r\n\r\n\r\n/**\r\n * Renderer.renderAttrs(token) -> String\r\n *\r\n * Render token attributes to string.\r\n **/\r\nRenderer.prototype.renderAttrs = function renderAttrs(token) {\r\n  var i, l, result;\r\n\r\n  if (!token.attrs) { return ''; }\r\n\r\n  result = '';\r\n\r\n  for (i = 0, l = token.attrs.length; i < l; i++) {\r\n    result += ' ' + escapeHtml(token.attrs[i][0]) + '=\"' + escapeHtml(token.attrs[i][1]) + '\"';\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n\r\n/**\r\n * Renderer.renderToken(tokens, idx, options) -> String\r\n * - tokens (Array): list of tokens\r\n * - idx (Numbed): token index to render\r\n * - options (Object): params of parser instance\r\n *\r\n * Default token renderer. Can be overriden by custom function\r\n * in [[Renderer#rules]].\r\n **/\r\nRenderer.prototype.renderToken = function renderToken(tokens, idx, options) {\r\n  var nextToken,\r\n      result = '',\r\n      needLf = false,\r\n      token = tokens[idx];\r\n\r\n  // Tight list paragraphs\r\n  if (token.hidden) {\r\n    return '';\r\n  }\r\n\r\n  // Insert a newline between hidden paragraph and subsequent opening\r\n  // block-level tag.\r\n  //\r\n  // For example, here we should insert a newline before blockquote:\r\n  //  - a\r\n  //    >\r\n  //\r\n  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {\r\n    result += '\\n';\r\n  }\r\n\r\n  // Add token name, e.g. `<img`\r\n  result += (token.nesting === -1 ? '</' : '<') + token.tag;\r\n\r\n  // Encode attributes, e.g. `<img src=\"foo\"`\r\n  result += this.renderAttrs(token);\r\n\r\n  // Add a slash for self-closing tags, e.g. `<img src=\"foo\" /`\r\n  if (token.nesting === 0 && options.xhtmlOut) {\r\n    result += ' /';\r\n  }\r\n\r\n  // Check if we need to add a newline after this tag\r\n  if (token.block) {\r\n    needLf = true;\r\n\r\n    if (token.nesting === 1) {\r\n      if (idx + 1 < tokens.length) {\r\n        nextToken = tokens[idx + 1];\r\n\r\n        if (nextToken.type === 'inline' || nextToken.hidden) {\r\n          // Block-level tag containing an inline tag.\r\n          //\r\n          needLf = false;\r\n\r\n        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {\r\n          // Opening tag + closing tag of the same type. E.g. `<li></li>`.\r\n          //\r\n          needLf = false;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  result += needLf ? '>\\n' : '>';\r\n\r\n  return result;\r\n};\r\n\r\n\r\n/**\r\n * Renderer.renderInline(tokens, options, env) -> String\r\n * - tokens (Array): list on block tokens to renter\r\n * - options (Object): params of parser instance\r\n * - env (Object): additional data from parsed input (references, for example)\r\n *\r\n * The same as [[Renderer.render]], but for single token of `inline` type.\r\n **/\r\nRenderer.prototype.renderInline = function (tokens, options, env) {\r\n  var type,\r\n      result = '',\r\n      rules = this.rules;\r\n\r\n  for (var i = 0, len = tokens.length; i < len; i++) {\r\n    type = tokens[i].type;\r\n\r\n    if (typeof rules[type] !== 'undefined') {\r\n      result += rules[type](tokens, i, options, env, this);\r\n    } else {\r\n      result += this.renderToken(tokens, i, options);\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n\r\n/** internal\r\n * Renderer.renderInlineAsText(tokens, options, env) -> String\r\n * - tokens (Array): list on block tokens to renter\r\n * - options (Object): params of parser instance\r\n * - env (Object): additional data from parsed input (references, for example)\r\n *\r\n * Special kludge for image `alt` attributes to conform CommonMark spec.\r\n * Don't try to use it! Spec requires to show `alt` content with stripped markup,\r\n * instead of simple escaping.\r\n **/\r\nRenderer.prototype.renderInlineAsText = function (tokens, options, env) {\r\n  var result = '',\r\n      rules = this.rules;\r\n\r\n  for (var i = 0, len = tokens.length; i < len; i++) {\r\n    if (tokens[i].type === 'text') {\r\n      result += rules.text(tokens, i, options, env, this);\r\n    } else if (tokens[i].type === 'image') {\r\n      result += this.renderInlineAsText(tokens[i].children, options, env);\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n\r\n/**\r\n * Renderer.render(tokens, options, env) -> String\r\n * - tokens (Array): list on block tokens to renter\r\n * - options (Object): params of parser instance\r\n * - env (Object): additional data from parsed input (references, for example)\r\n *\r\n * Takes token stream and generates HTML. Probably, you will never need to call\r\n * this method directly.\r\n **/\r\nRenderer.prototype.render = function (tokens, options, env) {\r\n  var i, len, type,\r\n      result = '',\r\n      rules = this.rules;\r\n\r\n  for (i = 0, len = tokens.length; i < len; i++) {\r\n    type = tokens[i].type;\r\n\r\n    if (type === 'inline') {\r\n      result += this.renderInline(tokens[i].children, options, env);\r\n    } else if (typeof rules[type] !== 'undefined') {\r\n      result += rules[tokens[i].type](tokens, i, options, env, this);\r\n    } else {\r\n      result += this.renderToken(tokens, i, options, env);\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nmodule.exports = Renderer;\r\n\r\n},{\"./common/utils\":5}],18:[function(require,module,exports){\r\n/**\r\n * class Ruler\r\n *\r\n * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and\r\n * [[MarkdownIt#inline]] to manage sequences of functions (rules):\r\n *\r\n * - keep rules in defined order\r\n * - assign the name to each rule\r\n * - enable/disable rules\r\n * - add/replace rules\r\n * - allow assign rules to additional named chains (in the same)\r\n * - cacheing lists of active rules\r\n *\r\n * You will not need use this class directly until write plugins. For simple\r\n * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and\r\n * [[MarkdownIt.use]].\r\n **/\r\n'use strict';\r\n\r\n\r\n/**\r\n * new Ruler()\r\n **/\r\nfunction Ruler() {\r\n  // List of added rules. Each element is:\r\n  //\r\n  // {\r\n  //   name: XXX,\r\n  //   enabled: Boolean,\r\n  //   fn: Function(),\r\n  //   alt: [ name2, name3 ]\r\n  // }\r\n  //\r\n  this.__rules__ = [];\r\n\r\n  // Cached rule chains.\r\n  //\r\n  // First level - chain name, '' for default.\r\n  // Second level - diginal anchor for fast filtering by charcodes.\r\n  //\r\n  this.__cache__ = null;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n// Helper methods, should not be used directly\r\n\r\n\r\n// Find rule index by name\r\n//\r\nRuler.prototype.__find__ = function (name) {\r\n  for (var i = 0; i < this.__rules__.length; i++) {\r\n    if (this.__rules__[i].name === name) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1;\r\n};\r\n\r\n\r\n// Build rules lookup cache\r\n//\r\nRuler.prototype.__compile__ = function () {\r\n  var self = this;\r\n  var chains = [ '' ];\r\n\r\n  // collect unique names\r\n  self.__rules__.forEach(function (rule) {\r\n    if (!rule.enabled) { return; }\r\n\r\n    rule.alt.forEach(function (altName) {\r\n      if (chains.indexOf(altName) < 0) {\r\n        chains.push(altName);\r\n      }\r\n    });\r\n  });\r\n\r\n  self.__cache__ = {};\r\n\r\n  chains.forEach(function (chain) {\r\n    self.__cache__[chain] = [];\r\n    self.__rules__.forEach(function (rule) {\r\n      if (!rule.enabled) { return; }\r\n\r\n      if (chain && rule.alt.indexOf(chain) < 0) { return; }\r\n\r\n      self.__cache__[chain].push(rule.fn);\r\n    });\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Ruler.at(name, fn [, options])\r\n * - name (String): rule name to replace.\r\n * - fn (Function): new rule function.\r\n * - options (Object): new rule options (not mandatory).\r\n *\r\n * Replace rule by name with new function & options. Throws error if name not\r\n * found.\r\n *\r\n * ##### Options:\r\n *\r\n * - __alt__ - array with names of \"alternate\" chains.\r\n *\r\n * ##### Example\r\n *\r\n * Replace existing typorgapher replacement rule with new one:\r\n *\r\n * ```javascript\r\n * var md = require('markdown-it')();\r\n *\r\n * md.core.ruler.at('replacements', function replace(state) {\r\n *   //...\r\n * });\r\n * ```\r\n **/\r\nRuler.prototype.at = function (name, fn, options) {\r\n  var index = this.__find__(name);\r\n  var opt = options || {};\r\n\r\n  if (index === -1) { throw new Error('Parser rule not found: ' + name); }\r\n\r\n  this.__rules__[index].fn = fn;\r\n  this.__rules__[index].alt = opt.alt || [];\r\n  this.__cache__ = null;\r\n};\r\n\r\n\r\n/**\r\n * Ruler.before(beforeName, ruleName, fn [, options])\r\n * - beforeName (String): new rule will be added before this one.\r\n * - ruleName (String): name of added rule.\r\n * - fn (Function): rule function.\r\n * - options (Object): rule options (not mandatory).\r\n *\r\n * Add new rule to chain before one with given name. See also\r\n * [[Ruler.after]], [[Ruler.push]].\r\n *\r\n * ##### Options:\r\n *\r\n * - __alt__ - array with names of \"alternate\" chains.\r\n *\r\n * ##### Example\r\n *\r\n * ```javascript\r\n * var md = require('markdown-it')();\r\n *\r\n * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {\r\n *   //...\r\n * });\r\n * ```\r\n **/\r\nRuler.prototype.before = function (beforeName, ruleName, fn, options) {\r\n  var index = this.__find__(beforeName);\r\n  var opt = options || {};\r\n\r\n  if (index === -1) { throw new Error('Parser rule not found: ' + beforeName); }\r\n\r\n  this.__rules__.splice(index, 0, {\r\n    name: ruleName,\r\n    enabled: true,\r\n    fn: fn,\r\n    alt: opt.alt || []\r\n  });\r\n\r\n  this.__cache__ = null;\r\n};\r\n\r\n\r\n/**\r\n * Ruler.after(afterName, ruleName, fn [, options])\r\n * - afterName (String): new rule will be added after this one.\r\n * - ruleName (String): name of added rule.\r\n * - fn (Function): rule function.\r\n * - options (Object): rule options (not mandatory).\r\n *\r\n * Add new rule to chain after one with given name. See also\r\n * [[Ruler.before]], [[Ruler.push]].\r\n *\r\n * ##### Options:\r\n *\r\n * - __alt__ - array with names of \"alternate\" chains.\r\n *\r\n * ##### Example\r\n *\r\n * ```javascript\r\n * var md = require('markdown-it')();\r\n *\r\n * md.inline.ruler.after('text', 'my_rule', function replace(state) {\r\n *   //...\r\n * });\r\n * ```\r\n **/\r\nRuler.prototype.after = function (afterName, ruleName, fn, options) {\r\n  var index = this.__find__(afterName);\r\n  var opt = options || {};\r\n\r\n  if (index === -1) { throw new Error('Parser rule not found: ' + afterName); }\r\n\r\n  this.__rules__.splice(index + 1, 0, {\r\n    name: ruleName,\r\n    enabled: true,\r\n    fn: fn,\r\n    alt: opt.alt || []\r\n  });\r\n\r\n  this.__cache__ = null;\r\n};\r\n\r\n/**\r\n * Ruler.push(ruleName, fn [, options])\r\n * - ruleName (String): name of added rule.\r\n * - fn (Function): rule function.\r\n * - options (Object): rule options (not mandatory).\r\n *\r\n * Push new rule to the end of chain. See also\r\n * [[Ruler.before]], [[Ruler.after]].\r\n *\r\n * ##### Options:\r\n *\r\n * - __alt__ - array with names of \"alternate\" chains.\r\n *\r\n * ##### Example\r\n *\r\n * ```javascript\r\n * var md = require('markdown-it')();\r\n *\r\n * md.core.ruler.push('my_rule', function replace(state) {\r\n *   //...\r\n * });\r\n * ```\r\n **/\r\nRuler.prototype.push = function (ruleName, fn, options) {\r\n  var opt = options || {};\r\n\r\n  this.__rules__.push({\r\n    name: ruleName,\r\n    enabled: true,\r\n    fn: fn,\r\n    alt: opt.alt || []\r\n  });\r\n\r\n  this.__cache__ = null;\r\n};\r\n\r\n\r\n/**\r\n * Ruler.enable(list [, ignoreInvalid]) -> Array\r\n * - list (String|Array): list of rule names to enable.\r\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\r\n *\r\n * Enable rules with given names. If any rule name not found - throw Error.\r\n * Errors can be disabled by second param.\r\n *\r\n * Returns list of found rule names (if no exception happened).\r\n *\r\n * See also [[Ruler.disable]], [[Ruler.enableOnly]].\r\n **/\r\nRuler.prototype.enable = function (list, ignoreInvalid) {\r\n  if (!Array.isArray(list)) { list = [ list ]; }\r\n\r\n  var result = [];\r\n\r\n  // Search by name and enable\r\n  list.forEach(function (name) {\r\n    var idx = this.__find__(name);\r\n\r\n    if (idx < 0) {\r\n      if (ignoreInvalid) { return; }\r\n      throw new Error('Rules manager: invalid rule name ' + name);\r\n    }\r\n    this.__rules__[idx].enabled = true;\r\n    result.push(name);\r\n  }, this);\r\n\r\n  this.__cache__ = null;\r\n  return result;\r\n};\r\n\r\n\r\n/**\r\n * Ruler.enableOnly(list [, ignoreInvalid])\r\n * - list (String|Array): list of rule names to enable (whitelist).\r\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\r\n *\r\n * Enable rules with given names, and disable everything else. If any rule name\r\n * not found - throw Error. Errors can be disabled by second param.\r\n *\r\n * See also [[Ruler.disable]], [[Ruler.enable]].\r\n **/\r\nRuler.prototype.enableOnly = function (list, ignoreInvalid) {\r\n  if (!Array.isArray(list)) { list = [ list ]; }\r\n\r\n  this.__rules__.forEach(function (rule) { rule.enabled = false; });\r\n\r\n  this.enable(list, ignoreInvalid);\r\n};\r\n\r\n\r\n/**\r\n * Ruler.disable(list [, ignoreInvalid]) -> Array\r\n * - list (String|Array): list of rule names to disable.\r\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\r\n *\r\n * Disable rules with given names. If any rule name not found - throw Error.\r\n * Errors can be disabled by second param.\r\n *\r\n * Returns list of found rule names (if no exception happened).\r\n *\r\n * See also [[Ruler.enable]], [[Ruler.enableOnly]].\r\n **/\r\nRuler.prototype.disable = function (list, ignoreInvalid) {\r\n  if (!Array.isArray(list)) { list = [ list ]; }\r\n\r\n  var result = [];\r\n\r\n  // Search by name and disable\r\n  list.forEach(function (name) {\r\n    var idx = this.__find__(name);\r\n\r\n    if (idx < 0) {\r\n      if (ignoreInvalid) { return; }\r\n      throw new Error('Rules manager: invalid rule name ' + name);\r\n    }\r\n    this.__rules__[idx].enabled = false;\r\n    result.push(name);\r\n  }, this);\r\n\r\n  this.__cache__ = null;\r\n  return result;\r\n};\r\n\r\n\r\n/**\r\n * Ruler.getRules(chainName) -> Array\r\n *\r\n * Return array of active functions (rules) for given chain name. It analyzes\r\n * rules configuration, compiles caches if not exists and returns result.\r\n *\r\n * Default chain name is `''` (empty string). It can't be skipped. That's\r\n * done intentionally, to keep signature monomorphic for high speed.\r\n **/\r\nRuler.prototype.getRules = function (chainName) {\r\n  if (this.__cache__ === null) {\r\n    this.__compile__();\r\n  }\r\n\r\n  // Chain can be empty, if rules disabled. But we still have to return Array.\r\n  return this.__cache__[chainName] || [];\r\n};\r\n\r\nmodule.exports = Ruler;\r\n\r\n},{}],19:[function(require,module,exports){\r\n// Block quotes\r\n\r\n'use strict';\r\n\r\n\r\nmodule.exports = function blockquote(state, startLine, endLine, silent) {\r\n  var nextLine, lastLineEmpty, oldTShift, oldBMarks, oldIndent, oldParentType, lines,\r\n      terminatorRules, token,\r\n      i, l, terminate,\r\n      pos = state.bMarks[startLine] + state.tShift[startLine],\r\n      max = state.eMarks[startLine];\r\n\r\n  // check the block quote marker\r\n  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }\r\n\r\n  // we know that it's going to be a valid blockquote,\r\n  // so no point trying to find the end of it in silent mode\r\n  if (silent) { return true; }\r\n\r\n  // skip one optional space after '>'\r\n  if (state.src.charCodeAt(pos) === 0x20) { pos++; }\r\n\r\n  oldIndent = state.blkIndent;\r\n  state.blkIndent = 0;\r\n\r\n  oldBMarks = [ state.bMarks[startLine] ];\r\n  state.bMarks[startLine] = pos;\r\n\r\n  // check if we have an empty blockquote\r\n  pos = pos < max ? state.skipSpaces(pos) : pos;\r\n  lastLineEmpty = pos >= max;\r\n\r\n  oldTShift = [ state.tShift[startLine] ];\r\n  state.tShift[startLine] = pos - state.bMarks[startLine];\r\n\r\n  terminatorRules = state.md.block.ruler.getRules('blockquote');\r\n\r\n  // Search the end of the block\r\n  //\r\n  // Block ends with either:\r\n  //  1. an empty line outside:\r\n  //     ```\r\n  //     > test\r\n  //\r\n  //     ```\r\n  //  2. an empty line inside:\r\n  //     ```\r\n  //     >\r\n  //     test\r\n  //     ```\r\n  //  3. another tag\r\n  //     ```\r\n  //     > test\r\n  //      - - -\r\n  //     ```\r\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\r\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\r\n    max = state.eMarks[nextLine];\r\n\r\n    if (pos >= max) {\r\n      // Case 1: line is not inside the blockquote, and this line is empty.\r\n      break;\r\n    }\r\n\r\n    if (state.src.charCodeAt(pos++) === 0x3E/* > */) {\r\n      // This line is inside the blockquote.\r\n\r\n      // skip one optional space after '>'\r\n      if (state.src.charCodeAt(pos) === 0x20) { pos++; }\r\n\r\n      oldBMarks.push(state.bMarks[nextLine]);\r\n      state.bMarks[nextLine] = pos;\r\n\r\n      pos = pos < max ? state.skipSpaces(pos) : pos;\r\n      lastLineEmpty = pos >= max;\r\n\r\n      oldTShift.push(state.tShift[nextLine]);\r\n      state.tShift[nextLine] = pos - state.bMarks[nextLine];\r\n      continue;\r\n    }\r\n\r\n    // Case 2: line is not inside the blockquote, and the last line was empty.\r\n    if (lastLineEmpty) { break; }\r\n\r\n    // Case 3: another tag found.\r\n    terminate = false;\r\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\r\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\r\n        terminate = true;\r\n        break;\r\n      }\r\n    }\r\n    if (terminate) { break; }\r\n\r\n    oldBMarks.push(state.bMarks[nextLine]);\r\n    oldTShift.push(state.tShift[nextLine]);\r\n\r\n    // A negative number means that this is a paragraph continuation;\r\n    //\r\n    // Any negative number will do the job here, but it's better for it\r\n    // to be large enough to make any bugs obvious.\r\n    state.tShift[nextLine] = -1337;\r\n  }\r\n\r\n  oldParentType = state.parentType;\r\n  state.parentType = 'blockquote';\r\n\r\n  token        = state.push('blockquote_open', 'blockquote', 1);\r\n  token.markup = '>';\r\n  token.map    = lines = [ startLine, 0 ];\r\n\r\n  state.md.block.tokenize(state, startLine, nextLine);\r\n\r\n  token        = state.push('blockquote_close', 'blockquote', -1);\r\n  token.markup = '>';\r\n\r\n  state.parentType = oldParentType;\r\n  lines[1] = state.line;\r\n\r\n  // Restore original tShift; this might not be necessary since the parser\r\n  // has already been here, but just to make sure we can do that.\r\n  for (i = 0; i < oldTShift.length; i++) {\r\n    state.bMarks[i + startLine] = oldBMarks[i];\r\n    state.tShift[i + startLine] = oldTShift[i];\r\n  }\r\n  state.blkIndent = oldIndent;\r\n\r\n  return true;\r\n};\r\n\r\n},{}],20:[function(require,module,exports){\r\n// Code block (4 spaces padded)\r\n\r\n'use strict';\r\n\r\n\r\nmodule.exports = function code(state, startLine, endLine/*, silent*/) {\r\n  var nextLine, last, token;\r\n\r\n  if (state.tShift[startLine] - state.blkIndent < 4) { return false; }\r\n\r\n  last = nextLine = startLine + 1;\r\n\r\n  while (nextLine < endLine) {\r\n    if (state.isEmpty(nextLine)) {\r\n      nextLine++;\r\n      continue;\r\n    }\r\n    if (state.tShift[nextLine] - state.blkIndent >= 4) {\r\n      nextLine++;\r\n      last = nextLine;\r\n      continue;\r\n    }\r\n    break;\r\n  }\r\n\r\n  state.line = nextLine;\r\n\r\n  token         = state.push('code_block', 'code', 0);\r\n  token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);\r\n  token.map     = [ startLine, state.line ];\r\n\r\n  return true;\r\n};\r\n\r\n},{}],21:[function(require,module,exports){\r\n// fences (``` lang, ~~~ lang)\r\n\r\n'use strict';\r\n\r\n\r\nmodule.exports = function fence(state, startLine, endLine, silent) {\r\n  var marker, len, params, nextLine, mem, token, markup,\r\n      haveEndMarker = false,\r\n      pos = state.bMarks[startLine] + state.tShift[startLine],\r\n      max = state.eMarks[startLine];\r\n\r\n  if (pos + 3 > max) { return false; }\r\n\r\n  marker = state.src.charCodeAt(pos);\r\n\r\n  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {\r\n    return false;\r\n  }\r\n\r\n  // scan marker length\r\n  mem = pos;\r\n  pos = state.skipChars(pos, marker);\r\n\r\n  len = pos - mem;\r\n\r\n  if (len < 3) { return false; }\r\n\r\n  markup = state.src.slice(mem, pos);\r\n  params = state.src.slice(pos, max);\r\n\r\n  if (params.indexOf('`') >= 0) { return false; }\r\n\r\n  // Since start is found, we can report success here in validation mode\r\n  if (silent) { return true; }\r\n\r\n  // search end of block\r\n  nextLine = startLine;\r\n\r\n  for (;;) {\r\n    nextLine++;\r\n    if (nextLine >= endLine) {\r\n      // unclosed block should be autoclosed by end of document.\r\n      // also block seems to be autoclosed by end of parent\r\n      break;\r\n    }\r\n\r\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\r\n    max = state.eMarks[nextLine];\r\n\r\n    if (pos < max && state.tShift[nextLine] < state.blkIndent) {\r\n      // non-empty line with negative indent should stop the list:\r\n      // - ```\r\n      //  test\r\n      break;\r\n    }\r\n\r\n    if (state.src.charCodeAt(pos) !== marker) { continue; }\r\n\r\n    if (state.tShift[nextLine] - state.blkIndent >= 4) {\r\n      // closing fence should be indented less than 4 spaces\r\n      continue;\r\n    }\r\n\r\n    pos = state.skipChars(pos, marker);\r\n\r\n    // closing code fence must be at least as long as the opening one\r\n    if (pos - mem < len) { continue; }\r\n\r\n    // make sure tail has spaces only\r\n    pos = state.skipSpaces(pos);\r\n\r\n    if (pos < max) { continue; }\r\n\r\n    haveEndMarker = true;\r\n    // found!\r\n    break;\r\n  }\r\n\r\n  // If a fence has heading spaces, they should be removed from its inner block\r\n  len = state.tShift[startLine];\r\n\r\n  state.line = nextLine + (haveEndMarker ? 1 : 0);\r\n\r\n  token         = state.push('fence', 'code', 0);\r\n  token.info    = params;\r\n  token.content = state.getLines(startLine + 1, nextLine, len, true);\r\n  token.markup  = markup;\r\n  token.map     = [ startLine, state.line ];\r\n\r\n  return true;\r\n};\r\n\r\n},{}],22:[function(require,module,exports){\r\n// heading (#, ##, ...)\r\n\r\n'use strict';\r\n\r\n\r\nmodule.exports = function heading(state, startLine, endLine, silent) {\r\n  var ch, level, tmp, token,\r\n      pos = state.bMarks[startLine] + state.tShift[startLine],\r\n      max = state.eMarks[startLine];\r\n\r\n  ch  = state.src.charCodeAt(pos);\r\n\r\n  if (ch !== 0x23/* # */ || pos >= max) { return false; }\r\n\r\n  // count heading level\r\n  level = 1;\r\n  ch = state.src.charCodeAt(++pos);\r\n  while (ch === 0x23/* # */ && pos < max && level <= 6) {\r\n    level++;\r\n    ch = state.src.charCodeAt(++pos);\r\n  }\r\n\r\n  if (level > 6 || (pos < max && ch !== 0x20/* space */)) { return false; }\r\n\r\n  if (silent) { return true; }\r\n\r\n  // Let's cut tails like '    ###  ' from the end of string\r\n\r\n  max = state.skipCharsBack(max, 0x20, pos); // space\r\n  tmp = state.skipCharsBack(max, 0x23, pos); // #\r\n  if (tmp > pos && state.src.charCodeAt(tmp - 1) === 0x20/* space */) {\r\n    max = tmp;\r\n  }\r\n\r\n  state.line = startLine + 1;\r\n\r\n  token        = state.push('heading_open', 'h' + String(level), 1);\r\n  token.markup = '########'.slice(0, level);\r\n  token.map    = [ startLine, state.line ];\r\n\r\n  token          = state.push('inline', '', 0);\r\n  token.content  = state.src.slice(pos, max).trim();\r\n  token.map      = [ startLine, state.line ];\r\n  token.children = [];\r\n\r\n  token        = state.push('heading_close', 'h' + String(level), -1);\r\n  token.markup = '########'.slice(0, level);\r\n\r\n  return true;\r\n};\r\n\r\n},{}],23:[function(require,module,exports){\r\n// Horizontal rule\r\n\r\n'use strict';\r\n\r\n\r\nmodule.exports = function hr(state, startLine, endLine, silent) {\r\n  var marker, cnt, ch, token,\r\n      pos = state.bMarks[startLine] + state.tShift[startLine],\r\n      max = state.eMarks[startLine];\r\n\r\n  marker = state.src.charCodeAt(pos++);\r\n\r\n  // Check hr marker\r\n  if (marker !== 0x2A/* * */ &&\r\n      marker !== 0x2D/* - */ &&\r\n      marker !== 0x5F/* _ */) {\r\n    return false;\r\n  }\r\n\r\n  // markers can be mixed with spaces, but there should be at least 3 one\r\n\r\n  cnt = 1;\r\n  while (pos < max) {\r\n    ch = state.src.charCodeAt(pos++);\r\n    if (ch !== marker && ch !== 0x20/* space */) { return false; }\r\n    if (ch === marker) { cnt++; }\r\n  }\r\n\r\n  if (cnt < 3) { return false; }\r\n\r\n  if (silent) { return true; }\r\n\r\n  state.line = startLine + 1;\r\n\r\n  token        = state.push('hr', 'hr', 0);\r\n  token.map    = [ startLine, state.line ];\r\n  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));\r\n\r\n  return true;\r\n};\r\n\r\n},{}],24:[function(require,module,exports){\r\n// HTML block\r\n\r\n'use strict';\r\n\r\n\r\nvar block_names = require('../common/html_blocks');\r\n\r\n\r\nvar HTML_TAG_OPEN_RE = /^<([a-zA-Z][a-zA-Z0-9]{0,14})[\\s\\/>]/;\r\nvar HTML_TAG_CLOSE_RE = /^<\\/([a-zA-Z][a-zA-Z0-9]{0,14})[\\s>]/;\r\n\r\nfunction isLetter(ch) {\r\n  /*eslint no-bitwise:0*/\r\n  var lc = ch | 0x20; // to lower case\r\n  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);\r\n}\r\n\r\nmodule.exports = function html_block(state, startLine, endLine, silent) {\r\n  var ch, match, nextLine, token,\r\n      pos = state.bMarks[startLine],\r\n      max = state.eMarks[startLine],\r\n      shift = state.tShift[startLine];\r\n\r\n  pos += shift;\r\n\r\n  if (!state.md.options.html) { return false; }\r\n\r\n  if (shift > 3 || pos + 2 >= max) { return false; }\r\n\r\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }\r\n\r\n  ch = state.src.charCodeAt(pos + 1);\r\n\r\n  if (ch === 0x21/* ! */ || ch === 0x3F/* ? */) {\r\n    // Directive start / comment start / processing instruction start\r\n    if (silent) { return true; }\r\n\r\n  } else if (ch === 0x2F/* / */ || isLetter(ch)) {\r\n\r\n    // Probably start or end of tag\r\n    if (ch === 0x2F/* \\ */) {\r\n      // closing tag\r\n      match = state.src.slice(pos, max).match(HTML_TAG_CLOSE_RE);\r\n      if (!match) { return false; }\r\n    } else {\r\n      // opening tag\r\n      match = state.src.slice(pos, max).match(HTML_TAG_OPEN_RE);\r\n      if (!match) { return false; }\r\n    }\r\n    // Make sure tag name is valid\r\n    if (block_names[match[1].toLowerCase()] !== true) { return false; }\r\n    if (silent) { return true; }\r\n\r\n  } else {\r\n    return false;\r\n  }\r\n\r\n  // If we are here - we detected HTML block.\r\n  // Let's roll down till empty line (block end).\r\n  nextLine = startLine + 1;\r\n  while (nextLine < state.lineMax && !state.isEmpty(nextLine)) {\r\n    nextLine++;\r\n  }\r\n\r\n  state.line = nextLine;\r\n\r\n  token         = state.push('html_block', '', 0);\r\n  token.map     = [ startLine, state.line ];\r\n  token.content = state.getLines(startLine, nextLine, 0, true);\r\n\r\n  return true;\r\n};\r\n\r\n},{\"../common/html_blocks\":2}],25:[function(require,module,exports){\r\n// lheading (---, ===)\r\n\r\n'use strict';\r\n\r\n\r\nmodule.exports = function lheading(state, startLine, endLine/*, silent*/) {\r\n  var marker, pos, max, token, level,\r\n      next = startLine + 1;\r\n\r\n  if (next >= endLine) { return false; }\r\n  if (state.tShift[next] < state.blkIndent) { return false; }\r\n\r\n  // Scan next line\r\n\r\n  if (state.tShift[next] - state.blkIndent > 3) { return false; }\r\n\r\n  pos = state.bMarks[next] + state.tShift[next];\r\n  max = state.eMarks[next];\r\n\r\n  if (pos >= max) { return false; }\r\n\r\n  marker = state.src.charCodeAt(pos);\r\n\r\n  if (marker !== 0x2D/* - */ && marker !== 0x3D/* = */) { return false; }\r\n\r\n  pos = state.skipChars(pos, marker);\r\n\r\n  pos = state.skipSpaces(pos);\r\n\r\n  if (pos < max) { return false; }\r\n\r\n  pos = state.bMarks[startLine] + state.tShift[startLine];\r\n\r\n  state.line = next + 1;\r\n  level = (marker === 0x3D/* = */ ? 1 : 2);\r\n\r\n  token          = state.push('heading_open', 'h' + String(level), 1);\r\n  token.markup   = String.fromCharCode(marker);\r\n  token.map      = [ startLine, state.line ];\r\n\r\n  token          = state.push('inline', '', 0);\r\n  token.content  = state.src.slice(pos, state.eMarks[startLine]).trim();\r\n  token.map      = [ startLine, state.line - 1 ];\r\n  token.children = [];\r\n\r\n  token          = state.push('heading_close', 'h' + String(level), -1);\r\n  token.markup   = String.fromCharCode(marker);\r\n\r\n  return true;\r\n};\r\n\r\n},{}],26:[function(require,module,exports){\r\n// Lists\r\n\r\n'use strict';\r\n\r\n\r\n// Search `[-+*][\\n ]`, returns next pos arter marker on success\r\n// or -1 on fail.\r\nfunction skipBulletListMarker(state, startLine) {\r\n  var marker, pos, max;\r\n\r\n  pos = state.bMarks[startLine] + state.tShift[startLine];\r\n  max = state.eMarks[startLine];\r\n\r\n  marker = state.src.charCodeAt(pos++);\r\n  // Check bullet\r\n  if (marker !== 0x2A/* * */ &&\r\n      marker !== 0x2D/* - */ &&\r\n      marker !== 0x2B/* + */) {\r\n    return -1;\r\n  }\r\n\r\n  if (pos < max && state.src.charCodeAt(pos) !== 0x20) {\r\n    // \" 1.test \" - is not a list item\r\n    return -1;\r\n  }\r\n\r\n  return pos;\r\n}\r\n\r\n// Search `\\d+[.)][\\n ]`, returns next pos arter marker on success\r\n// or -1 on fail.\r\nfunction skipOrderedListMarker(state, startLine) {\r\n  var ch,\r\n      pos = state.bMarks[startLine] + state.tShift[startLine],\r\n      max = state.eMarks[startLine];\r\n\r\n  // List marker should have at least 2 chars (digit + dot)\r\n  if (pos + 1 >= max) { return -1; }\r\n\r\n  ch = state.src.charCodeAt(pos++);\r\n\r\n  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }\r\n\r\n  for (;;) {\r\n    // EOL -> fail\r\n    if (pos >= max) { return -1; }\r\n\r\n    ch = state.src.charCodeAt(pos++);\r\n\r\n    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {\r\n      continue;\r\n    }\r\n\r\n    // found valid marker\r\n    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {\r\n      break;\r\n    }\r\n\r\n    return -1;\r\n  }\r\n\r\n\r\n  if (pos < max && state.src.charCodeAt(pos) !== 0x20/* space */) {\r\n    // \" 1.test \" - is not a list item\r\n    return -1;\r\n  }\r\n  return pos;\r\n}\r\n\r\nfunction markTightParagraphs(state, idx) {\r\n  var i, l,\r\n      level = state.level + 2;\r\n\r\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\r\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\r\n      state.tokens[i + 2].hidden = true;\r\n      state.tokens[i].hidden = true;\r\n      i += 2;\r\n    }\r\n  }\r\n}\r\n\r\n\r\nmodule.exports = function list(state, startLine, endLine, silent) {\r\n  var nextLine,\r\n      indent,\r\n      oldTShift,\r\n      oldIndent,\r\n      oldTight,\r\n      oldParentType,\r\n      start,\r\n      posAfterMarker,\r\n      max,\r\n      indentAfterMarker,\r\n      markerValue,\r\n      markerCharCode,\r\n      isOrdered,\r\n      contentStart,\r\n      listTokIdx,\r\n      prevEmptyEnd,\r\n      listLines,\r\n      itemLines,\r\n      tight = true,\r\n      terminatorRules,\r\n      token,\r\n      i, l, terminate;\r\n\r\n  // Detect list type and position after marker\r\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\r\n    isOrdered = true;\r\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\r\n    isOrdered = false;\r\n  } else {\r\n    return false;\r\n  }\r\n\r\n  // We should terminate list on style change. Remember first one to compare.\r\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\r\n\r\n  // For validation mode we can terminate immediately\r\n  if (silent) { return true; }\r\n\r\n  // Start list\r\n  listTokIdx = state.tokens.length;\r\n\r\n  if (isOrdered) {\r\n    start = state.bMarks[startLine] + state.tShift[startLine];\r\n    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));\r\n\r\n    token       = state.push('ordered_list_open', 'ol', 1);\r\n    if (markerValue > 1) {\r\n      token.attrs = [ [ 'start', markerValue ] ];\r\n    }\r\n\r\n  } else {\r\n    token       = state.push('bullet_list_open', 'ul', 1);\r\n  }\r\n\r\n  token.map    = listLines = [ startLine, 0 ];\r\n  token.markup = String.fromCharCode(markerCharCode);\r\n\r\n  //\r\n  // Iterate list items\r\n  //\r\n\r\n  nextLine = startLine;\r\n  prevEmptyEnd = false;\r\n  terminatorRules = state.md.block.ruler.getRules('list');\r\n\r\n  while (nextLine < endLine) {\r\n    contentStart = state.skipSpaces(posAfterMarker);\r\n    max = state.eMarks[nextLine];\r\n\r\n    if (contentStart >= max) {\r\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\r\n      indentAfterMarker = 1;\r\n    } else {\r\n      indentAfterMarker = contentStart - posAfterMarker;\r\n    }\r\n\r\n    // If we have more than 4 spaces, the indent is 1\r\n    // (the rest is just indented code block)\r\n    if (indentAfterMarker > 4) { indentAfterMarker = 1; }\r\n\r\n    // \"  -  test\"\r\n    //  ^^^^^ - calculating total length of this thing\r\n    indent = (posAfterMarker - state.bMarks[nextLine]) + indentAfterMarker;\r\n\r\n    // Run subparser & write tokens\r\n    token        = state.push('list_item_open', 'li', 1);\r\n    token.markup = String.fromCharCode(markerCharCode);\r\n    token.map    = itemLines = [ startLine, 0 ];\r\n\r\n    oldIndent = state.blkIndent;\r\n    oldTight = state.tight;\r\n    oldTShift = state.tShift[startLine];\r\n    oldParentType = state.parentType;\r\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\r\n    state.blkIndent = indent;\r\n    state.tight = true;\r\n    state.parentType = 'list';\r\n\r\n    state.md.block.tokenize(state, startLine, endLine, true);\r\n\r\n    // If any of list item is tight, mark list as tight\r\n    if (!state.tight || prevEmptyEnd) {\r\n      tight = false;\r\n    }\r\n    // Item become loose if finish with empty line,\r\n    // but we should filter last element, because it means list finish\r\n    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);\r\n\r\n    state.blkIndent = oldIndent;\r\n    state.tShift[startLine] = oldTShift;\r\n    state.tight = oldTight;\r\n    state.parentType = oldParentType;\r\n\r\n    token        = state.push('list_item_close', 'li', -1);\r\n    token.markup = String.fromCharCode(markerCharCode);\r\n\r\n    nextLine = startLine = state.line;\r\n    itemLines[1] = nextLine;\r\n    contentStart = state.bMarks[startLine];\r\n\r\n    if (nextLine >= endLine) { break; }\r\n\r\n    if (state.isEmpty(nextLine)) {\r\n      break;\r\n    }\r\n\r\n    //\r\n    // Try to check if list is terminated or continued.\r\n    //\r\n    if (state.tShift[nextLine] < state.blkIndent) { break; }\r\n\r\n    // fail if terminating block found\r\n    terminate = false;\r\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\r\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\r\n        terminate = true;\r\n        break;\r\n      }\r\n    }\r\n    if (terminate) { break; }\r\n\r\n    // fail if list has another type\r\n    if (isOrdered) {\r\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\r\n      if (posAfterMarker < 0) { break; }\r\n    } else {\r\n      posAfterMarker = skipBulletListMarker(state, nextLine);\r\n      if (posAfterMarker < 0) { break; }\r\n    }\r\n\r\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }\r\n  }\r\n\r\n  // Finilize list\r\n  if (isOrdered) {\r\n    token = state.push('ordered_list_close', 'ol', -1);\r\n  } else {\r\n    token = state.push('bullet_list_close', 'ul', -1);\r\n  }\r\n  token.markup = String.fromCharCode(markerCharCode);\r\n\r\n  listLines[1] = nextLine;\r\n  state.line = nextLine;\r\n\r\n  // mark paragraphs tight if needed\r\n  if (tight) {\r\n    markTightParagraphs(state, listTokIdx);\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n},{}],27:[function(require,module,exports){\r\n// Paragraph\r\n\r\n'use strict';\r\n\r\n\r\nmodule.exports = function paragraph(state, startLine/*, endLine*/) {\r\n  var content, terminate, i, l, token,\r\n      nextLine = startLine + 1,\r\n      terminatorRules = state.md.block.ruler.getRules('paragraph'),\r\n      endLine = state.lineMax;\r\n\r\n  // jump line-by-line until empty one or EOF\r\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\r\n    // this would be a code block normally, but after paragraph\r\n    // it's considered a lazy continuation regardless of what's there\r\n    if (state.tShift[nextLine] - state.blkIndent > 3) { continue; }\r\n\r\n    // Some tags can terminate paragraph without empty line.\r\n    terminate = false;\r\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\r\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\r\n        terminate = true;\r\n        break;\r\n      }\r\n    }\r\n    if (terminate) { break; }\r\n  }\r\n\r\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\r\n\r\n  state.line = nextLine;\r\n\r\n  token          = state.push('paragraph_open', 'p', 1);\r\n  token.map      = [ startLine, state.line ];\r\n\r\n  token          = state.push('inline', '', 0);\r\n  token.content  = content;\r\n  token.map      = [ startLine, state.line ];\r\n  token.children = [];\r\n\r\n  token          = state.push('paragraph_close', 'p', -1);\r\n\r\n  return true;\r\n};\r\n\r\n},{}],28:[function(require,module,exports){\r\n'use strict';\r\n\r\n\r\nvar parseLinkDestination = require('../helpers/parse_link_destination');\r\nvar parseLinkTitle       = require('../helpers/parse_link_title');\r\nvar normalizeReference   = require('../common/utils').normalizeReference;\r\n\r\n\r\nmodule.exports = function reference(state, startLine, _endLine, silent) {\r\n  var ch,\r\n      destEndPos,\r\n      destEndLineNo,\r\n      endLine,\r\n      href,\r\n      i,\r\n      l,\r\n      label,\r\n      labelEnd,\r\n      res,\r\n      start,\r\n      str,\r\n      terminate,\r\n      terminatorRules,\r\n      title,\r\n      lines = 0,\r\n      pos = state.bMarks[startLine] + state.tShift[startLine],\r\n      max = state.eMarks[startLine],\r\n      nextLine = startLine + 1;\r\n\r\n  if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false; }\r\n\r\n  // Simple check to quickly interrupt scan on [link](url) at the start of line.\r\n  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54\r\n  while (++pos < max) {\r\n    if (state.src.charCodeAt(pos) === 0x5D /* ] */ &&\r\n        state.src.charCodeAt(pos - 1) !== 0x5C/* \\ */) {\r\n      if (pos + 1 === max) { return false; }\r\n      if (state.src.charCodeAt(pos + 1) !== 0x3A/* : */) { return false; }\r\n      break;\r\n    }\r\n  }\r\n\r\n  endLine = state.lineMax;\r\n\r\n  // jump line-by-line until empty one or EOF\r\n  terminatorRules = state.md.block.ruler.getRules('reference');\r\n\r\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\r\n    // this would be a code block normally, but after paragraph\r\n    // it's considered a lazy continuation regardless of what's there\r\n    if (state.tShift[nextLine] - state.blkIndent > 3) { continue; }\r\n\r\n    // Some tags can terminate paragraph without empty line.\r\n    terminate = false;\r\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\r\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\r\n        terminate = true;\r\n        break;\r\n      }\r\n    }\r\n    if (terminate) { break; }\r\n  }\r\n\r\n  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\r\n  max = str.length;\r\n\r\n  for (pos = 1; pos < max; pos++) {\r\n    ch = str.charCodeAt(pos);\r\n    if (ch === 0x5B /* [ */) {\r\n      return false;\r\n    } else if (ch === 0x5D /* ] */) {\r\n      labelEnd = pos;\r\n      break;\r\n    } else if (ch === 0x0A /* \\n */) {\r\n      lines++;\r\n    } else if (ch === 0x5C /* \\ */) {\r\n      pos++;\r\n      if (pos < max && str.charCodeAt(pos) === 0x0A) {\r\n        lines++;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false; }\r\n\r\n  // [label]:   destination   'title'\r\n  //         ^^^ skip optional whitespace here\r\n  for (pos = labelEnd + 2; pos < max; pos++) {\r\n    ch = str.charCodeAt(pos);\r\n    if (ch === 0x0A) {\r\n      lines++;\r\n    } else if (ch === 0x20) {\r\n      /*eslint no-empty:0*/\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n\r\n  // [label]:   destination   'title'\r\n  //            ^^^^^^^^^^^ parse this\r\n  res = parseLinkDestination(str, pos, max);\r\n  if (!res.ok) { return false; }\r\n\r\n  href = state.md.normalizeLink(res.str);\r\n  if (!state.md.validateLink(href)) { return false; }\r\n\r\n  pos = res.pos;\r\n  lines += res.lines;\r\n\r\n  // save cursor state, we could require to rollback later\r\n  destEndPos = pos;\r\n  destEndLineNo = lines;\r\n\r\n  // [label]:   destination   'title'\r\n  //                       ^^^ skipping those spaces\r\n  start = pos;\r\n  for (; pos < max; pos++) {\r\n    ch = str.charCodeAt(pos);\r\n    if (ch === 0x0A) {\r\n      lines++;\r\n    } else if (ch === 0x20) {\r\n      /*eslint no-empty:0*/\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n\r\n  // [label]:   destination   'title'\r\n  //                          ^^^^^^^ parse this\r\n  res = parseLinkTitle(str, pos, max);\r\n  if (pos < max && start !== pos && res.ok) {\r\n    title = res.str;\r\n    pos = res.pos;\r\n    lines += res.lines;\r\n  } else {\r\n    title = '';\r\n    pos = destEndPos;\r\n    lines = destEndLineNo;\r\n  }\r\n\r\n  // skip trailing spaces until the rest of the line\r\n  while (pos < max && str.charCodeAt(pos) === 0x20/* space */) { pos++; }\r\n\r\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\r\n    // garbage at the end of the line\r\n    return false;\r\n  }\r\n\r\n  // Reference can not terminate anything. This check is for safety only.\r\n  /*istanbul ignore if*/\r\n  if (silent) { return true; }\r\n\r\n  label = normalizeReference(str.slice(1, labelEnd));\r\n  if (typeof state.env.references === 'undefined') {\r\n    state.env.references = {};\r\n  }\r\n  if (typeof state.env.references[label] === 'undefined') {\r\n    state.env.references[label] = { title: title, href: href };\r\n  }\r\n\r\n  state.line = startLine + lines + 1;\r\n  return true;\r\n};\r\n\r\n},{\"../common/utils\":5,\"../helpers/parse_link_destination\":7,\"../helpers/parse_link_title\":9}],29:[function(require,module,exports){\r\n// Parser state class\r\n\r\n'use strict';\r\n\r\nvar Token = require('../token');\r\n\r\n\r\nfunction StateBlock(src, md, env, tokens) {\r\n  var ch, s, start, pos, len, indent, indent_found;\r\n\r\n  this.src = src;\r\n\r\n  // link to parser instance\r\n  this.md     = md;\r\n\r\n  this.env = env;\r\n\r\n  //\r\n  // Internal state vartiables\r\n  //\r\n\r\n  this.tokens = tokens;\r\n\r\n  this.bMarks = [];  // line begin offsets for fast jumps\r\n  this.eMarks = [];  // line end offsets for fast jumps\r\n  this.tShift = [];  // indent for each line\r\n\r\n  // block parser variables\r\n  this.blkIndent  = 0; // required block content indent\r\n                       // (for example, if we are in list)\r\n  this.line       = 0; // line index in src\r\n  this.lineMax    = 0; // lines count\r\n  this.tight      = false;  // loose/tight mode for lists\r\n  this.parentType = 'root'; // if `list`, block parser stops on two newlines\r\n  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)\r\n\r\n  this.level = 0;\r\n\r\n  // renderer\r\n  this.result = '';\r\n\r\n  // Create caches\r\n  // Generate markers.\r\n  s = this.src;\r\n  indent = 0;\r\n  indent_found = false;\r\n\r\n  for (start = pos = indent = 0, len = s.length; pos < len; pos++) {\r\n    ch = s.charCodeAt(pos);\r\n\r\n    if (!indent_found) {\r\n      if (ch === 0x20/* space */) {\r\n        indent++;\r\n        continue;\r\n      } else {\r\n        indent_found = true;\r\n      }\r\n    }\r\n\r\n    if (ch === 0x0A || pos === len - 1) {\r\n      if (ch !== 0x0A) { pos++; }\r\n      this.bMarks.push(start);\r\n      this.eMarks.push(pos);\r\n      this.tShift.push(indent);\r\n\r\n      indent_found = false;\r\n      indent = 0;\r\n      start = pos + 1;\r\n    }\r\n  }\r\n\r\n  // Push fake entry to simplify cache bounds checks\r\n  this.bMarks.push(s.length);\r\n  this.eMarks.push(s.length);\r\n  this.tShift.push(0);\r\n\r\n  this.lineMax = this.bMarks.length - 1; // don't count last fake line\r\n}\r\n\r\n// Push new token to \"stream\".\r\n//\r\nStateBlock.prototype.push = function (type, tag, nesting) {\r\n  var token = new Token(type, tag, nesting);\r\n  token.block = true;\r\n\r\n  if (nesting < 0) { this.level--; }\r\n  token.level = this.level;\r\n  if (nesting > 0) { this.level++; }\r\n\r\n  this.tokens.push(token);\r\n  return token;\r\n};\r\n\r\nStateBlock.prototype.isEmpty = function isEmpty(line) {\r\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\r\n};\r\n\r\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\r\n  for (var max = this.lineMax; from < max; from++) {\r\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\r\n      break;\r\n    }\r\n  }\r\n  return from;\r\n};\r\n\r\n// Skip spaces from given position.\r\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\r\n  for (var max = this.src.length; pos < max; pos++) {\r\n    if (this.src.charCodeAt(pos) !== 0x20/* space */) { break; }\r\n  }\r\n  return pos;\r\n};\r\n\r\n// Skip char codes from given position\r\nStateBlock.prototype.skipChars = function skipChars(pos, code) {\r\n  for (var max = this.src.length; pos < max; pos++) {\r\n    if (this.src.charCodeAt(pos) !== code) { break; }\r\n  }\r\n  return pos;\r\n};\r\n\r\n// Skip char codes reverse from given position - 1\r\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\r\n  if (pos <= min) { return pos; }\r\n\r\n  while (pos > min) {\r\n    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }\r\n  }\r\n  return pos;\r\n};\r\n\r\n// cut lines range from source.\r\nStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\r\n  var i, first, last, queue, shift,\r\n      line = begin;\r\n\r\n  if (begin >= end) {\r\n    return '';\r\n  }\r\n\r\n  // Opt: don't use push queue for single line;\r\n  if (line + 1 === end) {\r\n    first = this.bMarks[line] + Math.min(this.tShift[line], indent);\r\n    last = keepLastLF ? this.bMarks[end] : this.eMarks[end - 1];\r\n    return this.src.slice(first, last);\r\n  }\r\n\r\n  queue = new Array(end - begin);\r\n\r\n  for (i = 0; line < end; line++, i++) {\r\n    shift = this.tShift[line];\r\n    if (shift > indent) { shift = indent; }\r\n    if (shift < 0) { shift = 0; }\r\n\r\n    first = this.bMarks[line] + shift;\r\n\r\n    if (line + 1 < end || keepLastLF) {\r\n      // No need for bounds check because we have fake entry on tail.\r\n      last = this.eMarks[line] + 1;\r\n    } else {\r\n      last = this.eMarks[line];\r\n    }\r\n\r\n    queue[i] = this.src.slice(first, last);\r\n  }\r\n\r\n  return queue.join('');\r\n};\r\n\r\n// re-export Token class to use in block rules\r\nStateBlock.prototype.Token = Token;\r\n\r\n\r\nmodule.exports = StateBlock;\r\n\r\n},{\"../token\":50}],30:[function(require,module,exports){\r\n// GFM table, non-standard\r\n\r\n'use strict';\r\n\r\n\r\nfunction getLine(state, line) {\r\n  var pos = state.bMarks[line] + state.blkIndent,\r\n      max = state.eMarks[line];\r\n\r\n  return state.src.substr(pos, max - pos);\r\n}\r\n\r\nfunction escapedSplit(str) {\r\n  var result = [],\r\n      pos = 0,\r\n      max = str.length,\r\n      ch,\r\n      escapes = 0,\r\n      lastPos = 0,\r\n      backTicked = false,\r\n      lastBackTick = 0;\r\n\r\n  ch  = str.charCodeAt(pos);\r\n\r\n  while (pos < max) {\r\n    if (ch === 0x60/* ` */ && (escapes % 2 === 0)) {\r\n      backTicked = !backTicked;\r\n      lastBackTick = pos;\r\n    } else if (ch === 0x7c/* | */ && (escapes % 2 === 0) && !backTicked) {\r\n      result.push(str.substring(lastPos, pos));\r\n      lastPos = pos + 1;\r\n    } else if (ch === 0x5c/* \\ */) {\r\n      escapes++;\r\n    } else {\r\n      escapes = 0;\r\n    }\r\n\r\n    pos++;\r\n\r\n    // If there was an un-closed backtick, go back to just after\r\n    // the last backtick, but as if it was a normal character\r\n    if (pos === max && backTicked) {\r\n      backTicked = false;\r\n      pos = lastBackTick + 1;\r\n    }\r\n\r\n    ch = str.charCodeAt(pos);\r\n  }\r\n\r\n  result.push(str.substring(lastPos));\r\n\r\n  return result;\r\n}\r\n\r\n\r\nmodule.exports = function table(state, startLine, endLine, silent) {\r\n  var ch, lineText, pos, i, nextLine, rows, token,\r\n      aligns, t, tableLines, tbodyLines;\r\n\r\n  // should have at least three lines\r\n  if (startLine + 2 > endLine) { return false; }\r\n\r\n  nextLine = startLine + 1;\r\n\r\n  if (state.tShift[nextLine] < state.blkIndent) { return false; }\r\n\r\n  // first character of the second line should be '|' or '-'\r\n\r\n  pos = state.bMarks[nextLine] + state.tShift[nextLine];\r\n  if (pos >= state.eMarks[nextLine]) { return false; }\r\n\r\n  ch = state.src.charCodeAt(pos);\r\n  if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */) { return false; }\r\n\r\n  lineText = getLine(state, startLine + 1);\r\n  if (!/^[-:| ]+$/.test(lineText)) { return false; }\r\n\r\n  rows = lineText.split('|');\r\n  if (rows.length < 2) { return false; }\r\n  aligns = [];\r\n  for (i = 0; i < rows.length; i++) {\r\n    t = rows[i].trim();\r\n    if (!t) {\r\n      // allow empty columns before and after table, but not in between columns;\r\n      // e.g. allow ` |---| `, disallow ` ---||--- `\r\n      if (i === 0 || i === rows.length - 1) {\r\n        continue;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    if (!/^:?-+:?$/.test(t)) { return false; }\r\n    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {\r\n      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right');\r\n    } else if (t.charCodeAt(0) === 0x3A/* : */) {\r\n      aligns.push('left');\r\n    } else {\r\n      aligns.push('');\r\n    }\r\n  }\r\n\r\n  lineText = getLine(state, startLine).trim();\r\n  if (lineText.indexOf('|') === -1) { return false; }\r\n  rows = escapedSplit(lineText.replace(/^\\||\\|$/g, ''));\r\n  if (aligns.length !== rows.length) { return false; }\r\n  if (silent) { return true; }\r\n\r\n  token     = state.push('table_open', 'table', 1);\r\n  token.map = tableLines = [ startLine, 0 ];\r\n\r\n  token     = state.push('thead_open', 'thead', 1);\r\n  token.map = [ startLine, startLine + 1 ];\r\n\r\n  token     = state.push('tr_open', 'tr', 1);\r\n  token.map = [ startLine, startLine + 1 ];\r\n\r\n  for (i = 0; i < rows.length; i++) {\r\n    token          = state.push('th_open', 'th', 1);\r\n    token.map      = [ startLine, startLine + 1 ];\r\n    if (aligns[i]) {\r\n      token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];\r\n    }\r\n\r\n    token          = state.push('inline', '', 0);\r\n    token.content  = rows[i].trim();\r\n    token.map      = [ startLine, startLine + 1 ];\r\n    token.children = [];\r\n\r\n    token          = state.push('th_close', 'th', -1);\r\n  }\r\n\r\n  token     = state.push('tr_close', 'tr', -1);\r\n  token     = state.push('thead_close', 'thead', -1);\r\n\r\n  token     = state.push('tbody_open', 'tbody', 1);\r\n  token.map = tbodyLines = [ startLine + 2, 0 ];\r\n\r\n  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\r\n    if (state.tShift[nextLine] < state.blkIndent) { break; }\r\n\r\n    lineText = getLine(state, nextLine).trim();\r\n    if (lineText.indexOf('|') === -1) { break; }\r\n    rows = escapedSplit(lineText.replace(/^\\||\\|$/g, ''));\r\n\r\n    // set number of columns to number of columns in header row\r\n    rows.length = aligns.length;\r\n\r\n    token = state.push('tr_open', 'tr', 1);\r\n    for (i = 0; i < rows.length; i++) {\r\n      token          = state.push('td_open', 'td', 1);\r\n      if (aligns[i]) {\r\n        token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];\r\n      }\r\n\r\n      token          = state.push('inline', '', 0);\r\n      token.content  = rows[i] ? rows[i].trim() : '';\r\n      token.children = [];\r\n\r\n      token          = state.push('td_close', 'td', -1);\r\n    }\r\n    token = state.push('tr_close', 'tr', -1);\r\n  }\r\n  token = state.push('tbody_close', 'tbody', -1);\r\n  token = state.push('table_close', 'table', -1);\r\n\r\n  tableLines[1] = tbodyLines[1] = nextLine;\r\n  state.line = nextLine;\r\n  return true;\r\n};\r\n\r\n},{}],31:[function(require,module,exports){\r\n'use strict';\r\n\r\n\r\nmodule.exports = function block(state) {\r\n  var token;\r\n\r\n  if (state.inlineMode) {\r\n    token          = new state.Token('inline', '', 0);\r\n    token.content  = state.src;\r\n    token.map      = [ 0, 1 ];\r\n    token.children = [];\r\n    state.tokens.push(token);\r\n  } else {\r\n    state.md.block.parse(state.src, state.md, state.env, state.tokens);\r\n  }\r\n};\r\n\r\n},{}],32:[function(require,module,exports){\r\n'use strict';\r\n\r\nmodule.exports = function inline(state) {\r\n  var tokens = state.tokens, tok, i, l;\r\n\r\n  // Parse inlines\r\n  for (i = 0, l = tokens.length; i < l; i++) {\r\n    tok = tokens[i];\r\n    if (tok.type === 'inline') {\r\n      state.md.inline.parse(tok.content, state.md, state.env, tok.children);\r\n    }\r\n  }\r\n};\r\n\r\n},{}],33:[function(require,module,exports){\r\n// Replace link-like texts with link nodes.\r\n//\r\n// Currently restricted by `md.validateLink()` to http/https/ftp\r\n//\r\n'use strict';\r\n\r\n\r\nvar arrayReplaceAt = require('../common/utils').arrayReplaceAt;\r\n\r\n\r\nfunction isLinkOpen(str) {\r\n  return /^<a[>\\s]/i.test(str);\r\n}\r\nfunction isLinkClose(str) {\r\n  return /^<\\/a\\s*>/i.test(str);\r\n}\r\n\r\n\r\nmodule.exports = function linkify(state) {\r\n  var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos,\r\n      level, htmlLinkLevel, url, fullUrl, urlText,\r\n      blockTokens = state.tokens,\r\n      links;\r\n\r\n  if (!state.md.options.linkify) { return; }\r\n\r\n  for (j = 0, l = blockTokens.length; j < l; j++) {\r\n    if (blockTokens[j].type !== 'inline' ||\r\n        !state.md.linkify.pretest(blockTokens[j].content)) {\r\n      continue;\r\n    }\r\n\r\n    tokens = blockTokens[j].children;\r\n\r\n    htmlLinkLevel = 0;\r\n\r\n    // We scan from the end, to keep position when new tags added.\r\n    // Use reversed logic in links start/end match\r\n    for (i = tokens.length - 1; i >= 0; i--) {\r\n      currentToken = tokens[i];\r\n\r\n      // Skip content of markdown links\r\n      if (currentToken.type === 'link_close') {\r\n        i--;\r\n        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {\r\n          i--;\r\n        }\r\n        continue;\r\n      }\r\n\r\n      // Skip content of html tag links\r\n      if (currentToken.type === 'html_inline') {\r\n        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {\r\n          htmlLinkLevel--;\r\n        }\r\n        if (isLinkClose(currentToken.content)) {\r\n          htmlLinkLevel++;\r\n        }\r\n      }\r\n      if (htmlLinkLevel > 0) { continue; }\r\n\r\n      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {\r\n\r\n        text = currentToken.content;\r\n        links = state.md.linkify.match(text);\r\n\r\n        // Now split string to nodes\r\n        nodes = [];\r\n        level = currentToken.level;\r\n        lastPos = 0;\r\n\r\n        for (ln = 0; ln < links.length; ln++) {\r\n\r\n          url = links[ln].url;\r\n          fullUrl = state.md.normalizeLink(url);\r\n          if (!state.md.validateLink(fullUrl)) { continue; }\r\n\r\n          urlText = links[ln].text;\r\n\r\n          // Linkifier might send raw hostnames like \"example.com\", where url\r\n          // starts with domain name. So we prepend http:// in those cases,\r\n          // and remove it afterwards.\r\n          //\r\n          if (!links[ln].schema) {\r\n            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\\/\\//, '');\r\n          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {\r\n            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');\r\n          } else {\r\n            urlText = state.md.normalizeLinkText(urlText);\r\n          }\r\n\r\n          pos = links[ln].index;\r\n\r\n          if (pos > lastPos) {\r\n            token         = new state.Token('text', '', 0);\r\n            token.content = text.slice(lastPos, pos);\r\n            token.level   = level;\r\n            nodes.push(token);\r\n          }\r\n\r\n          token         = new state.Token('link_open', 'a', 1);\r\n          token.attrs   = [ [ 'href', fullUrl ] ];\r\n          token.level   = level++;\r\n          token.markup  = 'linkify';\r\n          token.info    = 'auto';\r\n          nodes.push(token);\r\n\r\n          token         = new state.Token('text', '', 0);\r\n          token.content = urlText;\r\n          token.level   = level;\r\n          nodes.push(token);\r\n\r\n          token         = new state.Token('link_close', 'a', -1);\r\n          token.level   = --level;\r\n          token.markup  = 'linkify';\r\n          token.info    = 'auto';\r\n          nodes.push(token);\r\n\r\n          lastPos = links[ln].lastIndex;\r\n        }\r\n        if (lastPos < text.length) {\r\n          token         = new state.Token('text', '', 0);\r\n          token.content = text.slice(lastPos);\r\n          token.level   = level;\r\n          nodes.push(token);\r\n        }\r\n\r\n        // replace current node\r\n        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n},{\"../common/utils\":5}],34:[function(require,module,exports){\r\n// Normalize input string\r\n\r\n'use strict';\r\n\r\n\r\nvar TABS_SCAN_RE = /[\\n\\t]/g;\r\nvar NEWLINES_RE  = /\\r[\\n\\u0085]|[\\u2424\\u2028\\u0085]/g;\r\nvar NULL_RE      = /\\u0000/g;\r\n\r\n\r\nmodule.exports = function inline(state) {\r\n  var str, lineStart, lastTabPos;\r\n\r\n  // Normalize newlines\r\n  str = state.src.replace(NEWLINES_RE, '\\n');\r\n\r\n  // Replace NULL characters\r\n  str = str.replace(NULL_RE, '\\uFFFD');\r\n\r\n  // Replace tabs with proper number of spaces (1..4)\r\n  if (str.indexOf('\\t') >= 0) {\r\n    lineStart = 0;\r\n    lastTabPos = 0;\r\n\r\n    str = str.replace(TABS_SCAN_RE, function (match, offset) {\r\n      var result;\r\n      if (str.charCodeAt(offset) === 0x0A) {\r\n        lineStart = offset + 1;\r\n        lastTabPos = 0;\r\n        return match;\r\n      }\r\n      result = '    '.slice((offset - lineStart - lastTabPos) % 4);\r\n      lastTabPos = offset - lineStart + 1;\r\n      return result;\r\n    });\r\n  }\r\n\r\n  state.src = str;\r\n};\r\n\r\n},{}],35:[function(require,module,exports){\r\n// Simple typographyc replacements\r\n//\r\n// ''  \r\n// \"\"  . Set '' for Russian, '' for German, empty to disable\r\n// (c) (C)  \r\n// (tm) (TM)  \r\n// (r) (R)  \r\n// +-  \r\n// (p) (P) -> \r\n// ...   (also ?....  ?.., !....  !..)\r\n// ????????  ???, !!!!!  !!!, `,,`  `,`\r\n// --  &ndash;, ---  &mdash;\r\n//\r\n'use strict';\r\n\r\n// TODO:\r\n// - fractionals 1/2, 1/4, 3/4 -> , , \r\n// - miltiplication 2 x 4 -> 2  4\r\n\r\nvar RARE_RE = /\\+-|\\.\\.|\\?\\?\\?\\?|!!!!|,,|--/;\r\n\r\n// Workaround for phantomjs - need regex without /g flag,\r\n// or root check will fail every second time\r\nvar SCOPED_ABBR_TEST_RE = /\\((c|tm|r|p)\\)/i;\r\n\r\nvar SCOPED_ABBR_RE = /\\((c|tm|r|p)\\)/ig;\r\nvar SCOPED_ABBR = {\r\n  'c': '',\r\n  'r': '',\r\n  'p': '',\r\n  'tm': ''\r\n};\r\n\r\nfunction replaceFn(match, name) {\r\n  return SCOPED_ABBR[name.toLowerCase()];\r\n}\r\n\r\nfunction replace_scoped(inlineTokens) {\r\n  var i, token;\r\n\r\n  for (i = inlineTokens.length - 1; i >= 0; i--) {\r\n    token = inlineTokens[i];\r\n    if (token.type === 'text') {\r\n      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);\r\n    }\r\n  }\r\n}\r\n\r\nfunction replace_rare(inlineTokens) {\r\n  var i, token;\r\n\r\n  for (i = inlineTokens.length - 1; i >= 0; i--) {\r\n    token = inlineTokens[i];\r\n    if (token.type === 'text') {\r\n      if (RARE_RE.test(token.content)) {\r\n        token.content = token.content\r\n                    .replace(/\\+-/g, '')\r\n                    // .., ..., ....... -> \r\n                    // but ?..... & !..... -> ?.. & !..\r\n                    .replace(/\\.{2,}/g, '').replace(/([?!])/g, '$1..')\r\n                    .replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')\r\n                    // em-dash\r\n                    .replace(/(^|[^-])---([^-]|$)/mg, '$1\\u2014$2')\r\n                    // en-dash\r\n                    .replace(/(^|\\s)--(\\s|$)/mg, '$1\\u2013$2')\r\n                    .replace(/(^|[^-\\s])--([^-\\s]|$)/mg, '$1\\u2013$2');\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\r\nmodule.exports = function replace(state) {\r\n  var blkIdx;\r\n\r\n  if (!state.md.options.typographer) { return; }\r\n\r\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\r\n\r\n    if (state.tokens[blkIdx].type !== 'inline') { continue; }\r\n\r\n    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {\r\n      replace_scoped(state.tokens[blkIdx].children);\r\n    }\r\n\r\n    if (RARE_RE.test(state.tokens[blkIdx].content)) {\r\n      replace_rare(state.tokens[blkIdx].children);\r\n    }\r\n\r\n  }\r\n};\r\n\r\n},{}],36:[function(require,module,exports){\r\n// Convert straight quotation marks to typographic ones\r\n//\r\n'use strict';\r\n\r\n\r\nvar isWhiteSpace   = require('../common/utils').isWhiteSpace;\r\nvar isPunctChar    = require('../common/utils').isPunctChar;\r\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\r\n\r\nvar QUOTE_TEST_RE = /['\"]/;\r\nvar QUOTE_RE = /['\"]/g;\r\nvar APOSTROPHE = '\\u2019'; /*  */\r\n\r\n\r\nfunction replaceAt(str, index, ch) {\r\n  return str.substr(0, index) + ch + str.substr(index + 1);\r\n}\r\n\r\nfunction process_inlines(tokens, state) {\r\n  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar,\r\n      isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace,\r\n      canOpen, canClose, j, isSingle, stack;\r\n\r\n  stack = [];\r\n\r\n  for (i = 0; i < tokens.length; i++) {\r\n    token = tokens[i];\r\n\r\n    thisLevel = tokens[i].level;\r\n\r\n    for (j = stack.length - 1; j >= 0; j--) {\r\n      if (stack[j].level <= thisLevel) { break; }\r\n    }\r\n    stack.length = j + 1;\r\n\r\n    if (token.type !== 'text') { continue; }\r\n\r\n    text = token.content;\r\n    pos = 0;\r\n    max = text.length;\r\n\r\n    /*eslint no-labels:0,block-scoped-var:0*/\r\n    OUTER:\r\n    while (pos < max) {\r\n      QUOTE_RE.lastIndex = pos;\r\n      t = QUOTE_RE.exec(text);\r\n      if (!t) { break; }\r\n\r\n      canOpen = canClose = true;\r\n      pos = t.index + 1;\r\n      isSingle = (t[0] === \"'\");\r\n\r\n      // treat begin/end of the line as a whitespace\r\n      lastChar = t.index - 1 >= 0 ? text.charCodeAt(t.index - 1) : 0x20;\r\n      nextChar = pos < max ? text.charCodeAt(pos) : 0x20;\r\n\r\n      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\r\n      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\r\n\r\n      isLastWhiteSpace = isWhiteSpace(lastChar);\r\n      isNextWhiteSpace = isWhiteSpace(nextChar);\r\n\r\n      if (isNextWhiteSpace) {\r\n        canOpen = false;\r\n      } else if (isNextPunctChar) {\r\n        if (!(isLastWhiteSpace || isLastPunctChar)) {\r\n          canOpen = false;\r\n        }\r\n      }\r\n\r\n      if (isLastWhiteSpace) {\r\n        canClose = false;\r\n      } else if (isLastPunctChar) {\r\n        if (!(isNextWhiteSpace || isNextPunctChar)) {\r\n          canClose = false;\r\n        }\r\n      }\r\n\r\n      if (nextChar === 0x22 /* \" */ && t[0] === '\"') {\r\n        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {\r\n          // special case: 1\"\" - count first quote as an inch\r\n          canClose = canOpen = false;\r\n        }\r\n      }\r\n\r\n      if (canOpen && canClose) {\r\n        // treat this as the middle of the word\r\n        canOpen = false;\r\n        canClose = isNextPunctChar;\r\n      }\r\n\r\n      if (!canOpen && !canClose) {\r\n        // middle of word\r\n        if (isSingle) {\r\n          token.content = replaceAt(token.content, t.index, APOSTROPHE);\r\n        }\r\n        continue;\r\n      }\r\n\r\n      if (canClose) {\r\n        // this could be a closing quote, rewind the stack to get a match\r\n        for (j = stack.length - 1; j >= 0; j--) {\r\n          item = stack[j];\r\n          if (stack[j].level < thisLevel) { break; }\r\n          if (item.single === isSingle && stack[j].level === thisLevel) {\r\n            item = stack[j];\r\n            if (isSingle) {\r\n              tokens[item.token].content = replaceAt(\r\n                tokens[item.token].content, item.pos, state.md.options.quotes[2]);\r\n              token.content = replaceAt(\r\n                token.content, t.index, state.md.options.quotes[3]);\r\n            } else {\r\n              tokens[item.token].content = replaceAt(\r\n                tokens[item.token].content, item.pos, state.md.options.quotes[0]);\r\n              token.content = replaceAt(token.content, t.index, state.md.options.quotes[1]);\r\n            }\r\n            stack.length = j;\r\n            continue OUTER;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (canOpen) {\r\n        stack.push({\r\n          token: i,\r\n          pos: t.index,\r\n          single: isSingle,\r\n          level: thisLevel\r\n        });\r\n      } else if (canClose && isSingle) {\r\n        token.content = replaceAt(token.content, t.index, APOSTROPHE);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\r\nmodule.exports = function smartquotes(state) {\r\n  /*eslint max-depth:0*/\r\n  var blkIdx;\r\n\r\n  if (!state.md.options.typographer) { return; }\r\n\r\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\r\n\r\n    if (state.tokens[blkIdx].type !== 'inline' ||\r\n        !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {\r\n      continue;\r\n    }\r\n\r\n    process_inlines(state.tokens[blkIdx].children, state);\r\n  }\r\n};\r\n\r\n},{\"../common/utils\":5}],37:[function(require,module,exports){\r\n// Core state object\r\n//\r\n'use strict';\r\n\r\nvar Token = require('../token');\r\n\r\n\r\nfunction StateCore(src, md, env) {\r\n  this.src = src;\r\n  this.env = env;\r\n  this.tokens = [];\r\n  this.inlineMode = false;\r\n  this.md = md; // link to parser instance\r\n}\r\n\r\n// re-export Token class to use in core rules\r\nStateCore.prototype.Token = Token;\r\n\r\n\r\nmodule.exports = StateCore;\r\n\r\n},{\"../token\":50}],38:[function(require,module,exports){\r\n// Process autolinks '<protocol:...>'\r\n\r\n'use strict';\r\n\r\nvar url_schemas = require('../common/url_schemas');\r\n\r\n\r\n/*eslint max-len:0*/\r\nvar EMAIL_RE    = /^<([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;\r\nvar AUTOLINK_RE = /^<([a-zA-Z.\\-]{1,25}):([^<>\\x00-\\x20]*)>/;\r\n\r\n\r\nmodule.exports = function autolink(state, silent) {\r\n  var tail, linkMatch, emailMatch, url, fullUrl, token,\r\n      pos = state.pos;\r\n\r\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }\r\n\r\n  tail = state.src.slice(pos);\r\n\r\n  if (tail.indexOf('>') < 0) { return false; }\r\n\r\n  if (AUTOLINK_RE.test(tail)) {\r\n    linkMatch = tail.match(AUTOLINK_RE);\r\n\r\n    if (url_schemas.indexOf(linkMatch[1].toLowerCase()) < 0) { return false; }\r\n\r\n    url = linkMatch[0].slice(1, -1);\r\n    fullUrl = state.md.normalizeLink(url);\r\n    if (!state.md.validateLink(fullUrl)) { return false; }\r\n\r\n    if (!silent) {\r\n      token         = state.push('link_open', 'a', 1);\r\n      token.attrs   = [ [ 'href', fullUrl ] ];\r\n\r\n      token         = state.push('text', '', 0);\r\n      token.content = state.md.normalizeLinkText(url);\r\n\r\n      token         = state.push('link_close', 'a', -1);\r\n    }\r\n\r\n    state.pos += linkMatch[0].length;\r\n    return true;\r\n  }\r\n\r\n  if (EMAIL_RE.test(tail)) {\r\n    emailMatch = tail.match(EMAIL_RE);\r\n\r\n    url = emailMatch[0].slice(1, -1);\r\n    fullUrl = state.md.normalizeLink('mailto:' + url);\r\n    if (!state.md.validateLink(fullUrl)) { return false; }\r\n\r\n    if (!silent) {\r\n      token         = state.push('link_open', 'a', 1);\r\n      token.attrs   = [ [ 'href', fullUrl ] ];\r\n      token.markup  = 'autolink';\r\n      token.info    = 'auto';\r\n\r\n      token         = state.push('text', '', 0);\r\n      token.content = state.md.normalizeLinkText(url);\r\n\r\n      token         = state.push('link_close', 'a', -1);\r\n      token.markup  = 'autolink';\r\n      token.info    = 'auto';\r\n    }\r\n\r\n    state.pos += emailMatch[0].length;\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n},{\"../common/url_schemas\":4}],39:[function(require,module,exports){\r\n// Parse backticks\r\n\r\n'use strict';\r\n\r\nmodule.exports = function backtick(state, silent) {\r\n  var start, max, marker, matchStart, matchEnd, token,\r\n      pos = state.pos,\r\n      ch = state.src.charCodeAt(pos);\r\n\r\n  if (ch !== 0x60/* ` */) { return false; }\r\n\r\n  start = pos;\r\n  pos++;\r\n  max = state.posMax;\r\n\r\n  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }\r\n\r\n  marker = state.src.slice(start, pos);\r\n\r\n  matchStart = matchEnd = pos;\r\n\r\n  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {\r\n    matchEnd = matchStart + 1;\r\n\r\n    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }\r\n\r\n    if (matchEnd - matchStart === marker.length) {\r\n      if (!silent) {\r\n        token         = state.push('code_inline', 'code', 0);\r\n        token.markup  = marker;\r\n        token.content = state.src.slice(pos, matchStart)\r\n                                 .replace(/[ \\n]+/g, ' ')\r\n                                 .trim();\r\n      }\r\n      state.pos = matchEnd;\r\n      return true;\r\n    }\r\n  }\r\n\r\n  if (!silent) { state.pending += marker; }\r\n  state.pos += marker.length;\r\n  return true;\r\n};\r\n\r\n},{}],40:[function(require,module,exports){\r\n// Process *this* and _that_\r\n//\r\n'use strict';\r\n\r\n\r\nvar isWhiteSpace   = require('../common/utils').isWhiteSpace;\r\nvar isPunctChar    = require('../common/utils').isPunctChar;\r\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\r\n\r\n\r\n// parse sequence of emphasis markers,\r\n// \"start\" should point at a valid marker\r\nfunction scanDelims(state, start) {\r\n  var pos = start, lastChar, nextChar, count,\r\n      isLastWhiteSpace, isLastPunctChar,\r\n      isNextWhiteSpace, isNextPunctChar,\r\n      can_open = true,\r\n      can_close = true,\r\n      max = state.posMax,\r\n      marker = state.src.charCodeAt(start);\r\n\r\n  // treat beginning of the line as a whitespace\r\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : 0x20;\r\n\r\n  while (pos < max && state.src.charCodeAt(pos) === marker) { pos++; }\r\n\r\n  if (pos >= max) {\r\n    can_open = false;\r\n  }\r\n\r\n  count = pos - start;\r\n\r\n  // treat end of the line as a whitespace\r\n  nextChar = pos < max ? state.src.charCodeAt(pos) : 0x20;\r\n\r\n  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\r\n  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\r\n\r\n  isLastWhiteSpace = isWhiteSpace(lastChar);\r\n  isNextWhiteSpace = isWhiteSpace(nextChar);\r\n\r\n  if (isNextWhiteSpace) {\r\n    can_open = false;\r\n  } else if (isNextPunctChar) {\r\n    if (!(isLastWhiteSpace || isLastPunctChar)) {\r\n      can_open = false;\r\n    }\r\n  }\r\n\r\n  if (isLastWhiteSpace) {\r\n    can_close = false;\r\n  } else if (isLastPunctChar) {\r\n    if (!(isNextWhiteSpace || isNextPunctChar)) {\r\n      can_close = false;\r\n    }\r\n  }\r\n\r\n  if (marker === 0x5F /* _ */) {\r\n    if (can_open && can_close) {\r\n      // \"_\" inside a word can neither open nor close an emphasis\r\n      can_open = false;\r\n      can_close = isNextPunctChar;\r\n    }\r\n  }\r\n\r\n  return {\r\n    can_open: can_open,\r\n    can_close: can_close,\r\n    delims: count\r\n  };\r\n}\r\n\r\nmodule.exports = function emphasis(state, silent) {\r\n  var startCount,\r\n      count,\r\n      found,\r\n      oldCount,\r\n      newCount,\r\n      stack,\r\n      res,\r\n      token,\r\n      max = state.posMax,\r\n      start = state.pos,\r\n      marker = state.src.charCodeAt(start);\r\n\r\n  if (marker !== 0x5F/* _ */ && marker !== 0x2A /* * */) { return false; }\r\n  if (silent) { return false; } // don't run any pairs in validation mode\r\n\r\n  res = scanDelims(state, start);\r\n  startCount = res.delims;\r\n  if (!res.can_open) {\r\n    state.pos += startCount;\r\n    // Earlier we checked !silent, but this implementation does not need it\r\n    state.pending += state.src.slice(start, state.pos);\r\n    return true;\r\n  }\r\n\r\n  state.pos = start + startCount;\r\n  stack = [ startCount ];\r\n\r\n  while (state.pos < max) {\r\n    if (state.src.charCodeAt(state.pos) === marker) {\r\n      res = scanDelims(state, state.pos);\r\n      count = res.delims;\r\n      if (res.can_close) {\r\n        oldCount = stack.pop();\r\n        newCount = count;\r\n\r\n        while (oldCount !== newCount) {\r\n          if (newCount < oldCount) {\r\n            stack.push(oldCount - newCount);\r\n            break;\r\n          }\r\n\r\n          // assert(newCount > oldCount)\r\n          newCount -= oldCount;\r\n\r\n          if (stack.length === 0) { break; }\r\n          state.pos += oldCount;\r\n          oldCount = stack.pop();\r\n        }\r\n\r\n        if (stack.length === 0) {\r\n          startCount = oldCount;\r\n          found = true;\r\n          break;\r\n        }\r\n        state.pos += count;\r\n        continue;\r\n      }\r\n\r\n      if (res.can_open) { stack.push(count); }\r\n      state.pos += count;\r\n      continue;\r\n    }\r\n\r\n    state.md.inline.skipToken(state);\r\n  }\r\n\r\n  if (!found) {\r\n    // parser failed to find ending tag, so it's not valid emphasis\r\n    state.pos = start;\r\n    return false;\r\n  }\r\n\r\n  // found!\r\n  state.posMax = state.pos;\r\n  state.pos = start + startCount;\r\n\r\n  // Earlier we checked !silent, but this implementation does not need it\r\n\r\n  // we have `startCount` starting and ending markers,\r\n  // now trying to serialize them into tokens\r\n  for (count = startCount; count > 1; count -= 2) {\r\n    token        = state.push('strong_open', 'strong', 1);\r\n    token.markup = String.fromCharCode(marker) + String.fromCharCode(marker);\r\n  }\r\n  if (count % 2) {\r\n    token        = state.push('em_open', 'em', 1);\r\n    token.markup = String.fromCharCode(marker);\r\n  }\r\n\r\n  state.md.inline.tokenize(state);\r\n\r\n  if (count % 2) {\r\n    token        = state.push('em_close', 'em', -1);\r\n    token.markup = String.fromCharCode(marker);\r\n  }\r\n  for (count = startCount; count > 1; count -= 2) {\r\n    token        = state.push('strong_close', 'strong', -1);\r\n    token.markup = String.fromCharCode(marker) + String.fromCharCode(marker);\r\n  }\r\n\r\n  state.pos = state.posMax + startCount;\r\n  state.posMax = max;\r\n  return true;\r\n};\r\n\r\n},{\"../common/utils\":5}],41:[function(require,module,exports){\r\n// Process html entity - &#123;, &#xAF;, &quot;, ...\r\n\r\n'use strict';\r\n\r\nvar entities          = require('../common/entities');\r\nvar has               = require('../common/utils').has;\r\nvar isValidEntityCode = require('../common/utils').isValidEntityCode;\r\nvar fromCodePoint     = require('../common/utils').fromCodePoint;\r\n\r\n\r\nvar DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;\r\nvar NAMED_RE   = /^&([a-z][a-z0-9]{1,31});/i;\r\n\r\n\r\nmodule.exports = function entity(state, silent) {\r\n  var ch, code, match, pos = state.pos, max = state.posMax;\r\n\r\n  if (state.src.charCodeAt(pos) !== 0x26/* & */) { return false; }\r\n\r\n  if (pos + 1 < max) {\r\n    ch = state.src.charCodeAt(pos + 1);\r\n\r\n    if (ch === 0x23 /* # */) {\r\n      match = state.src.slice(pos).match(DIGITAL_RE);\r\n      if (match) {\r\n        if (!silent) {\r\n          code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);\r\n          state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);\r\n        }\r\n        state.pos += match[0].length;\r\n        return true;\r\n      }\r\n    } else {\r\n      match = state.src.slice(pos).match(NAMED_RE);\r\n      if (match) {\r\n        if (has(entities, match[1])) {\r\n          if (!silent) { state.pending += entities[match[1]]; }\r\n          state.pos += match[0].length;\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!silent) { state.pending += '&'; }\r\n  state.pos++;\r\n  return true;\r\n};\r\n\r\n},{\"../common/entities\":1,\"../common/utils\":5}],42:[function(require,module,exports){\r\n// Proceess escaped chars and hardbreaks\r\n\r\n'use strict';\r\n\r\nvar ESCAPED = [];\r\n\r\nfor (var i = 0; i < 256; i++) { ESCAPED.push(0); }\r\n\r\n'\\\\!\"#$%&\\'()*+,./:;<=>?@[]^_`{|}~-'\r\n  .split('').forEach(function(ch) { ESCAPED[ch.charCodeAt(0)] = 1; });\r\n\r\n\r\nmodule.exports = function escape(state, silent) {\r\n  var ch, pos = state.pos, max = state.posMax;\r\n\r\n  if (state.src.charCodeAt(pos) !== 0x5C/* \\ */) { return false; }\r\n\r\n  pos++;\r\n\r\n  if (pos < max) {\r\n    ch = state.src.charCodeAt(pos);\r\n\r\n    if (ch < 256 && ESCAPED[ch] !== 0) {\r\n      if (!silent) { state.pending += state.src[pos]; }\r\n      state.pos += 2;\r\n      return true;\r\n    }\r\n\r\n    if (ch === 0x0A) {\r\n      if (!silent) {\r\n        state.push('hardbreak', 'br', 0);\r\n      }\r\n\r\n      pos++;\r\n      // skip leading whitespaces from next line\r\n      while (pos < max && state.src.charCodeAt(pos) === 0x20) { pos++; }\r\n\r\n      state.pos = pos;\r\n      return true;\r\n    }\r\n  }\r\n\r\n  if (!silent) { state.pending += '\\\\'; }\r\n  state.pos++;\r\n  return true;\r\n};\r\n\r\n},{}],43:[function(require,module,exports){\r\n// Process html tags\r\n\r\n'use strict';\r\n\r\n\r\nvar HTML_TAG_RE = require('../common/html_re').HTML_TAG_RE;\r\n\r\n\r\nfunction isLetter(ch) {\r\n  /*eslint no-bitwise:0*/\r\n  var lc = ch | 0x20; // to lower case\r\n  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);\r\n}\r\n\r\n\r\nmodule.exports = function html_inline(state, silent) {\r\n  var ch, match, max, token,\r\n      pos = state.pos;\r\n\r\n  if (!state.md.options.html) { return false; }\r\n\r\n  // Check start\r\n  max = state.posMax;\r\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */ ||\r\n      pos + 2 >= max) {\r\n    return false;\r\n  }\r\n\r\n  // Quick fail on second char\r\n  ch = state.src.charCodeAt(pos + 1);\r\n  if (ch !== 0x21/* ! */ &&\r\n      ch !== 0x3F/* ? */ &&\r\n      ch !== 0x2F/* / */ &&\r\n      !isLetter(ch)) {\r\n    return false;\r\n  }\r\n\r\n  match = state.src.slice(pos).match(HTML_TAG_RE);\r\n  if (!match) { return false; }\r\n\r\n  if (!silent) {\r\n    token         = state.push('html_inline', '', 0);\r\n    token.content = state.src.slice(pos, pos + match[0].length);\r\n  }\r\n  state.pos += match[0].length;\r\n  return true;\r\n};\r\n\r\n},{\"../common/html_re\":3}],44:[function(require,module,exports){\r\n// Process ![image](<src> \"title\")\r\n\r\n'use strict';\r\n\r\nvar parseLinkLabel       = require('../helpers/parse_link_label');\r\nvar parseLinkDestination = require('../helpers/parse_link_destination');\r\nvar parseLinkTitle       = require('../helpers/parse_link_title');\r\nvar normalizeReference   = require('../common/utils').normalizeReference;\r\n\r\n\r\nmodule.exports = function image(state, silent) {\r\n  var attrs,\r\n      code,\r\n      label,\r\n      labelEnd,\r\n      labelStart,\r\n      pos,\r\n      ref,\r\n      res,\r\n      title,\r\n      token,\r\n      tokens,\r\n      start,\r\n      href = '',\r\n      oldPos = state.pos,\r\n      max = state.posMax;\r\n\r\n  if (state.src.charCodeAt(state.pos) !== 0x21/* ! */) { return false; }\r\n  if (state.src.charCodeAt(state.pos + 1) !== 0x5B/* [ */) { return false; }\r\n\r\n  labelStart = state.pos + 2;\r\n  labelEnd = parseLinkLabel(state, state.pos + 1, false);\r\n\r\n  // parser failed to find ']', so it's not a valid link\r\n  if (labelEnd < 0) { return false; }\r\n\r\n  pos = labelEnd + 1;\r\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\r\n    //\r\n    // Inline link\r\n    //\r\n\r\n    // [link](  <href>  \"title\"  )\r\n    //        ^^ skipping these spaces\r\n    pos++;\r\n    for (; pos < max; pos++) {\r\n      code = state.src.charCodeAt(pos);\r\n      if (code !== 0x20 && code !== 0x0A) { break; }\r\n    }\r\n    if (pos >= max) { return false; }\r\n\r\n    // [link](  <href>  \"title\"  )\r\n    //          ^^^^^^ parsing link destination\r\n    start = pos;\r\n    res = parseLinkDestination(state.src, pos, state.posMax);\r\n    if (res.ok) {\r\n      href = state.md.normalizeLink(res.str);\r\n      if (state.md.validateLink(href)) {\r\n        pos = res.pos;\r\n      } else {\r\n        href = '';\r\n      }\r\n    }\r\n\r\n    // [link](  <href>  \"title\"  )\r\n    //                ^^ skipping these spaces\r\n    start = pos;\r\n    for (; pos < max; pos++) {\r\n      code = state.src.charCodeAt(pos);\r\n      if (code !== 0x20 && code !== 0x0A) { break; }\r\n    }\r\n\r\n    // [link](  <href>  \"title\"  )\r\n    //                  ^^^^^^^ parsing link title\r\n    res = parseLinkTitle(state.src, pos, state.posMax);\r\n    if (pos < max && start !== pos && res.ok) {\r\n      title = res.str;\r\n      pos = res.pos;\r\n\r\n      // [link](  <href>  \"title\"  )\r\n      //                         ^^ skipping these spaces\r\n      for (; pos < max; pos++) {\r\n        code = state.src.charCodeAt(pos);\r\n        if (code !== 0x20 && code !== 0x0A) { break; }\r\n      }\r\n    } else {\r\n      title = '';\r\n    }\r\n\r\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\r\n      state.pos = oldPos;\r\n      return false;\r\n    }\r\n    pos++;\r\n  } else {\r\n    //\r\n    // Link reference\r\n    //\r\n    if (typeof state.env.references === 'undefined') { return false; }\r\n\r\n    // [foo]  [bar]\r\n    //      ^^ optional whitespace (can include newlines)\r\n    for (; pos < max; pos++) {\r\n      code = state.src.charCodeAt(pos);\r\n      if (code !== 0x20 && code !== 0x0A) { break; }\r\n    }\r\n\r\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\r\n      start = pos + 1;\r\n      pos = parseLinkLabel(state, pos);\r\n      if (pos >= 0) {\r\n        label = state.src.slice(start, pos++);\r\n      } else {\r\n        pos = labelEnd + 1;\r\n      }\r\n    } else {\r\n      pos = labelEnd + 1;\r\n    }\r\n\r\n    // covers label === '' and label === undefined\r\n    // (collapsed reference link and shortcut reference link respectively)\r\n    if (!label) { label = state.src.slice(labelStart, labelEnd); }\r\n\r\n    ref = state.env.references[normalizeReference(label)];\r\n    if (!ref) {\r\n      state.pos = oldPos;\r\n      return false;\r\n    }\r\n    href = ref.href;\r\n    title = ref.title;\r\n  }\r\n\r\n  //\r\n  // We found the end of the link, and know for a fact it's a valid link;\r\n  // so all that's left to do is to call tokenizer.\r\n  //\r\n  if (!silent) {\r\n    state.pos = labelStart;\r\n    state.posMax = labelEnd;\r\n\r\n    var newState = new state.md.inline.State(\r\n      state.src.slice(labelStart, labelEnd),\r\n      state.md,\r\n      state.env,\r\n      tokens = []\r\n    );\r\n    newState.md.inline.tokenize(newState);\r\n\r\n    token          = state.push('image', 'img', 0);\r\n    token.attrs    = attrs = [ [ 'src', href ], [ 'alt', '' ] ];\r\n    token.children = tokens;\r\n    if (title) {\r\n      attrs.push([ 'title', title ]);\r\n    }\r\n  }\r\n\r\n  state.pos = pos;\r\n  state.posMax = max;\r\n  return true;\r\n};\r\n\r\n},{\"../common/utils\":5,\"../helpers/parse_link_destination\":7,\"../helpers/parse_link_label\":8,\"../helpers/parse_link_title\":9}],45:[function(require,module,exports){\r\n// Process [link](<to> \"stuff\")\r\n\r\n'use strict';\r\n\r\nvar parseLinkLabel       = require('../helpers/parse_link_label');\r\nvar parseLinkDestination = require('../helpers/parse_link_destination');\r\nvar parseLinkTitle       = require('../helpers/parse_link_title');\r\nvar normalizeReference   = require('../common/utils').normalizeReference;\r\n\r\n\r\nmodule.exports = function link(state, silent) {\r\n  var attrs,\r\n      code,\r\n      label,\r\n      labelEnd,\r\n      labelStart,\r\n      pos,\r\n      res,\r\n      ref,\r\n      title,\r\n      token,\r\n      href = '',\r\n      oldPos = state.pos,\r\n      max = state.posMax,\r\n      start = state.pos;\r\n\r\n  if (state.src.charCodeAt(state.pos) !== 0x5B/* [ */) { return false; }\r\n\r\n  labelStart = state.pos + 1;\r\n  labelEnd = parseLinkLabel(state, state.pos, true);\r\n\r\n  // parser failed to find ']', so it's not a valid link\r\n  if (labelEnd < 0) { return false; }\r\n\r\n  pos = labelEnd + 1;\r\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\r\n    //\r\n    // Inline link\r\n    //\r\n\r\n    // [link](  <href>  \"title\"  )\r\n    //        ^^ skipping these spaces\r\n    pos++;\r\n    for (; pos < max; pos++) {\r\n      code = state.src.charCodeAt(pos);\r\n      if (code !== 0x20 && code !== 0x0A) { break; }\r\n    }\r\n    if (pos >= max) { return false; }\r\n\r\n    // [link](  <href>  \"title\"  )\r\n    //          ^^^^^^ parsing link destination\r\n    start = pos;\r\n    res = parseLinkDestination(state.src, pos, state.posMax);\r\n    if (res.ok) {\r\n      href = state.md.normalizeLink(res.str);\r\n      if (state.md.validateLink(href)) {\r\n        pos = res.pos;\r\n      } else {\r\n        href = '';\r\n      }\r\n    }\r\n\r\n    // [link](  <href>  \"title\"  )\r\n    //                ^^ skipping these spaces\r\n    start = pos;\r\n    for (; pos < max; pos++) {\r\n      code = state.src.charCodeAt(pos);\r\n      if (code !== 0x20 && code !== 0x0A) { break; }\r\n    }\r\n\r\n    // [link](  <href>  \"title\"  )\r\n    //                  ^^^^^^^ parsing link title\r\n    res = parseLinkTitle(state.src, pos, state.posMax);\r\n    if (pos < max && start !== pos && res.ok) {\r\n      title = res.str;\r\n      pos = res.pos;\r\n\r\n      // [link](  <href>  \"title\"  )\r\n      //                         ^^ skipping these spaces\r\n      for (; pos < max; pos++) {\r\n        code = state.src.charCodeAt(pos);\r\n        if (code !== 0x20 && code !== 0x0A) { break; }\r\n      }\r\n    } else {\r\n      title = '';\r\n    }\r\n\r\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\r\n      state.pos = oldPos;\r\n      return false;\r\n    }\r\n    pos++;\r\n  } else {\r\n    //\r\n    // Link reference\r\n    //\r\n    if (typeof state.env.references === 'undefined') { return false; }\r\n\r\n    // [foo]  [bar]\r\n    //      ^^ optional whitespace (can include newlines)\r\n    for (; pos < max; pos++) {\r\n      code = state.src.charCodeAt(pos);\r\n      if (code !== 0x20 && code !== 0x0A) { break; }\r\n    }\r\n\r\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\r\n      start = pos + 1;\r\n      pos = parseLinkLabel(state, pos);\r\n      if (pos >= 0) {\r\n        label = state.src.slice(start, pos++);\r\n      } else {\r\n        pos = labelEnd + 1;\r\n      }\r\n    } else {\r\n      pos = labelEnd + 1;\r\n    }\r\n\r\n    // covers label === '' and label === undefined\r\n    // (collapsed reference link and shortcut reference link respectively)\r\n    if (!label) { label = state.src.slice(labelStart, labelEnd); }\r\n\r\n    ref = state.env.references[normalizeReference(label)];\r\n    if (!ref) {\r\n      state.pos = oldPos;\r\n      return false;\r\n    }\r\n    href = ref.href;\r\n    title = ref.title;\r\n  }\r\n\r\n  //\r\n  // We found the end of the link, and know for a fact it's a valid link;\r\n  // so all that's left to do is to call tokenizer.\r\n  //\r\n  if (!silent) {\r\n    state.pos = labelStart;\r\n    state.posMax = labelEnd;\r\n\r\n    token        = state.push('link_open', 'a', 1);\r\n    token.attrs  = attrs = [ [ 'href', href ] ];\r\n    if (title) {\r\n      attrs.push([ 'title', title ]);\r\n    }\r\n\r\n    state.md.inline.tokenize(state);\r\n\r\n    token        = state.push('link_close', 'a', -1);\r\n  }\r\n\r\n  state.pos = pos;\r\n  state.posMax = max;\r\n  return true;\r\n};\r\n\r\n},{\"../common/utils\":5,\"../helpers/parse_link_destination\":7,\"../helpers/parse_link_label\":8,\"../helpers/parse_link_title\":9}],46:[function(require,module,exports){\r\n// Proceess '\\n'\r\n\r\n'use strict';\r\n\r\nmodule.exports = function newline(state, silent) {\r\n  var pmax, max, pos = state.pos;\r\n\r\n  if (state.src.charCodeAt(pos) !== 0x0A/* \\n */) { return false; }\r\n\r\n  pmax = state.pending.length - 1;\r\n  max = state.posMax;\r\n\r\n  // '  \\n' -> hardbreak\r\n  // Lookup in pending chars is bad practice! Don't copy to other rules!\r\n  // Pending string is stored in concat mode, indexed lookups will cause\r\n  // convertion to flat mode.\r\n  if (!silent) {\r\n    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {\r\n      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {\r\n        state.pending = state.pending.replace(/ +$/, '');\r\n        state.push('hardbreak', 'br', 0);\r\n      } else {\r\n        state.pending = state.pending.slice(0, -1);\r\n        state.push('softbreak', 'br', 0);\r\n      }\r\n\r\n    } else {\r\n      state.push('softbreak', 'br', 0);\r\n    }\r\n  }\r\n\r\n  pos++;\r\n\r\n  // skip heading spaces for next line\r\n  while (pos < max && state.src.charCodeAt(pos) === 0x20) { pos++; }\r\n\r\n  state.pos = pos;\r\n  return true;\r\n};\r\n\r\n},{}],47:[function(require,module,exports){\r\n// Inline parser state\r\n\r\n'use strict';\r\n\r\n\r\nvar Token = require('../token');\r\n\r\nfunction StateInline(src, md, env, outTokens) {\r\n  this.src = src;\r\n  this.env = env;\r\n  this.md = md;\r\n  this.tokens = outTokens;\r\n\r\n  this.pos = 0;\r\n  this.posMax = this.src.length;\r\n  this.level = 0;\r\n  this.pending = '';\r\n  this.pendingLevel = 0;\r\n\r\n  this.cache = {};        // Stores { start: end } pairs. Useful for backtrack\r\n                          // optimization of pairs parse (emphasis, strikes).\r\n}\r\n\r\n\r\n// Flush pending text\r\n//\r\nStateInline.prototype.pushPending = function () {\r\n  var token = new Token('text', '', 0);\r\n  token.content = this.pending;\r\n  token.level = this.pendingLevel;\r\n  this.tokens.push(token);\r\n  this.pending = '';\r\n  return token;\r\n};\r\n\r\n\r\n// Push new token to \"stream\".\r\n// If pending text exists - flush it as text token\r\n//\r\nStateInline.prototype.push = function (type, tag, nesting) {\r\n  if (this.pending) {\r\n    this.pushPending();\r\n  }\r\n\r\n  var token = new Token(type, tag, nesting);\r\n\r\n  if (nesting < 0) { this.level--; }\r\n  token.level = this.level;\r\n  if (nesting > 0) { this.level++; }\r\n\r\n  this.pendingLevel = this.level;\r\n  this.tokens.push(token);\r\n  return token;\r\n};\r\n\r\n// re-export Token class to use in block rules\r\nStateInline.prototype.Token = Token;\r\n\r\n\r\nmodule.exports = StateInline;\r\n\r\n},{\"../token\":50}],48:[function(require,module,exports){\r\n// ~~strike through~~\r\n//\r\n'use strict';\r\n\r\n\r\nvar isWhiteSpace   = require('../common/utils').isWhiteSpace;\r\nvar isPunctChar    = require('../common/utils').isPunctChar;\r\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\r\n\r\n\r\n// parse sequence of markers,\r\n// \"start\" should point at a valid marker\r\nfunction scanDelims(state, start) {\r\n  var pos = start, lastChar, nextChar, count,\r\n      isLastWhiteSpace, isLastPunctChar,\r\n      isNextWhiteSpace, isNextPunctChar,\r\n      can_open = true,\r\n      can_close = true,\r\n      max = state.posMax,\r\n      marker = state.src.charCodeAt(start);\r\n\r\n  // treat beginning of the line as a whitespace\r\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : 0x20;\r\n\r\n  while (pos < max && state.src.charCodeAt(pos) === marker) { pos++; }\r\n\r\n  if (pos >= max) {\r\n    can_open = false;\r\n  }\r\n\r\n  count = pos - start;\r\n\r\n  // treat end of the line as a whitespace\r\n  nextChar = pos < max ? state.src.charCodeAt(pos) : 0x20;\r\n\r\n  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\r\n  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\r\n\r\n  isLastWhiteSpace = isWhiteSpace(lastChar);\r\n  isNextWhiteSpace = isWhiteSpace(nextChar);\r\n\r\n  if (isNextWhiteSpace) {\r\n    can_open = false;\r\n  } else if (isNextPunctChar) {\r\n    if (!(isLastWhiteSpace || isLastPunctChar)) {\r\n      can_open = false;\r\n    }\r\n  }\r\n\r\n  if (isLastWhiteSpace) {\r\n    can_close = false;\r\n  } else if (isLastPunctChar) {\r\n    if (!(isNextWhiteSpace || isNextPunctChar)) {\r\n      can_close = false;\r\n    }\r\n  }\r\n\r\n  return {\r\n    can_open: can_open,\r\n    can_close: can_close,\r\n    delims: count\r\n  };\r\n}\r\n\r\n\r\nmodule.exports = function strikethrough(state, silent) {\r\n  var startCount,\r\n      count,\r\n      tagCount,\r\n      found,\r\n      stack,\r\n      res,\r\n      token,\r\n      max = state.posMax,\r\n      start = state.pos,\r\n      marker = state.src.charCodeAt(start);\r\n\r\n  if (marker !== 0x7E/* ~ */) { return false; }\r\n  if (silent) { return false; } // don't run any pairs in validation mode\r\n\r\n  res = scanDelims(state, start);\r\n  startCount = res.delims;\r\n  if (!res.can_open) {\r\n    state.pos += startCount;\r\n    // Earlier we checked !silent, but this implementation does not need it\r\n    state.pending += state.src.slice(start, state.pos);\r\n    return true;\r\n  }\r\n\r\n  stack = Math.floor(startCount / 2);\r\n  if (stack <= 0) { return false; }\r\n  state.pos = start + startCount;\r\n\r\n  while (state.pos < max) {\r\n    if (state.src.charCodeAt(state.pos) === marker) {\r\n      res = scanDelims(state, state.pos);\r\n      count = res.delims;\r\n      tagCount = Math.floor(count / 2);\r\n      if (res.can_close) {\r\n        if (tagCount >= stack) {\r\n          state.pos += count - 2;\r\n          found = true;\r\n          break;\r\n        }\r\n        stack -= tagCount;\r\n        state.pos += count;\r\n        continue;\r\n      }\r\n\r\n      if (res.can_open) { stack += tagCount; }\r\n      state.pos += count;\r\n      continue;\r\n    }\r\n\r\n    state.md.inline.skipToken(state);\r\n  }\r\n\r\n  if (!found) {\r\n    // parser failed to find ending tag, so it's not valid emphasis\r\n    state.pos = start;\r\n    return false;\r\n  }\r\n\r\n  // found!\r\n  state.posMax = state.pos;\r\n  state.pos = start + 2;\r\n\r\n  // Earlier we checked !silent, but this implementation does not need it\r\n  token        = state.push('s_open', 's', 1);\r\n  token.markup = '~~';\r\n\r\n  state.md.inline.tokenize(state);\r\n\r\n  token        = state.push('s_close', 's', -1);\r\n  token.markup = '~~';\r\n\r\n  state.pos = state.posMax + 2;\r\n  state.posMax = max;\r\n  return true;\r\n};\r\n\r\n},{\"../common/utils\":5}],49:[function(require,module,exports){\r\n// Skip text characters for text token, place those to pending buffer\r\n// and increment current pos\r\n\r\n'use strict';\r\n\r\n\r\n// Rule to skip pure text\r\n// '{}$%@~+=:' reserved for extentions\r\n\r\n// !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\r\n\r\n// !!!! Don't confuse with \"Markdown ASCII Punctuation\" chars\r\n// http://spec.commonmark.org/0.15/#ascii-punctuation-character\r\nfunction isTerminatorChar(ch) {\r\n  switch (ch) {\r\n    case 0x0A/* \\n */:\r\n    case 0x21/* ! */:\r\n    case 0x23/* # */:\r\n    case 0x24/* $ */:\r\n    case 0x25/* % */:\r\n    case 0x26/* & */:\r\n    case 0x2A/* * */:\r\n    case 0x2B/* + */:\r\n    case 0x2D/* - */:\r\n    case 0x3A/* : */:\r\n    case 0x3C/* < */:\r\n    case 0x3D/* = */:\r\n    case 0x3E/* > */:\r\n    case 0x40/* @ */:\r\n    case 0x5B/* [ */:\r\n    case 0x5C/* \\ */:\r\n    case 0x5D/* ] */:\r\n    case 0x5E/* ^ */:\r\n    case 0x5F/* _ */:\r\n    case 0x60/* ` */:\r\n    case 0x7B/* { */:\r\n    case 0x7D/* } */:\r\n    case 0x7E/* ~ */:\r\n      return true;\r\n    default:\r\n      return false;\r\n  }\r\n}\r\n\r\nmodule.exports = function text(state, silent) {\r\n  var pos = state.pos;\r\n\r\n  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {\r\n    pos++;\r\n  }\r\n\r\n  if (pos === state.pos) { return false; }\r\n\r\n  if (!silent) { state.pending += state.src.slice(state.pos, pos); }\r\n\r\n  state.pos = pos;\r\n\r\n  return true;\r\n};\r\n\r\n// Alternative implementation, for memory.\r\n//\r\n// It costs 10% of performance, but allows extend terminators list, if place it\r\n// to `ParcerInline` property. Probably, will switch to it sometime, such\r\n// flexibility required.\r\n\r\n/*\r\nvar TERMINATOR_RE = /[\\n!#$%&*+\\-:<=>@[\\\\\\]^_`{}~]/;\r\n\r\nmodule.exports = function text(state, silent) {\r\n  var pos = state.pos,\r\n      idx = state.src.slice(pos).search(TERMINATOR_RE);\r\n\r\n  // first char is terminator -> empty text\r\n  if (idx === 0) { return false; }\r\n\r\n  // no terminator -> text till end of string\r\n  if (idx < 0) {\r\n    if (!silent) { state.pending += state.src.slice(pos); }\r\n    state.pos = state.src.length;\r\n    return true;\r\n  }\r\n\r\n  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }\r\n\r\n  state.pos += idx;\r\n\r\n  return true;\r\n};*/\r\n\r\n},{}],50:[function(require,module,exports){\r\n// Token class\r\n\r\n'use strict';\r\n\r\n\r\n/**\r\n * class Token\r\n **/\r\n\r\n/**\r\n * new Token(type, tag, nesting)\r\n *\r\n * Create new token and fill passed properties.\r\n **/\r\nfunction Token(type, tag, nesting) {\r\n  /**\r\n   * Token#type -> String\r\n   *\r\n   * Type of the token (string, e.g. \"paragraph_open\")\r\n   **/\r\n  this.type     = type;\r\n\r\n  /**\r\n   * Token#tag -> String\r\n   *\r\n   * html tag name, e.g. \"p\"\r\n   **/\r\n  this.tag      = tag;\r\n\r\n  /**\r\n   * Token#attrs -> Array\r\n   *\r\n   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`\r\n   **/\r\n  this.attrs    = null;\r\n\r\n  /**\r\n   * Token#map -> Array\r\n   *\r\n   * Source map info. Format: `[ line_begin, line_end ]`\r\n   **/\r\n  this.map      = null;\r\n\r\n  /**\r\n   * Token#nesting -> Number\r\n   *\r\n   * Level change (number in {-1, 0, 1} set), where:\r\n   *\r\n   * -  `1` means the tag is opening\r\n   * -  `0` means the tag is self-closing\r\n   * - `-1` means the tag is closing\r\n   **/\r\n  this.nesting  = nesting;\r\n\r\n  /**\r\n   * Token#level -> Number\r\n   *\r\n   * nesting level, the same as `state.level`\r\n   **/\r\n  this.level    = 0;\r\n\r\n  /**\r\n   * Token#children -> Array\r\n   *\r\n   * An array of child nodes (inline and img tokens)\r\n   **/\r\n  this.children = null;\r\n\r\n  /**\r\n   * Token#content -> String\r\n   *\r\n   * In a case of self-closing tag (code, html, fence, etc.),\r\n   * it has contents of this tag.\r\n   **/\r\n  this.content  = '';\r\n\r\n  /**\r\n   * Token#markup -> String\r\n   *\r\n   * '*' or '_' for emphasis, fence string for fence, etc.\r\n   **/\r\n  this.markup   = '';\r\n\r\n  /**\r\n   * Token#info -> String\r\n   *\r\n   * fence infostring\r\n   **/\r\n  this.info     = '';\r\n\r\n  /**\r\n   * Token#meta -> Object\r\n   *\r\n   * A place for plugins to store an arbitrary data\r\n   **/\r\n  this.meta     = null;\r\n\r\n  /**\r\n   * Token#block -> Boolean\r\n   *\r\n   * True for block-level tokens, false for inline tokens.\r\n   * Used in renderer to calculate line breaks\r\n   **/\r\n  this.block    = false;\r\n\r\n  /**\r\n   * Token#hidden -> Boolean\r\n   *\r\n   * If it's true, ignore this element when rendering. Used for tight lists\r\n   * to hide paragraphs.\r\n   **/\r\n  this.hidden   = false;\r\n}\r\n\r\n\r\n/**\r\n * Token.attrIndex(name) -> Number\r\n *\r\n * Search attribute index by name.\r\n **/\r\nToken.prototype.attrIndex = function attrIndex(name) {\r\n  var attrs, i, len;\r\n\r\n  if (!this.attrs) { return -1; }\r\n\r\n  attrs = this.attrs;\r\n\r\n  for (i = 0, len = attrs.length; i < len; i++) {\r\n    if (attrs[i][0] === name) { return i; }\r\n  }\r\n  return -1;\r\n};\r\n\r\n\r\n/**\r\n * Token.attrPush(attrData)\r\n *\r\n * Add `[ name, value ]` attribute to list. Init attrs if necessary\r\n **/\r\nToken.prototype.attrPush = function attrPush(attrData) {\r\n  if (this.attrs) {\r\n    this.attrs.push(attrData);\r\n  } else {\r\n    this.attrs = [ attrData ];\r\n  }\r\n};\r\n\r\n\r\nmodule.exports = Token;\r\n\r\n},{}],51:[function(require,module,exports){\r\n(function (global){\r\n/*! http://mths.be/punycode v1.2.4 by @mathias */\r\n;(function(root) {\r\n\r\n\t/** Detect free variables */\r\n\tvar freeExports = typeof exports == 'object' && exports;\r\n\tvar freeModule = typeof module == 'object' && module &&\r\n\t\tmodule.exports == freeExports && module;\r\n\tvar freeGlobal = typeof global == 'object' && global;\r\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\r\n\t\troot = freeGlobal;\r\n\t}\r\n\r\n\t/**\r\n\t * The `punycode` object.\r\n\t * @name punycode\r\n\t * @type Object\r\n\t */\r\n\tvar punycode,\r\n\r\n\t/** Highest positive signed 32-bit float value */\r\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\r\n\r\n\t/** Bootstring parameters */\r\n\tbase = 36,\r\n\ttMin = 1,\r\n\ttMax = 26,\r\n\tskew = 38,\r\n\tdamp = 700,\r\n\tinitialBias = 72,\r\n\tinitialN = 128, // 0x80\r\n\tdelimiter = '-', // '\\x2D'\r\n\r\n\t/** Regular expressions */\r\n\tregexPunycode = /^xn--/,\r\n\tregexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars\r\n\tregexSeparators = /\\x2E|\\u3002|\\uFF0E|\\uFF61/g, // RFC 3490 separators\r\n\r\n\t/** Error messages */\r\n\terrors = {\r\n\t\t'overflow': 'Overflow: input needs wider integers to process',\r\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\r\n\t\t'invalid-input': 'Invalid input'\r\n\t},\r\n\r\n\t/** Convenience shortcuts */\r\n\tbaseMinusTMin = base - tMin,\r\n\tfloor = Math.floor,\r\n\tstringFromCharCode = String.fromCharCode,\r\n\r\n\t/** Temporary variable */\r\n\tkey;\r\n\r\n\t/*--------------------------------------------------------------------------*/\r\n\r\n\t/**\r\n\t * A generic error utility function.\r\n\t * @private\r\n\t * @param {String} type The error type.\r\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\r\n\t */\r\n\tfunction error(type) {\r\n\t\tthrow RangeError(errors[type]);\r\n\t}\r\n\r\n\t/**\r\n\t * A generic `Array#map` utility function.\r\n\t * @private\r\n\t * @param {Array} array The array to iterate over.\r\n\t * @param {Function} callback The function that gets called for every array\r\n\t * item.\r\n\t * @returns {Array} A new array of values returned by the callback function.\r\n\t */\r\n\tfunction map(array, fn) {\r\n\t\tvar length = array.length;\r\n\t\twhile (length--) {\r\n\t\t\tarray[length] = fn(array[length]);\r\n\t\t}\r\n\t\treturn array;\r\n\t}\r\n\r\n\t/**\r\n\t * A simple `Array#map`-like wrapper to work with domain name strings.\r\n\t * @private\r\n\t * @param {String} domain The domain name.\r\n\t * @param {Function} callback The function that gets called for every\r\n\t * character.\r\n\t * @returns {Array} A new string of characters returned by the callback\r\n\t * function.\r\n\t */\r\n\tfunction mapDomain(string, fn) {\r\n\t\treturn map(string.split(regexSeparators), fn).join('.');\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an array containing the numeric code points of each Unicode\r\n\t * character in the string. While JavaScript uses UCS-2 internally,\r\n\t * this function will convert a pair of surrogate halves (each of which\r\n\t * UCS-2 exposes as separate characters) into a single code point,\r\n\t * matching UTF-16.\r\n\t * @see `punycode.ucs2.encode`\r\n\t * @see <http://mathiasbynens.be/notes/javascript-encoding>\r\n\t * @memberOf punycode.ucs2\r\n\t * @name decode\r\n\t * @param {String} string The Unicode input string (UCS-2).\r\n\t * @returns {Array} The new array of code points.\r\n\t */\r\n\tfunction ucs2decode(string) {\r\n\t\tvar output = [],\r\n\t\t    counter = 0,\r\n\t\t    length = string.length,\r\n\t\t    value,\r\n\t\t    extra;\r\n\t\twhile (counter < length) {\r\n\t\t\tvalue = string.charCodeAt(counter++);\r\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\r\n\t\t\t\t// high surrogate, and there is a next character\r\n\t\t\t\textra = string.charCodeAt(counter++);\r\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\r\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\r\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\r\n\t\t\t\t\toutput.push(value);\r\n\t\t\t\t\tcounter--;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\toutput.push(value);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn output;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a string based on an array of numeric code points.\r\n\t * @see `punycode.ucs2.decode`\r\n\t * @memberOf punycode.ucs2\r\n\t * @name encode\r\n\t * @param {Array} codePoints The array of numeric code points.\r\n\t * @returns {String} The new Unicode string (UCS-2).\r\n\t */\r\n\tfunction ucs2encode(array) {\r\n\t\treturn map(array, function(value) {\r\n\t\t\tvar output = '';\r\n\t\t\tif (value > 0xFFFF) {\r\n\t\t\t\tvalue -= 0x10000;\r\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\r\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\r\n\t\t\t}\r\n\t\t\toutput += stringFromCharCode(value);\r\n\t\t\treturn output;\r\n\t\t}).join('');\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a basic code point into a digit/integer.\r\n\t * @see `digitToBasic()`\r\n\t * @private\r\n\t * @param {Number} codePoint The basic numeric code point value.\r\n\t * @returns {Number} The numeric value of a basic code point (for use in\r\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\r\n\t * the code point does not represent a value.\r\n\t */\r\n\tfunction basicToDigit(codePoint) {\r\n\t\tif (codePoint - 48 < 10) {\r\n\t\t\treturn codePoint - 22;\r\n\t\t}\r\n\t\tif (codePoint - 65 < 26) {\r\n\t\t\treturn codePoint - 65;\r\n\t\t}\r\n\t\tif (codePoint - 97 < 26) {\r\n\t\t\treturn codePoint - 97;\r\n\t\t}\r\n\t\treturn base;\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a digit/integer into a basic code point.\r\n\t * @see `basicToDigit()`\r\n\t * @private\r\n\t * @param {Number} digit The numeric value of a basic code point.\r\n\t * @returns {Number} The basic code point whose value (when used for\r\n\t * representing integers) is `digit`, which needs to be in the range\r\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\r\n\t * used; else, the lowercase form is used. The behavior is undefined\r\n\t * if `flag` is non-zero and `digit` has no uppercase form.\r\n\t */\r\n\tfunction digitToBasic(digit, flag) {\r\n\t\t//  0..25 map to ASCII a..z or A..Z\r\n\t\t// 26..35 map to ASCII 0..9\r\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\r\n\t}\r\n\r\n\t/**\r\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\r\n\t * http://tools.ietf.org/html/rfc3492#section-3.4\r\n\t * @private\r\n\t */\r\n\tfunction adapt(delta, numPoints, firstTime) {\r\n\t\tvar k = 0;\r\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\r\n\t\tdelta += floor(delta / numPoints);\r\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\r\n\t\t\tdelta = floor(delta / baseMinusTMin);\r\n\t\t}\r\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\r\n\t * symbols.\r\n\t * @memberOf punycode\r\n\t * @param {String} input The Punycode string of ASCII-only symbols.\r\n\t * @returns {String} The resulting string of Unicode symbols.\r\n\t */\r\n\tfunction decode(input) {\r\n\t\t// Don't use UCS-2\r\n\t\tvar output = [],\r\n\t\t    inputLength = input.length,\r\n\t\t    out,\r\n\t\t    i = 0,\r\n\t\t    n = initialN,\r\n\t\t    bias = initialBias,\r\n\t\t    basic,\r\n\t\t    j,\r\n\t\t    index,\r\n\t\t    oldi,\r\n\t\t    w,\r\n\t\t    k,\r\n\t\t    digit,\r\n\t\t    t,\r\n\t\t    /** Cached calculation results */\r\n\t\t    baseMinusT;\r\n\r\n\t\t// Handle the basic code points: let `basic` be the number of input code\r\n\t\t// points before the last delimiter, or `0` if there is none, then copy\r\n\t\t// the first basic code points to the output.\r\n\r\n\t\tbasic = input.lastIndexOf(delimiter);\r\n\t\tif (basic < 0) {\r\n\t\t\tbasic = 0;\r\n\t\t}\r\n\r\n\t\tfor (j = 0; j < basic; ++j) {\r\n\t\t\t// if it's not a basic code point\r\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\r\n\t\t\t\terror('not-basic');\r\n\t\t\t}\r\n\t\t\toutput.push(input.charCodeAt(j));\r\n\t\t}\r\n\r\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\r\n\t\t// points were copied; start at the beginning otherwise.\r\n\r\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\r\n\r\n\t\t\t// `index` is the index of the next character to be consumed.\r\n\t\t\t// Decode a generalized variable-length integer into `delta`,\r\n\t\t\t// which gets added to `i`. The overflow checking is easier\r\n\t\t\t// if we increase `i` as we go, then subtract off its starting\r\n\t\t\t// value at the end to obtain `delta`.\r\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\r\n\r\n\t\t\t\tif (index >= inputLength) {\r\n\t\t\t\t\terror('invalid-input');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\r\n\r\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\r\n\t\t\t\t\terror('overflow');\r\n\t\t\t\t}\r\n\r\n\t\t\t\ti += digit * w;\r\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\r\n\r\n\t\t\t\tif (digit < t) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbaseMinusT = base - t;\r\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\r\n\t\t\t\t\terror('overflow');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tw *= baseMinusT;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tout = output.length + 1;\r\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\r\n\r\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\r\n\t\t\t// incrementing `n` each time, so we'll fix that now:\r\n\t\t\tif (floor(i / out) > maxInt - n) {\r\n\t\t\t\terror('overflow');\r\n\t\t\t}\r\n\r\n\t\t\tn += floor(i / out);\r\n\t\t\ti %= out;\r\n\r\n\t\t\t// Insert `n` at position `i` of the output\r\n\t\t\toutput.splice(i++, 0, n);\r\n\r\n\t\t}\r\n\r\n\t\treturn ucs2encode(output);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a string of Unicode symbols to a Punycode string of ASCII-only\r\n\t * symbols.\r\n\t * @memberOf punycode\r\n\t * @param {String} input The string of Unicode symbols.\r\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\r\n\t */\r\n\tfunction encode(input) {\r\n\t\tvar n,\r\n\t\t    delta,\r\n\t\t    handledCPCount,\r\n\t\t    basicLength,\r\n\t\t    bias,\r\n\t\t    j,\r\n\t\t    m,\r\n\t\t    q,\r\n\t\t    k,\r\n\t\t    t,\r\n\t\t    currentValue,\r\n\t\t    output = [],\r\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\r\n\t\t    inputLength,\r\n\t\t    /** Cached calculation results */\r\n\t\t    handledCPCountPlusOne,\r\n\t\t    baseMinusT,\r\n\t\t    qMinusT;\r\n\r\n\t\t// Convert the input in UCS-2 to Unicode\r\n\t\tinput = ucs2decode(input);\r\n\r\n\t\t// Cache the length\r\n\t\tinputLength = input.length;\r\n\r\n\t\t// Initialize the state\r\n\t\tn = initialN;\r\n\t\tdelta = 0;\r\n\t\tbias = initialBias;\r\n\r\n\t\t// Handle the basic code points\r\n\t\tfor (j = 0; j < inputLength; ++j) {\r\n\t\t\tcurrentValue = input[j];\r\n\t\t\tif (currentValue < 0x80) {\r\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thandledCPCount = basicLength = output.length;\r\n\r\n\t\t// `handledCPCount` is the number of code points that have been handled;\r\n\t\t// `basicLength` is the number of basic code points.\r\n\r\n\t\t// Finish the basic string - if it is not empty - with a delimiter\r\n\t\tif (basicLength) {\r\n\t\t\toutput.push(delimiter);\r\n\t\t}\r\n\r\n\t\t// Main encoding loop:\r\n\t\twhile (handledCPCount < inputLength) {\r\n\r\n\t\t\t// All non-basic code points < n have been handled already. Find the next\r\n\t\t\t// larger one:\r\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\r\n\t\t\t\tcurrentValue = input[j];\r\n\t\t\t\tif (currentValue >= n && currentValue < m) {\r\n\t\t\t\t\tm = currentValue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\r\n\t\t\t// but guard against overflow\r\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\r\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\r\n\t\t\t\terror('overflow');\r\n\t\t\t}\r\n\r\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\r\n\t\t\tn = m;\r\n\r\n\t\t\tfor (j = 0; j < inputLength; ++j) {\r\n\t\t\t\tcurrentValue = input[j];\r\n\r\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\r\n\t\t\t\t\terror('overflow');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (currentValue == n) {\r\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\r\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\r\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\r\n\t\t\t\t\t\tif (q < t) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tqMinusT = q - t;\r\n\t\t\t\t\t\tbaseMinusT = base - t;\r\n\t\t\t\t\t\toutput.push(\r\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\r\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\r\n\t\t\t\t\tdelta = 0;\r\n\t\t\t\t\t++handledCPCount;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t++delta;\r\n\t\t\t++n;\r\n\r\n\t\t}\r\n\t\treturn output.join('');\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a Punycode string representing a domain name to Unicode. Only the\r\n\t * Punycoded parts of the domain name will be converted, i.e. it doesn't\r\n\t * matter if you call it on a string that has already been converted to\r\n\t * Unicode.\r\n\t * @memberOf punycode\r\n\t * @param {String} domain The Punycode domain name to convert to Unicode.\r\n\t * @returns {String} The Unicode representation of the given Punycode\r\n\t * string.\r\n\t */\r\n\tfunction toUnicode(domain) {\r\n\t\treturn mapDomain(domain, function(string) {\r\n\t\t\treturn regexPunycode.test(string)\r\n\t\t\t\t? decode(string.slice(4).toLowerCase())\r\n\t\t\t\t: string;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a Unicode string representing a domain name to Punycode. Only the\r\n\t * non-ASCII parts of the domain name will be converted, i.e. it doesn't\r\n\t * matter if you call it with a domain that's already in ASCII.\r\n\t * @memberOf punycode\r\n\t * @param {String} domain The domain name to convert, as a Unicode string.\r\n\t * @returns {String} The Punycode representation of the given domain name.\r\n\t */\r\n\tfunction toASCII(domain) {\r\n\t\treturn mapDomain(domain, function(string) {\r\n\t\t\treturn regexNonASCII.test(string)\r\n\t\t\t\t? 'xn--' + encode(string)\r\n\t\t\t\t: string;\r\n\t\t});\r\n\t}\r\n\r\n\t/*--------------------------------------------------------------------------*/\r\n\r\n\t/** Define the public API */\r\n\tpunycode = {\r\n\t\t/**\r\n\t\t * A string representing the current Punycode.js version number.\r\n\t\t * @memberOf punycode\r\n\t\t * @type String\r\n\t\t */\r\n\t\t'version': '1.2.4',\r\n\t\t/**\r\n\t\t * An object of methods to convert from JavaScript's internal character\r\n\t\t * representation (UCS-2) to Unicode code points, and back.\r\n\t\t * @see <http://mathiasbynens.be/notes/javascript-encoding>\r\n\t\t * @memberOf punycode\r\n\t\t * @type Object\r\n\t\t */\r\n\t\t'ucs2': {\r\n\t\t\t'decode': ucs2decode,\r\n\t\t\t'encode': ucs2encode\r\n\t\t},\r\n\t\t'decode': decode,\r\n\t\t'encode': encode,\r\n\t\t'toASCII': toASCII,\r\n\t\t'toUnicode': toUnicode\r\n\t};\r\n\r\n\t/** Expose `punycode` */\r\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\r\n\t// like the following:\r\n\tif (\r\n\t\ttypeof define == 'function' &&\r\n\t\ttypeof define.amd == 'object' &&\r\n\t\tdefine.amd\r\n\t) {\r\n\t\tdefine('punycode', function() {\r\n\t\t\treturn punycode;\r\n\t\t});\r\n\t} else if (freeExports && !freeExports.nodeType) {\r\n\t\tif (freeModule) { // in Node.js or RingoJS v0.8.0+\r\n\t\t\tfreeModule.exports = punycode;\r\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\r\n\t\t\tfor (key in punycode) {\r\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\r\n\t\t\t}\r\n\t\t}\r\n\t} else { // in Rhino or a web browser\r\n\t\troot.punycode = punycode;\r\n\t}\r\n\r\n}(this));\r\n\r\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\r\n},{}],52:[function(require,module,exports){\r\nmodule.exports={\"Aacute\":\"\\u00C1\",\"aacute\":\"\\u00E1\",\"Abreve\":\"\\u0102\",\"abreve\":\"\\u0103\",\"ac\":\"\\u223E\",\"acd\":\"\\u223F\",\"acE\":\"\\u223E\\u0333\",\"Acirc\":\"\\u00C2\",\"acirc\":\"\\u00E2\",\"acute\":\"\\u00B4\",\"Acy\":\"\\u0410\",\"acy\":\"\\u0430\",\"AElig\":\"\\u00C6\",\"aelig\":\"\\u00E6\",\"af\":\"\\u2061\",\"Afr\":\"\\uD835\\uDD04\",\"afr\":\"\\uD835\\uDD1E\",\"Agrave\":\"\\u00C0\",\"agrave\":\"\\u00E0\",\"alefsym\":\"\\u2135\",\"aleph\":\"\\u2135\",\"Alpha\":\"\\u0391\",\"alpha\":\"\\u03B1\",\"Amacr\":\"\\u0100\",\"amacr\":\"\\u0101\",\"amalg\":\"\\u2A3F\",\"amp\":\"&\",\"AMP\":\"&\",\"andand\":\"\\u2A55\",\"And\":\"\\u2A53\",\"and\":\"\\u2227\",\"andd\":\"\\u2A5C\",\"andslope\":\"\\u2A58\",\"andv\":\"\\u2A5A\",\"ang\":\"\\u2220\",\"ange\":\"\\u29A4\",\"angle\":\"\\u2220\",\"angmsdaa\":\"\\u29A8\",\"angmsdab\":\"\\u29A9\",\"angmsdac\":\"\\u29AA\",\"angmsdad\":\"\\u29AB\",\"angmsdae\":\"\\u29AC\",\"angmsdaf\":\"\\u29AD\",\"angmsdag\":\"\\u29AE\",\"angmsdah\":\"\\u29AF\",\"angmsd\":\"\\u2221\",\"angrt\":\"\\u221F\",\"angrtvb\":\"\\u22BE\",\"angrtvbd\":\"\\u299D\",\"angsph\":\"\\u2222\",\"angst\":\"\\u00C5\",\"angzarr\":\"\\u237C\",\"Aogon\":\"\\u0104\",\"aogon\":\"\\u0105\",\"Aopf\":\"\\uD835\\uDD38\",\"aopf\":\"\\uD835\\uDD52\",\"apacir\":\"\\u2A6F\",\"ap\":\"\\u2248\",\"apE\":\"\\u2A70\",\"ape\":\"\\u224A\",\"apid\":\"\\u224B\",\"apos\":\"'\",\"ApplyFunction\":\"\\u2061\",\"approx\":\"\\u2248\",\"approxeq\":\"\\u224A\",\"Aring\":\"\\u00C5\",\"aring\":\"\\u00E5\",\"Ascr\":\"\\uD835\\uDC9C\",\"ascr\":\"\\uD835\\uDCB6\",\"Assign\":\"\\u2254\",\"ast\":\"*\",\"asymp\":\"\\u2248\",\"asympeq\":\"\\u224D\",\"Atilde\":\"\\u00C3\",\"atilde\":\"\\u00E3\",\"Auml\":\"\\u00C4\",\"auml\":\"\\u00E4\",\"awconint\":\"\\u2233\",\"awint\":\"\\u2A11\",\"backcong\":\"\\u224C\",\"backepsilon\":\"\\u03F6\",\"backprime\":\"\\u2035\",\"backsim\":\"\\u223D\",\"backsimeq\":\"\\u22CD\",\"Backslash\":\"\\u2216\",\"Barv\":\"\\u2AE7\",\"barvee\":\"\\u22BD\",\"barwed\":\"\\u2305\",\"Barwed\":\"\\u2306\",\"barwedge\":\"\\u2305\",\"bbrk\":\"\\u23B5\",\"bbrktbrk\":\"\\u23B6\",\"bcong\":\"\\u224C\",\"Bcy\":\"\\u0411\",\"bcy\":\"\\u0431\",\"bdquo\":\"\\u201E\",\"becaus\":\"\\u2235\",\"because\":\"\\u2235\",\"Because\":\"\\u2235\",\"bemptyv\":\"\\u29B0\",\"bepsi\":\"\\u03F6\",\"bernou\":\"\\u212C\",\"Bernoullis\":\"\\u212C\",\"Beta\":\"\\u0392\",\"beta\":\"\\u03B2\",\"beth\":\"\\u2136\",\"between\":\"\\u226C\",\"Bfr\":\"\\uD835\\uDD05\",\"bfr\":\"\\uD835\\uDD1F\",\"bigcap\":\"\\u22C2\",\"bigcirc\":\"\\u25EF\",\"bigcup\":\"\\u22C3\",\"bigodot\":\"\\u2A00\",\"bigoplus\":\"\\u2A01\",\"bigotimes\":\"\\u2A02\",\"bigsqcup\":\"\\u2A06\",\"bigstar\":\"\\u2605\",\"bigtriangledown\":\"\\u25BD\",\"bigtriangleup\":\"\\u25B3\",\"biguplus\":\"\\u2A04\",\"bigvee\":\"\\u22C1\",\"bigwedge\":\"\\u22C0\",\"bkarow\":\"\\u290D\",\"blacklozenge\":\"\\u29EB\",\"blacksquare\":\"\\u25AA\",\"blacktriangle\":\"\\u25B4\",\"blacktriangledown\":\"\\u25BE\",\"blacktriangleleft\":\"\\u25C2\",\"blacktriangleright\":\"\\u25B8\",\"blank\":\"\\u2423\",\"blk12\":\"\\u2592\",\"blk14\":\"\\u2591\",\"blk34\":\"\\u2593\",\"block\":\"\\u2588\",\"bne\":\"=\\u20E5\",\"bnequiv\":\"\\u2261\\u20E5\",\"bNot\":\"\\u2AED\",\"bnot\":\"\\u2310\",\"Bopf\":\"\\uD835\\uDD39\",\"bopf\":\"\\uD835\\uDD53\",\"bot\":\"\\u22A5\",\"bottom\":\"\\u22A5\",\"bowtie\":\"\\u22C8\",\"boxbox\":\"\\u29C9\",\"boxdl\":\"\\u2510\",\"boxdL\":\"\\u2555\",\"boxDl\":\"\\u2556\",\"boxDL\":\"\\u2557\",\"boxdr\":\"\\u250C\",\"boxdR\":\"\\u2552\",\"boxDr\":\"\\u2553\",\"boxDR\":\"\\u2554\",\"boxh\":\"\\u2500\",\"boxH\":\"\\u2550\",\"boxhd\":\"\\u252C\",\"boxHd\":\"\\u2564\",\"boxhD\":\"\\u2565\",\"boxHD\":\"\\u2566\",\"boxhu\":\"\\u2534\",\"boxHu\":\"\\u2567\",\"boxhU\":\"\\u2568\",\"boxHU\":\"\\u2569\",\"boxminus\":\"\\u229F\",\"boxplus\":\"\\u229E\",\"boxtimes\":\"\\u22A0\",\"boxul\":\"\\u2518\",\"boxuL\":\"\\u255B\",\"boxUl\":\"\\u255C\",\"boxUL\":\"\\u255D\",\"boxur\":\"\\u2514\",\"boxuR\":\"\\u2558\",\"boxUr\":\"\\u2559\",\"boxUR\":\"\\u255A\",\"boxv\":\"\\u2502\",\"boxV\":\"\\u2551\",\"boxvh\":\"\\u253C\",\"boxvH\":\"\\u256A\",\"boxVh\":\"\\u256B\",\"boxVH\":\"\\u256C\",\"boxvl\":\"\\u2524\",\"boxvL\":\"\\u2561\",\"boxVl\":\"\\u2562\",\"boxVL\":\"\\u2563\",\"boxvr\":\"\\u251C\",\"boxvR\":\"\\u255E\",\"boxVr\":\"\\u255F\",\"boxVR\":\"\\u2560\",\"bprime\":\"\\u2035\",\"breve\":\"\\u02D8\",\"Breve\":\"\\u02D8\",\"brvbar\":\"\\u00A6\",\"bscr\":\"\\uD835\\uDCB7\",\"Bscr\":\"\\u212C\",\"bsemi\":\"\\u204F\",\"bsim\":\"\\u223D\",\"bsime\":\"\\u22CD\",\"bsolb\":\"\\u29C5\",\"bsol\":\"\\\\\",\"bsolhsub\":\"\\u27C8\",\"bull\":\"\\u2022\",\"bullet\":\"\\u2022\",\"bump\":\"\\u224E\",\"bumpE\":\"\\u2AAE\",\"bumpe\":\"\\u224F\",\"Bumpeq\":\"\\u224E\",\"bumpeq\":\"\\u224F\",\"Cacute\":\"\\u0106\",\"cacute\":\"\\u0107\",\"capand\":\"\\u2A44\",\"capbrcup\":\"\\u2A49\",\"capcap\":\"\\u2A4B\",\"cap\":\"\\u2229\",\"Cap\":\"\\u22D2\",\"capcup\":\"\\u2A47\",\"capdot\":\"\\u2A40\",\"CapitalDifferentialD\":\"\\u2145\",\"caps\":\"\\u2229\\uFE00\",\"caret\":\"\\u2041\",\"caron\":\"\\u02C7\",\"Cayleys\":\"\\u212D\",\"ccaps\":\"\\u2A4D\",\"Ccaron\":\"\\u010C\",\"ccaron\":\"\\u010D\",\"Ccedil\":\"\\u00C7\",\"ccedil\":\"\\u00E7\",\"Ccirc\":\"\\u0108\",\"ccirc\":\"\\u0109\",\"Cconint\":\"\\u2230\",\"ccups\":\"\\u2A4C\",\"ccupssm\":\"\\u2A50\",\"Cdot\":\"\\u010A\",\"cdot\":\"\\u010B\",\"cedil\":\"\\u00B8\",\"Cedilla\":\"\\u00B8\",\"cemptyv\":\"\\u29B2\",\"cent\":\"\\u00A2\",\"centerdot\":\"\\u00B7\",\"CenterDot\":\"\\u00B7\",\"cfr\":\"\\uD835\\uDD20\",\"Cfr\":\"\\u212D\",\"CHcy\":\"\\u0427\",\"chcy\":\"\\u0447\",\"check\":\"\\u2713\",\"checkmark\":\"\\u2713\",\"Chi\":\"\\u03A7\",\"chi\":\"\\u03C7\",\"circ\":\"\\u02C6\",\"circeq\":\"\\u2257\",\"circlearrowleft\":\"\\u21BA\",\"circlearrowright\":\"\\u21BB\",\"circledast\":\"\\u229B\",\"circledcirc\":\"\\u229A\",\"circleddash\":\"\\u229D\",\"CircleDot\":\"\\u2299\",\"circledR\":\"\\u00AE\",\"circledS\":\"\\u24C8\",\"CircleMinus\":\"\\u2296\",\"CirclePlus\":\"\\u2295\",\"CircleTimes\":\"\\u2297\",\"cir\":\"\\u25CB\",\"cirE\":\"\\u29C3\",\"cire\":\"\\u2257\",\"cirfnint\":\"\\u2A10\",\"cirmid\":\"\\u2AEF\",\"cirscir\":\"\\u29C2\",\"ClockwiseContourIntegral\":\"\\u2232\",\"CloseCurlyDoubleQuote\":\"\\u201D\",\"CloseCurlyQuote\":\"\\u2019\",\"clubs\":\"\\u2663\",\"clubsuit\":\"\\u2663\",\"colon\":\":\",\"Colon\":\"\\u2237\",\"Colone\":\"\\u2A74\",\"colone\":\"\\u2254\",\"coloneq\":\"\\u2254\",\"comma\":\",\",\"commat\":\"@\",\"comp\":\"\\u2201\",\"compfn\":\"\\u2218\",\"complement\":\"\\u2201\",\"complexes\":\"\\u2102\",\"cong\":\"\\u2245\",\"congdot\":\"\\u2A6D\",\"Congruent\":\"\\u2261\",\"conint\":\"\\u222E\",\"Conint\":\"\\u222F\",\"ContourIntegral\":\"\\u222E\",\"copf\":\"\\uD835\\uDD54\",\"Copf\":\"\\u2102\",\"coprod\":\"\\u2210\",\"Coproduct\":\"\\u2210\",\"copy\":\"\\u00A9\",\"COPY\":\"\\u00A9\",\"copysr\":\"\\u2117\",\"CounterClockwiseContourIntegral\":\"\\u2233\",\"crarr\":\"\\u21B5\",\"cross\":\"\\u2717\",\"Cross\":\"\\u2A2F\",\"Cscr\":\"\\uD835\\uDC9E\",\"cscr\":\"\\uD835\\uDCB8\",\"csub\":\"\\u2ACF\",\"csube\":\"\\u2AD1\",\"csup\":\"\\u2AD0\",\"csupe\":\"\\u2AD2\",\"ctdot\":\"\\u22EF\",\"cudarrl\":\"\\u2938\",\"cudarrr\":\"\\u2935\",\"cuepr\":\"\\u22DE\",\"cuesc\":\"\\u22DF\",\"cularr\":\"\\u21B6\",\"cularrp\":\"\\u293D\",\"cupbrcap\":\"\\u2A48\",\"cupcap\":\"\\u2A46\",\"CupCap\":\"\\u224D\",\"cup\":\"\\u222A\",\"Cup\":\"\\u22D3\",\"cupcup\":\"\\u2A4A\",\"cupdot\":\"\\u228D\",\"cupor\":\"\\u2A45\",\"cups\":\"\\u222A\\uFE00\",\"curarr\":\"\\u21B7\",\"curarrm\":\"\\u293C\",\"curlyeqprec\":\"\\u22DE\",\"curlyeqsucc\":\"\\u22DF\",\"curlyvee\":\"\\u22CE\",\"curlywedge\":\"\\u22CF\",\"curren\":\"\\u00A4\",\"curvearrowleft\":\"\\u21B6\",\"curvearrowright\":\"\\u21B7\",\"cuvee\":\"\\u22CE\",\"cuwed\":\"\\u22CF\",\"cwconint\":\"\\u2232\",\"cwint\":\"\\u2231\",\"cylcty\":\"\\u232D\",\"dagger\":\"\\u2020\",\"Dagger\":\"\\u2021\",\"daleth\":\"\\u2138\",\"darr\":\"\\u2193\",\"Darr\":\"\\u21A1\",\"dArr\":\"\\u21D3\",\"dash\":\"\\u2010\",\"Dashv\":\"\\u2AE4\",\"dashv\":\"\\u22A3\",\"dbkarow\":\"\\u290F\",\"dblac\":\"\\u02DD\",\"Dcaron\":\"\\u010E\",\"dcaron\":\"\\u010F\",\"Dcy\":\"\\u0414\",\"dcy\":\"\\u0434\",\"ddagger\":\"\\u2021\",\"ddarr\":\"\\u21CA\",\"DD\":\"\\u2145\",\"dd\":\"\\u2146\",\"DDotrahd\":\"\\u2911\",\"ddotseq\":\"\\u2A77\",\"deg\":\"\\u00B0\",\"Del\":\"\\u2207\",\"Delta\":\"\\u0394\",\"delta\":\"\\u03B4\",\"demptyv\":\"\\u29B1\",\"dfisht\":\"\\u297F\",\"Dfr\":\"\\uD835\\uDD07\",\"dfr\":\"\\uD835\\uDD21\",\"dHar\":\"\\u2965\",\"dharl\":\"\\u21C3\",\"dharr\":\"\\u21C2\",\"DiacriticalAcute\":\"\\u00B4\",\"DiacriticalDot\":\"\\u02D9\",\"DiacriticalDoubleAcute\":\"\\u02DD\",\"DiacriticalGrave\":\"`\",\"DiacriticalTilde\":\"\\u02DC\",\"diam\":\"\\u22C4\",\"diamond\":\"\\u22C4\",\"Diamond\":\"\\u22C4\",\"diamondsuit\":\"\\u2666\",\"diams\":\"\\u2666\",\"die\":\"\\u00A8\",\"DifferentialD\":\"\\u2146\",\"digamma\":\"\\u03DD\",\"disin\":\"\\u22F2\",\"div\":\"\\u00F7\",\"divide\":\"\\u00F7\",\"divideontimes\":\"\\u22C7\",\"divonx\":\"\\u22C7\",\"DJcy\":\"\\u0402\",\"djcy\":\"\\u0452\",\"dlcorn\":\"\\u231E\",\"dlcrop\":\"\\u230D\",\"dollar\":\"$\",\"Dopf\":\"\\uD835\\uDD3B\",\"dopf\":\"\\uD835\\uDD55\",\"Dot\":\"\\u00A8\",\"dot\":\"\\u02D9\",\"DotDot\":\"\\u20DC\",\"doteq\":\"\\u2250\",\"doteqdot\":\"\\u2251\",\"DotEqual\":\"\\u2250\",\"dotminus\":\"\\u2238\",\"dotplus\":\"\\u2214\",\"dotsquare\":\"\\u22A1\",\"doublebarwedge\":\"\\u2306\",\"DoubleContourIntegral\":\"\\u222F\",\"DoubleDot\":\"\\u00A8\",\"DoubleDownArrow\":\"\\u21D3\",\"DoubleLeftArrow\":\"\\u21D0\",\"DoubleLeftRightArrow\":\"\\u21D4\",\"DoubleLeftTee\":\"\\u2AE4\",\"DoubleLongLeftArrow\":\"\\u27F8\",\"DoubleLongLeftRightArrow\":\"\\u27FA\",\"DoubleLongRightArrow\":\"\\u27F9\",\"DoubleRightArrow\":\"\\u21D2\",\"DoubleRightTee\":\"\\u22A8\",\"DoubleUpArrow\":\"\\u21D1\",\"DoubleUpDownArrow\":\"\\u21D5\",\"DoubleVerticalBar\":\"\\u2225\",\"DownArrowBar\":\"\\u2913\",\"downarrow\":\"\\u2193\",\"DownArrow\":\"\\u2193\",\"Downarrow\":\"\\u21D3\",\"DownArrowUpArrow\":\"\\u21F5\",\"DownBreve\":\"\\u0311\",\"downdownarrows\":\"\\u21CA\",\"downharpoonleft\":\"\\u21C3\",\"downharpoonright\":\"\\u21C2\",\"DownLeftRightVector\":\"\\u2950\",\"DownLeftTeeVector\":\"\\u295E\",\"DownLeftVectorBar\":\"\\u2956\",\"DownLeftVector\":\"\\u21BD\",\"DownRightTeeVector\":\"\\u295F\",\"DownRightVectorBar\":\"\\u2957\",\"DownRightVector\":\"\\u21C1\",\"DownTeeArrow\":\"\\u21A7\",\"DownTee\":\"\\u22A4\",\"drbkarow\":\"\\u2910\",\"drcorn\":\"\\u231F\",\"drcrop\":\"\\u230C\",\"Dscr\":\"\\uD835\\uDC9F\",\"dscr\":\"\\uD835\\uDCB9\",\"DScy\":\"\\u0405\",\"dscy\":\"\\u0455\",\"dsol\":\"\\u29F6\",\"Dstrok\":\"\\u0110\",\"dstrok\":\"\\u0111\",\"dtdot\":\"\\u22F1\",\"dtri\":\"\\u25BF\",\"dtrif\":\"\\u25BE\",\"duarr\":\"\\u21F5\",\"duhar\":\"\\u296F\",\"dwangle\":\"\\u29A6\",\"DZcy\":\"\\u040F\",\"dzcy\":\"\\u045F\",\"dzigrarr\":\"\\u27FF\",\"Eacute\":\"\\u00C9\",\"eacute\":\"\\u00E9\",\"easter\":\"\\u2A6E\",\"Ecaron\":\"\\u011A\",\"ecaron\":\"\\u011B\",\"Ecirc\":\"\\u00CA\",\"ecirc\":\"\\u00EA\",\"ecir\":\"\\u2256\",\"ecolon\":\"\\u2255\",\"Ecy\":\"\\u042D\",\"ecy\":\"\\u044D\",\"eDDot\":\"\\u2A77\",\"Edot\":\"\\u0116\",\"edot\":\"\\u0117\",\"eDot\":\"\\u2251\",\"ee\":\"\\u2147\",\"efDot\":\"\\u2252\",\"Efr\":\"\\uD835\\uDD08\",\"efr\":\"\\uD835\\uDD22\",\"eg\":\"\\u2A9A\",\"Egrave\":\"\\u00C8\",\"egrave\":\"\\u00E8\",\"egs\":\"\\u2A96\",\"egsdot\":\"\\u2A98\",\"el\":\"\\u2A99\",\"Element\":\"\\u2208\",\"elinters\":\"\\u23E7\",\"ell\":\"\\u2113\",\"els\":\"\\u2A95\",\"elsdot\":\"\\u2A97\",\"Emacr\":\"\\u0112\",\"emacr\":\"\\u0113\",\"empty\":\"\\u2205\",\"emptyset\":\"\\u2205\",\"EmptySmallSquare\":\"\\u25FB\",\"emptyv\":\"\\u2205\",\"EmptyVerySmallSquare\":\"\\u25AB\",\"emsp13\":\"\\u2004\",\"emsp14\":\"\\u2005\",\"emsp\":\"\\u2003\",\"ENG\":\"\\u014A\",\"eng\":\"\\u014B\",\"ensp\":\"\\u2002\",\"Eogon\":\"\\u0118\",\"eogon\":\"\\u0119\",\"Eopf\":\"\\uD835\\uDD3C\",\"eopf\":\"\\uD835\\uDD56\",\"epar\":\"\\u22D5\",\"eparsl\":\"\\u29E3\",\"eplus\":\"\\u2A71\",\"epsi\":\"\\u03B5\",\"Epsilon\":\"\\u0395\",\"epsilon\":\"\\u03B5\",\"epsiv\":\"\\u03F5\",\"eqcirc\":\"\\u2256\",\"eqcolon\":\"\\u2255\",\"eqsim\":\"\\u2242\",\"eqslantgtr\":\"\\u2A96\",\"eqslantless\":\"\\u2A95\",\"Equal\":\"\\u2A75\",\"equals\":\"=\",\"EqualTilde\":\"\\u2242\",\"equest\":\"\\u225F\",\"Equilibrium\":\"\\u21CC\",\"equiv\":\"\\u2261\",\"equivDD\":\"\\u2A78\",\"eqvparsl\":\"\\u29E5\",\"erarr\":\"\\u2971\",\"erDot\":\"\\u2253\",\"escr\":\"\\u212F\",\"Escr\":\"\\u2130\",\"esdot\":\"\\u2250\",\"Esim\":\"\\u2A73\",\"esim\":\"\\u2242\",\"Eta\":\"\\u0397\",\"eta\":\"\\u03B7\",\"ETH\":\"\\u00D0\",\"eth\":\"\\u00F0\",\"Euml\":\"\\u00CB\",\"euml\":\"\\u00EB\",\"euro\":\"\\u20AC\",\"excl\":\"!\",\"exist\":\"\\u2203\",\"Exists\":\"\\u2203\",\"expectation\":\"\\u2130\",\"exponentiale\":\"\\u2147\",\"ExponentialE\":\"\\u2147\",\"fallingdotseq\":\"\\u2252\",\"Fcy\":\"\\u0424\",\"fcy\":\"\\u0444\",\"female\":\"\\u2640\",\"ffilig\":\"\\uFB03\",\"fflig\":\"\\uFB00\",\"ffllig\":\"\\uFB04\",\"Ffr\":\"\\uD835\\uDD09\",\"ffr\":\"\\uD835\\uDD23\",\"filig\":\"\\uFB01\",\"FilledSmallSquare\":\"\\u25FC\",\"FilledVerySmallSquare\":\"\\u25AA\",\"fjlig\":\"fj\",\"flat\":\"\\u266D\",\"fllig\":\"\\uFB02\",\"fltns\":\"\\u25B1\",\"fnof\":\"\\u0192\",\"Fopf\":\"\\uD835\\uDD3D\",\"fopf\":\"\\uD835\\uDD57\",\"forall\":\"\\u2200\",\"ForAll\":\"\\u2200\",\"fork\":\"\\u22D4\",\"forkv\":\"\\u2AD9\",\"Fouriertrf\":\"\\u2131\",\"fpartint\":\"\\u2A0D\",\"frac12\":\"\\u00BD\",\"frac13\":\"\\u2153\",\"frac14\":\"\\u00BC\",\"frac15\":\"\\u2155\",\"frac16\":\"\\u2159\",\"frac18\":\"\\u215B\",\"frac23\":\"\\u2154\",\"frac25\":\"\\u2156\",\"frac34\":\"\\u00BE\",\"frac35\":\"\\u2157\",\"frac38\":\"\\u215C\",\"frac45\":\"\\u2158\",\"frac56\":\"\\u215A\",\"frac58\":\"\\u215D\",\"frac78\":\"\\u215E\",\"frasl\":\"\\u2044\",\"frown\":\"\\u2322\",\"fscr\":\"\\uD835\\uDCBB\",\"Fscr\":\"\\u2131\",\"gacute\":\"\\u01F5\",\"Gamma\":\"\\u0393\",\"gamma\":\"\\u03B3\",\"Gammad\":\"\\u03DC\",\"gammad\":\"\\u03DD\",\"gap\":\"\\u2A86\",\"Gbreve\":\"\\u011E\",\"gbreve\":\"\\u011F\",\"Gcedil\":\"\\u0122\",\"Gcirc\":\"\\u011C\",\"gcirc\":\"\\u011D\",\"Gcy\":\"\\u0413\",\"gcy\":\"\\u0433\",\"Gdot\":\"\\u0120\",\"gdot\":\"\\u0121\",\"ge\":\"\\u2265\",\"gE\":\"\\u2267\",\"gEl\":\"\\u2A8C\",\"gel\":\"\\u22DB\",\"geq\":\"\\u2265\",\"geqq\":\"\\u2267\",\"geqslant\":\"\\u2A7E\",\"gescc\":\"\\u2AA9\",\"ges\":\"\\u2A7E\",\"gesdot\":\"\\u2A80\",\"gesdoto\":\"\\u2A82\",\"gesdotol\":\"\\u2A84\",\"gesl\":\"\\u22DB\\uFE00\",\"gesles\":\"\\u2A94\",\"Gfr\":\"\\uD835\\uDD0A\",\"gfr\":\"\\uD835\\uDD24\",\"gg\":\"\\u226B\",\"Gg\":\"\\u22D9\",\"ggg\":\"\\u22D9\",\"gimel\":\"\\u2137\",\"GJcy\":\"\\u0403\",\"gjcy\":\"\\u0453\",\"gla\":\"\\u2AA5\",\"gl\":\"\\u2277\",\"glE\":\"\\u2A92\",\"glj\":\"\\u2AA4\",\"gnap\":\"\\u2A8A\",\"gnapprox\":\"\\u2A8A\",\"gne\":\"\\u2A88\",\"gnE\":\"\\u2269\",\"gneq\":\"\\u2A88\",\"gneqq\":\"\\u2269\",\"gnsim\":\"\\u22E7\",\"Gopf\":\"\\uD835\\uDD3E\",\"gopf\":\"\\uD835\\uDD58\",\"grave\":\"`\",\"GreaterEqual\":\"\\u2265\",\"GreaterEqualLess\":\"\\u22DB\",\"GreaterFullEqual\":\"\\u2267\",\"GreaterGreater\":\"\\u2AA2\",\"GreaterLess\":\"\\u2277\",\"GreaterSlantEqual\":\"\\u2A7E\",\"GreaterTilde\":\"\\u2273\",\"Gscr\":\"\\uD835\\uDCA2\",\"gscr\":\"\\u210A\",\"gsim\":\"\\u2273\",\"gsime\":\"\\u2A8E\",\"gsiml\":\"\\u2A90\",\"gtcc\":\"\\u2AA7\",\"gtcir\":\"\\u2A7A\",\"gt\":\">\",\"GT\":\">\",\"Gt\":\"\\u226B\",\"gtdot\":\"\\u22D7\",\"gtlPar\":\"\\u2995\",\"gtquest\":\"\\u2A7C\",\"gtrapprox\":\"\\u2A86\",\"gtrarr\":\"\\u2978\",\"gtrdot\":\"\\u22D7\",\"gtreqless\":\"\\u22DB\",\"gtreqqless\":\"\\u2A8C\",\"gtrless\":\"\\u2277\",\"gtrsim\":\"\\u2273\",\"gvertneqq\":\"\\u2269\\uFE00\",\"gvnE\":\"\\u2269\\uFE00\",\"Hacek\":\"\\u02C7\",\"hairsp\":\"\\u200A\",\"half\":\"\\u00BD\",\"hamilt\":\"\\u210B\",\"HARDcy\":\"\\u042A\",\"hardcy\":\"\\u044A\",\"harrcir\":\"\\u2948\",\"harr\":\"\\u2194\",\"hArr\":\"\\u21D4\",\"harrw\":\"\\u21AD\",\"Hat\":\"^\",\"hbar\":\"\\u210F\",\"Hcirc\":\"\\u0124\",\"hcirc\":\"\\u0125\",\"hearts\":\"\\u2665\",\"heartsuit\":\"\\u2665\",\"hellip\":\"\\u2026\",\"hercon\":\"\\u22B9\",\"hfr\":\"\\uD835\\uDD25\",\"Hfr\":\"\\u210C\",\"HilbertSpace\":\"\\u210B\",\"hksearow\":\"\\u2925\",\"hkswarow\":\"\\u2926\",\"hoarr\":\"\\u21FF\",\"homtht\":\"\\u223B\",\"hookleftarrow\":\"\\u21A9\",\"hookrightarrow\":\"\\u21AA\",\"hopf\":\"\\uD835\\uDD59\",\"Hopf\":\"\\u210D\",\"horbar\":\"\\u2015\",\"HorizontalLine\":\"\\u2500\",\"hscr\":\"\\uD835\\uDCBD\",\"Hscr\":\"\\u210B\",\"hslash\":\"\\u210F\",\"Hstrok\":\"\\u0126\",\"hstrok\":\"\\u0127\",\"HumpDownHump\":\"\\u224E\",\"HumpEqual\":\"\\u224F\",\"hybull\":\"\\u2043\",\"hyphen\":\"\\u2010\",\"Iacute\":\"\\u00CD\",\"iacute\":\"\\u00ED\",\"ic\":\"\\u2063\",\"Icirc\":\"\\u00CE\",\"icirc\":\"\\u00EE\",\"Icy\":\"\\u0418\",\"icy\":\"\\u0438\",\"Idot\":\"\\u0130\",\"IEcy\":\"\\u0415\",\"iecy\":\"\\u0435\",\"iexcl\":\"\\u00A1\",\"iff\":\"\\u21D4\",\"ifr\":\"\\uD835\\uDD26\",\"Ifr\":\"\\u2111\",\"Igrave\":\"\\u00CC\",\"igrave\":\"\\u00EC\",\"ii\":\"\\u2148\",\"iiiint\":\"\\u2A0C\",\"iiint\":\"\\u222D\",\"iinfin\":\"\\u29DC\",\"iiota\":\"\\u2129\",\"IJlig\":\"\\u0132\",\"ijlig\":\"\\u0133\",\"Imacr\":\"\\u012A\",\"imacr\":\"\\u012B\",\"image\":\"\\u2111\",\"ImaginaryI\":\"\\u2148\",\"imagline\":\"\\u2110\",\"imagpart\":\"\\u2111\",\"imath\":\"\\u0131\",\"Im\":\"\\u2111\",\"imof\":\"\\u22B7\",\"imped\":\"\\u01B5\",\"Implies\":\"\\u21D2\",\"incare\":\"\\u2105\",\"in\":\"\\u2208\",\"infin\":\"\\u221E\",\"infintie\":\"\\u29DD\",\"inodot\":\"\\u0131\",\"intcal\":\"\\u22BA\",\"int\":\"\\u222B\",\"Int\":\"\\u222C\",\"integers\":\"\\u2124\",\"Integral\":\"\\u222B\",\"intercal\":\"\\u22BA\",\"Intersection\":\"\\u22C2\",\"intlarhk\":\"\\u2A17\",\"intprod\":\"\\u2A3C\",\"InvisibleComma\":\"\\u2063\",\"InvisibleTimes\":\"\\u2062\",\"IOcy\":\"\\u0401\",\"iocy\":\"\\u0451\",\"Iogon\":\"\\u012E\",\"iogon\":\"\\u012F\",\"Iopf\":\"\\uD835\\uDD40\",\"iopf\":\"\\uD835\\uDD5A\",\"Iota\":\"\\u0399\",\"iota\":\"\\u03B9\",\"iprod\":\"\\u2A3C\",\"iquest\":\"\\u00BF\",\"iscr\":\"\\uD835\\uDCBE\",\"Iscr\":\"\\u2110\",\"isin\":\"\\u2208\",\"isindot\":\"\\u22F5\",\"isinE\":\"\\u22F9\",\"isins\":\"\\u22F4\",\"isinsv\":\"\\u22F3\",\"isinv\":\"\\u2208\",\"it\":\"\\u2062\",\"Itilde\":\"\\u0128\",\"itilde\":\"\\u0129\",\"Iukcy\":\"\\u0406\",\"iukcy\":\"\\u0456\",\"Iuml\":\"\\u00CF\",\"iuml\":\"\\u00EF\",\"Jcirc\":\"\\u0134\",\"jcirc\":\"\\u0135\",\"Jcy\":\"\\u0419\",\"jcy\":\"\\u0439\",\"Jfr\":\"\\uD835\\uDD0D\",\"jfr\":\"\\uD835\\uDD27\",\"jmath\":\"\\u0237\",\"Jopf\":\"\\uD835\\uDD41\",\"jopf\":\"\\uD835\\uDD5B\",\"Jscr\":\"\\uD835\\uDCA5\",\"jscr\":\"\\uD835\\uDCBF\",\"Jsercy\":\"\\u0408\",\"jsercy\":\"\\u0458\",\"Jukcy\":\"\\u0404\",\"jukcy\":\"\\u0454\",\"Kappa\":\"\\u039A\",\"kappa\":\"\\u03BA\",\"kappav\":\"\\u03F0\",\"Kcedil\":\"\\u0136\",\"kcedil\":\"\\u0137\",\"Kcy\":\"\\u041A\",\"kcy\":\"\\u043A\",\"Kfr\":\"\\uD835\\uDD0E\",\"kfr\":\"\\uD835\\uDD28\",\"kgreen\":\"\\u0138\",\"KHcy\":\"\\u0425\",\"khcy\":\"\\u0445\",\"KJcy\":\"\\u040C\",\"kjcy\":\"\\u045C\",\"Kopf\":\"\\uD835\\uDD42\",\"kopf\":\"\\uD835\\uDD5C\",\"Kscr\":\"\\uD835\\uDCA6\",\"kscr\":\"\\uD835\\uDCC0\",\"lAarr\":\"\\u21DA\",\"Lacute\":\"\\u0139\",\"lacute\":\"\\u013A\",\"laemptyv\":\"\\u29B4\",\"lagran\":\"\\u2112\",\"Lambda\":\"\\u039B\",\"lambda\":\"\\u03BB\",\"lang\":\"\\u27E8\",\"Lang\":\"\\u27EA\",\"langd\":\"\\u2991\",\"langle\":\"\\u27E8\",\"lap\":\"\\u2A85\",\"Laplacetrf\":\"\\u2112\",\"laquo\":\"\\u00AB\",\"larrb\":\"\\u21E4\",\"larrbfs\":\"\\u291F\",\"larr\":\"\\u2190\",\"Larr\":\"\\u219E\",\"lArr\":\"\\u21D0\",\"larrfs\":\"\\u291D\",\"larrhk\":\"\\u21A9\",\"larrlp\":\"\\u21AB\",\"larrpl\":\"\\u2939\",\"larrsim\":\"\\u2973\",\"larrtl\":\"\\u21A2\",\"latail\":\"\\u2919\",\"lAtail\":\"\\u291B\",\"lat\":\"\\u2AAB\",\"late\":\"\\u2AAD\",\"lates\":\"\\u2AAD\\uFE00\",\"lbarr\":\"\\u290C\",\"lBarr\":\"\\u290E\",\"lbbrk\":\"\\u2772\",\"lbrace\":\"{\",\"lbrack\":\"[\",\"lbrke\":\"\\u298B\",\"lbrksld\":\"\\u298F\",\"lbrkslu\":\"\\u298D\",\"Lcaron\":\"\\u013D\",\"lcaron\":\"\\u013E\",\"Lcedil\":\"\\u013B\",\"lcedil\":\"\\u013C\",\"lceil\":\"\\u2308\",\"lcub\":\"{\",\"Lcy\":\"\\u041B\",\"lcy\":\"\\u043B\",\"ldca\":\"\\u2936\",\"ldquo\":\"\\u201C\",\"ldquor\":\"\\u201E\",\"ldrdhar\":\"\\u2967\",\"ldrushar\":\"\\u294B\",\"ldsh\":\"\\u21B2\",\"le\":\"\\u2264\",\"lE\":\"\\u2266\",\"LeftAngleBracket\":\"\\u27E8\",\"LeftArrowBar\":\"\\u21E4\",\"leftarrow\":\"\\u2190\",\"LeftArrow\":\"\\u2190\",\"Leftarrow\":\"\\u21D0\",\"LeftArrowRightArrow\":\"\\u21C6\",\"leftarrowtail\":\"\\u21A2\",\"LeftCeiling\":\"\\u2308\",\"LeftDoubleBracket\":\"\\u27E6\",\"LeftDownTeeVector\":\"\\u2961\",\"LeftDownVectorBar\":\"\\u2959\",\"LeftDownVector\":\"\\u21C3\",\"LeftFloor\":\"\\u230A\",\"leftharpoondown\":\"\\u21BD\",\"leftharpoonup\":\"\\u21BC\",\"leftleftarrows\":\"\\u21C7\",\"leftrightarrow\":\"\\u2194\",\"LeftRightArrow\":\"\\u2194\",\"Leftrightarrow\":\"\\u21D4\",\"leftrightarrows\":\"\\u21C6\",\"leftrightharpoons\":\"\\u21CB\",\"leftrightsquigarrow\":\"\\u21AD\",\"LeftRightVector\":\"\\u294E\",\"LeftTeeArrow\":\"\\u21A4\",\"LeftTee\":\"\\u22A3\",\"LeftTeeVector\":\"\\u295A\",\"leftthreetimes\":\"\\u22CB\",\"LeftTriangleBar\":\"\\u29CF\",\"LeftTriangle\":\"\\u22B2\",\"LeftTriangleEqual\":\"\\u22B4\",\"LeftUpDownVector\":\"\\u2951\",\"LeftUpTeeVector\":\"\\u2960\",\"LeftUpVectorBar\":\"\\u2958\",\"LeftUpVector\":\"\\u21BF\",\"LeftVectorBar\":\"\\u2952\",\"LeftVector\":\"\\u21BC\",\"lEg\":\"\\u2A8B\",\"leg\":\"\\u22DA\",\"leq\":\"\\u2264\",\"leqq\":\"\\u2266\",\"leqslant\":\"\\u2A7D\",\"lescc\":\"\\u2AA8\",\"les\":\"\\u2A7D\",\"lesdot\":\"\\u2A7F\",\"lesdoto\":\"\\u2A81\",\"lesdotor\":\"\\u2A83\",\"lesg\":\"\\u22DA\\uFE00\",\"lesges\":\"\\u2A93\",\"lessapprox\":\"\\u2A85\",\"lessdot\":\"\\u22D6\",\"lesseqgtr\":\"\\u22DA\",\"lesseqqgtr\":\"\\u2A8B\",\"LessEqualGreater\":\"\\u22DA\",\"LessFullEqual\":\"\\u2266\",\"LessGreater\":\"\\u2276\",\"lessgtr\":\"\\u2276\",\"LessLess\":\"\\u2AA1\",\"lesssim\":\"\\u2272\",\"LessSlantEqual\":\"\\u2A7D\",\"LessTilde\":\"\\u2272\",\"lfisht\":\"\\u297C\",\"lfloor\":\"\\u230A\",\"Lfr\":\"\\uD835\\uDD0F\",\"lfr\":\"\\uD835\\uDD29\",\"lg\":\"\\u2276\",\"lgE\":\"\\u2A91\",\"lHar\":\"\\u2962\",\"lhard\":\"\\u21BD\",\"lharu\":\"\\u21BC\",\"lharul\":\"\\u296A\",\"lhblk\":\"\\u2584\",\"LJcy\":\"\\u0409\",\"ljcy\":\"\\u0459\",\"llarr\":\"\\u21C7\",\"ll\":\"\\u226A\",\"Ll\":\"\\u22D8\",\"llcorner\":\"\\u231E\",\"Lleftarrow\":\"\\u21DA\",\"llhard\":\"\\u296B\",\"lltri\":\"\\u25FA\",\"Lmidot\":\"\\u013F\",\"lmidot\":\"\\u0140\",\"lmoustache\":\"\\u23B0\",\"lmoust\":\"\\u23B0\",\"lnap\":\"\\u2A89\",\"lnapprox\":\"\\u2A89\",\"lne\":\"\\u2A87\",\"lnE\":\"\\u2268\",\"lneq\":\"\\u2A87\",\"lneqq\":\"\\u2268\",\"lnsim\":\"\\u22E6\",\"loang\":\"\\u27EC\",\"loarr\":\"\\u21FD\",\"lobrk\":\"\\u27E6\",\"longleftarrow\":\"\\u27F5\",\"LongLeftArrow\":\"\\u27F5\",\"Longleftarrow\":\"\\u27F8\",\"longleftrightarrow\":\"\\u27F7\",\"LongLeftRightArrow\":\"\\u27F7\",\"Longleftrightarrow\":\"\\u27FA\",\"longmapsto\":\"\\u27FC\",\"longrightarrow\":\"\\u27F6\",\"LongRightArrow\":\"\\u27F6\",\"Longrightarrow\":\"\\u27F9\",\"looparrowleft\":\"\\u21AB\",\"looparrowright\":\"\\u21AC\",\"lopar\":\"\\u2985\",\"Lopf\":\"\\uD835\\uDD43\",\"lopf\":\"\\uD835\\uDD5D\",\"loplus\":\"\\u2A2D\",\"lotimes\":\"\\u2A34\",\"lowast\":\"\\u2217\",\"lowbar\":\"_\",\"LowerLeftArrow\":\"\\u2199\",\"LowerRightArrow\":\"\\u2198\",\"loz\":\"\\u25CA\",\"lozenge\":\"\\u25CA\",\"lozf\":\"\\u29EB\",\"lpar\":\"(\",\"lparlt\":\"\\u2993\",\"lrarr\":\"\\u21C6\",\"lrcorner\":\"\\u231F\",\"lrhar\":\"\\u21CB\",\"lrhard\":\"\\u296D\",\"lrm\":\"\\u200E\",\"lrtri\":\"\\u22BF\",\"lsaquo\":\"\\u2039\",\"lscr\":\"\\uD835\\uDCC1\",\"Lscr\":\"\\u2112\",\"lsh\":\"\\u21B0\",\"Lsh\":\"\\u21B0\",\"lsim\":\"\\u2272\",\"lsime\":\"\\u2A8D\",\"lsimg\":\"\\u2A8F\",\"lsqb\":\"[\",\"lsquo\":\"\\u2018\",\"lsquor\":\"\\u201A\",\"Lstrok\":\"\\u0141\",\"lstrok\":\"\\u0142\",\"ltcc\":\"\\u2AA6\",\"ltcir\":\"\\u2A79\",\"lt\":\"<\",\"LT\":\"<\",\"Lt\":\"\\u226A\",\"ltdot\":\"\\u22D6\",\"lthree\":\"\\u22CB\",\"ltimes\":\"\\u22C9\",\"ltlarr\":\"\\u2976\",\"ltquest\":\"\\u2A7B\",\"ltri\":\"\\u25C3\",\"ltrie\":\"\\u22B4\",\"ltrif\":\"\\u25C2\",\"ltrPar\":\"\\u2996\",\"lurdshar\":\"\\u294A\",\"luruhar\":\"\\u2966\",\"lvertneqq\":\"\\u2268\\uFE00\",\"lvnE\":\"\\u2268\\uFE00\",\"macr\":\"\\u00AF\",\"male\":\"\\u2642\",\"malt\":\"\\u2720\",\"maltese\":\"\\u2720\",\"Map\":\"\\u2905\",\"map\":\"\\u21A6\",\"mapsto\":\"\\u21A6\",\"mapstodown\":\"\\u21A7\",\"mapstoleft\":\"\\u21A4\",\"mapstoup\":\"\\u21A5\",\"marker\":\"\\u25AE\",\"mcomma\":\"\\u2A29\",\"Mcy\":\"\\u041C\",\"mcy\":\"\\u043C\",\"mdash\":\"\\u2014\",\"mDDot\":\"\\u223A\",\"measuredangle\":\"\\u2221\",\"MediumSpace\":\"\\u205F\",\"Mellintrf\":\"\\u2133\",\"Mfr\":\"\\uD835\\uDD10\",\"mfr\":\"\\uD835\\uDD2A\",\"mho\":\"\\u2127\",\"micro\":\"\\u00B5\",\"midast\":\"*\",\"midcir\":\"\\u2AF0\",\"mid\":\"\\u2223\",\"middot\":\"\\u00B7\",\"minusb\":\"\\u229F\",\"minus\":\"\\u2212\",\"minusd\":\"\\u2238\",\"minusdu\":\"\\u2A2A\",\"MinusPlus\":\"\\u2213\",\"mlcp\":\"\\u2ADB\",\"mldr\":\"\\u2026\",\"mnplus\":\"\\u2213\",\"models\":\"\\u22A7\",\"Mopf\":\"\\uD835\\uDD44\",\"mopf\":\"\\uD835\\uDD5E\",\"mp\":\"\\u2213\",\"mscr\":\"\\uD835\\uDCC2\",\"Mscr\":\"\\u2133\",\"mstpos\":\"\\u223E\",\"Mu\":\"\\u039C\",\"mu\":\"\\u03BC\",\"multimap\":\"\\u22B8\",\"mumap\":\"\\u22B8\",\"nabla\":\"\\u2207\",\"Nacute\":\"\\u0143\",\"nacute\":\"\\u0144\",\"nang\":\"\\u2220\\u20D2\",\"nap\":\"\\u2249\",\"napE\":\"\\u2A70\\u0338\",\"napid\":\"\\u224B\\u0338\",\"napos\":\"\\u0149\",\"napprox\":\"\\u2249\",\"natural\":\"\\u266E\",\"naturals\":\"\\u2115\",\"natur\":\"\\u266E\",\"nbsp\":\"\\u00A0\",\"nbump\":\"\\u224E\\u0338\",\"nbumpe\":\"\\u224F\\u0338\",\"ncap\":\"\\u2A43\",\"Ncaron\":\"\\u0147\",\"ncaron\":\"\\u0148\",\"Ncedil\":\"\\u0145\",\"ncedil\":\"\\u0146\",\"ncong\":\"\\u2247\",\"ncongdot\":\"\\u2A6D\\u0338\",\"ncup\":\"\\u2A42\",\"Ncy\":\"\\u041D\",\"ncy\":\"\\u043D\",\"ndash\":\"\\u2013\",\"nearhk\":\"\\u2924\",\"nearr\":\"\\u2197\",\"neArr\":\"\\u21D7\",\"nearrow\":\"\\u2197\",\"ne\":\"\\u2260\",\"nedot\":\"\\u2250\\u0338\",\"NegativeMediumSpace\":\"\\u200B\",\"NegativeThickSpace\":\"\\u200B\",\"NegativeThinSpace\":\"\\u200B\",\"NegativeVeryThinSpace\":\"\\u200B\",\"nequiv\":\"\\u2262\",\"nesear\":\"\\u2928\",\"nesim\":\"\\u2242\\u0338\",\"NestedGreaterGreater\":\"\\u226B\",\"NestedLessLess\":\"\\u226A\",\"NewLine\":\"\\n\",\"nexist\":\"\\u2204\",\"nexists\":\"\\u2204\",\"Nfr\":\"\\uD835\\uDD11\",\"nfr\":\"\\uD835\\uDD2B\",\"ngE\":\"\\u2267\\u0338\",\"nge\":\"\\u2271\",\"ngeq\":\"\\u2271\",\"ngeqq\":\"\\u2267\\u0338\",\"ngeqslant\":\"\\u2A7E\\u0338\",\"nges\":\"\\u2A7E\\u0338\",\"nGg\":\"\\u22D9\\u0338\",\"ngsim\":\"\\u2275\",\"nGt\":\"\\u226B\\u20D2\",\"ngt\":\"\\u226F\",\"ngtr\":\"\\u226F\",\"nGtv\":\"\\u226B\\u0338\",\"nharr\":\"\\u21AE\",\"nhArr\":\"\\u21CE\",\"nhpar\":\"\\u2AF2\",\"ni\":\"\\u220B\",\"nis\":\"\\u22FC\",\"nisd\":\"\\u22FA\",\"niv\":\"\\u220B\",\"NJcy\":\"\\u040A\",\"njcy\":\"\\u045A\",\"nlarr\":\"\\u219A\",\"nlArr\":\"\\u21CD\",\"nldr\":\"\\u2025\",\"nlE\":\"\\u2266\\u0338\",\"nle\":\"\\u2270\",\"nleftarrow\":\"\\u219A\",\"nLeftarrow\":\"\\u21CD\",\"nleftrightarrow\":\"\\u21AE\",\"nLeftrightarrow\":\"\\u21CE\",\"nleq\":\"\\u2270\",\"nleqq\":\"\\u2266\\u0338\",\"nleqslant\":\"\\u2A7D\\u0338\",\"nles\":\"\\u2A7D\\u0338\",\"nless\":\"\\u226E\",\"nLl\":\"\\u22D8\\u0338\",\"nlsim\":\"\\u2274\",\"nLt\":\"\\u226A\\u20D2\",\"nlt\":\"\\u226E\",\"nltri\":\"\\u22EA\",\"nltrie\":\"\\u22EC\",\"nLtv\":\"\\u226A\\u0338\",\"nmid\":\"\\u2224\",\"NoBreak\":\"\\u2060\",\"NonBreakingSpace\":\"\\u00A0\",\"nopf\":\"\\uD835\\uDD5F\",\"Nopf\":\"\\u2115\",\"Not\":\"\\u2AEC\",\"not\":\"\\u00AC\",\"NotCongruent\":\"\\u2262\",\"NotCupCap\":\"\\u226D\",\"NotDoubleVerticalBar\":\"\\u2226\",\"NotElement\":\"\\u2209\",\"NotEqual\":\"\\u2260\",\"NotEqualTilde\":\"\\u2242\\u0338\",\"NotExists\":\"\\u2204\",\"NotGreater\":\"\\u226F\",\"NotGreaterEqual\":\"\\u2271\",\"NotGreaterFullEqual\":\"\\u2267\\u0338\",\"NotGreaterGreater\":\"\\u226B\\u0338\",\"NotGreaterLess\":\"\\u2279\",\"NotGreaterSlantEqual\":\"\\u2A7E\\u0338\",\"NotGreaterTilde\":\"\\u2275\",\"NotHumpDownHump\":\"\\u224E\\u0338\",\"NotHumpEqual\":\"\\u224F\\u0338\",\"notin\":\"\\u2209\",\"notindot\":\"\\u22F5\\u0338\",\"notinE\":\"\\u22F9\\u0338\",\"notinva\":\"\\u2209\",\"notinvb\":\"\\u22F7\",\"notinvc\":\"\\u22F6\",\"NotLeftTriangleBar\":\"\\u29CF\\u0338\",\"NotLeftTriangle\":\"\\u22EA\",\"NotLeftTriangleEqual\":\"\\u22EC\",\"NotLess\":\"\\u226E\",\"NotLessEqual\":\"\\u2270\",\"NotLessGreater\":\"\\u2278\",\"NotLessLess\":\"\\u226A\\u0338\",\"NotLessSlantEqual\":\"\\u2A7D\\u0338\",\"NotLessTilde\":\"\\u2274\",\"NotNestedGreaterGreater\":\"\\u2AA2\\u0338\",\"NotNestedLessLess\":\"\\u2AA1\\u0338\",\"notni\":\"\\u220C\",\"notniva\":\"\\u220C\",\"notnivb\":\"\\u22FE\",\"notnivc\":\"\\u22FD\",\"NotPrecedes\":\"\\u2280\",\"NotPrecedesEqual\":\"\\u2AAF\\u0338\",\"NotPrecedesSlantEqual\":\"\\u22E0\",\"NotReverseElement\":\"\\u220C\",\"NotRightTriangleBar\":\"\\u29D0\\u0338\",\"NotRightTriangle\":\"\\u22EB\",\"NotRightTriangleEqual\":\"\\u22ED\",\"NotSquareSubset\":\"\\u228F\\u0338\",\"NotSquareSubsetEqual\":\"\\u22E2\",\"NotSquareSuperset\":\"\\u2290\\u0338\",\"NotSquareSupersetEqual\":\"\\u22E3\",\"NotSubset\":\"\\u2282\\u20D2\",\"NotSubsetEqual\":\"\\u2288\",\"NotSucceeds\":\"\\u2281\",\"NotSucceedsEqual\":\"\\u2AB0\\u0338\",\"NotSucceedsSlantEqual\":\"\\u22E1\",\"NotSucceedsTilde\":\"\\u227F\\u0338\",\"NotSuperset\":\"\\u2283\\u20D2\",\"NotSupersetEqual\":\"\\u2289\",\"NotTilde\":\"\\u2241\",\"NotTildeEqual\":\"\\u2244\",\"NotTildeFullEqual\":\"\\u2247\",\"NotTildeTilde\":\"\\u2249\",\"NotVerticalBar\":\"\\u2224\",\"nparallel\":\"\\u2226\",\"npar\":\"\\u2226\",\"nparsl\":\"\\u2AFD\\u20E5\",\"npart\":\"\\u2202\\u0338\",\"npolint\":\"\\u2A14\",\"npr\":\"\\u2280\",\"nprcue\":\"\\u22E0\",\"nprec\":\"\\u2280\",\"npreceq\":\"\\u2AAF\\u0338\",\"npre\":\"\\u2AAF\\u0338\",\"nrarrc\":\"\\u2933\\u0338\",\"nrarr\":\"\\u219B\",\"nrArr\":\"\\u21CF\",\"nrarrw\":\"\\u219D\\u0338\",\"nrightarrow\":\"\\u219B\",\"nRightarrow\":\"\\u21CF\",\"nrtri\":\"\\u22EB\",\"nrtrie\":\"\\u22ED\",\"nsc\":\"\\u2281\",\"nsccue\":\"\\u22E1\",\"nsce\":\"\\u2AB0\\u0338\",\"Nscr\":\"\\uD835\\uDCA9\",\"nscr\":\"\\uD835\\uDCC3\",\"nshortmid\":\"\\u2224\",\"nshortparallel\":\"\\u2226\",\"nsim\":\"\\u2241\",\"nsime\":\"\\u2244\",\"nsimeq\":\"\\u2244\",\"nsmid\":\"\\u2224\",\"nspar\":\"\\u2226\",\"nsqsube\":\"\\u22E2\",\"nsqsupe\":\"\\u22E3\",\"nsub\":\"\\u2284\",\"nsubE\":\"\\u2AC5\\u0338\",\"nsube\":\"\\u2288\",\"nsubset\":\"\\u2282\\u20D2\",\"nsubseteq\":\"\\u2288\",\"nsubseteqq\":\"\\u2AC5\\u0338\",\"nsucc\":\"\\u2281\",\"nsucceq\":\"\\u2AB0\\u0338\",\"nsup\":\"\\u2285\",\"nsupE\":\"\\u2AC6\\u0338\",\"nsupe\":\"\\u2289\",\"nsupset\":\"\\u2283\\u20D2\",\"nsupseteq\":\"\\u2289\",\"nsupseteqq\":\"\\u2AC6\\u0338\",\"ntgl\":\"\\u2279\",\"Ntilde\":\"\\u00D1\",\"ntilde\":\"\\u00F1\",\"ntlg\":\"\\u2278\",\"ntriangleleft\":\"\\u22EA\",\"ntrianglelefteq\":\"\\u22EC\",\"ntriangleright\":\"\\u22EB\",\"ntrianglerighteq\":\"\\u22ED\",\"Nu\":\"\\u039D\",\"nu\":\"\\u03BD\",\"num\":\"#\",\"numero\":\"\\u2116\",\"numsp\":\"\\u2007\",\"nvap\":\"\\u224D\\u20D2\",\"nvdash\":\"\\u22AC\",\"nvDash\":\"\\u22AD\",\"nVdash\":\"\\u22AE\",\"nVDash\":\"\\u22AF\",\"nvge\":\"\\u2265\\u20D2\",\"nvgt\":\">\\u20D2\",\"nvHarr\":\"\\u2904\",\"nvinfin\":\"\\u29DE\",\"nvlArr\":\"\\u2902\",\"nvle\":\"\\u2264\\u20D2\",\"nvlt\":\"<\\u20D2\",\"nvltrie\":\"\\u22B4\\u20D2\",\"nvrArr\":\"\\u2903\",\"nvrtrie\":\"\\u22B5\\u20D2\",\"nvsim\":\"\\u223C\\u20D2\",\"nwarhk\":\"\\u2923\",\"nwarr\":\"\\u2196\",\"nwArr\":\"\\u21D6\",\"nwarrow\":\"\\u2196\",\"nwnear\":\"\\u2927\",\"Oacute\":\"\\u00D3\",\"oacute\":\"\\u00F3\",\"oast\":\"\\u229B\",\"Ocirc\":\"\\u00D4\",\"ocirc\":\"\\u00F4\",\"ocir\":\"\\u229A\",\"Ocy\":\"\\u041E\",\"ocy\":\"\\u043E\",\"odash\":\"\\u229D\",\"Odblac\":\"\\u0150\",\"odblac\":\"\\u0151\",\"odiv\":\"\\u2A38\",\"odot\":\"\\u2299\",\"odsold\":\"\\u29BC\",\"OElig\":\"\\u0152\",\"oelig\":\"\\u0153\",\"ofcir\":\"\\u29BF\",\"Ofr\":\"\\uD835\\uDD12\",\"ofr\":\"\\uD835\\uDD2C\",\"ogon\":\"\\u02DB\",\"Ograve\":\"\\u00D2\",\"ograve\":\"\\u00F2\",\"ogt\":\"\\u29C1\",\"ohbar\":\"\\u29B5\",\"ohm\":\"\\u03A9\",\"oint\":\"\\u222E\",\"olarr\":\"\\u21BA\",\"olcir\":\"\\u29BE\",\"olcross\":\"\\u29BB\",\"oline\":\"\\u203E\",\"olt\":\"\\u29C0\",\"Omacr\":\"\\u014C\",\"omacr\":\"\\u014D\",\"Omega\":\"\\u03A9\",\"omega\":\"\\u03C9\",\"Omicron\":\"\\u039F\",\"omicron\":\"\\u03BF\",\"omid\":\"\\u29B6\",\"ominus\":\"\\u2296\",\"Oopf\":\"\\uD835\\uDD46\",\"oopf\":\"\\uD835\\uDD60\",\"opar\":\"\\u29B7\",\"OpenCurlyDoubleQuote\":\"\\u201C\",\"OpenCurlyQuote\":\"\\u2018\",\"operp\":\"\\u29B9\",\"oplus\":\"\\u2295\",\"orarr\":\"\\u21BB\",\"Or\":\"\\u2A54\",\"or\":\"\\u2228\",\"ord\":\"\\u2A5D\",\"order\":\"\\u2134\",\"orderof\":\"\\u2134\",\"ordf\":\"\\u00AA\",\"ordm\":\"\\u00BA\",\"origof\":\"\\u22B6\",\"oror\":\"\\u2A56\",\"orslope\":\"\\u2A57\",\"orv\":\"\\u2A5B\",\"oS\":\"\\u24C8\",\"Oscr\":\"\\uD835\\uDCAA\",\"oscr\":\"\\u2134\",\"Oslash\":\"\\u00D8\",\"oslash\":\"\\u00F8\",\"osol\":\"\\u2298\",\"Otilde\":\"\\u00D5\",\"otilde\":\"\\u00F5\",\"otimesas\":\"\\u2A36\",\"Otimes\":\"\\u2A37\",\"otimes\":\"\\u2297\",\"Ouml\":\"\\u00D6\",\"ouml\":\"\\u00F6\",\"ovbar\":\"\\u233D\",\"OverBar\":\"\\u203E\",\"OverBrace\":\"\\u23DE\",\"OverBracket\":\"\\u23B4\",\"OverParenthesis\":\"\\u23DC\",\"para\":\"\\u00B6\",\"parallel\":\"\\u2225\",\"par\":\"\\u2225\",\"parsim\":\"\\u2AF3\",\"parsl\":\"\\u2AFD\",\"part\":\"\\u2202\",\"PartialD\":\"\\u2202\",\"Pcy\":\"\\u041F\",\"pcy\":\"\\u043F\",\"percnt\":\"%\",\"period\":\".\",\"permil\":\"\\u2030\",\"perp\":\"\\u22A5\",\"pertenk\":\"\\u2031\",\"Pfr\":\"\\uD835\\uDD13\",\"pfr\":\"\\uD835\\uDD2D\",\"Phi\":\"\\u03A6\",\"phi\":\"\\u03C6\",\"phiv\":\"\\u03D5\",\"phmmat\":\"\\u2133\",\"phone\":\"\\u260E\",\"Pi\":\"\\u03A0\",\"pi\":\"\\u03C0\",\"pitchfork\":\"\\u22D4\",\"piv\":\"\\u03D6\",\"planck\":\"\\u210F\",\"planckh\":\"\\u210E\",\"plankv\":\"\\u210F\",\"plusacir\":\"\\u2A23\",\"plusb\":\"\\u229E\",\"pluscir\":\"\\u2A22\",\"plus\":\"+\",\"plusdo\":\"\\u2214\",\"plusdu\":\"\\u2A25\",\"pluse\":\"\\u2A72\",\"PlusMinus\":\"\\u00B1\",\"plusmn\":\"\\u00B1\",\"plussim\":\"\\u2A26\",\"plustwo\":\"\\u2A27\",\"pm\":\"\\u00B1\",\"Poincareplane\":\"\\u210C\",\"pointint\":\"\\u2A15\",\"popf\":\"\\uD835\\uDD61\",\"Popf\":\"\\u2119\",\"pound\":\"\\u00A3\",\"prap\":\"\\u2AB7\",\"Pr\":\"\\u2ABB\",\"pr\":\"\\u227A\",\"prcue\":\"\\u227C\",\"precapprox\":\"\\u2AB7\",\"prec\":\"\\u227A\",\"preccurlyeq\":\"\\u227C\",\"Precedes\":\"\\u227A\",\"PrecedesEqual\":\"\\u2AAF\",\"PrecedesSlantEqual\":\"\\u227C\",\"PrecedesTilde\":\"\\u227E\",\"preceq\":\"\\u2AAF\",\"precnapprox\":\"\\u2AB9\",\"precneqq\":\"\\u2AB5\",\"precnsim\":\"\\u22E8\",\"pre\":\"\\u2AAF\",\"prE\":\"\\u2AB3\",\"precsim\":\"\\u227E\",\"prime\":\"\\u2032\",\"Prime\":\"\\u2033\",\"primes\":\"\\u2119\",\"prnap\":\"\\u2AB9\",\"prnE\":\"\\u2AB5\",\"prnsim\":\"\\u22E8\",\"prod\":\"\\u220F\",\"Product\":\"\\u220F\",\"profalar\":\"\\u232E\",\"profline\":\"\\u2312\",\"profsurf\":\"\\u2313\",\"prop\":\"\\u221D\",\"Proportional\":\"\\u221D\",\"Proportion\":\"\\u2237\",\"propto\":\"\\u221D\",\"prsim\":\"\\u227E\",\"prurel\":\"\\u22B0\",\"Pscr\":\"\\uD835\\uDCAB\",\"pscr\":\"\\uD835\\uDCC5\",\"Psi\":\"\\u03A8\",\"psi\":\"\\u03C8\",\"puncsp\":\"\\u2008\",\"Qfr\":\"\\uD835\\uDD14\",\"qfr\":\"\\uD835\\uDD2E\",\"qint\":\"\\u2A0C\",\"qopf\":\"\\uD835\\uDD62\",\"Qopf\":\"\\u211A\",\"qprime\":\"\\u2057\",\"Qscr\":\"\\uD835\\uDCAC\",\"qscr\":\"\\uD835\\uDCC6\",\"quaternions\":\"\\u210D\",\"quatint\":\"\\u2A16\",\"quest\":\"?\",\"questeq\":\"\\u225F\",\"quot\":\"\\\"\",\"QUOT\":\"\\\"\",\"rAarr\":\"\\u21DB\",\"race\":\"\\u223D\\u0331\",\"Racute\":\"\\u0154\",\"racute\":\"\\u0155\",\"radic\":\"\\u221A\",\"raemptyv\":\"\\u29B3\",\"rang\":\"\\u27E9\",\"Rang\":\"\\u27EB\",\"rangd\":\"\\u2992\",\"range\":\"\\u29A5\",\"rangle\":\"\\u27E9\",\"raquo\":\"\\u00BB\",\"rarrap\":\"\\u2975\",\"rarrb\":\"\\u21E5\",\"rarrbfs\":\"\\u2920\",\"rarrc\":\"\\u2933\",\"rarr\":\"\\u2192\",\"Rarr\":\"\\u21A0\",\"rArr\":\"\\u21D2\",\"rarrfs\":\"\\u291E\",\"rarrhk\":\"\\u21AA\",\"rarrlp\":\"\\u21AC\",\"rarrpl\":\"\\u2945\",\"rarrsim\":\"\\u2974\",\"Rarrtl\":\"\\u2916\",\"rarrtl\":\"\\u21A3\",\"rarrw\":\"\\u219D\",\"ratail\":\"\\u291A\",\"rAtail\":\"\\u291C\",\"ratio\":\"\\u2236\",\"rationals\":\"\\u211A\",\"rbarr\":\"\\u290D\",\"rBarr\":\"\\u290F\",\"RBarr\":\"\\u2910\",\"rbbrk\":\"\\u2773\",\"rbrace\":\"}\",\"rbrack\":\"]\",\"rbrke\":\"\\u298C\",\"rbrksld\":\"\\u298E\",\"rbrkslu\":\"\\u2990\",\"Rcaron\":\"\\u0158\",\"rcaron\":\"\\u0159\",\"Rcedil\":\"\\u0156\",\"rcedil\":\"\\u0157\",\"rceil\":\"\\u2309\",\"rcub\":\"}\",\"Rcy\":\"\\u0420\",\"rcy\":\"\\u0440\",\"rdca\":\"\\u2937\",\"rdldhar\":\"\\u2969\",\"rdquo\":\"\\u201D\",\"rdquor\":\"\\u201D\",\"rdsh\":\"\\u21B3\",\"real\":\"\\u211C\",\"realine\":\"\\u211B\",\"realpart\":\"\\u211C\",\"reals\":\"\\u211D\",\"Re\":\"\\u211C\",\"rect\":\"\\u25AD\",\"reg\":\"\\u00AE\",\"REG\":\"\\u00AE\",\"ReverseElement\":\"\\u220B\",\"ReverseEquilibrium\":\"\\u21CB\",\"ReverseUpEquilibrium\":\"\\u296F\",\"rfisht\":\"\\u297D\",\"rfloor\":\"\\u230B\",\"rfr\":\"\\uD835\\uDD2F\",\"Rfr\":\"\\u211C\",\"rHar\":\"\\u2964\",\"rhard\":\"\\u21C1\",\"rharu\":\"\\u21C0\",\"rharul\":\"\\u296C\",\"Rho\":\"\\u03A1\",\"rho\":\"\\u03C1\",\"rhov\":\"\\u03F1\",\"RightAngleBracket\":\"\\u27E9\",\"RightArrowBar\":\"\\u21E5\",\"rightarrow\":\"\\u2192\",\"RightArrow\":\"\\u2192\",\"Rightarrow\":\"\\u21D2\",\"RightArrowLeftArrow\":\"\\u21C4\",\"rightarrowtail\":\"\\u21A3\",\"RightCeiling\":\"\\u2309\",\"RightDoubleBracket\":\"\\u27E7\",\"RightDownTeeVector\":\"\\u295D\",\"RightDownVectorBar\":\"\\u2955\",\"RightDownVector\":\"\\u21C2\",\"RightFloor\":\"\\u230B\",\"rightharpoondown\":\"\\u21C1\",\"rightharpoonup\":\"\\u21C0\",\"rightleftarrows\":\"\\u21C4\",\"rightleftharpoons\":\"\\u21CC\",\"rightrightarrows\":\"\\u21C9\",\"rightsquigarrow\":\"\\u219D\",\"RightTeeArrow\":\"\\u21A6\",\"RightTee\":\"\\u22A2\",\"RightTeeVector\":\"\\u295B\",\"rightthreetimes\":\"\\u22CC\",\"RightTriangleBar\":\"\\u29D0\",\"RightTriangle\":\"\\u22B3\",\"RightTriangleEqual\":\"\\u22B5\",\"RightUpDownVector\":\"\\u294F\",\"RightUpTeeVector\":\"\\u295C\",\"RightUpVectorBar\":\"\\u2954\",\"RightUpVector\":\"\\u21BE\",\"RightVectorBar\":\"\\u2953\",\"RightVector\":\"\\u21C0\",\"ring\":\"\\u02DA\",\"risingdotseq\":\"\\u2253\",\"rlarr\":\"\\u21C4\",\"rlhar\":\"\\u21CC\",\"rlm\":\"\\u200F\",\"rmoustache\":\"\\u23B1\",\"rmoust\":\"\\u23B1\",\"rnmid\":\"\\u2AEE\",\"roang\":\"\\u27ED\",\"roarr\":\"\\u21FE\",\"robrk\":\"\\u27E7\",\"ropar\":\"\\u2986\",\"ropf\":\"\\uD835\\uDD63\",\"Ropf\":\"\\u211D\",\"roplus\":\"\\u2A2E\",\"rotimes\":\"\\u2A35\",\"RoundImplies\":\"\\u2970\",\"rpar\":\")\",\"rpargt\":\"\\u2994\",\"rppolint\":\"\\u2A12\",\"rrarr\":\"\\u21C9\",\"Rrightarrow\":\"\\u21DB\",\"rsaquo\":\"\\u203A\",\"rscr\":\"\\uD835\\uDCC7\",\"Rscr\":\"\\u211B\",\"rsh\":\"\\u21B1\",\"Rsh\":\"\\u21B1\",\"rsqb\":\"]\",\"rsquo\":\"\\u2019\",\"rsquor\":\"\\u2019\",\"rthree\":\"\\u22CC\",\"rtimes\":\"\\u22CA\",\"rtri\":\"\\u25B9\",\"rtrie\":\"\\u22B5\",\"rtrif\":\"\\u25B8\",\"rtriltri\":\"\\u29CE\",\"RuleDelayed\":\"\\u29F4\",\"ruluhar\":\"\\u2968\",\"rx\":\"\\u211E\",\"Sacute\":\"\\u015A\",\"sacute\":\"\\u015B\",\"sbquo\":\"\\u201A\",\"scap\":\"\\u2AB8\",\"Scaron\":\"\\u0160\",\"scaron\":\"\\u0161\",\"Sc\":\"\\u2ABC\",\"sc\":\"\\u227B\",\"sccue\":\"\\u227D\",\"sce\":\"\\u2AB0\",\"scE\":\"\\u2AB4\",\"Scedil\":\"\\u015E\",\"scedil\":\"\\u015F\",\"Scirc\":\"\\u015C\",\"scirc\":\"\\u015D\",\"scnap\":\"\\u2ABA\",\"scnE\":\"\\u2AB6\",\"scnsim\":\"\\u22E9\",\"scpolint\":\"\\u2A13\",\"scsim\":\"\\u227F\",\"Scy\":\"\\u0421\",\"scy\":\"\\u0441\",\"sdotb\":\"\\u22A1\",\"sdot\":\"\\u22C5\",\"sdote\":\"\\u2A66\",\"searhk\":\"\\u2925\",\"searr\":\"\\u2198\",\"seArr\":\"\\u21D8\",\"searrow\":\"\\u2198\",\"sect\":\"\\u00A7\",\"semi\":\";\",\"seswar\":\"\\u2929\",\"setminus\":\"\\u2216\",\"setmn\":\"\\u2216\",\"sext\":\"\\u2736\",\"Sfr\":\"\\uD835\\uDD16\",\"sfr\":\"\\uD835\\uDD30\",\"sfrown\":\"\\u2322\",\"sharp\":\"\\u266F\",\"SHCHcy\":\"\\u0429\",\"shchcy\":\"\\u0449\",\"SHcy\":\"\\u0428\",\"shcy\":\"\\u0448\",\"ShortDownArrow\":\"\\u2193\",\"ShortLeftArrow\":\"\\u2190\",\"shortmid\":\"\\u2223\",\"shortparallel\":\"\\u2225\",\"ShortRightArrow\":\"\\u2192\",\"ShortUpArrow\":\"\\u2191\",\"shy\":\"\\u00AD\",\"Sigma\":\"\\u03A3\",\"sigma\":\"\\u03C3\",\"sigmaf\":\"\\u03C2\",\"sigmav\":\"\\u03C2\",\"sim\":\"\\u223C\",\"simdot\":\"\\u2A6A\",\"sime\":\"\\u2243\",\"simeq\":\"\\u2243\",\"simg\":\"\\u2A9E\",\"simgE\":\"\\u2AA0\",\"siml\":\"\\u2A9D\",\"simlE\":\"\\u2A9F\",\"simne\":\"\\u2246\",\"simplus\":\"\\u2A24\",\"simrarr\":\"\\u2972\",\"slarr\":\"\\u2190\",\"SmallCircle\":\"\\u2218\",\"smallsetminus\":\"\\u2216\",\"smashp\":\"\\u2A33\",\"smeparsl\":\"\\u29E4\",\"smid\":\"\\u2223\",\"smile\":\"\\u2323\",\"smt\":\"\\u2AAA\",\"smte\":\"\\u2AAC\",\"smtes\":\"\\u2AAC\\uFE00\",\"SOFTcy\":\"\\u042C\",\"softcy\":\"\\u044C\",\"solbar\":\"\\u233F\",\"solb\":\"\\u29C4\",\"sol\":\"/\",\"Sopf\":\"\\uD835\\uDD4A\",\"sopf\":\"\\uD835\\uDD64\",\"spades\":\"\\u2660\",\"spadesuit\":\"\\u2660\",\"spar\":\"\\u2225\",\"sqcap\":\"\\u2293\",\"sqcaps\":\"\\u2293\\uFE00\",\"sqcup\":\"\\u2294\",\"sqcups\":\"\\u2294\\uFE00\",\"Sqrt\":\"\\u221A\",\"sqsub\":\"\\u228F\",\"sqsube\":\"\\u2291\",\"sqsubset\":\"\\u228F\",\"sqsubseteq\":\"\\u2291\",\"sqsup\":\"\\u2290\",\"sqsupe\":\"\\u2292\",\"sqsupset\":\"\\u2290\",\"sqsupseteq\":\"\\u2292\",\"square\":\"\\u25A1\",\"Square\":\"\\u25A1\",\"SquareIntersection\":\"\\u2293\",\"SquareSubset\":\"\\u228F\",\"SquareSubsetEqual\":\"\\u2291\",\"SquareSuperset\":\"\\u2290\",\"SquareSupersetEqual\":\"\\u2292\",\"SquareUnion\":\"\\u2294\",\"squarf\":\"\\u25AA\",\"squ\":\"\\u25A1\",\"squf\":\"\\u25AA\",\"srarr\":\"\\u2192\",\"Sscr\":\"\\uD835\\uDCAE\",\"sscr\":\"\\uD835\\uDCC8\",\"ssetmn\":\"\\u2216\",\"ssmile\":\"\\u2323\",\"sstarf\":\"\\u22C6\",\"Star\":\"\\u22C6\",\"star\":\"\\u2606\",\"starf\":\"\\u2605\",\"straightepsilon\":\"\\u03F5\",\"straightphi\":\"\\u03D5\",\"strns\":\"\\u00AF\",\"sub\":\"\\u2282\",\"Sub\":\"\\u22D0\",\"subdot\":\"\\u2ABD\",\"subE\":\"\\u2AC5\",\"sube\":\"\\u2286\",\"subedot\":\"\\u2AC3\",\"submult\":\"\\u2AC1\",\"subnE\":\"\\u2ACB\",\"subne\":\"\\u228A\",\"subplus\":\"\\u2ABF\",\"subrarr\":\"\\u2979\",\"subset\":\"\\u2282\",\"Subset\":\"\\u22D0\",\"subseteq\":\"\\u2286\",\"subseteqq\":\"\\u2AC5\",\"SubsetEqual\":\"\\u2286\",\"subsetneq\":\"\\u228A\",\"subsetneqq\":\"\\u2ACB\",\"subsim\":\"\\u2AC7\",\"subsub\":\"\\u2AD5\",\"subsup\":\"\\u2AD3\",\"succapprox\":\"\\u2AB8\",\"succ\":\"\\u227B\",\"succcurlyeq\":\"\\u227D\",\"Succeeds\":\"\\u227B\",\"SucceedsEqual\":\"\\u2AB0\",\"SucceedsSlantEqual\":\"\\u227D\",\"SucceedsTilde\":\"\\u227F\",\"succeq\":\"\\u2AB0\",\"succnapprox\":\"\\u2ABA\",\"succneqq\":\"\\u2AB6\",\"succnsim\":\"\\u22E9\",\"succsim\":\"\\u227F\",\"SuchThat\":\"\\u220B\",\"sum\":\"\\u2211\",\"Sum\":\"\\u2211\",\"sung\":\"\\u266A\",\"sup1\":\"\\u00B9\",\"sup2\":\"\\u00B2\",\"sup3\":\"\\u00B3\",\"sup\":\"\\u2283\",\"Sup\":\"\\u22D1\",\"supdot\":\"\\u2ABE\",\"supdsub\":\"\\u2AD8\",\"supE\":\"\\u2AC6\",\"supe\":\"\\u2287\",\"supedot\":\"\\u2AC4\",\"Superset\":\"\\u2283\",\"SupersetEqual\":\"\\u2287\",\"suphsol\":\"\\u27C9\",\"suphsub\":\"\\u2AD7\",\"suplarr\":\"\\u297B\",\"supmult\":\"\\u2AC2\",\"supnE\":\"\\u2ACC\",\"supne\":\"\\u228B\",\"supplus\":\"\\u2AC0\",\"supset\":\"\\u2283\",\"Supset\":\"\\u22D1\",\"supseteq\":\"\\u2287\",\"supseteqq\":\"\\u2AC6\",\"supsetneq\":\"\\u228B\",\"supsetneqq\":\"\\u2ACC\",\"supsim\":\"\\u2AC8\",\"supsub\":\"\\u2AD4\",\"supsup\":\"\\u2AD6\",\"swarhk\":\"\\u2926\",\"swarr\":\"\\u2199\",\"swArr\":\"\\u21D9\",\"swarrow\":\"\\u2199\",\"swnwar\":\"\\u292A\",\"szlig\":\"\\u00DF\",\"Tab\":\"\\t\",\"target\":\"\\u2316\",\"Tau\":\"\\u03A4\",\"tau\":\"\\u03C4\",\"tbrk\":\"\\u23B4\",\"Tcaron\":\"\\u0164\",\"tcaron\":\"\\u0165\",\"Tcedil\":\"\\u0162\",\"tcedil\":\"\\u0163\",\"Tcy\":\"\\u0422\",\"tcy\":\"\\u0442\",\"tdot\":\"\\u20DB\",\"telrec\":\"\\u2315\",\"Tfr\":\"\\uD835\\uDD17\",\"tfr\":\"\\uD835\\uDD31\",\"there4\":\"\\u2234\",\"therefore\":\"\\u2234\",\"Therefore\":\"\\u2234\",\"Theta\":\"\\u0398\",\"theta\":\"\\u03B8\",\"thetasym\":\"\\u03D1\",\"thetav\":\"\\u03D1\",\"thickapprox\":\"\\u2248\",\"thicksim\":\"\\u223C\",\"ThickSpace\":\"\\u205F\\u200A\",\"ThinSpace\":\"\\u2009\",\"thinsp\":\"\\u2009\",\"thkap\":\"\\u2248\",\"thksim\":\"\\u223C\",\"THORN\":\"\\u00DE\",\"thorn\":\"\\u00FE\",\"tilde\":\"\\u02DC\",\"Tilde\":\"\\u223C\",\"TildeEqual\":\"\\u2243\",\"TildeFullEqual\":\"\\u2245\",\"TildeTilde\":\"\\u2248\",\"timesbar\":\"\\u2A31\",\"timesb\":\"\\u22A0\",\"times\":\"\\u00D7\",\"timesd\":\"\\u2A30\",\"tint\":\"\\u222D\",\"toea\":\"\\u2928\",\"topbot\":\"\\u2336\",\"topcir\":\"\\u2AF1\",\"top\":\"\\u22A4\",\"Topf\":\"\\uD835\\uDD4B\",\"topf\":\"\\uD835\\uDD65\",\"topfork\":\"\\u2ADA\",\"tosa\":\"\\u2929\",\"tprime\":\"\\u2034\",\"trade\":\"\\u2122\",\"TRADE\":\"\\u2122\",\"triangle\":\"\\u25B5\",\"triangledown\":\"\\u25BF\",\"triangleleft\":\"\\u25C3\",\"trianglelefteq\":\"\\u22B4\",\"triangleq\":\"\\u225C\",\"triangleright\":\"\\u25B9\",\"trianglerighteq\":\"\\u22B5\",\"tridot\":\"\\u25EC\",\"trie\":\"\\u225C\",\"triminus\":\"\\u2A3A\",\"TripleDot\":\"\\u20DB\",\"triplus\":\"\\u2A39\",\"trisb\":\"\\u29CD\",\"tritime\":\"\\u2A3B\",\"trpezium\":\"\\u23E2\",\"Tscr\":\"\\uD835\\uDCAF\",\"tscr\":\"\\uD835\\uDCC9\",\"TScy\":\"\\u0426\",\"tscy\":\"\\u0446\",\"TSHcy\":\"\\u040B\",\"tshcy\":\"\\u045B\",\"Tstrok\":\"\\u0166\",\"tstrok\":\"\\u0167\",\"twixt\":\"\\u226C\",\"twoheadleftarrow\":\"\\u219E\",\"twoheadrightarrow\":\"\\u21A0\",\"Uacute\":\"\\u00DA\",\"uacute\":\"\\u00FA\",\"uarr\":\"\\u2191\",\"Uarr\":\"\\u219F\",\"uArr\":\"\\u21D1\",\"Uarrocir\":\"\\u2949\",\"Ubrcy\":\"\\u040E\",\"ubrcy\":\"\\u045E\",\"Ubreve\":\"\\u016C\",\"ubreve\":\"\\u016D\",\"Ucirc\":\"\\u00DB\",\"ucirc\":\"\\u00FB\",\"Ucy\":\"\\u0423\",\"ucy\":\"\\u0443\",\"udarr\":\"\\u21C5\",\"Udblac\":\"\\u0170\",\"udblac\":\"\\u0171\",\"udhar\":\"\\u296E\",\"ufisht\":\"\\u297E\",\"Ufr\":\"\\uD835\\uDD18\",\"ufr\":\"\\uD835\\uDD32\",\"Ugrave\":\"\\u00D9\",\"ugrave\":\"\\u00F9\",\"uHar\":\"\\u2963\",\"uharl\":\"\\u21BF\",\"uharr\":\"\\u21BE\",\"uhblk\":\"\\u2580\",\"ulcorn\":\"\\u231C\",\"ulcorner\":\"\\u231C\",\"ulcrop\":\"\\u230F\",\"ultri\":\"\\u25F8\",\"Umacr\":\"\\u016A\",\"umacr\":\"\\u016B\",\"uml\":\"\\u00A8\",\"UnderBar\":\"_\",\"UnderBrace\":\"\\u23DF\",\"UnderBracket\":\"\\u23B5\",\"UnderParenthesis\":\"\\u23DD\",\"Union\":\"\\u22C3\",\"UnionPlus\":\"\\u228E\",\"Uogon\":\"\\u0172\",\"uogon\":\"\\u0173\",\"Uopf\":\"\\uD835\\uDD4C\",\"uopf\":\"\\uD835\\uDD66\",\"UpArrowBar\":\"\\u2912\",\"uparrow\":\"\\u2191\",\"UpArrow\":\"\\u2191\",\"Uparrow\":\"\\u21D1\",\"UpArrowDownArrow\":\"\\u21C5\",\"updownarrow\":\"\\u2195\",\"UpDownArrow\":\"\\u2195\",\"Updownarrow\":\"\\u21D5\",\"UpEquilibrium\":\"\\u296E\",\"upharpoonleft\":\"\\u21BF\",\"upharpoonright\":\"\\u21BE\",\"uplus\":\"\\u228E\",\"UpperLeftArrow\":\"\\u2196\",\"UpperRightArrow\":\"\\u2197\",\"upsi\":\"\\u03C5\",\"Upsi\":\"\\u03D2\",\"upsih\":\"\\u03D2\",\"Upsilon\":\"\\u03A5\",\"upsilon\":\"\\u03C5\",\"UpTeeArrow\":\"\\u21A5\",\"UpTee\":\"\\u22A5\",\"upuparrows\":\"\\u21C8\",\"urcorn\":\"\\u231D\",\"urcorner\":\"\\u231D\",\"urcrop\":\"\\u230E\",\"Uring\":\"\\u016E\",\"uring\":\"\\u016F\",\"urtri\":\"\\u25F9\",\"Uscr\":\"\\uD835\\uDCB0\",\"uscr\":\"\\uD835\\uDCCA\",\"utdot\":\"\\u22F0\",\"Utilde\":\"\\u0168\",\"utilde\":\"\\u0169\",\"utri\":\"\\u25B5\",\"utrif\":\"\\u25B4\",\"uuarr\":\"\\u21C8\",\"Uuml\":\"\\u00DC\",\"uuml\":\"\\u00FC\",\"uwangle\":\"\\u29A7\",\"vangrt\":\"\\u299C\",\"varepsilon\":\"\\u03F5\",\"varkappa\":\"\\u03F0\",\"varnothing\":\"\\u2205\",\"varphi\":\"\\u03D5\",\"varpi\":\"\\u03D6\",\"varpropto\":\"\\u221D\",\"varr\":\"\\u2195\",\"vArr\":\"\\u21D5\",\"varrho\":\"\\u03F1\",\"varsigma\":\"\\u03C2\",\"varsubsetneq\":\"\\u228A\\uFE00\",\"varsubsetneqq\":\"\\u2ACB\\uFE00\",\"varsupsetneq\":\"\\u228B\\uFE00\",\"varsupsetneqq\":\"\\u2ACC\\uFE00\",\"vartheta\":\"\\u03D1\",\"vartriangleleft\":\"\\u22B2\",\"vartriangleright\":\"\\u22B3\",\"vBar\":\"\\u2AE8\",\"Vbar\":\"\\u2AEB\",\"vBarv\":\"\\u2AE9\",\"Vcy\":\"\\u0412\",\"vcy\":\"\\u0432\",\"vdash\":\"\\u22A2\",\"vDash\":\"\\u22A8\",\"Vdash\":\"\\u22A9\",\"VDash\":\"\\u22AB\",\"Vdashl\":\"\\u2AE6\",\"veebar\":\"\\u22BB\",\"vee\":\"\\u2228\",\"Vee\":\"\\u22C1\",\"veeeq\":\"\\u225A\",\"vellip\":\"\\u22EE\",\"verbar\":\"|\",\"Verbar\":\"\\u2016\",\"vert\":\"|\",\"Vert\":\"\\u2016\",\"VerticalBar\":\"\\u2223\",\"VerticalLine\":\"|\",\"VerticalSeparator\":\"\\u2758\",\"VerticalTilde\":\"\\u2240\",\"VeryThinSpace\":\"\\u200A\",\"Vfr\":\"\\uD835\\uDD19\",\"vfr\":\"\\uD835\\uDD33\",\"vltri\":\"\\u22B2\",\"vnsub\":\"\\u2282\\u20D2\",\"vnsup\":\"\\u2283\\u20D2\",\"Vopf\":\"\\uD835\\uDD4D\",\"vopf\":\"\\uD835\\uDD67\",\"vprop\":\"\\u221D\",\"vrtri\":\"\\u22B3\",\"Vscr\":\"\\uD835\\uDCB1\",\"vscr\":\"\\uD835\\uDCCB\",\"vsubnE\":\"\\u2ACB\\uFE00\",\"vsubne\":\"\\u228A\\uFE00\",\"vsupnE\":\"\\u2ACC\\uFE00\",\"vsupne\":\"\\u228B\\uFE00\",\"Vvdash\":\"\\u22AA\",\"vzigzag\":\"\\u299A\",\"Wcirc\":\"\\u0174\",\"wcirc\":\"\\u0175\",\"wedbar\":\"\\u2A5F\",\"wedge\":\"\\u2227\",\"Wedge\":\"\\u22C0\",\"wedgeq\":\"\\u2259\",\"weierp\":\"\\u2118\",\"Wfr\":\"\\uD835\\uDD1A\",\"wfr\":\"\\uD835\\uDD34\",\"Wopf\":\"\\uD835\\uDD4E\",\"wopf\":\"\\uD835\\uDD68\",\"wp\":\"\\u2118\",\"wr\":\"\\u2240\",\"wreath\":\"\\u2240\",\"Wscr\":\"\\uD835\\uDCB2\",\"wscr\":\"\\uD835\\uDCCC\",\"xcap\":\"\\u22C2\",\"xcirc\":\"\\u25EF\",\"xcup\":\"\\u22C3\",\"xdtri\":\"\\u25BD\",\"Xfr\":\"\\uD835\\uDD1B\",\"xfr\":\"\\uD835\\uDD35\",\"xharr\":\"\\u27F7\",\"xhArr\":\"\\u27FA\",\"Xi\":\"\\u039E\",\"xi\":\"\\u03BE\",\"xlarr\":\"\\u27F5\",\"xlArr\":\"\\u27F8\",\"xmap\":\"\\u27FC\",\"xnis\":\"\\u22FB\",\"xodot\":\"\\u2A00\",\"Xopf\":\"\\uD835\\uDD4F\",\"xopf\":\"\\uD835\\uDD69\",\"xoplus\":\"\\u2A01\",\"xotime\":\"\\u2A02\",\"xrarr\":\"\\u27F6\",\"xrArr\":\"\\u27F9\",\"Xscr\":\"\\uD835\\uDCB3\",\"xscr\":\"\\uD835\\uDCCD\",\"xsqcup\":\"\\u2A06\",\"xuplus\":\"\\u2A04\",\"xutri\":\"\\u25B3\",\"xvee\":\"\\u22C1\",\"xwedge\":\"\\u22C0\",\"Yacute\":\"\\u00DD\",\"yacute\":\"\\u00FD\",\"YAcy\":\"\\u042F\",\"yacy\":\"\\u044F\",\"Ycirc\":\"\\u0176\",\"ycirc\":\"\\u0177\",\"Ycy\":\"\\u042B\",\"ycy\":\"\\u044B\",\"yen\":\"\\u00A5\",\"Yfr\":\"\\uD835\\uDD1C\",\"yfr\":\"\\uD835\\uDD36\",\"YIcy\":\"\\u0407\",\"yicy\":\"\\u0457\",\"Yopf\":\"\\uD835\\uDD50\",\"yopf\":\"\\uD835\\uDD6A\",\"Yscr\":\"\\uD835\\uDCB4\",\"yscr\":\"\\uD835\\uDCCE\",\"YUcy\":\"\\u042E\",\"yucy\":\"\\u044E\",\"yuml\":\"\\u00FF\",\"Yuml\":\"\\u0178\",\"Zacute\":\"\\u0179\",\"zacute\":\"\\u017A\",\"Zcaron\":\"\\u017D\",\"zcaron\":\"\\u017E\",\"Zcy\":\"\\u0417\",\"zcy\":\"\\u0437\",\"Zdot\":\"\\u017B\",\"zdot\":\"\\u017C\",\"zeetrf\":\"\\u2128\",\"ZeroWidthSpace\":\"\\u200B\",\"Zeta\":\"\\u0396\",\"zeta\":\"\\u03B6\",\"zfr\":\"\\uD835\\uDD37\",\"Zfr\":\"\\u2128\",\"ZHcy\":\"\\u0416\",\"zhcy\":\"\\u0436\",\"zigrarr\":\"\\u21DD\",\"zopf\":\"\\uD835\\uDD6B\",\"Zopf\":\"\\u2124\",\"Zscr\":\"\\uD835\\uDCB5\",\"zscr\":\"\\uD835\\uDCCF\",\"zwj\":\"\\u200D\",\"zwnj\":\"\\u200C\"}\r\n},{}],53:[function(require,module,exports){\r\n'use strict';\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n// Helpers\r\n\r\n// Merge objects\r\n//\r\nfunction assign(obj /*from1, from2, from3, ...*/) {\r\n  var sources = Array.prototype.slice.call(arguments, 1);\r\n\r\n  sources.forEach(function (source) {\r\n    if (!source) { return; }\r\n\r\n    Object.keys(source).forEach(function (key) {\r\n      obj[key] = source[key];\r\n    });\r\n  });\r\n\r\n  return obj;\r\n}\r\n\r\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\r\nfunction isString(obj) { return _class(obj) === '[object String]'; }\r\nfunction isObject(obj) { return _class(obj) === '[object Object]'; }\r\nfunction isRegExp(obj) { return _class(obj) === '[object RegExp]'; }\r\nfunction isFunction(obj) { return _class(obj) === '[object Function]'; }\r\n\r\n\r\nfunction escapeRE (str) { return str.replace(/[.?*+^$[\\]\\\\(){}|-]/g, '\\\\$&'); }\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\nvar defaultSchemas = {\r\n  'http:': {\r\n    validate: function (text, pos, self) {\r\n      var tail = text.slice(pos);\r\n\r\n      if (!self.re.http) {\r\n        // compile lazily, because \"host\"-containing variables can change on tlds update.\r\n        self.re.http =  new RegExp(\r\n          '^\\\\/\\\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i'\r\n        );\r\n      }\r\n      if (self.re.http.test(tail)) {\r\n        return tail.match(self.re.http)[0].length;\r\n      }\r\n      return 0;\r\n    }\r\n  },\r\n  'https:':  'http:',\r\n  'ftp:':    'http:',\r\n  '//':      {\r\n    validate: function (text, pos, self) {\r\n      var tail = text.slice(pos);\r\n\r\n      if (!self.re.no_http) {\r\n      // compile lazily, becayse \"host\"-containing variables can change on tlds update.\r\n        self.re.no_http =  new RegExp(\r\n          '^' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i'\r\n        );\r\n      }\r\n\r\n      if (self.re.no_http.test(tail)) {\r\n        // should not be `://`, that protects from errors in protocol name\r\n        if (pos >= 3 && text[pos - 3] === ':') { return 0; }\r\n        return tail.match(self.re.no_http)[0].length;\r\n      }\r\n      return 0;\r\n    }\r\n  },\r\n  'mailto:': {\r\n    validate: function (text, pos, self) {\r\n      var tail = text.slice(pos);\r\n\r\n      if (!self.re.mailto) {\r\n        self.re.mailto =  new RegExp(\r\n          '^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i'\r\n        );\r\n      }\r\n      if (self.re.mailto.test(tail)) {\r\n        return tail.match(self.re.mailto)[0].length;\r\n      }\r\n      return 0;\r\n    }\r\n  }\r\n};\r\n\r\n// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead\r\nvar tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|'.split('|');\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction resetScanCache(self) {\r\n  self.__index__ = -1;\r\n  self.__text_cache__   = '';\r\n}\r\n\r\nfunction createValidator(re) {\r\n  return function (text, pos) {\r\n    var tail = text.slice(pos);\r\n\r\n    if (re.test(tail)) {\r\n      return tail.match(re)[0].length;\r\n    }\r\n    return 0;\r\n  };\r\n}\r\n\r\nfunction createNormalizer() {\r\n  return function (match, self) {\r\n    self.normalize(match);\r\n  };\r\n}\r\n\r\n// Schemas compiler. Build regexps.\r\n//\r\nfunction compile(self) {\r\n\r\n  // Load & clone RE patterns.\r\n  var re = self.re = assign({}, require('./lib/re'));\r\n\r\n  // Define dynamic patterns\r\n  var tlds = self.__tlds__.slice();\r\n\r\n  if (!self.__tlds_replaced__) {\r\n    tlds.push('[a-z]{2}');\r\n  }\r\n  tlds.push(re.src_xn);\r\n\r\n  re.src_tlds = tlds.join('|');\r\n\r\n  function untpl(tpl) { return tpl.replace('%TLDS%', re.src_tlds); }\r\n\r\n  re.email_fuzzy      = RegExp(untpl(re.tpl_email_fuzzy), 'i');\r\n  re.link_fuzzy       = RegExp(untpl(re.tpl_link_fuzzy), 'i');\r\n  re.host_fuzzy_test  = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');\r\n\r\n  //\r\n  // Compile each schema\r\n  //\r\n\r\n  var aliases = [];\r\n\r\n  self.__compiled__ = {}; // Reset compiled data\r\n\r\n  function schemaError(name, val) {\r\n    throw new Error('(LinkifyIt) Invalid schema \"' + name + '\": ' + val);\r\n  }\r\n\r\n  Object.keys(self.__schemas__).forEach(function (name) {\r\n    var val = self.__schemas__[name];\r\n\r\n    // skip disabled methods\r\n    if (val === null) { return; }\r\n\r\n    var compiled = { validate: null, link: null };\r\n\r\n    self.__compiled__[name] = compiled;\r\n\r\n    if (isObject(val)) {\r\n      if (isRegExp(val.validate)) {\r\n        compiled.validate = createValidator(val.validate);\r\n      } else if (isFunction(val.validate)) {\r\n        compiled.validate = val.validate;\r\n      } else {\r\n        schemaError(name, val);\r\n      }\r\n\r\n      if (isFunction(val.normalize)) {\r\n        compiled.normalize = val.normalize;\r\n      } else if (!val.normalize) {\r\n        compiled.normalize = createNormalizer();\r\n      } else {\r\n        schemaError(name, val);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (isString(val)) {\r\n      aliases.push(name);\r\n      return;\r\n    }\r\n\r\n    schemaError(name, val);\r\n  });\r\n\r\n  //\r\n  // Compile postponed aliases\r\n  //\r\n\r\n  aliases.forEach(function (alias) {\r\n    if (!self.__compiled__[self.__schemas__[alias]]) {\r\n      // Silently fail on missed schemas to avoid errons on disable.\r\n      // schemaError(alias, self.__schemas__[alias]);\r\n      return;\r\n    }\r\n\r\n    self.__compiled__[alias].validate =\r\n      self.__compiled__[self.__schemas__[alias]].validate;\r\n    self.__compiled__[alias].normalize =\r\n      self.__compiled__[self.__schemas__[alias]].normalize;\r\n  });\r\n\r\n  //\r\n  // Fake record for guessed links\r\n  //\r\n  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };\r\n\r\n  //\r\n  // Build schema condition\r\n  //\r\n  var slist = Object.keys(self.__compiled__)\r\n                      .filter(function(name) {\r\n                        // Filter disabled & fake schemas\r\n                        return name.length > 0 && self.__compiled__[name];\r\n                      })\r\n                      .map(escapeRE)\r\n                      .join('|');\r\n  // (?!_) cause 1.5x slowdown\r\n  self.re.schema_test   = RegExp('(^|(?!_)(?:>|' + re.src_ZPCc + '))(' + slist + ')', 'i');\r\n  self.re.schema_search = RegExp('(^|(?!_)(?:>|' + re.src_ZPCc + '))(' + slist + ')', 'ig');\r\n\r\n  self.re.pretest       = RegExp(\r\n                            '(' + self.re.schema_test.source + ')|' +\r\n                            '(' + self.re.host_fuzzy_test.source + ')|' +\r\n                            '@',\r\n                            'i');\r\n\r\n  //\r\n  // Cleanup\r\n  //\r\n\r\n  resetScanCache(self);\r\n}\r\n\r\n/**\r\n * class Match\r\n *\r\n * Match result. Single element of array, returned by [[LinkifyIt#match]]\r\n **/\r\nfunction Match(self, shift) {\r\n  var start = self.__index__,\r\n      end   = self.__last_index__,\r\n      text  = self.__text_cache__.slice(start, end);\r\n\r\n  /**\r\n   * Match#schema -> String\r\n   *\r\n   * Prefix (protocol) for matched string.\r\n   **/\r\n  this.schema    = self.__schema__.toLowerCase();\r\n  /**\r\n   * Match#index -> Number\r\n   *\r\n   * First position of matched string.\r\n   **/\r\n  this.index     = start + shift;\r\n  /**\r\n   * Match#lastIndex -> Number\r\n   *\r\n   * Next position after matched string.\r\n   **/\r\n  this.lastIndex = end + shift;\r\n  /**\r\n   * Match#raw -> String\r\n   *\r\n   * Matched string.\r\n   **/\r\n  this.raw       = text;\r\n  /**\r\n   * Match#text -> String\r\n   *\r\n   * Notmalized text of matched string.\r\n   **/\r\n  this.text      = text;\r\n  /**\r\n   * Match#url -> String\r\n   *\r\n   * Normalized url of matched string.\r\n   **/\r\n  this.url       = text;\r\n}\r\n\r\nfunction createMatch(self, shift) {\r\n  var match = new Match(self, shift);\r\n\r\n  self.__compiled__[match.schema].normalize(match, self);\r\n\r\n  return match;\r\n}\r\n\r\n\r\n/**\r\n * class LinkifyIt\r\n **/\r\n\r\n/**\r\n * new LinkifyIt(schemas)\r\n * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)\r\n *\r\n * Creates new linkifier instance with optional additional schemas.\r\n * Can be called without `new` keyword for convenience.\r\n *\r\n * By default understands:\r\n *\r\n * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links\r\n * - \"fuzzy\" links and emails (example.com, foo@bar.com).\r\n *\r\n * `schemas` is an object, where each key/value describes protocol/rule:\r\n *\r\n * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`\r\n *   for example). `linkify-it` makes shure that prefix is not preceeded with\r\n *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.\r\n * - __value__ - rule to check tail after link prefix\r\n *   - _String_ - just alias to existing rule\r\n *   - _Object_\r\n *     - _validate_ - validator function (should return matched length on success),\r\n *       or `RegExp`.\r\n *     - _normalize_ - optional function to normalize text & url of matched result\r\n *       (for example, for @twitter mentions).\r\n **/\r\nfunction LinkifyIt(schemas) {\r\n  if (!(this instanceof LinkifyIt)) {\r\n    return new LinkifyIt(schemas);\r\n  }\r\n\r\n  // Cache last tested result. Used to skip repeating steps on next `match` call.\r\n  this.__index__          = -1;\r\n  this.__last_index__     = -1; // Next scan position\r\n  this.__schema__         = '';\r\n  this.__text_cache__     = '';\r\n\r\n  this.__schemas__        = assign({}, defaultSchemas, schemas);\r\n  this.__compiled__       = {};\r\n\r\n  this.__tlds__           = tlds_default;\r\n  this.__tlds_replaced__  = false;\r\n\r\n  this.re = {};\r\n\r\n  compile(this);\r\n}\r\n\r\n\r\n/** chainable\r\n * LinkifyIt#add(schema, definition)\r\n * - schema (String): rule name (fixed pattern prefix)\r\n * - definition (String|RegExp|Object): schema definition\r\n *\r\n * Add new rule definition. See constructor description for details.\r\n **/\r\nLinkifyIt.prototype.add = function add(schema, definition) {\r\n  this.__schemas__[schema] = definition;\r\n  compile(this);\r\n  return this;\r\n};\r\n\r\n\r\n/**\r\n * LinkifyIt#test(text) -> Boolean\r\n *\r\n * Searches linkifiable pattern and returns `true` on success or `false` on fail.\r\n **/\r\nLinkifyIt.prototype.test = function test(text) {\r\n  // Reset scan cache\r\n  this.__text_cache__ = text;\r\n  this.__index__      = -1;\r\n\r\n  if (!text.length) { return false; }\r\n\r\n  var m, ml, me, len, shift, next, re, tld_pos, at_pos;\r\n\r\n  // try to scan for link with schema - that's the most simple rule\r\n  if (this.re.schema_test.test(text)) {\r\n    re = this.re.schema_search;\r\n    re.lastIndex = 0;\r\n    while ((m = re.exec(text)) !== null) {\r\n      len = this.testSchemaAt(text, m[2], re.lastIndex);\r\n      if (len) {\r\n        this.__schema__     = m[2];\r\n        this.__index__      = m.index + m[1].length;\r\n        this.__last_index__ = m.index + m[0].length + len;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (this.__compiled__['http:']) {\r\n    // guess schemaless links\r\n    tld_pos = text.search(this.re.host_fuzzy_test);\r\n    if (tld_pos >= 0) {\r\n      // if tld is located after found link - no need to check fuzzy pattern\r\n      if (this.__index__ < 0 || tld_pos < this.__index__) {\r\n        if ((ml = text.match(this.re.link_fuzzy)) !== null) {\r\n\r\n          shift = ml.index + ml[1].length;\r\n\r\n          if (this.__index__ < 0 || shift < this.__index__) {\r\n            this.__schema__     = '';\r\n            this.__index__      = shift;\r\n            this.__last_index__ = ml.index + ml[0].length;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (this.__compiled__['mailto:']) {\r\n    // guess schemaless emails\r\n    at_pos = text.indexOf('@');\r\n    if (at_pos >= 0) {\r\n      // We can't skip this check, because this cases are possible:\r\n      // 192.168.1.1@gmail.com, my.in@example.com\r\n      if ((me = text.match(this.re.email_fuzzy)) !== null) {\r\n\r\n        shift = me.index + me[1].length;\r\n        next  = me.index + me[0].length;\r\n\r\n        if (this.__index__ < 0 || shift < this.__index__ ||\r\n            (shift === this.__index__ && next > this.__last_index__)) {\r\n          this.__schema__     = 'mailto:';\r\n          this.__index__      = shift;\r\n          this.__last_index__ = next;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return this.__index__ >= 0;\r\n};\r\n\r\n\r\n/**\r\n * LinkifyIt#pretest(text) -> Boolean\r\n *\r\n * Very quick check, that can give false positives. Returns true if link MAY BE\r\n * can exists. Can be used for speed optimization, when you need to check that\r\n * link NOT exists.\r\n **/\r\nLinkifyIt.prototype.pretest = function pretest(text) {\r\n  return this.re.pretest.test(text);\r\n};\r\n\r\n\r\n/**\r\n * LinkifyIt#testSchemaAt(text, name, position) -> Number\r\n * - text (String): text to scan\r\n * - name (String): rule (schema) name\r\n * - position (Number): text offset to check from\r\n *\r\n * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly\r\n * at given position. Returns length of found pattern (0 on fail).\r\n **/\r\nLinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {\r\n  // If not supported schema check requested - terminate\r\n  if (!this.__compiled__[schema.toLowerCase()]) {\r\n    return 0;\r\n  }\r\n  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);\r\n};\r\n\r\n\r\n/**\r\n * LinkifyIt#match(text) -> Array|null\r\n *\r\n * Returns array of found link descriptions or `null` on fail. We strongly\r\n * to use [[LinkifyIt#test]] first, for best speed.\r\n *\r\n * ##### Result match description\r\n *\r\n * - __schema__ - link schema, can be empty for fuzzy links, or `//` for\r\n *   protocol-neutral  links.\r\n * - __index__ - offset of matched text\r\n * - __lastIndex__ - index of next char after mathch end\r\n * - __raw__ - matched text\r\n * - __text__ - normalized text\r\n * - __url__ - link, generated from matched text\r\n **/\r\nLinkifyIt.prototype.match = function match(text) {\r\n  var shift = 0, result = [];\r\n\r\n  // Try to take previous element from cache, if .test() called before\r\n  if (this.__index__ >= 0 && this.__text_cache__ === text) {\r\n    result.push(createMatch(this, shift));\r\n    shift = this.__last_index__;\r\n  }\r\n\r\n  // Cut head if cache was used\r\n  var tail = shift ? text.slice(shift) : text;\r\n\r\n  // Scan string until end reached\r\n  while (this.test(tail)) {\r\n    result.push(createMatch(this, shift));\r\n\r\n    tail = tail.slice(this.__last_index__);\r\n    shift += this.__last_index__;\r\n  }\r\n\r\n  if (result.length) {\r\n    return result;\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\n\r\n/** chainable\r\n * LinkifyIt#tlds(list [, keepOld]) -> this\r\n * - list (Array): list of tlds\r\n * - keepOld (Boolean): merge with current list if `true` (`false` by default)\r\n *\r\n * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)\r\n * to avoid false positives. By default this algorythm used:\r\n *\r\n * - hostname with any 2-letter root zones are ok.\r\n * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\r\n *   are ok.\r\n * - encoded (`xn--...`) root zones are ok.\r\n *\r\n * If list is replaced, then exact match for 2-chars root zones will be checked.\r\n **/\r\nLinkifyIt.prototype.tlds = function tlds(list, keepOld) {\r\n  list = Array.isArray(list) ? list : [ list ];\r\n\r\n  if (!keepOld) {\r\n    this.__tlds__ = list.slice();\r\n    this.__tlds_replaced__ = true;\r\n    compile(this);\r\n    return this;\r\n  }\r\n\r\n  this.__tlds__ = this.__tlds__.concat(list)\r\n                                  .sort()\r\n                                  .filter(function(el, idx, arr) {\r\n                                    return el !== arr[idx - 1];\r\n                                  })\r\n                                  .reverse();\r\n\r\n  compile(this);\r\n  return this;\r\n};\r\n\r\n/**\r\n * LinkifyIt#normalize(match)\r\n *\r\n * Default normalizer (if schema does not define it's own).\r\n **/\r\nLinkifyIt.prototype.normalize = function normalize(match) {\r\n\r\n  // Do minimal possible changes by default. Need to collect feedback prior\r\n  // to move forward https://github.com/markdown-it/linkify-it/issues/1\r\n\r\n  if (!match.schema) { match.url = 'http://' + match.url; }\r\n\r\n  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {\r\n    match.url = 'mailto:' + match.url;\r\n  }\r\n};\r\n\r\n\r\nmodule.exports = LinkifyIt;\r\n\r\n},{\"./lib/re\":54}],54:[function(require,module,exports){\r\n'use strict';\r\n\r\n// Use direct extract instead of `regenerate` to reduse browserified size\r\nvar src_Any = exports.src_Any = require('uc.micro/properties/Any/regex').source;\r\nvar src_Cc  = exports.src_Cc = require('uc.micro/categories/Cc/regex').source;\r\nvar src_Z   = exports.src_Z  = require('uc.micro/categories/Z/regex').source;\r\nvar src_P   = exports.src_P  = require('uc.micro/categories/P/regex').source;\r\n\r\n// \\p{\\Z\\P\\Cc\\CF} (white spaces + control + format + punctuation)\r\nvar src_ZPCc = exports.src_ZPCc = [ src_Z, src_P, src_Cc ].join('|');\r\n\r\n// \\p{\\Z\\Cc} (white spaces + control)\r\nvar src_ZCc = exports.src_ZCc = [ src_Z, src_Cc ].join('|');\r\n\r\n// All possible word characters (everything without punctuation, spaces & controls)\r\n// Defined via punctuation & spaces to save space\r\n// Should be something like \\p{\\L\\N\\S\\M} (\\w but without `_`)\r\nvar src_pseudo_letter       = '(?:(?!' + src_ZPCc + ')' + src_Any + ')';\r\n// The same as abothe but without [0-9]\r\nvar src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar src_ip4 = exports.src_ip4 =\r\n\r\n  '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';\r\n\r\nexports.src_auth    = '(?:(?:(?!' + src_ZCc + ').)+@)?';\r\n\r\nvar src_port = exports.src_port =\r\n\r\n  '(?::(?:6(?:[0-4]\\\\d{3}|5(?:[0-4]\\\\d{2}|5(?:[0-2]\\\\d|3[0-5])))|[1-5]?\\\\d{1,4}))?';\r\n\r\nvar src_host_terminator = exports.src_host_terminator =\r\n\r\n  '(?=$|' + src_ZPCc + ')(?!-|_|:\\\\d|\\\\.-|\\\\.(?!$|' + src_ZPCc + '))';\r\n\r\nvar src_path = exports.src_path =\r\n\r\n  '(?:' +\r\n    '[/?#]' +\r\n      '(?:' +\r\n        '(?!' + src_ZCc + '|[()[\\\\]{}.,\"\\'?!\\\\-]).|' +\r\n        '\\\\[(?:(?!' + src_ZCc + '|\\\\]).)*\\\\]|' +\r\n        '\\\\((?:(?!' + src_ZCc + '|[)]).)*\\\\)|' +\r\n        '\\\\{(?:(?!' + src_ZCc + '|[}]).)*\\\\}|' +\r\n        '\\\\\"(?:(?!' + src_ZCc + '|[\"]).)+\\\\\"|' +\r\n        \"\\\\'(?:(?!\" + src_ZCc + \"|[']).)+\\\\'|\" +\r\n        \"\\\\'(?=\" + src_pseudo_letter + ').|' +  // allow `I'm_king` if no pair found\r\n        '\\\\.{2,3}[a-zA-Z0-9%]|' + // github has ... in commit range links. Restrict to\r\n                                  // english & percent-encoded only, until more examples found.\r\n        '\\\\.(?!' + src_ZCc + '|[.]).|' +\r\n        '\\\\-(?!' + src_ZCc + '|--(?:[^-]|$))(?:[-]+|.)|' +  // `---` => long dash, terminate\r\n        '\\\\,(?!' + src_ZCc + ').|' +      // allow `,,,` in paths\r\n        '\\\\!(?!' + src_ZCc + '|[!]).|' +\r\n        '\\\\?(?!' + src_ZCc + '|[?]).' +\r\n      ')+' +\r\n    '|\\\\/' +\r\n  ')?';\r\n\r\nvar src_email_name = exports.src_email_name =\r\n\r\n  '[\\\\-;:&=\\\\+\\\\$,\\\\\"\\\\.a-zA-Z0-9_]+';\r\n\r\nvar src_xn = exports.src_xn =\r\n\r\n  'xn--[a-z0-9\\\\-]{1,59}';\r\n\r\n// More to read about domain names\r\n// http://serverfault.com/questions/638260/\r\n\r\nvar src_domain_root = exports.src_domain_root =\r\n\r\n  // Can't have digits and dashes\r\n  '(?:' +\r\n    src_xn +\r\n    '|' +\r\n    src_pseudo_letter_non_d + '{1,63}' +\r\n  ')';\r\n\r\nvar src_domain = exports.src_domain =\r\n\r\n  '(?:' +\r\n    src_xn +\r\n    '|' +\r\n    '(?:' + src_pseudo_letter + ')' +\r\n    '|' +\r\n    // don't allow `--` in domain names, because:\r\n    // - that can conflict with markdown &mdash; / &ndash;\r\n    // - nobody use those anyway\r\n    '(?:' + src_pseudo_letter + '(?:-(?!-)|' + src_pseudo_letter + '){0,61}' + src_pseudo_letter + ')' +\r\n  ')';\r\n\r\nvar src_host = exports.src_host =\r\n\r\n  '(?:' +\r\n    src_ip4 +\r\n  '|' +\r\n    '(?:(?:(?:' + src_domain + ')\\\\.)*' + src_domain_root + ')' +\r\n  ')';\r\n\r\nvar tpl_host_fuzzy = exports.tpl_host_fuzzy =\r\n\r\n  '(?:' +\r\n    src_ip4 +\r\n  '|' +\r\n    '(?:(?:(?:' + src_domain + ')\\\\.)+(?:%TLDS%))' +\r\n  ')';\r\n\r\nexports.src_host_strict =\r\n\r\n  src_host + src_host_terminator;\r\n\r\nvar tpl_host_fuzzy_strict = exports.tpl_host_fuzzy_strict =\r\n\r\n  tpl_host_fuzzy + src_host_terminator;\r\n\r\nexports.src_host_port_strict =\r\n\r\n  src_host + src_port + src_host_terminator;\r\n\r\nvar tpl_host_port_fuzzy_strict = exports.tpl_host_port_fuzzy_strict =\r\n\r\n  tpl_host_fuzzy + src_port + src_host_terminator;\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n// Main rules\r\n\r\n// Rude test fuzzy links by host, for quick deny\r\nexports.tpl_host_fuzzy_test =\r\n\r\n  'localhost|\\\\.\\\\d{1,3}\\\\.|(?:\\\\.(?:%TLDS%)(?:' + src_ZPCc + '|$))';\r\n\r\nexports.tpl_email_fuzzy =\r\n\r\n    '(^|>|' + src_ZCc + ')(' + src_email_name + '@' + tpl_host_fuzzy_strict + ')';\r\n\r\nexports.tpl_link_fuzzy =\r\n    // Fuzzy link can't be prepended with .:/\\- and non punctuation.\r\n    // but can start with > (markdown blockquote)\r\n    '(^|(?![.:/\\\\-_@])(?:[$+<=>^`|]|' + src_ZPCc + '))' +\r\n    '((?![$+<=>^`|])' + tpl_host_port_fuzzy_strict + src_path + ')';\r\n\r\n},{\"uc.micro/categories/Cc/regex\":60,\"uc.micro/categories/P/regex\":62,\"uc.micro/categories/Z/regex\":63,\"uc.micro/properties/Any/regex\":65}],55:[function(require,module,exports){\r\n\r\n'use strict';\r\n\r\n\r\n/* eslint-disable no-bitwise */\r\n\r\nvar decodeCache = {};\r\n\r\nfunction getDecodeCache(exclude) {\r\n  var i, ch, cache = decodeCache[exclude];\r\n  if (cache) { return cache; }\r\n\r\n  cache = decodeCache[exclude] = [];\r\n\r\n  for (i = 0; i < 128; i++) {\r\n    ch = String.fromCharCode(i);\r\n    cache.push(ch);\r\n  }\r\n\r\n  for (i = 0; i < exclude.length; i++) {\r\n    ch = exclude.charCodeAt(i);\r\n    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);\r\n  }\r\n\r\n  return cache;\r\n}\r\n\r\n\r\n// Decode percent-encoded string.\r\n//\r\nfunction decode(string, exclude) {\r\n  var cache;\r\n\r\n  if (typeof exclude !== 'string') {\r\n    exclude = decode.defaultChars;\r\n  }\r\n\r\n  cache = getDecodeCache(exclude);\r\n\r\n  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {\r\n    var i, l, b1, b2, b3, b4, char,\r\n        result = '';\r\n\r\n    for (i = 0, l = seq.length; i < l; i += 3) {\r\n      b1 = parseInt(seq.slice(i + 1, i + 3), 16);\r\n\r\n      if (b1 < 0x80) {\r\n        result += cache[b1];\r\n        continue;\r\n      }\r\n\r\n      if ((b1 & 0xE0) === 0xC0 && (i + 3 < l)) {\r\n        // 110xxxxx 10xxxxxx\r\n        b2 = parseInt(seq.slice(i + 4, i + 6), 16);\r\n\r\n        if ((b2 & 0xC0) === 0x80) {\r\n          char = ((b1 << 6) & 0x7C0) | (b2 & 0x3F);\r\n\r\n          if (char < 0x80) {\r\n            result += '\\ufffd\\ufffd';\r\n          } else {\r\n            result += String.fromCharCode(char);\r\n          }\r\n\r\n          i += 3;\r\n          continue;\r\n        }\r\n      }\r\n\r\n      if ((b1 & 0xF0) === 0xE0 && (i + 6 < l)) {\r\n        // 1110xxxx 10xxxxxx 10xxxxxx\r\n        b2 = parseInt(seq.slice(i + 4, i + 6), 16);\r\n        b3 = parseInt(seq.slice(i + 7, i + 9), 16);\r\n\r\n        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\r\n          char = ((b1 << 12) & 0xF000) | ((b2 << 6) & 0xFC0) | (b3 & 0x3F);\r\n\r\n          if (char < 0x800 || (char >= 0xD800 && char <= 0xDFFF)) {\r\n            result += '\\ufffd\\ufffd\\ufffd';\r\n          } else {\r\n            result += String.fromCharCode(char);\r\n          }\r\n\r\n          i += 6;\r\n          continue;\r\n        }\r\n      }\r\n\r\n      if ((b1 & 0xF8) === 0xF0 && (i + 9 < l)) {\r\n        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx\r\n        b2 = parseInt(seq.slice(i + 4, i + 6), 16);\r\n        b3 = parseInt(seq.slice(i + 7, i + 9), 16);\r\n        b4 = parseInt(seq.slice(i + 10, i + 12), 16);\r\n\r\n        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {\r\n          char = ((b1 << 18) & 0x1C0000) | ((b2 << 12) & 0x3F000) | ((b3 << 6) & 0xFC0) | (b4 & 0x3F);\r\n\r\n          if (char < 0x10000 || char > 0x10FFFF) {\r\n            result += '\\ufffd\\ufffd\\ufffd\\ufffd';\r\n          } else {\r\n            char -= 0x10000;\r\n            result += String.fromCharCode(0xD800 + (char >> 10), 0xDC00 + (char & 0x3FF));\r\n          }\r\n\r\n          i += 9;\r\n          continue;\r\n        }\r\n      }\r\n\r\n      result += '\\ufffd';\r\n    }\r\n\r\n    return result;\r\n  });\r\n}\r\n\r\n\r\ndecode.defaultChars   = ';/?:@&=+$,#';\r\ndecode.componentChars = '';\r\n\r\n\r\nmodule.exports = decode;\r\n\r\n},{}],56:[function(require,module,exports){\r\n\r\n'use strict';\r\n\r\n\r\nvar encodeCache = {};\r\n\r\n\r\n// Create a lookup array where anything but characters in `chars` string\r\n// and alphanumeric chars is percent-encoded.\r\n//\r\nfunction getEncodeCache(exclude) {\r\n  var i, ch, cache = encodeCache[exclude];\r\n  if (cache) { return cache; }\r\n\r\n  cache = encodeCache[exclude] = [];\r\n\r\n  for (i = 0; i < 128; i++) {\r\n    ch = String.fromCharCode(i);\r\n\r\n    if (/^[0-9a-z]$/i.test(ch)) {\r\n      // always allow unencoded alphanumeric characters\r\n      cache.push(ch);\r\n    } else {\r\n      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));\r\n    }\r\n  }\r\n\r\n  for (i = 0; i < exclude.length; i++) {\r\n    cache[exclude.charCodeAt(i)] = exclude[i];\r\n  }\r\n\r\n  return cache;\r\n}\r\n\r\n\r\n// Encode unsafe characters with percent-encoding, skipping already\r\n// encoded sequences.\r\n//\r\n//  - string       - string to encode\r\n//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)\r\n//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)\r\n//\r\nfunction encode(string, exclude, keepEscaped) {\r\n  var i, l, code, nextCode, cache,\r\n      result = '';\r\n\r\n  if (typeof exclude !== 'string') {\r\n    // encode(string, keepEscaped)\r\n    keepEscaped  = exclude;\r\n    exclude = encode.defaultChars;\r\n  }\r\n\r\n  if (typeof keepEscaped === 'undefined') {\r\n    keepEscaped = true;\r\n  }\r\n\r\n  cache = getEncodeCache(exclude);\r\n\r\n  for (i = 0, l = string.length; i < l; i++) {\r\n    code = string.charCodeAt(i);\r\n\r\n    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {\r\n      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {\r\n        result += string.slice(i, i + 3);\r\n        i += 2;\r\n        continue;\r\n      }\r\n    }\r\n\r\n    if (code < 128) {\r\n      result += cache[code];\r\n      continue;\r\n    }\r\n\r\n    if (code >= 0xD800 && code <= 0xDFFF) {\r\n      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {\r\n        nextCode = string.charCodeAt(i + 1);\r\n        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {\r\n          result += encodeURIComponent(string[i] + string[i + 1]);\r\n          i++;\r\n          continue;\r\n        }\r\n      }\r\n      result += '%EF%BF%BD';\r\n      continue;\r\n    }\r\n\r\n    result += encodeURIComponent(string[i]);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nencode.defaultChars   = \";/?:@&=+$,-_.!~*'()#\";\r\nencode.componentChars = \"-_.!~*'()\";\r\n\r\n\r\nmodule.exports = encode;\r\n\r\n},{}],57:[function(require,module,exports){\r\n\r\n'use strict';\r\n\r\n\r\nmodule.exports = function format(url) {\r\n  var result = '';\r\n\r\n  result += url.protocol || '';\r\n  result += url.slashes ? '//' : '';\r\n  result += url.auth ? url.auth + '@' : '';\r\n\r\n  if (url.hostname && url.hostname.indexOf(':') !== -1) {\r\n    // ipv6 address\r\n    result += '[' + url.hostname + ']';\r\n  } else {\r\n    result += url.hostname || '';\r\n  }\r\n\r\n  result += url.port ? ':' + url.port : '';\r\n  result += url.pathname || '';\r\n  result += url.search || '';\r\n  result += url.hash || '';\r\n\r\n  return result;\r\n};\r\n\r\n},{}],58:[function(require,module,exports){\r\n'use strict';\r\n\r\n\r\nmodule.exports.encode = require('./encode');\r\nmodule.exports.decode = require('./decode');\r\nmodule.exports.format = require('./format');\r\nmodule.exports.parse  = require('./parse');\r\n\r\n},{\"./decode\":55,\"./encode\":56,\"./format\":57,\"./parse\":59}],59:[function(require,module,exports){\r\n// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n'use strict';\r\n\r\n//\r\n// Changes from joyent/node:\r\n//\r\n// 1. No leading slash in paths,\r\n//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`\r\n//\r\n// 2. Backslashes are not replaced with slashes,\r\n//    so `http:\\\\example.org\\` is treated like a relative path\r\n//\r\n// 3. Trailing colon is treated like a part of the path,\r\n//    i.e. in `http://example.org:foo` pathname is `:foo`\r\n//\r\n// 4. Nothing is URL-encoded in the resulting object,\r\n//    (in joyent/node some chars in auth and paths are encoded)\r\n//\r\n// 5. `url.parse()` does not have `parseQueryString` argument\r\n//\r\n// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,\r\n//    which can be constructed using other parts of the url.\r\n//\r\n\r\n\r\nfunction Url() {\r\n  this.protocol = null;\r\n  this.slashes = null;\r\n  this.auth = null;\r\n  this.port = null;\r\n  this.hostname = null;\r\n  this.hash = null;\r\n  this.search = null;\r\n  this.pathname = null;\r\n}\r\n\r\n// Reference: RFC 3986, RFC 1808, RFC 2396\r\n\r\n// define these here so at least they only have to be\r\n// compiled once on the first module load.\r\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\r\n    portPattern = /:[0-9]*$/,\r\n\r\n    // Special case for a simple path URL\r\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\r\n\r\n    // RFC 2396: characters reserved for delimiting URLs.\r\n    // We actually just auto-escape these.\r\n    delims = [ '<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t' ],\r\n\r\n    // RFC 2396: characters not allowed for various reasons.\r\n    unwise = [ '{', '}', '|', '\\\\', '^', '`' ].concat(delims),\r\n\r\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\r\n    autoEscape = [ '\\'' ].concat(unwise),\r\n    // Characters that are never ever allowed in a hostname.\r\n    // Note that any invalid chars are also handled, but these\r\n    // are the ones that are *expected* to be seen, so we fast-path\r\n    // them.\r\n    nonHostChars = [ '%', '/', '?', ';', '#' ].concat(autoEscape),\r\n    hostEndingChars = [ '/', '?', '#' ],\r\n    hostnameMaxLen = 255,\r\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\r\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\r\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\r\n    /* eslint-disable no-script-url */\r\n    // protocols that never have a hostname.\r\n    hostlessProtocol = {\r\n      'javascript': true,\r\n      'javascript:': true\r\n    },\r\n    // protocols that always contain a // bit.\r\n    slashedProtocol = {\r\n      'http': true,\r\n      'https': true,\r\n      'ftp': true,\r\n      'gopher': true,\r\n      'file': true,\r\n      'http:': true,\r\n      'https:': true,\r\n      'ftp:': true,\r\n      'gopher:': true,\r\n      'file:': true\r\n    };\r\n    /* eslint-enable no-script-url */\r\n\r\nfunction urlParse(url, slashesDenoteHost) {\r\n  if (url && url instanceof Url) { return url; }\r\n\r\n  var u = new Url();\r\n  u.parse(url, slashesDenoteHost);\r\n  return u;\r\n}\r\n\r\nUrl.prototype.parse = function(url, slashesDenoteHost) {\r\n  var i, l, lowerProto, hec, slashes,\r\n      rest = url;\r\n\r\n  // trim before proceeding.\r\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\r\n  rest = rest.trim();\r\n\r\n  if (!slashesDenoteHost && url.split('#').length === 1) {\r\n    // Try fast path regexp\r\n    var simplePath = simplePathPattern.exec(rest);\r\n    if (simplePath) {\r\n      this.pathname = simplePath[1];\r\n      if (simplePath[2]) {\r\n        this.search = simplePath[2];\r\n      }\r\n      return this;\r\n    }\r\n  }\r\n\r\n  var proto = protocolPattern.exec(rest);\r\n  if (proto) {\r\n    proto = proto[0];\r\n    lowerProto = proto.toLowerCase();\r\n    this.protocol = proto;\r\n    rest = rest.substr(proto.length);\r\n  }\r\n\r\n  // figure out if it's got a host\r\n  // user@server is *always* interpreted as a hostname, and url\r\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\r\n  // how the browser resolves relative URLs.\r\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\r\n    slashes = rest.substr(0, 2) === '//';\r\n    if (slashes && !(proto && hostlessProtocol[proto])) {\r\n      rest = rest.substr(2);\r\n      this.slashes = true;\r\n    }\r\n  }\r\n\r\n  if (!hostlessProtocol[proto] &&\r\n      (slashes || (proto && !slashedProtocol[proto]))) {\r\n\r\n    // there's a hostname.\r\n    // the first instance of /, ?, ;, or # ends the host.\r\n    //\r\n    // If there is an @ in the hostname, then non-host chars *are* allowed\r\n    // to the left of the last @ sign, unless some host-ending character\r\n    // comes *before* the @-sign.\r\n    // URLs are obnoxious.\r\n    //\r\n    // ex:\r\n    // http://a@b@c/ => user:a@b host:c\r\n    // http://a@b?@c => user:a host:c path:/?@c\r\n\r\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\r\n    // Review our test case against browsers more comprehensively.\r\n\r\n    // find the first instance of any hostEndingChars\r\n    var hostEnd = -1;\r\n    for (i = 0; i < hostEndingChars.length; i++) {\r\n      hec = rest.indexOf(hostEndingChars[i]);\r\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\r\n        hostEnd = hec;\r\n      }\r\n    }\r\n\r\n    // at this point, either we have an explicit point where the\r\n    // auth portion cannot go past, or the last @ char is the decider.\r\n    var auth, atSign;\r\n    if (hostEnd === -1) {\r\n      // atSign can be anywhere.\r\n      atSign = rest.lastIndexOf('@');\r\n    } else {\r\n      // atSign must be in auth portion.\r\n      // http://a@b/c@d => host:b auth:a path:/c@d\r\n      atSign = rest.lastIndexOf('@', hostEnd);\r\n    }\r\n\r\n    // Now we have a portion which is definitely the auth.\r\n    // Pull that off.\r\n    if (atSign !== -1) {\r\n      auth = rest.slice(0, atSign);\r\n      rest = rest.slice(atSign + 1);\r\n      this.auth = auth;\r\n    }\r\n\r\n    // the host is the remaining to the left of the first non-host char\r\n    hostEnd = -1;\r\n    for (i = 0; i < nonHostChars.length; i++) {\r\n      hec = rest.indexOf(nonHostChars[i]);\r\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\r\n        hostEnd = hec;\r\n      }\r\n    }\r\n    // if we still have not hit it, then the entire thing is a host.\r\n    if (hostEnd === -1) {\r\n      hostEnd = rest.length;\r\n    }\r\n\r\n    if (rest[hostEnd - 1] === ':') { hostEnd--; }\r\n    var host = rest.slice(0, hostEnd);\r\n    rest = rest.slice(hostEnd);\r\n\r\n    // pull out port.\r\n    this.parseHost(host);\r\n\r\n    // we've indicated that there is a hostname,\r\n    // so even if it's empty, it has to be present.\r\n    this.hostname = this.hostname || '';\r\n\r\n    // if hostname begins with [ and ends with ]\r\n    // assume that it's an IPv6 address.\r\n    var ipv6Hostname = this.hostname[0] === '[' &&\r\n        this.hostname[this.hostname.length - 1] === ']';\r\n\r\n    // validate a little.\r\n    if (!ipv6Hostname) {\r\n      var hostparts = this.hostname.split(/\\./);\r\n      for (i = 0, l = hostparts.length; i < l; i++) {\r\n        var part = hostparts[i];\r\n        if (!part) { continue; }\r\n        if (!part.match(hostnamePartPattern)) {\r\n          var newpart = '';\r\n          for (var j = 0, k = part.length; j < k; j++) {\r\n            if (part.charCodeAt(j) > 127) {\r\n              // we replace non-ASCII char with a temporary placeholder\r\n              // we need this to make sure size of hostname is not\r\n              // broken by replacing non-ASCII by nothing\r\n              newpart += 'x';\r\n            } else {\r\n              newpart += part[j];\r\n            }\r\n          }\r\n          // we test again with ASCII char only\r\n          if (!newpart.match(hostnamePartPattern)) {\r\n            var validParts = hostparts.slice(0, i);\r\n            var notHost = hostparts.slice(i + 1);\r\n            var bit = part.match(hostnamePartStart);\r\n            if (bit) {\r\n              validParts.push(bit[1]);\r\n              notHost.unshift(bit[2]);\r\n            }\r\n            if (notHost.length) {\r\n              rest = notHost.join('.') + rest;\r\n            }\r\n            this.hostname = validParts.join('.');\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.hostname.length > hostnameMaxLen) {\r\n      this.hostname = '';\r\n    }\r\n\r\n    // strip [ and ] from the hostname\r\n    // the host field still retains them, though\r\n    if (ipv6Hostname) {\r\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\r\n    }\r\n  }\r\n\r\n  // chop off from the tail first.\r\n  var hash = rest.indexOf('#');\r\n  if (hash !== -1) {\r\n    // got a fragment string.\r\n    this.hash = rest.substr(hash);\r\n    rest = rest.slice(0, hash);\r\n  }\r\n  var qm = rest.indexOf('?');\r\n  if (qm !== -1) {\r\n    this.search = rest.substr(qm);\r\n    rest = rest.slice(0, qm);\r\n  }\r\n  if (rest) { this.pathname = rest; }\r\n  if (slashedProtocol[lowerProto] &&\r\n      this.hostname && !this.pathname) {\r\n    this.pathname = '';\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\nUrl.prototype.parseHost = function(host) {\r\n  var port = portPattern.exec(host);\r\n  if (port) {\r\n    port = port[0];\r\n    if (port !== ':') {\r\n      this.port = port.substr(1);\r\n    }\r\n    host = host.substr(0, host.length - port.length);\r\n  }\r\n  if (host) { this.hostname = host; }\r\n};\r\n\r\nmodule.exports = urlParse;\r\n\r\n},{}],60:[function(require,module,exports){\r\nmodule.exports=/[\\0-\\x1F\\x7F-\\x9F]/\r\n},{}],61:[function(require,module,exports){\r\nmodule.exports=/[\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB]|\\uD804\\uDCBD|\\uD82F[\\uDCA0-\\uDCA3]|\\uD834[\\uDD73-\\uDD7A]|\\uDB40[\\uDC01\\uDC20-\\uDC7F]/\r\n},{}],62:[function(require,module,exports){\r\nmodule.exports=/[!-#%-\\*,-/:;\\?@\\[-\\]_\\{\\}\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E42\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]|\\uD800[\\uDD00-\\uDD02\\uDF9F\\uDFD0]|\\uD801\\uDD6F|\\uD802[\\uDC57\\uDD1F\\uDD3F\\uDE50-\\uDE58\\uDE7F\\uDEF0-\\uDEF6\\uDF39-\\uDF3F\\uDF99-\\uDF9C]|\\uD804[\\uDC47-\\uDC4D\\uDCBB\\uDCBC\\uDCBE-\\uDCC1\\uDD40-\\uDD43\\uDD74\\uDD75\\uDDC5-\\uDDC8\\uDDCD\\uDE38-\\uDE3D]|\\uD805[\\uDCC6\\uDDC1-\\uDDC9\\uDE41-\\uDE43]|\\uD809[\\uDC70-\\uDC74]|\\uD81A[\\uDE6E\\uDE6F\\uDEF5\\uDF37-\\uDF3B\\uDF44]|\\uD82F\\uDC9F/\r\n},{}],63:[function(require,module,exports){\r\nmodule.exports=/[ \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000]/\r\n},{}],64:[function(require,module,exports){\r\n\r\nmodule.exports.Any = require('./properties/Any/regex');\r\nmodule.exports.Cc  = require('./categories/Cc/regex');\r\nmodule.exports.Cf  = require('./categories/Cf/regex');\r\nmodule.exports.P   = require('./categories/P/regex');\r\nmodule.exports.Z   = require('./categories/Z/regex');\r\n\r\n},{\"./categories/Cc/regex\":60,\"./categories/Cf/regex\":61,\"./categories/P/regex\":62,\"./categories/Z/regex\":63,\"./properties/Any/regex\":65}],65:[function(require,module,exports){\r\nmodule.exports=/[\\0-\\uD7FF\\uDC00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF]/\r\n},{}],66:[function(require,module,exports){\r\n'use strict';\r\n\r\n\r\nmodule.exports = require('./lib/');\r\n\r\n},{\"./lib/\":10}]},{},[66])(66)\r\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvbWFya2Rvd24taXQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvbWFya2Rvd24taXQuanM/MGI1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbWFya2Rvd24taXQgNC4xLjEgaHR0cHM6Ly9naXRodWIuY29tLy9tYXJrZG93bi1pdC9tYXJrZG93bi1pdCBAbGljZW5zZSBNSVQgKi8oZnVuY3Rpb24oZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiJiZ0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9ZigpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGYpfWVsc2V7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe2c9d2luZG93fWVsc2UgaWYodHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCIpe2c9Z2xvYmFsfWVsc2UgaWYodHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiKXtnPXNlbGZ9ZWxzZXtnPXRoaXN9Zy5tYXJrZG93bml0ID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4vLyBIVE1MNSBlbnRpdGllcyBtYXA6IHsgbmFtZSAtPiB1dGYxNnN0cmluZyB9XHJcbi8vXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qZXNsaW50IHF1b3RlczowKi9cclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdlbnRpdGllcy9tYXBzL2VudGl0aWVzLmpzb24nKTtcclxuXHJcbn0se1wiZW50aXRpZXMvbWFwcy9lbnRpdGllcy5qc29uXCI6NTJ9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLy8gTGlzdCBvZiB2YWxpZCBodG1sIGJsb2NrcyBuYW1lcywgYWNjb3J0aW5nIHRvIGNvbW1vbm1hcmsgc3BlY1xyXG4vLyBodHRwOi8vamdtLmdpdGh1Yi5pby9Db21tb25NYXJrL3NwZWMuaHRtbCNodG1sLWJsb2Nrc1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGh0bWxfYmxvY2tzID0ge307XHJcblxyXG5bXHJcbiAgJ2FydGljbGUnLFxyXG4gICdhc2lkZScsXHJcbiAgJ2J1dHRvbicsXHJcbiAgJ2Jsb2NrcXVvdGUnLFxyXG4gICdib2R5JyxcclxuICAnY2FudmFzJyxcclxuICAnY2FwdGlvbicsXHJcbiAgJ2NvbCcsXHJcbiAgJ2NvbGdyb3VwJyxcclxuICAnZGQnLFxyXG4gICdkaXYnLFxyXG4gICdkbCcsXHJcbiAgJ2R0JyxcclxuICAnZW1iZWQnLFxyXG4gICdmaWVsZHNldCcsXHJcbiAgJ2ZpZ2NhcHRpb24nLFxyXG4gICdmaWd1cmUnLFxyXG4gICdmb290ZXInLFxyXG4gICdmb3JtJyxcclxuICAnaDEnLFxyXG4gICdoMicsXHJcbiAgJ2gzJyxcclxuICAnaDQnLFxyXG4gICdoNScsXHJcbiAgJ2g2JyxcclxuICAnaGVhZGVyJyxcclxuICAnaGdyb3VwJyxcclxuICAnaHInLFxyXG4gICdpZnJhbWUnLFxyXG4gICdsaScsXHJcbiAgJ21hcCcsXHJcbiAgJ29iamVjdCcsXHJcbiAgJ29sJyxcclxuICAnb3V0cHV0JyxcclxuICAncCcsXHJcbiAgJ3ByZScsXHJcbiAgJ3Byb2dyZXNzJyxcclxuICAnc2NyaXB0JyxcclxuICAnc2VjdGlvbicsXHJcbiAgJ3N0eWxlJyxcclxuICAndGFibGUnLFxyXG4gICd0Ym9keScsXHJcbiAgJ3RkJyxcclxuICAndGV4dGFyZWEnLFxyXG4gICd0Zm9vdCcsXHJcbiAgJ3RoJyxcclxuICAndHInLFxyXG4gICd0aGVhZCcsXHJcbiAgJ3VsJyxcclxuICAndmlkZW8nXHJcbl0uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkgeyBodG1sX2Jsb2Nrc1tuYW1lXSA9IHRydWU7IH0pO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaHRtbF9ibG9ja3M7XHJcblxyXG59LHt9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLy8gUmVnZXhwcyB0byBtYXRjaCBodG1sIGVsZW1lbnRzXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgYXR0cl9uYW1lICAgICA9ICdbYS16QS1aXzpdW2EtekEtWjAtOTouXy1dKic7XHJcblxyXG52YXIgdW5xdW90ZWQgICAgICA9ICdbXlwiXFwnPTw+YFxcXFx4MDAtXFxcXHgyMF0rJztcclxudmFyIHNpbmdsZV9xdW90ZWQgPSBcIidbXiddKidcIjtcclxudmFyIGRvdWJsZV9xdW90ZWQgPSAnXCJbXlwiXSpcIic7XHJcblxyXG52YXIgYXR0cl92YWx1ZSAgPSAnKD86JyArIHVucXVvdGVkICsgJ3wnICsgc2luZ2xlX3F1b3RlZCArICd8JyArIGRvdWJsZV9xdW90ZWQgKyAnKSc7XHJcblxyXG52YXIgYXR0cmlidXRlICAgPSAnKD86XFxcXHMrJyArIGF0dHJfbmFtZSArICcoPzpcXFxccyo9XFxcXHMqJyArIGF0dHJfdmFsdWUgKyAnKT8pJztcclxuXHJcbnZhciBvcGVuX3RhZyAgICA9ICc8W0EtWmEtel1bQS1aYS16MC05XFxcXC1dKicgKyBhdHRyaWJ1dGUgKyAnKlxcXFxzKlxcXFwvPz4nO1xyXG5cclxudmFyIGNsb3NlX3RhZyAgID0gJzxcXFxcL1tBLVphLXpdW0EtWmEtejAtOVxcXFwtXSpcXFxccyo+JztcclxudmFyIGNvbW1lbnQgICAgID0gJzwhLS0tLT58PCEtLSg/Oi0/W14+LV0pKD86LT9bXi1dKSotLT4nO1xyXG52YXIgcHJvY2Vzc2luZyAgPSAnPFs/XS4qP1s/XT4nO1xyXG52YXIgZGVjbGFyYXRpb24gPSAnPCFbQS1aXStcXFxccytbXj5dKj4nO1xyXG52YXIgY2RhdGEgICAgICAgPSAnPCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qP1xcXFxdXFxcXF0+JztcclxuXHJcbnZhciBIVE1MX1RBR19SRSA9IG5ldyBSZWdFeHAoJ14oPzonICsgb3Blbl90YWcgKyAnfCcgKyBjbG9zZV90YWcgKyAnfCcgKyBjb21tZW50ICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ3wnICsgcHJvY2Vzc2luZyArICd8JyArIGRlY2xhcmF0aW9uICsgJ3wnICsgY2RhdGEgKyAnKScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuSFRNTF9UQUdfUkUgPSBIVE1MX1RBR19SRTtcclxuXHJcbn0se31dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4vLyBMaXN0IG9mIHZhbGlkIHVybCBzY2hlbWFzLCBhY2NvcnRpbmcgdG8gY29tbW9ubWFyayBzcGVjXHJcbi8vIGh0dHA6Ly9qZ20uZ2l0aHViLmlvL0NvbW1vbk1hcmsvc3BlYy5odG1sI2F1dG9saW5rc1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gW1xyXG4gICdjb2FwJyxcclxuICAnZG9pJyxcclxuICAnamF2YXNjcmlwdCcsXHJcbiAgJ2FhYScsXHJcbiAgJ2FhYXMnLFxyXG4gICdhYm91dCcsXHJcbiAgJ2FjYXAnLFxyXG4gICdjYXAnLFxyXG4gICdjaWQnLFxyXG4gICdjcmlkJyxcclxuICAnZGF0YScsXHJcbiAgJ2RhdicsXHJcbiAgJ2RpY3QnLFxyXG4gICdkbnMnLFxyXG4gICdmaWxlJyxcclxuICAnZnRwJyxcclxuICAnZ2VvJyxcclxuICAnZ28nLFxyXG4gICdnb3BoZXInLFxyXG4gICdoMzIzJyxcclxuICAnaHR0cCcsXHJcbiAgJ2h0dHBzJyxcclxuICAnaWF4JyxcclxuICAnaWNhcCcsXHJcbiAgJ2ltJyxcclxuICAnaW1hcCcsXHJcbiAgJ2luZm8nLFxyXG4gICdpcHAnLFxyXG4gICdpcmlzJyxcclxuICAnaXJpcy5iZWVwJyxcclxuICAnaXJpcy54cGMnLFxyXG4gICdpcmlzLnhwY3MnLFxyXG4gICdpcmlzLmx3eicsXHJcbiAgJ2xkYXAnLFxyXG4gICdtYWlsdG8nLFxyXG4gICdtaWQnLFxyXG4gICdtc3JwJyxcclxuICAnbXNycHMnLFxyXG4gICdtdHFwJyxcclxuICAnbXVwZGF0ZScsXHJcbiAgJ25ld3MnLFxyXG4gICduZnMnLFxyXG4gICduaScsXHJcbiAgJ25paCcsXHJcbiAgJ25udHAnLFxyXG4gICdvcGFxdWVsb2NrdG9rZW4nLFxyXG4gICdwb3AnLFxyXG4gICdwcmVzJyxcclxuICAncnRzcCcsXHJcbiAgJ3NlcnZpY2UnLFxyXG4gICdzZXNzaW9uJyxcclxuICAnc2h0dHAnLFxyXG4gICdzaWV2ZScsXHJcbiAgJ3NpcCcsXHJcbiAgJ3NpcHMnLFxyXG4gICdzbXMnLFxyXG4gICdzbm1wJyxcclxuICAnc29hcC5iZWVwJyxcclxuICAnc29hcC5iZWVwcycsXHJcbiAgJ3RhZycsXHJcbiAgJ3RlbCcsXHJcbiAgJ3RlbG5ldCcsXHJcbiAgJ3RmdHAnLFxyXG4gICd0aGlzbWVzc2FnZScsXHJcbiAgJ3RuMzI3MCcsXHJcbiAgJ3RpcCcsXHJcbiAgJ3R2JyxcclxuICAndXJuJyxcclxuICAndmVtbWknLFxyXG4gICd3cycsXHJcbiAgJ3dzcycsXHJcbiAgJ3hjb24nLFxyXG4gICd4Y29uLXVzZXJpZCcsXHJcbiAgJ3htbHJwYy5iZWVwJyxcclxuICAneG1scnBjLmJlZXBzJyxcclxuICAneG1wcCcsXHJcbiAgJ3ozOS41MHInLFxyXG4gICd6MzkuNTBzJyxcclxuICAnYWRpdW14dHJhJyxcclxuICAnYWZwJyxcclxuICAnYWZzJyxcclxuICAnYWltJyxcclxuICAnYXB0JyxcclxuICAnYXR0YWNobWVudCcsXHJcbiAgJ2F3JyxcclxuICAnYmVzaGFyZScsXHJcbiAgJ2JpdGNvaW4nLFxyXG4gICdib2xvJyxcclxuICAnY2FsbHRvJyxcclxuICAnY2hyb21lJyxcclxuICAnY2hyb21lLWV4dGVuc2lvbicsXHJcbiAgJ2NvbS1ldmVudGJyaXRlLWF0dGVuZGVlJyxcclxuICAnY29udGVudCcsXHJcbiAgJ2N2cycsXHJcbiAgJ2RsbmEtcGxheXNpbmdsZScsXHJcbiAgJ2RsbmEtcGxheWNvbnRhaW5lcicsXHJcbiAgJ2R0bicsXHJcbiAgJ2R2YicsXHJcbiAgJ2VkMmsnLFxyXG4gICdmYWNldGltZScsXHJcbiAgJ2ZlZWQnLFxyXG4gICdmaW5nZXInLFxyXG4gICdmaXNoJyxcclxuICAnZ2cnLFxyXG4gICdnaXQnLFxyXG4gICdnaXptb3Byb2plY3QnLFxyXG4gICdndGFsaycsXHJcbiAgJ2hjcCcsXHJcbiAgJ2ljb24nLFxyXG4gICdpcG4nLFxyXG4gICdpcmMnLFxyXG4gICdpcmM2JyxcclxuICAnaXJjcycsXHJcbiAgJ2l0bXMnLFxyXG4gICdqYXInLFxyXG4gICdqbXMnLFxyXG4gICdrZXlwYXJjJyxcclxuICAnbGFzdGZtJyxcclxuICAnbGRhcHMnLFxyXG4gICdtYWduZXQnLFxyXG4gICdtYXBzJyxcclxuICAnbWFya2V0JyxcclxuICAnbWVzc2FnZScsXHJcbiAgJ21tcycsXHJcbiAgJ21zLWhlbHAnLFxyXG4gICdtc25pbScsXHJcbiAgJ211bWJsZScsXHJcbiAgJ212bicsXHJcbiAgJ25vdGVzJyxcclxuICAnb2lkJyxcclxuICAncGFsbScsXHJcbiAgJ3BhcGFyYXp6aScsXHJcbiAgJ3BsYXRmb3JtJyxcclxuICAncHJveHknLFxyXG4gICdwc3ljJyxcclxuICAncXVlcnknLFxyXG4gICdyZXMnLFxyXG4gICdyZXNvdXJjZScsXHJcbiAgJ3JtaScsXHJcbiAgJ3JzeW5jJyxcclxuICAncnRtcCcsXHJcbiAgJ3NlY29uZGxpZmUnLFxyXG4gICdzZnRwJyxcclxuICAnc2duJyxcclxuICAnc2t5cGUnLFxyXG4gICdzbWInLFxyXG4gICdzb2xkYXQnLFxyXG4gICdzcG90aWZ5JyxcclxuICAnc3NoJyxcclxuICAnc3RlYW0nLFxyXG4gICdzdm4nLFxyXG4gICd0ZWFtc3BlYWsnLFxyXG4gICd0aGluZ3MnLFxyXG4gICd1ZHAnLFxyXG4gICd1bnJlYWwnLFxyXG4gICd1dDIwMDQnLFxyXG4gICd2ZW50cmlsbycsXHJcbiAgJ3ZpZXctc291cmNlJyxcclxuICAnd2ViY2FsJyxcclxuICAnd3RhaScsXHJcbiAgJ3d5Y2l3eWcnLFxyXG4gICd4ZmlyZScsXHJcbiAgJ3hyaScsXHJcbiAgJ3ltc2dyJ1xyXG5dO1xyXG5cclxufSx7fV0sNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8vIFV0aWxpdGllc1xyXG4vL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5cclxuZnVuY3Rpb24gX2NsYXNzKG9iaikgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7IH1cclxuXHJcbmZ1bmN0aW9uIGlzU3RyaW5nKG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nOyB9XHJcblxyXG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuXHJcbmZ1bmN0aW9uIGhhcyhvYmplY3QsIGtleSkge1xyXG4gIHJldHVybiBfaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XHJcbn1cclxuXHJcbi8vIE1lcmdlIG9iamVjdHNcclxuLy9cclxuZnVuY3Rpb24gYXNzaWduKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7XHJcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cclxuICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgaWYgKCFzb3VyY2UpIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgb2JqZWN0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG4vLyBSZW1vdmUgZWxlbWVudCBmcm9tIGFycmF5IGFuZCBwdXQgYW5vdGhlciBhcnJheSBhdCB0aG9zZSBwb3NpdGlvbi5cclxuLy8gVXNlZnVsIGZvciBzb21lIG9wZXJhdGlvbnMgd2l0aCB0b2tlbnNcclxuZnVuY3Rpb24gYXJyYXlSZXBsYWNlQXQoc3JjLCBwb3MsIG5ld0VsZW1lbnRzKSB7XHJcbiAgcmV0dXJuIFtdLmNvbmNhdChzcmMuc2xpY2UoMCwgcG9zKSwgbmV3RWxlbWVudHMsIHNyYy5zbGljZShwb3MgKyAxKSk7XHJcbn1cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5mdW5jdGlvbiBpc1ZhbGlkRW50aXR5Q29kZShjKSB7XHJcbiAgLyplc2xpbnQgbm8tYml0d2lzZTowKi9cclxuICAvLyBicm9rZW4gc2VxdWVuY2VcclxuICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERGRkYpIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgLy8gbmV2ZXIgdXNlZFxyXG4gIGlmIChjID49IDB4RkREMCAmJiBjIDw9IDB4RkRFRikgeyByZXR1cm4gZmFsc2U7IH1cclxuICBpZiAoKGMgJiAweEZGRkYpID09PSAweEZGRkYgfHwgKGMgJiAweEZGRkYpID09PSAweEZGRkUpIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgLy8gY29udHJvbCBjb2Rlc1xyXG4gIGlmIChjID49IDB4MDAgJiYgYyA8PSAweDA4KSB7IHJldHVybiBmYWxzZTsgfVxyXG4gIGlmIChjID09PSAweDBCKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gIGlmIChjID49IDB4MEUgJiYgYyA8PSAweDFGKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gIGlmIChjID49IDB4N0YgJiYgYyA8PSAweDlGKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gIC8vIG91dCBvZiByYW5nZVxyXG4gIGlmIChjID4gMHgxMEZGRkYpIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoYykge1xyXG4gIC8qZXNsaW50IG5vLWJpdHdpc2U6MCovXHJcbiAgaWYgKGMgPiAweGZmZmYpIHtcclxuICAgIGMgLT0gMHgxMDAwMDtcclxuICAgIHZhciBzdXJyb2dhdGUxID0gMHhkODAwICsgKGMgPj4gMTApLFxyXG4gICAgICAgIHN1cnJvZ2F0ZTIgPSAweGRjMDAgKyAoYyAmIDB4M2ZmKTtcclxuXHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShzdXJyb2dhdGUxLCBzdXJyb2dhdGUyKTtcclxuICB9XHJcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XHJcbn1cclxuXHJcblxyXG52YXIgVU5FU0NBUEVfTURfUkUgID0gL1xcXFwoWyFcIiMkJSYnKCkqKyxcXC0uXFwvOjs8PT4/QFtcXFxcXFxdXl9ge3x9fl0pL2c7XHJcbnZhciBFTlRJVFlfUkUgICAgICAgPSAvJihbYS16I11bYS16MC05XXsxLDMxfSk7L2dpO1xyXG52YXIgVU5FU0NBUEVfQUxMX1JFID0gbmV3IFJlZ0V4cChVTkVTQ0FQRV9NRF9SRS5zb3VyY2UgKyAnfCcgKyBFTlRJVFlfUkUuc291cmNlLCAnZ2knKTtcclxuXHJcbnZhciBESUdJVEFMX0VOVElUWV9URVNUX1JFID0gL14jKCg/OnhbYS1mMC05XXsxLDh9fFswLTldezEsOH0pKS9pO1xyXG5cclxudmFyIGVudGl0aWVzID0gcmVxdWlyZSgnLi9lbnRpdGllcycpO1xyXG5cclxuZnVuY3Rpb24gcmVwbGFjZUVudGl0eVBhdHRlcm4obWF0Y2gsIG5hbWUpIHtcclxuICB2YXIgY29kZSA9IDA7XHJcblxyXG4gIGlmIChoYXMoZW50aXRpZXMsIG5hbWUpKSB7XHJcbiAgICByZXR1cm4gZW50aXRpZXNbbmFtZV07XHJcbiAgfVxyXG5cclxuICBpZiAobmFtZS5jaGFyQ29kZUF0KDApID09PSAweDIzLyogIyAqLyAmJiBESUdJVEFMX0VOVElUWV9URVNUX1JFLnRlc3QobmFtZSkpIHtcclxuICAgIGNvZGUgPSBuYW1lWzFdLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/XHJcbiAgICAgIHBhcnNlSW50KG5hbWUuc2xpY2UoMiksIDE2KVxyXG4gICAgOlxyXG4gICAgICBwYXJzZUludChuYW1lLnNsaWNlKDEpLCAxMCk7XHJcbiAgICBpZiAoaXNWYWxpZEVudGl0eUNvZGUoY29kZSkpIHtcclxuICAgICAgcmV0dXJuIGZyb21Db2RlUG9pbnQoY29kZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbWF0Y2g7XHJcbn1cclxuXHJcbi8qZnVuY3Rpb24gcmVwbGFjZUVudGl0aWVzKHN0cikge1xyXG4gIGlmIChzdHIuaW5kZXhPZignJicpIDwgMCkgeyByZXR1cm4gc3RyOyB9XHJcblxyXG4gIHJldHVybiBzdHIucmVwbGFjZShFTlRJVFlfUkUsIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKTtcclxufSovXHJcblxyXG5mdW5jdGlvbiB1bmVzY2FwZU1kKHN0cikge1xyXG4gIGlmIChzdHIuaW5kZXhPZignXFxcXCcpIDwgMCkgeyByZXR1cm4gc3RyOyB9XHJcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKFVORVNDQVBFX01EX1JFLCAnJDEnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdW5lc2NhcGVBbGwoc3RyKSB7XHJcbiAgaWYgKHN0ci5pbmRleE9mKCdcXFxcJykgPCAwICYmIHN0ci5pbmRleE9mKCcmJykgPCAwKSB7IHJldHVybiBzdHI7IH1cclxuXHJcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKFVORVNDQVBFX0FMTF9SRSwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZWQsIGVudGl0eSkge1xyXG4gICAgaWYgKGVzY2FwZWQpIHsgcmV0dXJuIGVzY2FwZWQ7IH1cclxuICAgIHJldHVybiByZXBsYWNlRW50aXR5UGF0dGVybihtYXRjaCwgZW50aXR5KTtcclxuICB9KTtcclxufVxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbnZhciBIVE1MX0VTQ0FQRV9URVNUX1JFID0gL1smPD5cIl0vO1xyXG52YXIgSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSA9IC9bJjw+XCJdL2c7XHJcbnZhciBIVE1MX1JFUExBQ0VNRU5UUyA9IHtcclxuICAnJic6ICcmYW1wOycsXHJcbiAgJzwnOiAnJmx0OycsXHJcbiAgJz4nOiAnJmd0OycsXHJcbiAgJ1wiJzogJyZxdW90OydcclxufTtcclxuXHJcbmZ1bmN0aW9uIHJlcGxhY2VVbnNhZmVDaGFyKGNoKSB7XHJcbiAgcmV0dXJuIEhUTUxfUkVQTEFDRU1FTlRTW2NoXTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHIpIHtcclxuICBpZiAoSFRNTF9FU0NBUEVfVEVTVF9SRS50ZXN0KHN0cikpIHtcclxuICAgIHJldHVybiBzdHIucmVwbGFjZShIVE1MX0VTQ0FQRV9SRVBMQUNFX1JFLCByZXBsYWNlVW5zYWZlQ2hhcik7XHJcbiAgfVxyXG4gIHJldHVybiBzdHI7XHJcbn1cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG52YXIgUkVHRVhQX0VTQ0FQRV9SRSA9IC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2c7XHJcblxyXG5mdW5jdGlvbiBlc2NhcGVSRSAoc3RyKSB7XHJcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKFJFR0VYUF9FU0NBUEVfUkUsICdcXFxcJCYnKTtcclxufVxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8vIFpzICh1bmljb2RlIGNsYXNzKSB8fCBbXFx0XFxmXFx2XFxyXFxuXVxyXG5mdW5jdGlvbiBpc1doaXRlU3BhY2UoY29kZSkge1xyXG4gIGlmIChjb2RlID49IDB4MjAwMCAmJiBjb2RlIDw9IDB4MjAwQSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG4gIHN3aXRjaCAoY29kZSkge1xyXG4gICAgY2FzZSAweDA5OiAvLyBcXHRcclxuICAgIGNhc2UgMHgwQTogLy8gXFxuXHJcbiAgICBjYXNlIDB4MEI6IC8vIFxcdlxyXG4gICAgY2FzZSAweDBDOiAvLyBcXGZcclxuICAgIGNhc2UgMHgwRDogLy8gXFxyXHJcbiAgICBjYXNlIDB4MjA6XHJcbiAgICBjYXNlIDB4QTA6XHJcbiAgICBjYXNlIDB4MTY4MDpcclxuICAgIGNhc2UgMHgyMDJGOlxyXG4gICAgY2FzZSAweDIwNUY6XHJcbiAgICBjYXNlIDB4MzAwMDpcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qZXNsaW50LWRpc2FibGUgbWF4LWxlbiovXHJcbnZhciBVTklDT0RFX1BVTkNUX1JFID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4Jyk7XHJcblxyXG4vLyBDdXJyZW50bHkgd2l0aG91dCBhc3RyYWwgY2hhcmFjdGVycyBzdXBwb3J0LlxyXG5mdW5jdGlvbiBpc1B1bmN0Q2hhcihjaGFyKSB7XHJcbiAgcmV0dXJuIFVOSUNPREVfUFVOQ1RfUkUudGVzdChjaGFyKTtcclxufVxyXG5cclxuXHJcbi8vIE1hcmtkb3duIEFTQ0lJIHB1bmN0dWF0aW9uIGNoYXJhY3RlcnMuXHJcbi8vXHJcbi8vICEsIFwiLCAjLCAkLCAlLCAmLCAnLCAoLCApLCAqLCArLCAsLCAtLCAuLCAvLCA6LCA7LCA8LCA9LCA+LCA/LCBALCBbLCBcXCwgXSwgXiwgXywgYCwgeywgfCwgfSwgb3IgflxyXG4vLyBodHRwOi8vc3BlYy5jb21tb25tYXJrLm9yZy8wLjE1LyNhc2NpaS1wdW5jdHVhdGlvbi1jaGFyYWN0ZXJcclxuLy9cclxuLy8gRG9uJ3QgY29uZnVzZSB3aXRoIHVuaWNvZGUgcHVuY3R1YXRpb24gISEhIEl0IGxhY2tzIHNvbWUgY2hhcnMgaW4gYXNjaWkgcmFuZ2UuXHJcbi8vXHJcbmZ1bmN0aW9uIGlzTWRBc2NpaVB1bmN0KGNoKSB7XHJcbiAgc3dpdGNoIChjaCkge1xyXG4gICAgY2FzZSAweDIxLyogISAqLzpcclxuICAgIGNhc2UgMHgyMi8qIFwiICovOlxyXG4gICAgY2FzZSAweDIzLyogIyAqLzpcclxuICAgIGNhc2UgMHgyNC8qICQgKi86XHJcbiAgICBjYXNlIDB4MjUvKiAlICovOlxyXG4gICAgY2FzZSAweDI2LyogJiAqLzpcclxuICAgIGNhc2UgMHgyNy8qICcgKi86XHJcbiAgICBjYXNlIDB4MjgvKiAoICovOlxyXG4gICAgY2FzZSAweDI5LyogKSAqLzpcclxuICAgIGNhc2UgMHgyQS8qICogKi86XHJcbiAgICBjYXNlIDB4MkIvKiArICovOlxyXG4gICAgY2FzZSAweDJDLyogLCAqLzpcclxuICAgIGNhc2UgMHgyRC8qIC0gKi86XHJcbiAgICBjYXNlIDB4MkUvKiAuICovOlxyXG4gICAgY2FzZSAweDJGLyogLyAqLzpcclxuICAgIGNhc2UgMHgzQS8qIDogKi86XHJcbiAgICBjYXNlIDB4M0IvKiA7ICovOlxyXG4gICAgY2FzZSAweDNDLyogPCAqLzpcclxuICAgIGNhc2UgMHgzRC8qID0gKi86XHJcbiAgICBjYXNlIDB4M0UvKiA+ICovOlxyXG4gICAgY2FzZSAweDNGLyogPyAqLzpcclxuICAgIGNhc2UgMHg0MC8qIEAgKi86XHJcbiAgICBjYXNlIDB4NUIvKiBbICovOlxyXG4gICAgY2FzZSAweDVDLyogXFwgKi86XHJcbiAgICBjYXNlIDB4NUQvKiBdICovOlxyXG4gICAgY2FzZSAweDVFLyogXiAqLzpcclxuICAgIGNhc2UgMHg1Ri8qIF8gKi86XHJcbiAgICBjYXNlIDB4NjAvKiBgICovOlxyXG4gICAgY2FzZSAweDdCLyogeyAqLzpcclxuICAgIGNhc2UgMHg3Qy8qIHwgKi86XHJcbiAgICBjYXNlIDB4N0QvKiB9ICovOlxyXG4gICAgY2FzZSAweDdFLyogfiAqLzpcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBIZXBsZXIgdG8gdW5pZnkgW3JlZmVyZW5jZSBsYWJlbHNdLlxyXG4vL1xyXG5mdW5jdGlvbiBub3JtYWxpemVSZWZlcmVuY2Uoc3RyKSB7XHJcbiAgLy8gdXNlIC50b1VwcGVyQ2FzZSgpIGluc3RlYWQgb2YgLnRvTG93ZXJDYXNlKClcclxuICAvLyBoZXJlIHRvIGF2b2lkIGEgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlXHJcbiAgLy8gbWVtYmVycyAobW9zdCBub3RhYmx5LCBgX19wcm90b19fYClcclxuICByZXR1cm4gc3RyLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csICcgJykudG9VcHBlckNhc2UoKTtcclxufVxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8vIFJlLWV4cG9ydCBsaWJyYXJpZXMgY29tbW9ubHkgdXNlZCBpbiBib3RoIG1hcmtkb3duLWl0IGFuZCBpdHMgcGx1Z2lucyxcclxuLy8gc28gcGx1Z2lucyB3b24ndCBoYXZlIHRvIGRlcGVuZCBvbiB0aGVtIGV4cGxpY2l0bHksIHdoaWNoIHJlZHVjZXMgdGhlaXJcclxuLy8gYnVuZGxlZCBzaXplIChlLmcuIGEgYnJvd3NlciBidWlsZCkuXHJcbi8vXHJcbmV4cG9ydHMubGliICAgICAgICAgICAgICAgICA9IHt9O1xyXG5leHBvcnRzLmxpYi5tZHVybCAgICAgICAgICAgPSByZXF1aXJlKCdtZHVybCcpO1xyXG5leHBvcnRzLmxpYi51Y21pY3JvICAgICAgICAgPSByZXF1aXJlKCd1Yy5taWNybycpO1xyXG5cclxuZXhwb3J0cy5hc3NpZ24gICAgICAgICAgICAgID0gYXNzaWduO1xyXG5leHBvcnRzLmlzU3RyaW5nICAgICAgICAgICAgPSBpc1N0cmluZztcclxuZXhwb3J0cy5oYXMgICAgICAgICAgICAgICAgID0gaGFzO1xyXG5leHBvcnRzLnVuZXNjYXBlTWQgICAgICAgICAgPSB1bmVzY2FwZU1kO1xyXG5leHBvcnRzLnVuZXNjYXBlQWxsICAgICAgICAgPSB1bmVzY2FwZUFsbDtcclxuZXhwb3J0cy5pc1ZhbGlkRW50aXR5Q29kZSAgID0gaXNWYWxpZEVudGl0eUNvZGU7XHJcbmV4cG9ydHMuZnJvbUNvZGVQb2ludCAgICAgICA9IGZyb21Db2RlUG9pbnQ7XHJcbi8vIGV4cG9ydHMucmVwbGFjZUVudGl0aWVzICAgICA9IHJlcGxhY2VFbnRpdGllcztcclxuZXhwb3J0cy5lc2NhcGVIdG1sICAgICAgICAgID0gZXNjYXBlSHRtbDtcclxuZXhwb3J0cy5hcnJheVJlcGxhY2VBdCAgICAgID0gYXJyYXlSZXBsYWNlQXQ7XHJcbmV4cG9ydHMuaXNXaGl0ZVNwYWNlICAgICAgICA9IGlzV2hpdGVTcGFjZTtcclxuZXhwb3J0cy5pc01kQXNjaWlQdW5jdCAgICAgID0gaXNNZEFzY2lpUHVuY3Q7XHJcbmV4cG9ydHMuaXNQdW5jdENoYXIgICAgICAgICA9IGlzUHVuY3RDaGFyO1xyXG5leHBvcnRzLmVzY2FwZVJFICAgICAgICAgICAgPSBlc2NhcGVSRTtcclxuZXhwb3J0cy5ub3JtYWxpemVSZWZlcmVuY2UgID0gbm9ybWFsaXplUmVmZXJlbmNlO1xyXG5cclxufSx7XCIuL2VudGl0aWVzXCI6MSxcIm1kdXJsXCI6NTgsXCJ1Yy5taWNyb1wiOjY0LFwidWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4XCI6NjJ9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLy8gSnVzdCBhIHNob3J0Y3V0IGZvciBidWxrIGV4cG9ydFxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5cclxuZXhwb3J0cy5wYXJzZUxpbmtMYWJlbCAgICAgICA9IHJlcXVpcmUoJy4vcGFyc2VfbGlua19sYWJlbCcpO1xyXG5leHBvcnRzLnBhcnNlTGlua0Rlc3RpbmF0aW9uID0gcmVxdWlyZSgnLi9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uJyk7XHJcbmV4cG9ydHMucGFyc2VMaW5rVGl0bGUgICAgICAgPSByZXF1aXJlKCcuL3BhcnNlX2xpbmtfdGl0bGUnKTtcclxuXHJcbn0se1wiLi9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uXCI6NyxcIi4vcGFyc2VfbGlua19sYWJlbFwiOjgsXCIuL3BhcnNlX2xpbmtfdGl0bGVcIjo5fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8vIFBhcnNlIGxpbmsgZGVzdGluYXRpb25cclxuLy9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciB1bmVzY2FwZUFsbCAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykudW5lc2NhcGVBbGw7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUxpbmtEZXN0aW5hdGlvbihzdHIsIHBvcywgbWF4KSB7XHJcbiAgdmFyIGNvZGUsIGxldmVsLFxyXG4gICAgICBsaW5lcyA9IDAsXHJcbiAgICAgIHN0YXJ0ID0gcG9zLFxyXG4gICAgICByZXN1bHQgPSB7XHJcbiAgICAgICAgb2s6IGZhbHNlLFxyXG4gICAgICAgIHBvczogMCxcclxuICAgICAgICBsaW5lczogMCxcclxuICAgICAgICBzdHI6ICcnXHJcbiAgICAgIH07XHJcblxyXG4gIGlmIChzdHIuY2hhckNvZGVBdChwb3MpID09PSAweDNDIC8qIDwgKi8pIHtcclxuICAgIHBvcysrO1xyXG4gICAgd2hpbGUgKHBvcyA8IG1heCkge1xyXG4gICAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcclxuICAgICAgaWYgKGNvZGUgPT09IDB4MEEgLyogXFxuICovKSB7IHJldHVybiByZXN1bHQ7IH1cclxuICAgICAgaWYgKGNvZGUgPT09IDB4M0UgLyogPiAqLykge1xyXG4gICAgICAgIHJlc3VsdC5wb3MgPSBwb3MgKyAxO1xyXG4gICAgICAgIHJlc3VsdC5zdHIgPSB1bmVzY2FwZUFsbChzdHIuc2xpY2Uoc3RhcnQgKyAxLCBwb3MpKTtcclxuICAgICAgICByZXN1bHQub2sgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNvZGUgPT09IDB4NUMgLyogXFwgKi8gJiYgcG9zICsgMSA8IG1heCkge1xyXG4gICAgICAgIHBvcyArPSAyO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwb3MrKztcclxuICAgIH1cclxuXHJcbiAgICAvLyBubyBjbG9zaW5nICc+J1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIC8vIHRoaXMgc2hvdWxkIGJlIC4uLiB9IGVsc2UgeyAuLi4gYnJhbmNoXHJcblxyXG4gIGxldmVsID0gMDtcclxuICB3aGlsZSAocG9zIDwgbWF4KSB7XHJcbiAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcclxuXHJcbiAgICBpZiAoY29kZSA9PT0gMHgyMCkgeyBicmVhazsgfVxyXG5cclxuICAgIC8vIGFzY2lpIGNvbnRyb2wgY2hhcmFjdGVyc1xyXG4gICAgaWYgKGNvZGUgPCAweDIwIHx8IGNvZGUgPT09IDB4N0YpIHsgYnJlYWs7IH1cclxuXHJcbiAgICBpZiAoY29kZSA9PT0gMHg1QyAvKiBcXCAqLyAmJiBwb3MgKyAxIDwgbWF4KSB7XHJcbiAgICAgIHBvcyArPSAyO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY29kZSA9PT0gMHgyOCAvKiAoICovKSB7XHJcbiAgICAgIGxldmVsKys7XHJcbiAgICAgIGlmIChsZXZlbCA+IDEpIHsgYnJlYWs7IH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoY29kZSA9PT0gMHgyOSAvKiApICovKSB7XHJcbiAgICAgIGxldmVsLS07XHJcbiAgICAgIGlmIChsZXZlbCA8IDApIHsgYnJlYWs7IH1cclxuICAgIH1cclxuXHJcbiAgICBwb3MrKztcclxuICB9XHJcblxyXG4gIGlmIChzdGFydCA9PT0gcG9zKSB7IHJldHVybiByZXN1bHQ7IH1cclxuXHJcbiAgcmVzdWx0LnN0ciA9IHVuZXNjYXBlQWxsKHN0ci5zbGljZShzdGFydCwgcG9zKSk7XHJcbiAgcmVzdWx0LmxpbmVzID0gbGluZXM7XHJcbiAgcmVzdWx0LnBvcyA9IHBvcztcclxuICByZXN1bHQub2sgPSB0cnVlO1xyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG59LHtcIi4uL2NvbW1vbi91dGlsc1wiOjV9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLy8gUGFyc2UgbGluayBsYWJlbFxyXG4vL1xyXG4vLyB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBmaXJzdCBjaGFyYWN0ZXIgKFwiW1wiKSBhbHJlYWR5IG1hdGNoZXM7XHJcbi8vIHJldHVybnMgdGhlIGVuZCBvZiB0aGUgbGFiZWxcclxuLy9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUxpbmtMYWJlbChzdGF0ZSwgc3RhcnQsIGRpc2FibGVOZXN0ZWQpIHtcclxuICB2YXIgbGV2ZWwsIGZvdW5kLCBtYXJrZXIsIHByZXZQb3MsXHJcbiAgICAgIGxhYmVsRW5kID0gLTEsXHJcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heCxcclxuICAgICAgb2xkUG9zID0gc3RhdGUucG9zO1xyXG5cclxuICBzdGF0ZS5wb3MgPSBzdGFydCArIDE7XHJcbiAgbGV2ZWwgPSAxO1xyXG5cclxuICB3aGlsZSAoc3RhdGUucG9zIDwgbWF4KSB7XHJcbiAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpO1xyXG4gICAgaWYgKG1hcmtlciA9PT0gMHg1RCAvKiBdICovKSB7XHJcbiAgICAgIGxldmVsLS07XHJcbiAgICAgIGlmIChsZXZlbCA9PT0gMCkge1xyXG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByZXZQb3MgPSBzdGF0ZS5wb3M7XHJcbiAgICBzdGF0ZS5tZC5pbmxpbmUuc2tpcFRva2VuKHN0YXRlKTtcclxuICAgIGlmIChtYXJrZXIgPT09IDB4NUIgLyogWyAqLykge1xyXG4gICAgICBpZiAocHJldlBvcyA9PT0gc3RhdGUucG9zIC0gMSkge1xyXG4gICAgICAgIC8vIGluY3JlYXNlIGxldmVsIGlmIHdlIGZpbmQgdGV4dCBgW2AsIHdoaWNoIGlzIG5vdCBhIHBhcnQgb2YgYW55IHRva2VuXHJcbiAgICAgICAgbGV2ZWwrKztcclxuICAgICAgfSBlbHNlIGlmIChkaXNhYmxlTmVzdGVkKSB7XHJcbiAgICAgICAgc3RhdGUucG9zID0gb2xkUG9zO1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGZvdW5kKSB7XHJcbiAgICBsYWJlbEVuZCA9IHN0YXRlLnBvcztcclxuICB9XHJcblxyXG4gIC8vIHJlc3RvcmUgb2xkIHN0YXRlXHJcbiAgc3RhdGUucG9zID0gb2xkUG9zO1xyXG5cclxuICByZXR1cm4gbGFiZWxFbmQ7XHJcbn07XHJcblxyXG59LHt9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLy8gUGFyc2UgbGluayB0aXRsZVxyXG4vL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHVuZXNjYXBlQWxsID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykudW5lc2NhcGVBbGw7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUxpbmtUaXRsZShzdHIsIHBvcywgbWF4KSB7XHJcbiAgdmFyIGNvZGUsXHJcbiAgICAgIG1hcmtlcixcclxuICAgICAgbGluZXMgPSAwLFxyXG4gICAgICBzdGFydCA9IHBvcyxcclxuICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgIG9rOiBmYWxzZSxcclxuICAgICAgICBwb3M6IDAsXHJcbiAgICAgICAgbGluZXM6IDAsXHJcbiAgICAgICAgc3RyOiAnJ1xyXG4gICAgICB9O1xyXG5cclxuICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gcmVzdWx0OyB9XHJcblxyXG4gIG1hcmtlciA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XHJcblxyXG4gIGlmIChtYXJrZXIgIT09IDB4MjIgLyogXCIgKi8gJiYgbWFya2VyICE9PSAweDI3IC8qICcgKi8gJiYgbWFya2VyICE9PSAweDI4IC8qICggKi8pIHsgcmV0dXJuIHJlc3VsdDsgfVxyXG5cclxuICBwb3MrKztcclxuXHJcbiAgLy8gaWYgb3BlbmluZyBtYXJrZXIgaXMgXCIoXCIsIHN3aXRjaCBpdCB0byBjbG9zaW5nIG1hcmtlciBcIilcIlxyXG4gIGlmIChtYXJrZXIgPT09IDB4MjgpIHsgbWFya2VyID0gMHgyOTsgfVxyXG5cclxuICB3aGlsZSAocG9zIDwgbWF4KSB7XHJcbiAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcclxuICAgIGlmIChjb2RlID09PSBtYXJrZXIpIHtcclxuICAgICAgcmVzdWx0LnBvcyA9IHBvcyArIDE7XHJcbiAgICAgIHJlc3VsdC5saW5lcyA9IGxpbmVzO1xyXG4gICAgICByZXN1bHQuc3RyID0gdW5lc2NhcGVBbGwoc3RyLnNsaWNlKHN0YXJ0ICsgMSwgcG9zKSk7XHJcbiAgICAgIHJlc3VsdC5vayA9IHRydWU7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MEEpIHtcclxuICAgICAgbGluZXMrKztcclxuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1QyAvKiBcXCAqLyAmJiBwb3MgKyAxIDwgbWF4KSB7XHJcbiAgICAgIHBvcysrO1xyXG4gICAgICBpZiAoc3RyLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwQSkge1xyXG4gICAgICAgIGxpbmVzKys7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwb3MrKztcclxuICB9XHJcblxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG59LHtcIi4uL2NvbW1vbi91dGlsc1wiOjV9XSwxMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8vIE1haW4gcGVyc2VyIGNsYXNzXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJyk7XHJcbnZhciBoZWxwZXJzICAgICAgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcclxudmFyIFJlbmRlcmVyICAgICA9IHJlcXVpcmUoJy4vcmVuZGVyZXInKTtcclxudmFyIFBhcnNlckNvcmUgICA9IHJlcXVpcmUoJy4vcGFyc2VyX2NvcmUnKTtcclxudmFyIFBhcnNlckJsb2NrICA9IHJlcXVpcmUoJy4vcGFyc2VyX2Jsb2NrJyk7XHJcbnZhciBQYXJzZXJJbmxpbmUgPSByZXF1aXJlKCcuL3BhcnNlcl9pbmxpbmUnKTtcclxudmFyIExpbmtpZnlJdCAgICA9IHJlcXVpcmUoJ2xpbmtpZnktaXQnKTtcclxudmFyIG1kdXJsICAgICAgICA9IHJlcXVpcmUoJ21kdXJsJyk7XHJcbnZhciBwdW55Y29kZSAgICAgPSByZXF1aXJlKCdwdW55Y29kZScpO1xyXG5cclxuXHJcbnZhciBjb25maWcgPSB7XHJcbiAgJ2RlZmF1bHQnOiByZXF1aXJlKCcuL3ByZXNldHMvZGVmYXVsdCcpLFxyXG4gIHplcm86IHJlcXVpcmUoJy4vcHJlc2V0cy96ZXJvJyksXHJcbiAgY29tbW9ubWFyazogcmVxdWlyZSgnLi9wcmVzZXRzL2NvbW1vbm1hcmsnKVxyXG59O1xyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9cclxuLy8gVGhpcyB2YWxpZGF0b3IgZG9lcyBub3QgcHJldGVuZCB0byBmdW5jdGlvbmFsaXR5IG9mIGZ1bGwgd2VpZ2h0IHNhbml0aXplcnMuXHJcbi8vIEl0J3MgYSB0cmFkZW9mZiBiZXR3ZWVuIGRlZmF1bHQgc2VjdXJpdHksIHNpbXBsaWNpdHkgYW5kIHVzYWJpbGl0eS5cclxuLy8gSWYgeW91IG5lZWQgZGlmZmVyZW50IHNldHVwIC0gb3ZlcnJpZGUgdmFsaWRhdG9yIG1ldGhvZCBhcyB5b3Ugd2lzaC4gT3JcclxuLy8gcmVwbGFjZSBpdCB3aXRoIGR1bW15IGZ1bmN0aW9uIGFuZCB1c2UgZXh0ZXJuYWwgc2FuaXRpemVyLlxyXG4vL1xyXG5cclxudmFyIEJBRF9QUk9UT19SRSA9IC9eKHZic2NyaXB0fGphdmFzY3JpcHR8ZmlsZXxkYXRhKTovO1xyXG52YXIgR09PRF9EQVRBX1JFID0gL15kYXRhOmltYWdlXFwvKGdpZnxwbmd8anBlZ3x3ZWJwKTsvO1xyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGVMaW5rKHVybCkge1xyXG4gIC8vIHVybCBzaG91bGQgYmUgbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50LCBhbmQgZXhpc3RpbmcgZW50aXRpZXMgYXJlIGRlY29kZWRcclxuICB2YXIgc3RyID0gdXJsLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICByZXR1cm4gQkFEX1BST1RPX1JFLnRlc3Qoc3RyKSA/IChHT09EX0RBVEFfUkUudGVzdChzdHIpID8gdHJ1ZSA6IGZhbHNlKSA6IHRydWU7XHJcbn1cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5cclxudmFyIFJFQ09ERV9IT1NUTkFNRV9GT1IgPSBbICdodHRwOicsICdodHRwczonLCAnbWFpbHRvOicgXTtcclxuXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUxpbmsodXJsKSB7XHJcbiAgdmFyIHBhcnNlZCA9IG1kdXJsLnBhcnNlKHVybCwgdHJ1ZSk7XHJcblxyXG4gIGlmIChwYXJzZWQuaG9zdG5hbWUpIHtcclxuICAgIC8vIEVuY29kZSBob3N0bmFtZXMgaW4gdXJscyBsaWtlOlxyXG4gICAgLy8gYGh0dHA6Ly9ob3N0L2AsIGBodHRwczovL2hvc3QvYCwgYG1haWx0bzp1c2VyQGhvc3RgLCBgLy9ob3N0L2BcclxuICAgIC8vXHJcbiAgICAvLyBXZSBkb24ndCBlbmNvZGUgdW5rbm93biBzY2hlbWFzLCBiZWNhdXNlIGl0J3MgbGlrZWx5IHRoYXQgd2UgZW5jb2RlXHJcbiAgICAvLyBzb21ldGhpbmcgd2Ugc2hvdWxkbid0IChlLmcuIGBza3lwZTpuYW1lYCB0cmVhdGVkIGFzIGBza3lwZTpob3N0YClcclxuICAgIC8vXHJcbiAgICBpZiAoIXBhcnNlZC5wcm90b2NvbCB8fCBSRUNPREVfSE9TVE5BTUVfRk9SLmluZGV4T2YocGFyc2VkLnByb3RvY29sKSA+PSAwKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcGFyc2VkLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSShwYXJzZWQuaG9zdG5hbWUpO1xyXG4gICAgICB9IGNhdGNoKGVyKSB7fVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG1kdXJsLmVuY29kZShtZHVybC5mb3JtYXQocGFyc2VkKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUxpbmtUZXh0KHVybCkge1xyXG4gIHZhciBwYXJzZWQgPSBtZHVybC5wYXJzZSh1cmwsIHRydWUpO1xyXG5cclxuICBpZiAocGFyc2VkLmhvc3RuYW1lKSB7XHJcbiAgICAvLyBFbmNvZGUgaG9zdG5hbWVzIGluIHVybHMgbGlrZTpcclxuICAgIC8vIGBodHRwOi8vaG9zdC9gLCBgaHR0cHM6Ly9ob3N0L2AsIGBtYWlsdG86dXNlckBob3N0YCwgYC8vaG9zdC9gXHJcbiAgICAvL1xyXG4gICAgLy8gV2UgZG9uJ3QgZW5jb2RlIHVua25vd24gc2NoZW1hcywgYmVjYXVzZSBpdCdzIGxpa2VseSB0aGF0IHdlIGVuY29kZVxyXG4gICAgLy8gc29tZXRoaW5nIHdlIHNob3VsZG4ndCAoZS5nLiBgc2t5cGU6bmFtZWAgdHJlYXRlZCBhcyBgc2t5cGU6aG9zdGApXHJcbiAgICAvL1xyXG4gICAgaWYgKCFwYXJzZWQucHJvdG9jb2wgfHwgUkVDT0RFX0hPU1ROQU1FX0ZPUi5pbmRleE9mKHBhcnNlZC5wcm90b2NvbCkgPj0gMCkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHBhcnNlZC5ob3N0bmFtZSA9IHB1bnljb2RlLnRvVW5pY29kZShwYXJzZWQuaG9zdG5hbWUpO1xyXG4gICAgICB9IGNhdGNoKGVyKSB7fVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG1kdXJsLmRlY29kZShtZHVybC5mb3JtYXQocGFyc2VkKSk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogY2xhc3MgTWFya2Rvd25JdFxyXG4gKlxyXG4gKiBNYWluIHBhcnNlci9yZW5kZXJlciBjbGFzcy5cclxuICpcclxuICogIyMjIyMgVXNhZ2VcclxuICpcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiAvLyBub2RlLmpzLCBcImNsYXNzaWNcIiB3YXk6XHJcbiAqIHZhciBNYXJrZG93bkl0ID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSxcclxuICogICAgIG1kID0gbmV3IE1hcmtkb3duSXQoKTtcclxuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XHJcbiAqXHJcbiAqIC8vIG5vZGUuanMsIHRoZSBzYW1lLCBidXQgd2l0aCBzdWdhcjpcclxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xyXG4gKiB2YXIgcmVzdWx0ID0gbWQucmVuZGVyKCcjIG1hcmtkb3duLWl0IHJ1bGV6eiEnKTtcclxuICpcclxuICogLy8gYnJvd3NlciB3aXRob3V0IEFNRCwgYWRkZWQgdG8gXCJ3aW5kb3dcIiBvbiBzY3JpcHQgbG9hZFxyXG4gKiAvLyBOb3RlLCB0aGVyZSBhcmUgbm8gZGFzaC5cclxuICogdmFyIG1kID0gd2luZG93Lm1hcmtkb3duaXQoKTtcclxuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBTaW5nbGUgbGluZSByZW5kZXJpbmcsIHdpdGhvdXQgcGFyYWdyYXBoIHdyYXA6XHJcbiAqXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xyXG4gKiB2YXIgcmVzdWx0ID0gbWQucmVuZGVySW5saW5lKCdfX21hcmtkb3duLWl0X18gcnVsZXp6IScpO1xyXG4gKiBgYGBcclxuICoqL1xyXG5cclxuLyoqXHJcbiAqIG5ldyBNYXJrZG93bkl0KFtwcmVzZXROYW1lLCBvcHRpb25zXSlcclxuICogLSBwcmVzZXROYW1lIChTdHJpbmcpOiBvcHRpb25hbCwgYGNvbW1vbm1hcmtgIC8gYHplcm9gXHJcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KVxyXG4gKlxyXG4gKiBDcmVhdGVzIHBhcnNlciBpbnN0YW5zZSB3aXRoIGdpdmVuIGNvbmZpZy4gQ2FuIGJlIGNhbGxlZCB3aXRob3V0IGBuZXdgLlxyXG4gKlxyXG4gKiAjIyMjIyBwcmVzZXROYW1lXHJcbiAqXHJcbiAqIE1hcmtkb3duSXQgcHJvdmlkZXMgbmFtZWQgcHJlc2V0cyBhcyBhIGNvbnZlbmllbmNlIHRvIHF1aWNrbHlcclxuICogZW5hYmxlL2Rpc2FibGUgYWN0aXZlIHN5bnRheCBydWxlcyBhbmQgb3B0aW9ucyBmb3IgY29tbW9uIHVzZSBjYXNlcy5cclxuICpcclxuICogLSBbXCJjb21tb25tYXJrXCJdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcHJlc2V0cy9jb21tb25tYXJrLmpzKSAtXHJcbiAqICAgY29uZmlndXJlcyBwYXJzZXIgdG8gc3RyaWN0IFtDb21tb25NYXJrXShodHRwOi8vY29tbW9ubWFyay5vcmcvKSBtb2RlLlxyXG4gKiAtIFtkZWZhdWx0XShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3ByZXNldHMvZGVmYXVsdC5qcykgLVxyXG4gKiAgIHNpbWlsYXIgdG8gR0ZNLCB1c2VkIHdoZW4gbm8gcHJlc2V0IG5hbWUgZ2l2ZW4uIEVuYWJsZXMgYWxsIGF2YWlsYWJsZSBydWxlcyxcclxuICogICBidXQgc3RpbGwgd2l0aG91dCBodG1sLCB0eXBvZ3JhcGhlciAmIGF1dG9saW5rZXIuXHJcbiAqIC0gW1wiemVyb1wiXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3ByZXNldHMvemVyby5qcykgLVxyXG4gKiAgIGFsbCBydWxlcyBkaXNhYmxlZC4gVXNlZnVsIHRvIHF1aWNrbHkgc2V0dXAgeW91ciBjb25maWcgdmlhIGAuZW5hYmxlKClgLlxyXG4gKiAgIEZvciBleGFtcGxlLCB3aGVuIHlvdSBuZWVkIG9ubHkgYGJvbGRgIGFuZCBgaXRhbGljYCBtYXJrdXAgYW5kIG5vdGhpbmcgZWxzZS5cclxuICpcclxuICogIyMjIyMgb3B0aW9uczpcclxuICpcclxuICogLSBfX2h0bWxfXyAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gZW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2UuIEJlIGNhcmVmdWwhXHJcbiAqICAgVGhhdCdzIG5vdCBzYWZlISBZb3UgbWF5IG5lZWQgZXh0ZXJuYWwgc2FuaXRpemVyIHRvIHByb3RlY3Qgb3V0cHV0IGZyb20gWFNTLlxyXG4gKiAgIEl0J3MgYmV0dGVyIHRvIGV4dGVuZCBmZWF0dXJlcyB2aWEgcGx1Z2lucywgaW5zdGVhZCBvZiBlbmFibGluZyBIVE1MLlxyXG4gKiAtIF9feGh0bWxPdXRfXyAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gYWRkICcvJyB3aGVuIGNsb3Npbmcgc2luZ2xlIHRhZ3NcclxuICogICAoYDxiciAvPmApLiBUaGlzIGlzIG5lZWRlZCBvbmx5IGZvciBmdWxsIENvbW1vbk1hcmsgY29tcGF0aWJpbGl0eS4gSW4gcmVhbFxyXG4gKiAgIHdvcmxkIHlvdSB3aWxsIG5lZWQgSFRNTCBvdXRwdXQuXHJcbiAqIC0gX19icmVha3NfXyAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gY29udmVydCBgXFxuYCBpbiBwYXJhZ3JhcGhzIGludG8gYDxicj5gLlxyXG4gKiAtIF9fbGFuZ1ByZWZpeF9fIC0gYGxhbmd1YWdlLWAuIENTUyBsYW5ndWFnZSBjbGFzcyBwcmVmaXggZm9yIGZlbmNlZCBibG9ja3MuXHJcbiAqICAgQ2FuIGJlIHVzZWZ1bCBmb3IgZXh0ZXJuYWwgaGlnaGxpZ2h0ZXJzLlxyXG4gKiAtIF9fbGlua2lmeV9fIC0gYGZhbHNlYC4gU2V0IGB0cnVlYCB0byBhdXRvY29udmVydCBVUkwtbGlrZSB0ZXh0IHRvIGxpbmtzLlxyXG4gKiAtIF9fdHlwb2dyYXBoZXJfXyAgLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGVuYWJsZSBbc29tZSBsYW5ndWFnZS1uZXV0cmFsXHJcbiAqICAgcmVwbGFjZW1lbnRdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcnVsZXNfY29yZS9yZXBsYWNlbWVudHMuanMpICtcclxuICogICBxdW90ZXMgYmVhdXRpZmljYXRpb24gKHNtYXJ0cXVvdGVzKS5cclxuICogLSBfX3F1b3Rlc19fIC0gYOKAnOKAneKAmOKAmWAsIHN0cmluZy4gRG91YmxlICsgc2luZ2xlIHF1b3RlcyByZXBsYWNlbWVudCBwYWlycywgd2hlblxyXG4gKiAgIHR5cG9ncmFwaGVyIGVuYWJsZWQgYW5kIHNtYXJ0cXVvdGVzIG9uLiBTZXQgZG91YmxlcyB0byAnwqvCuycgZm9yIFJ1c3NpYW4sXHJcbiAqICAgJ+KAnuKAnCcgZm9yIEdlcm1hbi5cclxuICogLSBfX2hpZ2hsaWdodF9fIC0gYG51bGxgLiBIaWdobGlnaHRlciBmdW5jdGlvbiBmb3IgZmVuY2VkIGNvZGUgYmxvY2tzLlxyXG4gKiAgIEhpZ2hsaWdodGVyIGBmdW5jdGlvbiAoc3RyLCBsYW5nKWAgc2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwuIEl0IGNhbiBhbHNvXHJcbiAqICAgcmV0dXJuIGVtcHR5IHN0cmluZyBpZiB0aGUgc291cmNlIHdhcyBub3QgY2hhbmdlZCBhbmQgc2hvdWxkIGJlIGVzY2FwZWQgZXh0ZXJuYWx5LlxyXG4gKlxyXG4gKiAjIyMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gY29tbW9ubWFyayBtb2RlXHJcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoJ2NvbW1vbm1hcmsnKTtcclxuICpcclxuICogLy8gZGVmYXVsdCBtb2RlXHJcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcclxuICpcclxuICogLy8gZW5hYmxlIGV2ZXJ5dGhpbmdcclxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSh7XHJcbiAqICAgaHRtbDogdHJ1ZSxcclxuICogICBsaW5raWZ5OiB0cnVlLFxyXG4gKiAgIHR5cG9ncmFwaGVyOiB0cnVlXHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICpcclxuICogIyMjIyMgU3ludGF4IGhpZ2hsaWdodGluZ1xyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgaGxqcyA9IHJlcXVpcmUoJ2hpZ2hsaWdodC5qcycpIC8vIGh0dHBzOi8vaGlnaGxpZ2h0anMub3JnL1xyXG4gKlxyXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKHtcclxuICogICBoaWdobGlnaHQ6IGZ1bmN0aW9uIChzdHIsIGxhbmcpIHtcclxuICogICAgIGlmIChsYW5nICYmIGhsanMuZ2V0TGFuZ3VhZ2UobGFuZykpIHtcclxuICogICAgICAgdHJ5IHtcclxuICogICAgICAgICByZXR1cm4gaGxqcy5oaWdobGlnaHQobGFuZywgc3RyKS52YWx1ZTtcclxuICogICAgICAgfSBjYXRjaCAoX18pIHt9XHJcbiAqICAgICB9XHJcbiAqXHJcbiAqICAgICB0cnkge1xyXG4gKiAgICAgICByZXR1cm4gaGxqcy5oaWdobGlnaHRBdXRvKHN0cikudmFsdWU7XHJcbiAqICAgICB9IGNhdGNoIChfXykge31cclxuICpcclxuICogICAgIHJldHVybiAnJzsgLy8gdXNlIGV4dGVybmFsIGRlZmF1bHQgZXNjYXBpbmdcclxuICogICB9XHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICoqL1xyXG5mdW5jdGlvbiBNYXJrZG93bkl0KHByZXNldE5hbWUsIG9wdGlvbnMpIHtcclxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFya2Rvd25JdCkpIHtcclxuICAgIHJldHVybiBuZXcgTWFya2Rvd25JdChwcmVzZXROYW1lLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIGlmICghb3B0aW9ucykge1xyXG4gICAgaWYgKCF1dGlscy5pc1N0cmluZyhwcmVzZXROYW1lKSkge1xyXG4gICAgICBvcHRpb25zID0gcHJlc2V0TmFtZSB8fCB7fTtcclxuICAgICAgcHJlc2V0TmFtZSA9ICdkZWZhdWx0JztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1hcmtkb3duSXQjaW5saW5lIC0+IFBhcnNlcklubGluZVxyXG4gICAqXHJcbiAgICogSW5zdGFuY2Ugb2YgW1tQYXJzZXJJbmxpbmVdXS4gWW91IG1heSBuZWVkIGl0IHRvIGFkZCBuZXcgcnVsZXMgd2hlblxyXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxyXG4gICAqIFtbTWFya2Rvd25JdC5lbmFibGVdXS5cclxuICAgKiovXHJcbiAgdGhpcy5pbmxpbmUgPSBuZXcgUGFyc2VySW5saW5lKCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIE1hcmtkb3duSXQjYmxvY2sgLT4gUGFyc2VyQmxvY2tcclxuICAgKlxyXG4gICAqIEluc3RhbmNlIG9mIFtbUGFyc2VyQmxvY2tdXS4gWW91IG1heSBuZWVkIGl0IHRvIGFkZCBuZXcgcnVsZXMgd2hlblxyXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxyXG4gICAqIFtbTWFya2Rvd25JdC5lbmFibGVdXS5cclxuICAgKiovXHJcbiAgdGhpcy5ibG9jayA9IG5ldyBQYXJzZXJCbG9jaygpO1xyXG5cclxuICAvKipcclxuICAgKiBNYXJrZG93bkl0I2NvcmUgLT4gQ29yZVxyXG4gICAqXHJcbiAgICogSW5zdGFuY2Ugb2YgW1tDb3JlXV0gY2hhaW4gZXhlY3V0b3IuIFlvdSBtYXkgbmVlZCBpdCB0byBhZGQgbmV3IHJ1bGVzIHdoZW5cclxuICAgKiB3cml0aW5nIHBsdWdpbnMuIEZvciBzaW1wbGUgcnVsZXMgY29udHJvbCB1c2UgW1tNYXJrZG93bkl0LmRpc2FibGVdXSBhbmRcclxuICAgKiBbW01hcmtkb3duSXQuZW5hYmxlXV0uXHJcbiAgICoqL1xyXG4gIHRoaXMuY29yZSA9IG5ldyBQYXJzZXJDb3JlKCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIE1hcmtkb3duSXQjcmVuZGVyZXIgLT4gUmVuZGVyZXJcclxuICAgKlxyXG4gICAqIEluc3RhbmNlIG9mIFtbUmVuZGVyZXJdXS4gVXNlIGl0IHRvIG1vZGlmeSBvdXRwdXQgbG9vay4gT3IgdG8gYWRkIHJlbmRlcmluZ1xyXG4gICAqIHJ1bGVzIGZvciBuZXcgdG9rZW4gdHlwZXMsIGdlbmVyYXRlZCBieSBwbHVnaW5zLlxyXG4gICAqXHJcbiAgICogIyMjIyMgRXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBgamF2YXNjcmlwdFxyXG4gICAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcclxuICAgKlxyXG4gICAqIGZ1bmN0aW9uIG15VG9rZW4odG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2VsZikge1xyXG4gICAqICAgLy8uLi5cclxuICAgKiAgIHJldHVybiByZXN1bHQ7XHJcbiAgICogfTtcclxuICAgKlxyXG4gICAqIG1kLnJlbmRlcmVyLnJ1bGVzWydteV90b2tlbiddID0gbXlUb2tlblxyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogU2VlIFtbUmVuZGVyZXJdXSBkb2NzIGFuZCBbc291cmNlIGNvZGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcmVuZGVyZXIuanMpLlxyXG4gICAqKi9cclxuICB0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIE1hcmtkb3duSXQjbGlua2lmeSAtPiBMaW5raWZ5SXRcclxuICAgKlxyXG4gICAqIFtsaW5raWZ5LWl0XShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbGlua2lmeS1pdCkgaW5zdGFuY2UuXHJcbiAgICogVXNlZCBieSBbbGlua2lmeV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9ydWxlc19jb3JlL2xpbmtpZnkuanMpXHJcbiAgICogcnVsZS5cclxuICAgKiovXHJcbiAgdGhpcy5saW5raWZ5ID0gbmV3IExpbmtpZnlJdCgpO1xyXG5cclxuICAvKipcclxuICAgKiBNYXJrZG93bkl0I3ZhbGlkYXRlTGluayh1cmwpIC0+IEJvb2xlYW5cclxuICAgKlxyXG4gICAqIExpbmsgdmFsaWRhdGlvbiBmdW5jdGlvbi4gQ29tbW9uTWFyayBhbGxvd3MgdG9vIG11Y2ggaW4gbGlua3MuIEJ5IGRlZmF1bHRcclxuICAgKiB3ZSBkaXNhYmxlIGBqYXZhc2NyaXB0OmAgYW5kIGB2YnNjcmlwdDpgIHNjaGVtYXMuIFlvdSBjYW4gY2hhbmdlIHRoaXNcclxuICAgKiBiZWhhdmlvdXIuXHJcbiAgICpcclxuICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xyXG4gICAqIC8vIGVuYWJsZSBldmVyeXRoaW5nXHJcbiAgICogbWQudmFsaWRhdGVMaW5rID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG4gICAqIGBgYFxyXG4gICAqKi9cclxuICB0aGlzLnZhbGlkYXRlTGluayA9IHZhbGlkYXRlTGluaztcclxuXHJcbiAgLyoqXHJcbiAgICogTWFya2Rvd25JdCNub3JtYWxpemVMaW5rKHVybCkgLT4gU3RyaW5nXHJcbiAgICpcclxuICAgKiBGdW5jdGlvbiB1c2VkIHRvIGVuY29kZSBsaW5rIHVybCB0byBhIG1hY2hpbmUtcmVhZGFibGUgZm9ybWF0LFxyXG4gICAqIHdoaWNoIGluY2x1ZGVzIHVybC1lbmNvZGluZywgcHVueWNvZGUsIGV0Yy5cclxuICAgKiovXHJcbiAgdGhpcy5ub3JtYWxpemVMaW5rID0gbm9ybWFsaXplTGluaztcclxuXHJcbiAgLyoqXHJcbiAgICogTWFya2Rvd25JdCNub3JtYWxpemVMaW5rVGV4dCh1cmwpIC0+IFN0cmluZ1xyXG4gICAqXHJcbiAgICogRnVuY3Rpb24gdXNlZCB0byBkZWNvZGUgbGluayB1cmwgdG8gYSBodW1hbi1yZWFkYWJsZSBmb3JtYXRgXHJcbiAgICoqL1xyXG4gIHRoaXMubm9ybWFsaXplTGlua1RleHQgPSBub3JtYWxpemVMaW5rVGV4dDtcclxuXHJcblxyXG4gIC8vIEV4cG9zZSB1dGlscyAmIGhlbHBlcnMgZm9yIGVhc3kgYWNjZXMgZnJvbSBwbHVnaW5zXHJcblxyXG4gIC8qKlxyXG4gICAqIE1hcmtkb3duSXQjdXRpbHMgLT4gdXRpbHNcclxuICAgKlxyXG4gICAqIEFzc29ydGVkIHV0aWxpdHkgZnVuY3Rpb25zLCB1c2VmdWwgdG8gd3JpdGUgcGx1Z2lucy4gU2VlIGRldGFpbHNcclxuICAgKiBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9jb21tb24vdXRpbHMuanMpLlxyXG4gICAqKi9cclxuICB0aGlzLnV0aWxzID0gdXRpbHM7XHJcblxyXG4gIC8qKlxyXG4gICAqIE1hcmtkb3duSXQjaGVscGVycyAtPiBoZWxwZXJzXHJcbiAgICpcclxuICAgKiBMaW5rIGNvbXBvbmVudHMgcGFyc2VyIGZ1bmN0aW9ucywgdXNlZnVsIHRvIHdyaXRlIHBsdWdpbnMuIFNlZSBkZXRhaWxzXHJcbiAgICogW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvaGVscGVycykuXHJcbiAgICoqL1xyXG4gIHRoaXMuaGVscGVycyA9IGhlbHBlcnM7XHJcblxyXG5cclxuICB0aGlzLm9wdGlvbnMgPSB7fTtcclxuICB0aGlzLmNvbmZpZ3VyZShwcmVzZXROYW1lKTtcclxuXHJcbiAgaWYgKG9wdGlvbnMpIHsgdGhpcy5zZXQob3B0aW9ucyk7IH1cclxufVxyXG5cclxuXHJcbi8qKiBjaGFpbmFibGVcclxuICogTWFya2Rvd25JdC5zZXQob3B0aW9ucylcclxuICpcclxuICogU2V0IHBhcnNlciBvcHRpb25zIChpbiB0aGUgc2FtZSBmb3JtYXQgYXMgaW4gY29uc3RydWN0b3IpLiBQcm9iYWJseSwgeW91XHJcbiAqIHdpbGwgbmV2ZXIgbmVlZCBpdCwgYnV0IHlvdSBjYW4gY2hhbmdlIG9wdGlvbnMgYWZ0ZXIgY29uc3RydWN0b3IgY2FsbC5cclxuICpcclxuICogIyMjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxyXG4gKiAgICAgICAgICAgICAuc2V0KHsgaHRtbDogdHJ1ZSwgYnJlYWtzOiB0cnVlIH0pXHJcbiAqICAgICAgICAgICAgIC5zZXQoeyB0eXBvZ3JhcGhlciwgdHJ1ZSB9KTtcclxuICogYGBgXHJcbiAqXHJcbiAqIF9fTm90ZTpfXyBUbyBhY2hpZXZlIHRoZSBiZXN0IHBvc3NpYmxlIHBlcmZvcm1hbmNlLCBkb24ndCBtb2RpZnkgYVxyXG4gKiBgbWFya2Rvd24taXRgIGluc3RhbmNlIG9wdGlvbnMgb24gdGhlIGZseS4gSWYgeW91IG5lZWQgbXVsdGlwbGUgY29uZmlndXJhdGlvbnNcclxuICogaXQncyBiZXN0IHRvIGNyZWF0ZSBtdWx0aXBsZSBpbnN0YW5jZXMgYW5kIGluaXRpYWxpemUgZWFjaCB3aXRoIHNlcGFyYXRlXHJcbiAqIGNvbmZpZy5cclxuICoqL1xyXG5NYXJrZG93bkl0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIHV0aWxzLmFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuXHJcbi8qKiBjaGFpbmFibGUsIGludGVybmFsXHJcbiAqIE1hcmtkb3duSXQuY29uZmlndXJlKHByZXNldHMpXHJcbiAqXHJcbiAqIEJhdGNoIGxvYWQgb2YgYWxsIG9wdGlvbnMgYW5kIGNvbXBlbmVudCBzZXR0aW5ncy4gVGhpcyBpcyBpbnRlcm5hbCBtZXRob2QsXHJcbiAqIGFuZCB5b3UgcHJvYmFibHkgd2lsbCBub3QgbmVlZCBpdC4gQnV0IGlmIHlvdSB3aXRoIC0gc2VlIGF2YWlsYWJsZSBwcmVzZXRzXHJcbiAqIGFuZCBkYXRhIHN0cnVjdHVyZSBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L3RyZWUvbWFzdGVyL2xpYi9wcmVzZXRzKVxyXG4gKlxyXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIHByZXNldHMgaW5zdGVhZCBvZiBkaXJlY3QgY29uZmlnIGxvYWRzLiBUaGF0XHJcbiAqIHdpbGwgZ2l2ZSBiZXR0ZXIgY29tcGF0aWJpbGl0eSB3aXRoIG5leHQgdmVyc2lvbnMuXHJcbiAqKi9cclxuTWFya2Rvd25JdC5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24gKHByZXNldHMpIHtcclxuICB2YXIgc2VsZiA9IHRoaXMsIHByZXNldE5hbWU7XHJcblxyXG4gIGlmICh1dGlscy5pc1N0cmluZyhwcmVzZXRzKSkge1xyXG4gICAgcHJlc2V0TmFtZSA9IHByZXNldHM7XHJcbiAgICBwcmVzZXRzID0gY29uZmlnW3ByZXNldE5hbWVdO1xyXG4gICAgaWYgKCFwcmVzZXRzKSB7IHRocm93IG5ldyBFcnJvcignV3JvbmcgYG1hcmtkb3duLWl0YCBwcmVzZXQgXCInICsgcHJlc2V0TmFtZSArICdcIiwgY2hlY2sgbmFtZScpOyB9XHJcbiAgfVxyXG5cclxuICBpZiAoIXByZXNldHMpIHsgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBgbWFya2Rvd24taXRgIHByZXNldCwgY2FuXFwndCBiZSBlbXB0eScpOyB9XHJcblxyXG4gIGlmIChwcmVzZXRzLm9wdGlvbnMpIHsgc2VsZi5zZXQocHJlc2V0cy5vcHRpb25zKTsgfVxyXG5cclxuICBpZiAocHJlc2V0cy5jb21wb25lbnRzKSB7XHJcbiAgICBPYmplY3Qua2V5cyhwcmVzZXRzLmNvbXBvbmVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgaWYgKHByZXNldHMuY29tcG9uZW50c1tuYW1lXS5ydWxlcykge1xyXG4gICAgICAgIHNlbGZbbmFtZV0ucnVsZXIuZW5hYmxlT25seShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5cclxuLyoqIGNoYWluYWJsZVxyXG4gKiBNYXJrZG93bkl0LmVuYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKVxyXG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IHJ1bGUgbmFtZSBvciBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZW5hYmxlXHJcbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxyXG4gKlxyXG4gKiBFbmFibGUgbGlzdCBvciBydWxlcy4gSXQgd2lsbCBhdXRvbWF0aWNhbGx5IGZpbmQgYXBwcm9wcmlhdGUgY29tcG9uZW50cyxcclxuICogY29udGFpbmluZyBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBydWxlIG5vdCBmb3VuZCwgYW5kIGBpZ25vcmVJbnZhbGlkYFxyXG4gKiBub3Qgc2V0IC0gdGhyb3dzIGV4Y2VwdGlvbi5cclxuICpcclxuICogIyMjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxyXG4gKiAgICAgICAgICAgICAuZW5hYmxlKFsnc3ViJywgJ3N1cCddKVxyXG4gKiAgICAgICAgICAgICAuZGlzYWJsZSgnc21hcnRxdW90ZXMnKTtcclxuICogYGBgXHJcbiAqKi9cclxuTWFya2Rvd25JdC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcclxuICB2YXIgcmVzdWx0ID0gW107XHJcblxyXG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cclxuXHJcbiAgWyAnY29yZScsICdibG9jaycsICdpbmxpbmUnIF0uZm9yRWFjaChmdW5jdGlvbiAoY2hhaW4pIHtcclxuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpc1tjaGFpbl0ucnVsZXIuZW5hYmxlKGxpc3QsIHRydWUpKTtcclxuICB9LCB0aGlzKTtcclxuXHJcbiAgdmFyIG1pc3NlZCA9IGxpc3QuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiByZXN1bHQuaW5kZXhPZihuYW1lKSA8IDA7IH0pO1xyXG5cclxuICBpZiAobWlzc2VkLmxlbmd0aCAmJiAhaWdub3JlSW52YWxpZCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXJrZG93bkl0LiBGYWlsZWQgdG8gZW5hYmxlIHVua25vd24gcnVsZShzKTogJyArIG1pc3NlZCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblxyXG4vKiogY2hhaW5hYmxlXHJcbiAqIE1hcmtkb3duSXQuZGlzYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKVxyXG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IHJ1bGUgbmFtZSBvciBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZGlzYWJsZS5cclxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXHJcbiAqXHJcbiAqIFRoZSBzYW1lIGFzIFtbTWFya2Rvd25JdC5lbmFibGVdXSwgYnV0IHR1cm4gc3BlY2lmaWVkIHJ1bGVzIG9mZi5cclxuICoqL1xyXG5NYXJrZG93bkl0LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcclxuICB2YXIgcmVzdWx0ID0gW107XHJcblxyXG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cclxuXHJcbiAgWyAnY29yZScsICdibG9jaycsICdpbmxpbmUnIF0uZm9yRWFjaChmdW5jdGlvbiAoY2hhaW4pIHtcclxuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpc1tjaGFpbl0ucnVsZXIuZGlzYWJsZShsaXN0LCB0cnVlKSk7XHJcbiAgfSwgdGhpcyk7XHJcblxyXG4gIHZhciBtaXNzZWQgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gcmVzdWx0LmluZGV4T2YobmFtZSkgPCAwOyB9KTtcclxuXHJcbiAgaWYgKG1pc3NlZC5sZW5ndGggJiYgIWlnbm9yZUludmFsaWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTWFya2Rvd25JdC4gRmFpbGVkIHRvIGRpc2FibGUgdW5rbm93biBydWxlKHMpOiAnICsgbWlzc2VkKTtcclxuICB9XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5cclxuLyoqIGNoYWluYWJsZVxyXG4gKiBNYXJrZG93bkl0LnVzZShwbHVnaW4sIHBhcmFtcylcclxuICpcclxuICogTG9hZCBzcGVjaWZpZWQgcGx1Z2luIHdpdGggZ2l2ZW4gcGFyYW1zIGludG8gY3VycmVudCBwYXJzZXIgaW5zdGFuY2UuXHJcbiAqIEl0J3MganVzdCBhIHN1Z2FyIHRvIGNhbGwgYHBsdWdpbihtZCwgcGFyYW1zKWAgd2l0aCBjdXJyaW5nLlxyXG4gKlxyXG4gKiAjIyMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogdmFyIGl0ZXJhdG9yID0gcmVxdWlyZSgnbWFya2Rvd24taXQtZm9yLWlubGluZScpO1xyXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKClcclxuICogICAgICAgICAgICAgLnVzZShpdGVyYXRvciwgJ2Zvb19yZXBsYWNlJywgJ3RleHQnLCBmdW5jdGlvbiAodG9rZW5zLCBpZHgpIHtcclxuICogICAgICAgICAgICAgICB0b2tlbnNbaWR4XS5jb250ZW50ID0gdG9rZW5zW2lkeF0uY29udGVudC5yZXBsYWNlKC9mb28vZywgJ2JhcicpO1xyXG4gKiAgICAgICAgICAgICB9KTtcclxuICogYGBgXHJcbiAqKi9cclxuTWFya2Rvd25JdC5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gKHBsdWdpbiAvKiwgcGFyYW1zLCAuLi4gKi8pIHtcclxuICB2YXIgYXJncyA9IFsgdGhpcyBdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcclxuICBwbHVnaW4uYXBwbHkocGx1Z2luLCBhcmdzKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblxyXG4vKiogaW50ZXJuYWxcclxuICogTWFya2Rvd25JdC5wYXJzZShzcmMsIGVudikgLT4gQXJyYXlcclxuICogLSBzcmMgKFN0cmluZyk6IHNvdXJjZSBzdHJpbmdcclxuICogLSBlbnYgKE9iamVjdCk6IGVudmlyb25tZW50IHNhbmRib3hcclxuICpcclxuICogUGFyc2UgaW5wdXQgc3RyaW5nIGFuZCByZXR1cm5zIGxpc3Qgb2YgYmxvY2sgdG9rZW5zIChzcGVjaWFsIHRva2VuIHR5cGVcclxuICogXCJpbmxpbmVcIiB3aWxsIGNvbnRhaW4gbGlzdCBvZiBpbmxpbmUgdG9rZW5zKS4gWW91IHNob3VsZCBub3QgY2FsbCB0aGlzXHJcbiAqIG1ldGhvZCBkaXJlY3RseSwgdW50aWwgeW91IHdyaXRlIGN1c3RvbSByZW5kZXJlciAoZm9yIGV4YW1wbGUsIHRvIHByb2R1Y2VcclxuICogQVNUKS5cclxuICpcclxuICogYGVudmAgaXMgdXNlZCB0byBwYXNzIGRhdGEgYmV0d2VlbiBcImRpc3RyaWJ1dGVkXCIgcnVsZXMgYW5kIHJldHVybiBhZGRpdGlvbmFsXHJcbiAqIG1ldGFkYXRhIGxpa2UgcmVmZXJlbmNlIGluZm8sIG5lZWRlZCBmb3IgZm9yIHJlbmRlcmVyLiBJdCBhbHNvIGNhbiBiZSB1c2VkIHRvXHJcbiAqIGluamVjdCBkYXRhIGluIHNwZWNpZmljIGNhc2VzLiBVc3VhbGx5LCB5b3Ugd2lsbCBiZSBvayB0byBwYXNzIGB7fWAsXHJcbiAqIGFuZCB0aGVuIHBhc3MgdXBkYXRlZCBvYmplY3QgdG8gcmVuZGVyZXIuXHJcbiAqKi9cclxuTWFya2Rvd25JdC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc3JjLCBlbnYpIHtcclxuICB2YXIgc3RhdGUgPSBuZXcgdGhpcy5jb3JlLlN0YXRlKHNyYywgdGhpcywgZW52KTtcclxuXHJcbiAgdGhpcy5jb3JlLnByb2Nlc3Moc3RhdGUpO1xyXG5cclxuICByZXR1cm4gc3RhdGUudG9rZW5zO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBNYXJrZG93bkl0LnJlbmRlcihzcmMgWywgZW52XSkgLT4gU3RyaW5nXHJcbiAqIC0gc3JjIChTdHJpbmcpOiBzb3VyY2Ugc3RyaW5nXHJcbiAqIC0gZW52IChPYmplY3QpOiBlbnZpcm9ubWVudCBzYW5kYm94XHJcbiAqXHJcbiAqIFJlbmRlciBtYXJrZG93biBzdHJpbmcgaW50byBodG1sLiBJdCBkb2VzIGFsbCBtYWdpYyBmb3IgeW91IDopLlxyXG4gKlxyXG4gKiBgZW52YCBjYW4gYmUgdXNlZCB0byBpbmplY3QgYWRkaXRpb25hbCBtZXRhZGF0YSAoYHt9YCBieSBkZWZhdWx0KS5cclxuICogQnV0IHlvdSB3aWxsIG5vdCBuZWVkIGl0IHdpdGggaGlnaCBwcm9iYWJpbGl0eS4gU2VlIGFsc28gY29tbWVudFxyXG4gKiBpbiBbW01hcmtkb3duSXQucGFyc2VdXS5cclxuICoqL1xyXG5NYXJrZG93bkl0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoc3JjLCBlbnYpIHtcclxuICBlbnYgPSBlbnYgfHwge307XHJcblxyXG4gIHJldHVybiB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnBhcnNlKHNyYywgZW52KSwgdGhpcy5vcHRpb25zLCBlbnYpO1xyXG59O1xyXG5cclxuXHJcbi8qKiBpbnRlcm5hbFxyXG4gKiBNYXJrZG93bkl0LnBhcnNlSW5saW5lKHNyYywgZW52KSAtPiBBcnJheVxyXG4gKiAtIHNyYyAoU3RyaW5nKTogc291cmNlIHN0cmluZ1xyXG4gKiAtIGVudiAoT2JqZWN0KTogZW52aXJvbm1lbnQgc2FuZGJveFxyXG4gKlxyXG4gKiBUaGUgc2FtZSBhcyBbW01hcmtkb3duSXQucGFyc2VdXSBidXQgc2tpcCBhbGwgYmxvY2sgcnVsZXMuIEl0IHJldHVybnMgdGhlXHJcbiAqIGJsb2NrIHRva2VucyBsaXN0IHdpdGggdGhlIHNpbmdsZSBgaW5saW5lYCBlbGVtZW50LCBjb250YWluaW5nIHBhcnNlZCBpbmxpbmVcclxuICogdG9rZW5zIGluIGBjaGlsZHJlbmAgcHJvcGVydHkuIEFsc28gdXBkYXRlcyBgZW52YCBvYmplY3QuXHJcbiAqKi9cclxuTWFya2Rvd25JdC5wcm90b3R5cGUucGFyc2VJbmxpbmUgPSBmdW5jdGlvbiAoc3JjLCBlbnYpIHtcclxuICB2YXIgc3RhdGUgPSBuZXcgdGhpcy5jb3JlLlN0YXRlKHNyYywgdGhpcywgZW52KTtcclxuXHJcbiAgc3RhdGUuaW5saW5lTW9kZSA9IHRydWU7XHJcbiAgdGhpcy5jb3JlLnByb2Nlc3Moc3RhdGUpO1xyXG5cclxuICByZXR1cm4gc3RhdGUudG9rZW5zO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBNYXJrZG93bkl0LnJlbmRlcklubGluZShzcmMgWywgZW52XSkgLT4gU3RyaW5nXHJcbiAqIC0gc3JjIChTdHJpbmcpOiBzb3VyY2Ugc3RyaW5nXHJcbiAqIC0gZW52IChPYmplY3QpOiBlbnZpcm9ubWVudCBzYW5kYm94XHJcbiAqXHJcbiAqIFNpbWlsYXIgdG8gW1tNYXJrZG93bkl0LnJlbmRlcl1dIGJ1dCBmb3Igc2luZ2xlIHBhcmFncmFwaCBjb250ZW50LiBSZXN1bHRcclxuICogd2lsbCBOT1QgYmUgd3JhcHBlZCBpbnRvIGA8cD5gIHRhZ3MuXHJcbiAqKi9cclxuTWFya2Rvd25JdC5wcm90b3R5cGUucmVuZGVySW5saW5lID0gZnVuY3Rpb24gKHNyYywgZW52KSB7XHJcbiAgZW52ID0gZW52IHx8IHt9O1xyXG5cclxuICByZXR1cm4gdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5wYXJzZUlubGluZShzcmMsIGVudiksIHRoaXMub3B0aW9ucywgZW52KTtcclxufTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1hcmtkb3duSXQ7XHJcblxyXG59LHtcIi4vY29tbW9uL3V0aWxzXCI6NSxcIi4vaGVscGVyc1wiOjYsXCIuL3BhcnNlcl9ibG9ja1wiOjExLFwiLi9wYXJzZXJfY29yZVwiOjEyLFwiLi9wYXJzZXJfaW5saW5lXCI6MTMsXCIuL3ByZXNldHMvY29tbW9ubWFya1wiOjE0LFwiLi9wcmVzZXRzL2RlZmF1bHRcIjoxNSxcIi4vcHJlc2V0cy96ZXJvXCI6MTYsXCIuL3JlbmRlcmVyXCI6MTcsXCJsaW5raWZ5LWl0XCI6NTMsXCJtZHVybFwiOjU4LFwicHVueWNvZGVcIjo1MX1dLDExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLyoqIGludGVybmFsXHJcbiAqIGNsYXNzIFBhcnNlckJsb2NrXHJcbiAqXHJcbiAqIEJsb2NrLWxldmVsIHRva2VuaXplci5cclxuICoqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIFJ1bGVyICAgICAgICAgICA9IHJlcXVpcmUoJy4vcnVsZXInKTtcclxuXHJcblxyXG52YXIgX3J1bGVzID0gW1xyXG4gIC8vIEZpcnN0IDIgcGFyYW1zIC0gcnVsZSBuYW1lICYgc291cmNlLiBTZWNvbmRhcnkgYXJyYXkgLSBsaXN0IG9mIHJ1bGVzLFxyXG4gIC8vIHdoaWNoIGNhbiBiZSB0ZXJtaW5hdGVkIGJ5IHRoaXMgb25lLlxyXG4gIFsgJ2NvZGUnLCAgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2NvZGUnKSBdLFxyXG4gIFsgJ2ZlbmNlJywgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2ZlbmNlJyksICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJywgJ2xpc3QnIF0gXSxcclxuICBbICdibG9ja3F1b3RlJywgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9ibG9ja3F1b3RlJyksIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnbGlzdCcgXSBdLFxyXG4gIFsgJ2hyJywgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2hyJyksICAgICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJywgJ2xpc3QnIF0gXSxcclxuICBbICdsaXN0JywgICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9saXN0JyksICAgICAgIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScgXSBdLFxyXG4gIFsgJ3JlZmVyZW5jZScsICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL3JlZmVyZW5jZScpIF0sXHJcbiAgWyAnaGVhZGluZycsICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svaGVhZGluZycpLCAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnIF0gXSxcclxuICBbICdsaGVhZGluZycsICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9saGVhZGluZycpIF0sXHJcbiAgWyAnaHRtbF9ibG9jaycsIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svaHRtbF9ibG9jaycpLCBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnIF0gXSxcclxuICBbICd0YWJsZScsICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay90YWJsZScpLCAgICAgIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnIF0gXSxcclxuICBbICdwYXJhZ3JhcGgnLCAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9wYXJhZ3JhcGgnKSBdXHJcbl07XHJcblxyXG5cclxuLyoqXHJcbiAqIG5ldyBQYXJzZXJCbG9jaygpXHJcbiAqKi9cclxuZnVuY3Rpb24gUGFyc2VyQmxvY2soKSB7XHJcbiAgLyoqXHJcbiAgICogUGFyc2VyQmxvY2sjcnVsZXIgLT4gUnVsZXJcclxuICAgKlxyXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gS2VlcCBjb25maWd1cmF0aW9uIG9mIGJsb2NrIHJ1bGVzLlxyXG4gICAqKi9cclxuICB0aGlzLnJ1bGVyID0gbmV3IFJ1bGVyKCk7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB0aGlzLnJ1bGVyLnB1c2goX3J1bGVzW2ldWzBdLCBfcnVsZXNbaV1bMV0sIHsgYWx0OiAoX3J1bGVzW2ldWzJdIHx8IFtdKS5zbGljZSgpIH0pO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbi8vIEdlbmVyYXRlIHRva2VucyBmb3IgaW5wdXQgcmFuZ2VcclxuLy9cclxuUGFyc2VyQmxvY2sucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24gKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUpIHtcclxuICB2YXIgb2ssIGksXHJcbiAgICAgIHJ1bGVzID0gdGhpcy5ydWxlci5nZXRSdWxlcygnJyksXHJcbiAgICAgIGxlbiA9IHJ1bGVzLmxlbmd0aCxcclxuICAgICAgbGluZSA9IHN0YXJ0TGluZSxcclxuICAgICAgaGFzRW1wdHlMaW5lcyA9IGZhbHNlLFxyXG4gICAgICBtYXhOZXN0aW5nID0gc3RhdGUubWQub3B0aW9ucy5tYXhOZXN0aW5nO1xyXG5cclxuICB3aGlsZSAobGluZSA8IGVuZExpbmUpIHtcclxuICAgIHN0YXRlLmxpbmUgPSBsaW5lID0gc3RhdGUuc2tpcEVtcHR5TGluZXMobGluZSk7XHJcbiAgICBpZiAobGluZSA+PSBlbmRMaW5lKSB7IGJyZWFrOyB9XHJcblxyXG4gICAgLy8gVGVybWluYXRpb24gY29uZGl0aW9uIGZvciBuZXN0ZWQgY2FsbHMuXHJcbiAgICAvLyBOZXN0ZWQgY2FsbHMgY3VycmVudGx5IHVzZWQgZm9yIGJsb2NrcXVvdGVzICYgbGlzdHNcclxuICAgIGlmIChzdGF0ZS50U2hpZnRbbGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgYnJlYWs7IH1cclxuXHJcbiAgICAvLyBJZiBuZXN0aW5nIGxldmVsIGV4Y2VlZGVkIC0gc2tpcCB0YWlsIHRvIHRoZSBlbmQuIFRoYXQncyBub3Qgb3JkaW5hcnlcclxuICAgIC8vIHNpdHVhdGlvbiBhbmQgd2Ugc2hvdWxkIG5vdCBjYXJlIGFib3V0IGNvbnRlbnQuXHJcbiAgICBpZiAoc3RhdGUubGV2ZWwgPj0gbWF4TmVzdGluZykge1xyXG4gICAgICBzdGF0ZS5saW5lID0gZW5kTGluZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVHJ5IGFsbCBwb3NzaWJsZSBydWxlcy5cclxuICAgIC8vIE9uIHN1Y2Nlc3MsIHJ1bGUgc2hvdWxkOlxyXG4gICAgLy9cclxuICAgIC8vIC0gdXBkYXRlIGBzdGF0ZS5saW5lYFxyXG4gICAgLy8gLSB1cGRhdGUgYHN0YXRlLnRva2Vuc2BcclxuICAgIC8vIC0gcmV0dXJuIHRydWVcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgbGluZSwgZW5kTGluZSwgZmFsc2UpO1xyXG4gICAgICBpZiAob2spIHsgYnJlYWs7IH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBzZXQgc3RhdGUudGlnaHQgaWZmIHdlIGhhZCBhbiBlbXB0eSBsaW5lIGJlZm9yZSBjdXJyZW50IHRhZ1xyXG4gICAgLy8gaS5lLiBsYXRlc3QgZW1wdHkgbGluZSBzaG91bGQgbm90IGNvdW50XHJcbiAgICBzdGF0ZS50aWdodCA9ICFoYXNFbXB0eUxpbmVzO1xyXG5cclxuICAgIC8vIHBhcmFncmFwaCBtaWdodCBcImVhdFwiIG9uZSBuZXdsaW5lIGFmdGVyIGl0IGluIG5lc3RlZCBsaXN0c1xyXG4gICAgaWYgKHN0YXRlLmlzRW1wdHkoc3RhdGUubGluZSAtIDEpKSB7XHJcbiAgICAgIGhhc0VtcHR5TGluZXMgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGxpbmUgPSBzdGF0ZS5saW5lO1xyXG5cclxuICAgIGlmIChsaW5lIDwgZW5kTGluZSAmJiBzdGF0ZS5pc0VtcHR5KGxpbmUpKSB7XHJcbiAgICAgIGhhc0VtcHR5TGluZXMgPSB0cnVlO1xyXG4gICAgICBsaW5lKys7XHJcblxyXG4gICAgICAvLyB0d28gZW1wdHkgbGluZXMgc2hvdWxkIHN0b3AgdGhlIHBhcnNlciBpbiBsaXN0IG1vZGVcclxuICAgICAgaWYgKGxpbmUgPCBlbmRMaW5lICYmIHN0YXRlLnBhcmVudFR5cGUgPT09ICdsaXN0JyAmJiBzdGF0ZS5pc0VtcHR5KGxpbmUpKSB7IGJyZWFrOyB9XHJcbiAgICAgIHN0YXRlLmxpbmUgPSBsaW5lO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogUGFyc2VyQmxvY2sucGFyc2Uoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpXHJcbiAqXHJcbiAqIFByb2Nlc3MgaW5wdXQgc3RyaW5nIGFuZCBwdXNoIGJsb2NrIHRva2VucyBpbnRvIGBvdXRUb2tlbnNgXHJcbiAqKi9cclxuUGFyc2VyQmxvY2sucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNyYywgbWQsIGVudiwgb3V0VG9rZW5zKSB7XHJcbiAgdmFyIHN0YXRlO1xyXG5cclxuICBpZiAoIXNyYykgeyByZXR1cm4gW107IH1cclxuXHJcbiAgc3RhdGUgPSBuZXcgdGhpcy5TdGF0ZShzcmMsIG1kLCBlbnYsIG91dFRva2Vucyk7XHJcblxyXG4gIHRoaXMudG9rZW5pemUoc3RhdGUsIHN0YXRlLmxpbmUsIHN0YXRlLmxpbmVNYXgpO1xyXG59O1xyXG5cclxuXHJcblBhcnNlckJsb2NrLnByb3RvdHlwZS5TdGF0ZSA9IHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svc3RhdGVfYmxvY2snKTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlckJsb2NrO1xyXG5cclxufSx7XCIuL3J1bGVyXCI6MTgsXCIuL3J1bGVzX2Jsb2NrL2Jsb2NrcXVvdGVcIjoxOSxcIi4vcnVsZXNfYmxvY2svY29kZVwiOjIwLFwiLi9ydWxlc19ibG9jay9mZW5jZVwiOjIxLFwiLi9ydWxlc19ibG9jay9oZWFkaW5nXCI6MjIsXCIuL3J1bGVzX2Jsb2NrL2hyXCI6MjMsXCIuL3J1bGVzX2Jsb2NrL2h0bWxfYmxvY2tcIjoyNCxcIi4vcnVsZXNfYmxvY2svbGhlYWRpbmdcIjoyNSxcIi4vcnVsZXNfYmxvY2svbGlzdFwiOjI2LFwiLi9ydWxlc19ibG9jay9wYXJhZ3JhcGhcIjoyNyxcIi4vcnVsZXNfYmxvY2svcmVmZXJlbmNlXCI6MjgsXCIuL3J1bGVzX2Jsb2NrL3N0YXRlX2Jsb2NrXCI6MjksXCIuL3J1bGVzX2Jsb2NrL3RhYmxlXCI6MzB9XSwxMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8qKiBpbnRlcm5hbFxyXG4gKiBjbGFzcyBDb3JlXHJcbiAqXHJcbiAqIFRvcC1sZXZlbCBydWxlcyBleGVjdXRvci4gR2x1ZXMgYmxvY2svaW5saW5lIHBhcnNlcnMgYW5kIGRvZXMgaW50ZXJtZWRpYXRlXHJcbiAqIHRyYW5zZm9ybWF0aW9ucy5cclxuICoqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIFJ1bGVyICA9IHJlcXVpcmUoJy4vcnVsZXInKTtcclxuXHJcblxyXG52YXIgX3J1bGVzID0gW1xyXG4gIFsgJ25vcm1hbGl6ZScsICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL25vcm1hbGl6ZScpICAgICAgXSxcclxuICBbICdibG9jaycsICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9ibG9jaycpICAgICAgICAgIF0sXHJcbiAgWyAnaW5saW5lJywgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvaW5saW5lJykgICAgICAgICBdLFxyXG4gIFsgJ2xpbmtpZnknLCAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL2xpbmtpZnknKSAgICAgICAgXSxcclxuICBbICdyZXBsYWNlbWVudHMnLCAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9yZXBsYWNlbWVudHMnKSAgIF0sXHJcbiAgWyAnc21hcnRxdW90ZXMnLCAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvc21hcnRxdW90ZXMnKSAgICBdXHJcbl07XHJcblxyXG5cclxuLyoqXHJcbiAqIG5ldyBDb3JlKClcclxuICoqL1xyXG5mdW5jdGlvbiBDb3JlKCkge1xyXG4gIC8qKlxyXG4gICAqIENvcmUjcnVsZXIgLT4gUnVsZXJcclxuICAgKlxyXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gS2VlcCBjb25maWd1cmF0aW9uIG9mIGNvcmUgcnVsZXMuXHJcbiAgICoqL1xyXG4gIHRoaXMucnVsZXIgPSBuZXcgUnVsZXIoKTtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBfcnVsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIHRoaXMucnVsZXIucHVzaChfcnVsZXNbaV1bMF0sIF9ydWxlc1tpXVsxXSk7XHJcbiAgfVxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIENvcmUucHJvY2VzcyhzdGF0ZSlcclxuICpcclxuICogRXhlY3V0ZXMgY29yZSBjaGFpbiBydWxlcy5cclxuICoqL1xyXG5Db3JlLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgdmFyIGksIGwsIHJ1bGVzO1xyXG5cclxuICBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpO1xyXG5cclxuICBmb3IgKGkgPSAwLCBsID0gcnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICBydWxlc1tpXShzdGF0ZSk7XHJcbiAgfVxyXG59O1xyXG5cclxuQ29yZS5wcm90b3R5cGUuU3RhdGUgPSByZXF1aXJlKCcuL3J1bGVzX2NvcmUvc3RhdGVfY29yZScpO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29yZTtcclxuXHJcbn0se1wiLi9ydWxlclwiOjE4LFwiLi9ydWxlc19jb3JlL2Jsb2NrXCI6MzEsXCIuL3J1bGVzX2NvcmUvaW5saW5lXCI6MzIsXCIuL3J1bGVzX2NvcmUvbGlua2lmeVwiOjMzLFwiLi9ydWxlc19jb3JlL25vcm1hbGl6ZVwiOjM0LFwiLi9ydWxlc19jb3JlL3JlcGxhY2VtZW50c1wiOjM1LFwiLi9ydWxlc19jb3JlL3NtYXJ0cXVvdGVzXCI6MzYsXCIuL3J1bGVzX2NvcmUvc3RhdGVfY29yZVwiOjM3fV0sMTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4vKiogaW50ZXJuYWxcclxuICogY2xhc3MgUGFyc2VySW5saW5lXHJcbiAqXHJcbiAqIFRva2VuaXplcyBwYXJhZ3JhcGggY29udGVudC5cclxuICoqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIFJ1bGVyICAgICAgICAgICA9IHJlcXVpcmUoJy4vcnVsZXInKTtcclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLyBQYXJzZXIgcnVsZXNcclxuXHJcbnZhciBfcnVsZXMgPSBbXHJcbiAgWyAndGV4dCcsICAgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvdGV4dCcpIF0sXHJcbiAgWyAnbmV3bGluZScsICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvbmV3bGluZScpIF0sXHJcbiAgWyAnZXNjYXBlJywgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvZXNjYXBlJykgXSxcclxuICBbICdiYWNrdGlja3MnLCAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9iYWNrdGlja3MnKSBdLFxyXG4gIFsgJ3N0cmlrZXRocm91Z2gnLCAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3N0cmlrZXRocm91Z2gnKSBdLFxyXG4gIFsgJ2VtcGhhc2lzJywgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VtcGhhc2lzJykgXSxcclxuICBbICdsaW5rJywgICAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9saW5rJykgXSxcclxuICBbICdpbWFnZScsICAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9pbWFnZScpIF0sXHJcbiAgWyAnYXV0b2xpbmsnLCAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvYXV0b2xpbmsnKSBdLFxyXG4gIFsgJ2h0bWxfaW5saW5lJywgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2h0bWxfaW5saW5lJykgXSxcclxuICBbICdlbnRpdHknLCAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9lbnRpdHknKSBdXHJcbl07XHJcblxyXG5cclxuLyoqXHJcbiAqIG5ldyBQYXJzZXJJbmxpbmUoKVxyXG4gKiovXHJcbmZ1bmN0aW9uIFBhcnNlcklubGluZSgpIHtcclxuICAvKipcclxuICAgKiBQYXJzZXJJbmxpbmUjcnVsZXIgLT4gUnVsZXJcclxuICAgKlxyXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gS2VlcCBjb25maWd1cmF0aW9uIG9mIGlubGluZSBydWxlcy5cclxuICAgKiovXHJcbiAgdGhpcy5ydWxlciA9IG5ldyBSdWxlcigpO1xyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IF9ydWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgdGhpcy5ydWxlci5wdXNoKF9ydWxlc1tpXVswXSwgX3J1bGVzW2ldWzFdKTtcclxuICB9XHJcbn1cclxuXHJcblxyXG4vLyBTa2lwIHNpbmdsZSB0b2tlbiBieSBydW5uaW5nIGFsbCBydWxlcyBpbiB2YWxpZGF0aW9uIG1vZGU7XHJcbi8vIHJldHVybnMgYHRydWVgIGlmIGFueSBydWxlIHJlcG9ydGVkIHN1Y2Nlc3NcclxuLy9cclxuUGFyc2VySW5saW5lLnByb3RvdHlwZS5za2lwVG9rZW4gPSBmdW5jdGlvbiAoc3RhdGUpIHtcclxuICB2YXIgaSwgcG9zID0gc3RhdGUucG9zLFxyXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpLFxyXG4gICAgICBsZW4gPSBydWxlcy5sZW5ndGgsXHJcbiAgICAgIG1heE5lc3RpbmcgPSBzdGF0ZS5tZC5vcHRpb25zLm1heE5lc3RpbmcsXHJcbiAgICAgIGNhY2hlID0gc3RhdGUuY2FjaGU7XHJcblxyXG5cclxuICBpZiAodHlwZW9mIGNhY2hlW3Bvc10gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBzdGF0ZS5wb3MgPSBjYWNoZVtwb3NdO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgLyppc3RhbmJ1bCBpZ25vcmUgZWxzZSovXHJcbiAgaWYgKHN0YXRlLmxldmVsIDwgbWF4TmVzdGluZykge1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIGlmIChydWxlc1tpXShzdGF0ZSwgdHJ1ZSkpIHtcclxuICAgICAgICBjYWNoZVtwb3NdID0gc3RhdGUucG9zO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RhdGUucG9zKys7XHJcbiAgY2FjaGVbcG9zXSA9IHN0YXRlLnBvcztcclxufTtcclxuXHJcblxyXG4vLyBHZW5lcmF0ZSB0b2tlbnMgZm9yIGlucHV0IHJhbmdlXHJcbi8vXHJcblBhcnNlcklubGluZS5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcclxuICB2YXIgb2ssIGksXHJcbiAgICAgIHJ1bGVzID0gdGhpcy5ydWxlci5nZXRSdWxlcygnJyksXHJcbiAgICAgIGxlbiA9IHJ1bGVzLmxlbmd0aCxcclxuICAgICAgZW5kID0gc3RhdGUucG9zTWF4LFxyXG4gICAgICBtYXhOZXN0aW5nID0gc3RhdGUubWQub3B0aW9ucy5tYXhOZXN0aW5nO1xyXG5cclxuICB3aGlsZSAoc3RhdGUucG9zIDwgZW5kKSB7XHJcbiAgICAvLyBUcnkgYWxsIHBvc3NpYmxlIHJ1bGVzLlxyXG4gICAgLy8gT24gc3VjY2VzcywgcnVsZSBzaG91bGQ6XHJcbiAgICAvL1xyXG4gICAgLy8gLSB1cGRhdGUgYHN0YXRlLnBvc2BcclxuICAgIC8vIC0gdXBkYXRlIGBzdGF0ZS50b2tlbnNgXHJcbiAgICAvLyAtIHJldHVybiB0cnVlXHJcblxyXG4gICAgaWYgKHN0YXRlLmxldmVsIDwgbWF4TmVzdGluZykge1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBvayA9IHJ1bGVzW2ldKHN0YXRlLCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKG9rKSB7IGJyZWFrOyB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAob2spIHtcclxuICAgICAgaWYgKHN0YXRlLnBvcyA+PSBlbmQpIHsgYnJlYWs7IH1cclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmNbc3RhdGUucG9zKytdO1xyXG4gIH1cclxuXHJcbiAgaWYgKHN0YXRlLnBlbmRpbmcpIHtcclxuICAgIHN0YXRlLnB1c2hQZW5kaW5nKCk7XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBQYXJzZXJJbmxpbmUucGFyc2Uoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpXHJcbiAqXHJcbiAqIFByb2Nlc3MgaW5wdXQgc3RyaW5nIGFuZCBwdXNoIGlubGluZSB0b2tlbnMgaW50byBgb3V0VG9rZW5zYFxyXG4gKiovXHJcblBhcnNlcklubGluZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpIHtcclxuICB2YXIgc3RhdGUgPSBuZXcgdGhpcy5TdGF0ZShzdHIsIG1kLCBlbnYsIG91dFRva2Vucyk7XHJcblxyXG4gIHRoaXMudG9rZW5pemUoc3RhdGUpO1xyXG59O1xyXG5cclxuXHJcblBhcnNlcklubGluZS5wcm90b3R5cGUuU3RhdGUgPSByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUnKTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlcklubGluZTtcclxuXHJcbn0se1wiLi9ydWxlclwiOjE4LFwiLi9ydWxlc19pbmxpbmUvYXV0b2xpbmtcIjozOCxcIi4vcnVsZXNfaW5saW5lL2JhY2t0aWNrc1wiOjM5LFwiLi9ydWxlc19pbmxpbmUvZW1waGFzaXNcIjo0MCxcIi4vcnVsZXNfaW5saW5lL2VudGl0eVwiOjQxLFwiLi9ydWxlc19pbmxpbmUvZXNjYXBlXCI6NDIsXCIuL3J1bGVzX2lubGluZS9odG1sX2lubGluZVwiOjQzLFwiLi9ydWxlc19pbmxpbmUvaW1hZ2VcIjo0NCxcIi4vcnVsZXNfaW5saW5lL2xpbmtcIjo0NSxcIi4vcnVsZXNfaW5saW5lL25ld2xpbmVcIjo0NixcIi4vcnVsZXNfaW5saW5lL3N0YXRlX2lubGluZVwiOjQ3LFwiLi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaFwiOjQ4LFwiLi9ydWxlc19pbmxpbmUvdGV4dFwiOjQ5fV0sMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4vLyBDb21tb25tYXJrIGRlZmF1bHQgb3B0aW9uc1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIG9wdGlvbnM6IHtcclxuICAgIGh0bWw6ICAgICAgICAgdHJ1ZSwgICAgICAgICAvLyBFbmFibGUgSFRNTCB0YWdzIGluIHNvdXJjZVxyXG4gICAgeGh0bWxPdXQ6ICAgICB0cnVlLCAgICAgICAgIC8vIFVzZSAnLycgdG8gY2xvc2Ugc2luZ2xlIHRhZ3MgKDxiciAvPilcclxuICAgIGJyZWFrczogICAgICAgZmFsc2UsICAgICAgICAvLyBDb252ZXJ0ICdcXG4nIGluIHBhcmFncmFwaHMgaW50byA8YnI+XHJcbiAgICBsYW5nUHJlZml4OiAgICdsYW5ndWFnZS0nLCAgLy8gQ1NTIGxhbmd1YWdlIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrc1xyXG4gICAgbGlua2lmeTogICAgICBmYWxzZSwgICAgICAgIC8vIGF1dG9jb252ZXJ0IFVSTC1saWtlIHRleHRzIHRvIGxpbmtzXHJcblxyXG4gICAgLy8gRW5hYmxlIHNvbWUgbGFuZ3VhZ2UtbmV1dHJhbCByZXBsYWNlbWVudHMgKyBxdW90ZXMgYmVhdXRpZmljYXRpb25cclxuICAgIHR5cG9ncmFwaGVyOiAgZmFsc2UsXHJcblxyXG4gICAgLy8gRG91YmxlICsgc2luZ2xlIHF1b3RlcyByZXBsYWNlbWVudCBwYWlycywgd2hlbiB0eXBvZ3JhcGhlciBlbmFibGVkLFxyXG4gICAgLy8gYW5kIHNtYXJ0cXVvdGVzIG9uLiBTZXQgZG91YmxlcyB0byAnwqvCuycgZm9yIFJ1c3NpYW4sICfigJ7igJwnIGZvciBHZXJtYW4uXHJcbiAgICBxdW90ZXM6ICdcXHUyMDFjXFx1MjAxZFxcdTIwMThcXHUyMDE5JyAvKiDigJzigJ3igJjigJkgKi8sXHJcblxyXG4gICAgLy8gSGlnaGxpZ2h0ZXIgZnVuY3Rpb24uIFNob3VsZCByZXR1cm4gZXNjYXBlZCBIVE1MLFxyXG4gICAgLy8gb3IgJycgaWYgaW5wdXQgbm90IGNoYW5nZWRcclxuICAgIC8vXHJcbiAgICAvLyBmdW5jdGlvbiAoLypzdHIsIGxhbmcqLykgeyByZXR1cm4gJyc7IH1cclxuICAgIC8vXHJcbiAgICBoaWdobGlnaHQ6IG51bGwsXHJcblxyXG4gICAgbWF4TmVzdGluZzogICAyMCAgICAgICAgICAgIC8vIEludGVybmFsIHByb3RlY3Rpb24sIHJlY3Vyc2lvbiBsaW1pdFxyXG4gIH0sXHJcblxyXG4gIGNvbXBvbmVudHM6IHtcclxuXHJcbiAgICBjb3JlOiB7XHJcbiAgICAgIHJ1bGVzOiBbXHJcbiAgICAgICAgJ25vcm1hbGl6ZScsXHJcbiAgICAgICAgJ2Jsb2NrJyxcclxuICAgICAgICAnaW5saW5lJ1xyXG4gICAgICBdXHJcbiAgICB9LFxyXG5cclxuICAgIGJsb2NrOiB7XHJcbiAgICAgIHJ1bGVzOiBbXHJcbiAgICAgICAgJ2Jsb2NrcXVvdGUnLFxyXG4gICAgICAgICdjb2RlJyxcclxuICAgICAgICAnZmVuY2UnLFxyXG4gICAgICAgICdoZWFkaW5nJyxcclxuICAgICAgICAnaHInLFxyXG4gICAgICAgICdodG1sX2Jsb2NrJyxcclxuICAgICAgICAnbGhlYWRpbmcnLFxyXG4gICAgICAgICdsaXN0JyxcclxuICAgICAgICAncmVmZXJlbmNlJyxcclxuICAgICAgICAncGFyYWdyYXBoJ1xyXG4gICAgICBdXHJcbiAgICB9LFxyXG5cclxuICAgIGlubGluZToge1xyXG4gICAgICBydWxlczogW1xyXG4gICAgICAgICdhdXRvbGluaycsXHJcbiAgICAgICAgJ2JhY2t0aWNrcycsXHJcbiAgICAgICAgJ2VtcGhhc2lzJyxcclxuICAgICAgICAnZW50aXR5JyxcclxuICAgICAgICAnZXNjYXBlJyxcclxuICAgICAgICAnaHRtbF9pbmxpbmUnLFxyXG4gICAgICAgICdpbWFnZScsXHJcbiAgICAgICAgJ2xpbmsnLFxyXG4gICAgICAgICduZXdsaW5lJyxcclxuICAgICAgICAndGV4dCdcclxuICAgICAgXVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbn0se31dLDE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLy8gbWFya2Rvd24taXQgZGVmYXVsdCBvcHRpb25zXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgb3B0aW9uczoge1xyXG4gICAgaHRtbDogICAgICAgICBmYWxzZSwgICAgICAgIC8vIEVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlXHJcbiAgICB4aHRtbE91dDogICAgIGZhbHNlLCAgICAgICAgLy8gVXNlICcvJyB0byBjbG9zZSBzaW5nbGUgdGFncyAoPGJyIC8+KVxyXG4gICAgYnJlYWtzOiAgICAgICBmYWxzZSwgICAgICAgIC8vIENvbnZlcnQgJ1xcbicgaW4gcGFyYWdyYXBocyBpbnRvIDxicj5cclxuICAgIGxhbmdQcmVmaXg6ICAgJ2xhbmd1YWdlLScsICAvLyBDU1MgbGFuZ3VhZ2UgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzXHJcbiAgICBsaW5raWZ5OiAgICAgIGZhbHNlLCAgICAgICAgLy8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dHMgdG8gbGlua3NcclxuXHJcbiAgICAvLyBFbmFibGUgc29tZSBsYW5ndWFnZS1uZXV0cmFsIHJlcGxhY2VtZW50cyArIHF1b3RlcyBiZWF1dGlmaWNhdGlvblxyXG4gICAgdHlwb2dyYXBoZXI6ICBmYWxzZSxcclxuXHJcbiAgICAvLyBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50IHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQsXHJcbiAgICAvLyBhbmQgc21hcnRxdW90ZXMgb24uIFNldCBkb3VibGVzIHRvICfCq8K7JyBmb3IgUnVzc2lhbiwgJ+KAnuKAnCcgZm9yIEdlcm1hbi5cclxuICAgIHF1b3RlczogJ1xcdTIwMWNcXHUyMDFkXFx1MjAxOFxcdTIwMTknIC8qIOKAnOKAneKAmOKAmSAqLyxcclxuXHJcbiAgICAvLyBIaWdobGlnaHRlciBmdW5jdGlvbi4gU2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwsXHJcbiAgICAvLyBvciAnJyBpZiBpbnB1dCBub3QgY2hhbmdlZFxyXG4gICAgLy9cclxuICAgIC8vIGZ1bmN0aW9uICgvKnN0ciwgbGFuZyovKSB7IHJldHVybiAnJzsgfVxyXG4gICAgLy9cclxuICAgIGhpZ2hsaWdodDogbnVsbCxcclxuXHJcbiAgICBtYXhOZXN0aW5nOiAgIDIwICAgICAgICAgICAgLy8gSW50ZXJuYWwgcHJvdGVjdGlvbiwgcmVjdXJzaW9uIGxpbWl0XHJcbiAgfSxcclxuXHJcbiAgY29tcG9uZW50czoge1xyXG5cclxuICAgIGNvcmU6IHt9LFxyXG4gICAgYmxvY2s6IHt9LFxyXG4gICAgaW5saW5lOiB7fVxyXG4gIH1cclxufTtcclxuXHJcbn0se31dLDE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLy8gXCJaZXJvXCIgcHJlc2V0LCB3aXRoIG5vdGhpbmcgZW5hYmxlZC4gVXNlZnVsIGZvciBtYW51YWwgY29uZmlndXJpbmcgb2Ygc2ltcGxlXHJcbi8vIG1vZGVzLiBGb3IgZXhhbXBsZSwgdG8gcGFyc2UgYm9sZC9pdGFsaWMgb25seS5cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBvcHRpb25zOiB7XHJcbiAgICBodG1sOiAgICAgICAgIGZhbHNlLCAgICAgICAgLy8gRW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2VcclxuICAgIHhodG1sT3V0OiAgICAgZmFsc2UsICAgICAgICAvLyBVc2UgJy8nIHRvIGNsb3NlIHNpbmdsZSB0YWdzICg8YnIgLz4pXHJcbiAgICBicmVha3M6ICAgICAgIGZhbHNlLCAgICAgICAgLy8gQ29udmVydCAnXFxuJyBpbiBwYXJhZ3JhcGhzIGludG8gPGJyPlxyXG4gICAgbGFuZ1ByZWZpeDogICAnbGFuZ3VhZ2UtJywgIC8vIENTUyBsYW5ndWFnZSBwcmVmaXggZm9yIGZlbmNlZCBibG9ja3NcclxuICAgIGxpbmtpZnk6ICAgICAgZmFsc2UsICAgICAgICAvLyBhdXRvY29udmVydCBVUkwtbGlrZSB0ZXh0cyB0byBsaW5rc1xyXG5cclxuICAgIC8vIEVuYWJsZSBzb21lIGxhbmd1YWdlLW5ldXRyYWwgcmVwbGFjZW1lbnRzICsgcXVvdGVzIGJlYXV0aWZpY2F0aW9uXHJcbiAgICB0eXBvZ3JhcGhlcjogIGZhbHNlLFxyXG5cclxuICAgIC8vIERvdWJsZSArIHNpbmdsZSBxdW90ZXMgcmVwbGFjZW1lbnQgcGFpcnMsIHdoZW4gdHlwb2dyYXBoZXIgZW5hYmxlZCxcclxuICAgIC8vIGFuZCBzbWFydHF1b3RlcyBvbi4gU2V0IGRvdWJsZXMgdG8gJ8KrwrsnIGZvciBSdXNzaWFuLCAn4oCe4oCcJyBmb3IgR2VybWFuLlxyXG4gICAgcXVvdGVzOiAnXFx1MjAxY1xcdTIwMWRcXHUyMDE4XFx1MjAxOScgLyog4oCc4oCd4oCY4oCZICovLFxyXG5cclxuICAgIC8vIEhpZ2hsaWdodGVyIGZ1bmN0aW9uLiBTaG91bGQgcmV0dXJuIGVzY2FwZWQgSFRNTCxcclxuICAgIC8vIG9yICcnIGlmIGlucHV0IG5vdCBjaGFuZ2VkXHJcbiAgICAvL1xyXG4gICAgLy8gZnVuY3Rpb24gKC8qc3RyLCBsYW5nKi8pIHsgcmV0dXJuICcnOyB9XHJcbiAgICAvL1xyXG4gICAgaGlnaGxpZ2h0OiBudWxsLFxyXG5cclxuICAgIG1heE5lc3Rpbmc6ICAgMjAgICAgICAgICAgICAvLyBJbnRlcm5hbCBwcm90ZWN0aW9uLCByZWN1cnNpb24gbGltaXRcclxuICB9LFxyXG5cclxuICBjb21wb25lbnRzOiB7XHJcblxyXG4gICAgY29yZToge1xyXG4gICAgICBydWxlczogW1xyXG4gICAgICAgICdub3JtYWxpemUnLFxyXG4gICAgICAgICdibG9jaycsXHJcbiAgICAgICAgJ2lubGluZSdcclxuICAgICAgXVxyXG4gICAgfSxcclxuXHJcbiAgICBibG9jazoge1xyXG4gICAgICBydWxlczogW1xyXG4gICAgICAgICdwYXJhZ3JhcGgnXHJcbiAgICAgIF1cclxuICAgIH0sXHJcblxyXG4gICAgaW5saW5lOiB7XHJcbiAgICAgIHJ1bGVzOiBbXHJcbiAgICAgICAgJ3RleHQnXHJcbiAgICAgIF1cclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG59LHt9XSwxNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8qKlxyXG4gKiBjbGFzcyBSZW5kZXJlclxyXG4gKlxyXG4gKiBHZW5lcmF0ZXMgSFRNTCBmcm9tIHBhcnNlZCB0b2tlbiBzdHJlYW0uIEVhY2ggaW5zdGFuY2UgaGFzIGluZGVwZW5kZW50XHJcbiAqIGNvcHkgb2YgcnVsZXMuIFRob3NlIGNhbiBiZSByZXdyaXR0ZW4gd2l0aCBlYXNlLiBBbHNvLCB5b3UgY2FuIGFkZCBuZXdcclxuICogcnVsZXMgaWYgeW91IGNyZWF0ZSBwbHVnaW4gYW5kIGFkZHMgbmV3IHRva2VuIHR5cGVzLlxyXG4gKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgYXNzaWduICAgICAgICAgID0gcmVxdWlyZSgnLi9jb21tb24vdXRpbHMnKS5hc3NpZ247XHJcbnZhciB1bmVzY2FwZUFsbCAgICAgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpLnVuZXNjYXBlQWxsO1xyXG52YXIgZXNjYXBlSHRtbCAgICAgID0gcmVxdWlyZSgnLi9jb21tb24vdXRpbHMnKS5lc2NhcGVIdG1sO1xyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG52YXIgZGVmYXVsdF9ydWxlcyA9IHt9O1xyXG5cclxuXHJcbmRlZmF1bHRfcnVsZXMuY29kZV9pbmxpbmUgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xyXG4gIHJldHVybiAnPGNvZGU+JyArIGVzY2FwZUh0bWwodG9rZW5zW2lkeF0uY29udGVudCkgKyAnPC9jb2RlPic7XHJcbn07XHJcblxyXG5cclxuZGVmYXVsdF9ydWxlcy5jb2RlX2Jsb2NrID0gZnVuY3Rpb24gKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcclxuICByZXR1cm4gJzxwcmU+PGNvZGU+JyArIGVzY2FwZUh0bWwodG9rZW5zW2lkeF0uY29udGVudCkgKyAnPC9jb2RlPjwvcHJlPlxcbic7XHJcbn07XHJcblxyXG5cclxuZGVmYXVsdF9ydWxlcy5mZW5jZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzZWxmKSB7XHJcbiAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF0sXHJcbiAgICAgIGxhbmdOYW1lID0gJycsXHJcbiAgICAgIGhpZ2hsaWdodGVkO1xyXG5cclxuICBpZiAodG9rZW4uaW5mbykge1xyXG4gICAgbGFuZ05hbWUgPSB1bmVzY2FwZUFsbCh0b2tlbi5pbmZvLnRyaW0oKS5zcGxpdCgvXFxzKy9nKVswXSk7XHJcbiAgICB0b2tlbi5hdHRyUHVzaChbICdjbGFzcycsIG9wdGlvbnMubGFuZ1ByZWZpeCArIGxhbmdOYW1lIF0pO1xyXG4gIH1cclxuXHJcbiAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0KSB7XHJcbiAgICBoaWdobGlnaHRlZCA9IG9wdGlvbnMuaGlnaGxpZ2h0KHRva2VuLmNvbnRlbnQsIGxhbmdOYW1lKSB8fCBlc2NhcGVIdG1sKHRva2VuLmNvbnRlbnQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBoaWdobGlnaHRlZCA9IGVzY2FwZUh0bWwodG9rZW4uY29udGVudCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gICc8cHJlPjxjb2RlJyArIHNlbGYucmVuZGVyQXR0cnModG9rZW4pICsgJz4nXHJcbiAgICAgICAgKyBoaWdobGlnaHRlZFxyXG4gICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xyXG59O1xyXG5cclxuXHJcbmRlZmF1bHRfcnVsZXMuaW1hZ2UgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2VsZikge1xyXG4gIHZhciB0b2tlbiA9IHRva2Vuc1tpZHhdO1xyXG5cclxuICAvLyBcImFsdFwiIGF0dHIgTVVTVCBiZSBzZXQsIGV2ZW4gaWYgZW1wdHkuIEJlY2F1c2UgaXQncyBtYW5kYXRvcnkgYW5kXHJcbiAgLy8gc2hvdWxkIGJlIHBsYWNlZCBvbiBwcm9wZXIgcG9zaXRpb24gZm9yIHRlc3RzLlxyXG4gIC8vXHJcbiAgLy8gUmVwbGFjZSBjb250ZW50IHdpdGggYWN0dWFsIHZhbHVlXHJcblxyXG4gIHRva2VuLmF0dHJzW3Rva2VuLmF0dHJJbmRleCgnYWx0JyldWzFdID1cclxuICAgIHNlbGYucmVuZGVySW5saW5lQXNUZXh0KHRva2VuLmNoaWxkcmVuLCBvcHRpb25zLCBlbnYpO1xyXG5cclxuICByZXR1cm4gc2VsZi5yZW5kZXJUb2tlbih0b2tlbnMsIGlkeCwgb3B0aW9ucyk7XHJcbn07XHJcblxyXG5cclxuZGVmYXVsdF9ydWxlcy5oYXJkYnJlYWsgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMgLyosIGVudiAqLykge1xyXG4gIHJldHVybiBvcHRpb25zLnhodG1sT3V0ID8gJzxiciAvPlxcbicgOiAnPGJyPlxcbic7XHJcbn07XHJcbmRlZmF1bHRfcnVsZXMuc29mdGJyZWFrID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zIC8qLCBlbnYgKi8pIHtcclxuICByZXR1cm4gb3B0aW9ucy5icmVha3MgPyAob3B0aW9ucy54aHRtbE91dCA/ICc8YnIgLz5cXG4nIDogJzxicj5cXG4nKSA6ICdcXG4nO1xyXG59O1xyXG5cclxuXHJcbmRlZmF1bHRfcnVsZXMudGV4dCA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XHJcbiAgcmV0dXJuIGVzY2FwZUh0bWwodG9rZW5zW2lkeF0uY29udGVudCk7XHJcbn07XHJcblxyXG5cclxuZGVmYXVsdF9ydWxlcy5odG1sX2Jsb2NrID0gZnVuY3Rpb24gKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcclxuICByZXR1cm4gdG9rZW5zW2lkeF0uY29udGVudDtcclxufTtcclxuZGVmYXVsdF9ydWxlcy5odG1sX2lubGluZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XHJcbiAgcmV0dXJuIHRva2Vuc1tpZHhdLmNvbnRlbnQ7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIG5ldyBSZW5kZXJlcigpXHJcbiAqXHJcbiAqIENyZWF0ZXMgbmV3IFtbUmVuZGVyZXJdXSBpbnN0YW5jZSBhbmQgZmlsbCBbW1JlbmRlcmVyI3J1bGVzXV0gd2l0aCBkZWZhdWx0cy5cclxuICoqL1xyXG5mdW5jdGlvbiBSZW5kZXJlcigpIHtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVuZGVyZXIjcnVsZXMgLT4gT2JqZWN0XHJcbiAgICpcclxuICAgKiBDb250YWlucyByZW5kZXIgcnVsZXMgZm9yIHRva2Vucy4gQ2FuIGJlIHVwZGF0ZWQgYW5kIGV4dGVuZGVkLlxyXG4gICAqXHJcbiAgICogIyMjIyMgRXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBgamF2YXNjcmlwdFxyXG4gICAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcclxuICAgKlxyXG4gICAqIG1kLnJlbmRlcmVyLnJ1bGVzLnN0cm9uZ19vcGVuICA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICc8Yj4nOyB9O1xyXG4gICAqIG1kLnJlbmRlcmVyLnJ1bGVzLnN0cm9uZ19jbG9zZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICc8L2I+JzsgfTtcclxuICAgKlxyXG4gICAqIHZhciByZXN1bHQgPSBtZC5yZW5kZXJJbmxpbmUoLi4uKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEVhY2ggcnVsZSBpcyBjYWxsZWQgYXMgaW5kZXBlbmRlZCBzdGF0aWMgZnVuY3Rpb24gd2l0aCBmaXhlZCBzaWduYXR1cmU6XHJcbiAgICpcclxuICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICogZnVuY3Rpb24gbXlfdG9rZW5fcmVuZGVyKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHJlbmRlcmVyKSB7XHJcbiAgICogICAvLyAuLi5cclxuICAgKiAgIHJldHVybiByZW5kZXJlZEhUTUw7XHJcbiAgICogfVxyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogU2VlIFtzb3VyY2UgY29kZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9yZW5kZXJlci5qcylcclxuICAgKiBmb3IgbW9yZSBkZXRhaWxzIGFuZCBleGFtcGxlcy5cclxuICAgKiovXHJcbiAgdGhpcy5ydWxlcyA9IGFzc2lnbih7fSwgZGVmYXVsdF9ydWxlcyk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogUmVuZGVyZXIucmVuZGVyQXR0cnModG9rZW4pIC0+IFN0cmluZ1xyXG4gKlxyXG4gKiBSZW5kZXIgdG9rZW4gYXR0cmlidXRlcyB0byBzdHJpbmcuXHJcbiAqKi9cclxuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckF0dHJzID0gZnVuY3Rpb24gcmVuZGVyQXR0cnModG9rZW4pIHtcclxuICB2YXIgaSwgbCwgcmVzdWx0O1xyXG5cclxuICBpZiAoIXRva2VuLmF0dHJzKSB7IHJldHVybiAnJzsgfVxyXG5cclxuICByZXN1bHQgPSAnJztcclxuXHJcbiAgZm9yIChpID0gMCwgbCA9IHRva2VuLmF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgcmVzdWx0ICs9ICcgJyArIGVzY2FwZUh0bWwodG9rZW4uYXR0cnNbaV1bMF0pICsgJz1cIicgKyBlc2NhcGVIdG1sKHRva2VuLmF0dHJzW2ldWzFdKSArICdcIic7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJlci5yZW5kZXJUb2tlbih0b2tlbnMsIGlkeCwgb3B0aW9ucykgLT4gU3RyaW5nXHJcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb2YgdG9rZW5zXHJcbiAqIC0gaWR4IChOdW1iZWQpOiB0b2tlbiBpbmRleCB0byByZW5kZXJcclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXHJcbiAqXHJcbiAqIERlZmF1bHQgdG9rZW4gcmVuZGVyZXIuIENhbiBiZSBvdmVycmlkZW4gYnkgY3VzdG9tIGZ1bmN0aW9uXHJcbiAqIGluIFtbUmVuZGVyZXIjcnVsZXNdXS5cclxuICoqL1xyXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVyVG9rZW4gPSBmdW5jdGlvbiByZW5kZXJUb2tlbih0b2tlbnMsIGlkeCwgb3B0aW9ucykge1xyXG4gIHZhciBuZXh0VG9rZW4sXHJcbiAgICAgIHJlc3VsdCA9ICcnLFxyXG4gICAgICBuZWVkTGYgPSBmYWxzZSxcclxuICAgICAgdG9rZW4gPSB0b2tlbnNbaWR4XTtcclxuXHJcbiAgLy8gVGlnaHQgbGlzdCBwYXJhZ3JhcGhzXHJcbiAgaWYgKHRva2VuLmhpZGRlbikge1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxuXHJcbiAgLy8gSW5zZXJ0IGEgbmV3bGluZSBiZXR3ZWVuIGhpZGRlbiBwYXJhZ3JhcGggYW5kIHN1YnNlcXVlbnQgb3BlbmluZ1xyXG4gIC8vIGJsb2NrLWxldmVsIHRhZy5cclxuICAvL1xyXG4gIC8vIEZvciBleGFtcGxlLCBoZXJlIHdlIHNob3VsZCBpbnNlcnQgYSBuZXdsaW5lIGJlZm9yZSBibG9ja3F1b3RlOlxyXG4gIC8vICAtIGFcclxuICAvLyAgICA+XHJcbiAgLy9cclxuICBpZiAodG9rZW4uYmxvY2sgJiYgdG9rZW4ubmVzdGluZyAhPT0gLTEgJiYgaWR4ICYmIHRva2Vuc1tpZHggLSAxXS5oaWRkZW4pIHtcclxuICAgIHJlc3VsdCArPSAnXFxuJztcclxuICB9XHJcblxyXG4gIC8vIEFkZCB0b2tlbiBuYW1lLCBlLmcuIGA8aW1nYFxyXG4gIHJlc3VsdCArPSAodG9rZW4ubmVzdGluZyA9PT0gLTEgPyAnPC8nIDogJzwnKSArIHRva2VuLnRhZztcclxuXHJcbiAgLy8gRW5jb2RlIGF0dHJpYnV0ZXMsIGUuZy4gYDxpbWcgc3JjPVwiZm9vXCJgXHJcbiAgcmVzdWx0ICs9IHRoaXMucmVuZGVyQXR0cnModG9rZW4pO1xyXG5cclxuICAvLyBBZGQgYSBzbGFzaCBmb3Igc2VsZi1jbG9zaW5nIHRhZ3MsIGUuZy4gYDxpbWcgc3JjPVwiZm9vXCIgL2BcclxuICBpZiAodG9rZW4ubmVzdGluZyA9PT0gMCAmJiBvcHRpb25zLnhodG1sT3V0KSB7XHJcbiAgICByZXN1bHQgKz0gJyAvJztcclxuICB9XHJcblxyXG4gIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gYWRkIGEgbmV3bGluZSBhZnRlciB0aGlzIHRhZ1xyXG4gIGlmICh0b2tlbi5ibG9jaykge1xyXG4gICAgbmVlZExmID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAodG9rZW4ubmVzdGluZyA9PT0gMSkge1xyXG4gICAgICBpZiAoaWR4ICsgMSA8IHRva2Vucy5sZW5ndGgpIHtcclxuICAgICAgICBuZXh0VG9rZW4gPSB0b2tlbnNbaWR4ICsgMV07XHJcblxyXG4gICAgICAgIGlmIChuZXh0VG9rZW4udHlwZSA9PT0gJ2lubGluZScgfHwgbmV4dFRva2VuLmhpZGRlbikge1xyXG4gICAgICAgICAgLy8gQmxvY2stbGV2ZWwgdGFnIGNvbnRhaW5pbmcgYW4gaW5saW5lIHRhZy5cclxuICAgICAgICAgIC8vXHJcbiAgICAgICAgICBuZWVkTGYgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0VG9rZW4ubmVzdGluZyA9PT0gLTEgJiYgbmV4dFRva2VuLnRhZyA9PT0gdG9rZW4udGFnKSB7XHJcbiAgICAgICAgICAvLyBPcGVuaW5nIHRhZyArIGNsb3NpbmcgdGFnIG9mIHRoZSBzYW1lIHR5cGUuIEUuZy4gYDxsaT48L2xpPmAuXHJcbiAgICAgICAgICAvL1xyXG4gICAgICAgICAgbmVlZExmID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXN1bHQgKz0gbmVlZExmID8gJz5cXG4nIDogJz4nO1xyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJlci5yZW5kZXJJbmxpbmUodG9rZW5zLCBvcHRpb25zLCBlbnYpIC0+IFN0cmluZ1xyXG4gKiAtIHRva2VucyAoQXJyYXkpOiBsaXN0IG9uIGJsb2NrIHRva2VucyB0byByZW50ZXJcclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXHJcbiAqIC0gZW52IChPYmplY3QpOiBhZGRpdGlvbmFsIGRhdGEgZnJvbSBwYXJzZWQgaW5wdXQgKHJlZmVyZW5jZXMsIGZvciBleGFtcGxlKVxyXG4gKlxyXG4gKiBUaGUgc2FtZSBhcyBbW1JlbmRlcmVyLnJlbmRlcl1dLCBidXQgZm9yIHNpbmdsZSB0b2tlbiBvZiBgaW5saW5lYCB0eXBlLlxyXG4gKiovXHJcblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJJbmxpbmUgPSBmdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zLCBlbnYpIHtcclxuICB2YXIgdHlwZSxcclxuICAgICAgcmVzdWx0ID0gJycsXHJcbiAgICAgIHJ1bGVzID0gdGhpcy5ydWxlcztcclxuXHJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgdHlwZSA9IHRva2Vuc1tpXS50eXBlO1xyXG5cclxuICAgIGlmICh0eXBlb2YgcnVsZXNbdHlwZV0gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHJlc3VsdCArPSBydWxlc1t0eXBlXSh0b2tlbnMsIGksIG9wdGlvbnMsIGVudiwgdGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJUb2tlbih0b2tlbnMsIGksIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblxyXG4vKiogaW50ZXJuYWxcclxuICogUmVuZGVyZXIucmVuZGVySW5saW5lQXNUZXh0KHRva2Vucywgb3B0aW9ucywgZW52KSAtPiBTdHJpbmdcclxuICogLSB0b2tlbnMgKEFycmF5KTogbGlzdCBvbiBibG9jayB0b2tlbnMgdG8gcmVudGVyXHJcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcGFyYW1zIG9mIHBhcnNlciBpbnN0YW5jZVxyXG4gKiAtIGVudiAoT2JqZWN0KTogYWRkaXRpb25hbCBkYXRhIGZyb20gcGFyc2VkIGlucHV0IChyZWZlcmVuY2VzLCBmb3IgZXhhbXBsZSlcclxuICpcclxuICogU3BlY2lhbCBrbHVkZ2UgZm9yIGltYWdlIGBhbHRgIGF0dHJpYnV0ZXMgdG8gY29uZm9ybSBDb21tb25NYXJrIHNwZWMuXHJcbiAqIERvbid0IHRyeSB0byB1c2UgaXQhIFNwZWMgcmVxdWlyZXMgdG8gc2hvdyBgYWx0YCBjb250ZW50IHdpdGggc3RyaXBwZWQgbWFya3VwLFxyXG4gKiBpbnN0ZWFkIG9mIHNpbXBsZSBlc2NhcGluZy5cclxuICoqL1xyXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVySW5saW5lQXNUZXh0ID0gZnVuY3Rpb24gKHRva2Vucywgb3B0aW9ucywgZW52KSB7XHJcbiAgdmFyIHJlc3VsdCA9ICcnLFxyXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXM7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgIGlmICh0b2tlbnNbaV0udHlwZSA9PT0gJ3RleHQnKSB7XHJcbiAgICAgIHJlc3VsdCArPSBydWxlcy50ZXh0KHRva2VucywgaSwgb3B0aW9ucywgZW52LCB0aGlzKTtcclxuICAgIH0gZWxzZSBpZiAodG9rZW5zW2ldLnR5cGUgPT09ICdpbWFnZScpIHtcclxuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVySW5saW5lQXNUZXh0KHRva2Vuc1tpXS5jaGlsZHJlbiwgb3B0aW9ucywgZW52KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFJlbmRlcmVyLnJlbmRlcih0b2tlbnMsIG9wdGlvbnMsIGVudikgLT4gU3RyaW5nXHJcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb24gYmxvY2sgdG9rZW5zIHRvIHJlbnRlclxyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHBhcmFtcyBvZiBwYXJzZXIgaW5zdGFuY2VcclxuICogLSBlbnYgKE9iamVjdCk6IGFkZGl0aW9uYWwgZGF0YSBmcm9tIHBhcnNlZCBpbnB1dCAocmVmZXJlbmNlcywgZm9yIGV4YW1wbGUpXHJcbiAqXHJcbiAqIFRha2VzIHRva2VuIHN0cmVhbSBhbmQgZ2VuZXJhdGVzIEhUTUwuIFByb2JhYmx5LCB5b3Ugd2lsbCBuZXZlciBuZWVkIHRvIGNhbGxcclxuICogdGhpcyBtZXRob2QgZGlyZWN0bHkuXHJcbiAqKi9cclxuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICh0b2tlbnMsIG9wdGlvbnMsIGVudikge1xyXG4gIHZhciBpLCBsZW4sIHR5cGUsXHJcbiAgICAgIHJlc3VsdCA9ICcnLFxyXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXM7XHJcblxyXG4gIGZvciAoaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgdHlwZSA9IHRva2Vuc1tpXS50eXBlO1xyXG5cclxuICAgIGlmICh0eXBlID09PSAnaW5saW5lJykge1xyXG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJJbmxpbmUodG9rZW5zW2ldLmNoaWxkcmVuLCBvcHRpb25zLCBlbnYpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcnVsZXNbdHlwZV0gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHJlc3VsdCArPSBydWxlc1t0b2tlbnNbaV0udHlwZV0odG9rZW5zLCBpLCBvcHRpb25zLCBlbnYsIHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVyVG9rZW4odG9rZW5zLCBpLCBvcHRpb25zLCBlbnYpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyZXI7XHJcblxyXG59LHtcIi4vY29tbW9uL3V0aWxzXCI6NX1dLDE4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLyoqXHJcbiAqIGNsYXNzIFJ1bGVyXHJcbiAqXHJcbiAqIEhlbHBlciBjbGFzcywgdXNlZCBieSBbW01hcmtkb3duSXQjY29yZV1dLCBbW01hcmtkb3duSXQjYmxvY2tdXSBhbmRcclxuICogW1tNYXJrZG93bkl0I2lubGluZV1dIHRvIG1hbmFnZSBzZXF1ZW5jZXMgb2YgZnVuY3Rpb25zIChydWxlcyk6XHJcbiAqXHJcbiAqIC0ga2VlcCBydWxlcyBpbiBkZWZpbmVkIG9yZGVyXHJcbiAqIC0gYXNzaWduIHRoZSBuYW1lIHRvIGVhY2ggcnVsZVxyXG4gKiAtIGVuYWJsZS9kaXNhYmxlIHJ1bGVzXHJcbiAqIC0gYWRkL3JlcGxhY2UgcnVsZXNcclxuICogLSBhbGxvdyBhc3NpZ24gcnVsZXMgdG8gYWRkaXRpb25hbCBuYW1lZCBjaGFpbnMgKGluIHRoZSBzYW1lKVxyXG4gKiAtIGNhY2hlaW5nIGxpc3RzIG9mIGFjdGl2ZSBydWxlc1xyXG4gKlxyXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSB1bnRpbCB3cml0ZSBwbHVnaW5zLiBGb3Igc2ltcGxlXHJcbiAqIHJ1bGVzIGNvbnRyb2wgdXNlIFtbTWFya2Rvd25JdC5kaXNhYmxlXV0sIFtbTWFya2Rvd25JdC5lbmFibGVdXSBhbmRcclxuICogW1tNYXJrZG93bkl0LnVzZV1dLlxyXG4gKiovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcblxyXG4vKipcclxuICogbmV3IFJ1bGVyKClcclxuICoqL1xyXG5mdW5jdGlvbiBSdWxlcigpIHtcclxuICAvLyBMaXN0IG9mIGFkZGVkIHJ1bGVzLiBFYWNoIGVsZW1lbnQgaXM6XHJcbiAgLy9cclxuICAvLyB7XHJcbiAgLy8gICBuYW1lOiBYWFgsXHJcbiAgLy8gICBlbmFibGVkOiBCb29sZWFuLFxyXG4gIC8vICAgZm46IEZ1bmN0aW9uKCksXHJcbiAgLy8gICBhbHQ6IFsgbmFtZTIsIG5hbWUzIF1cclxuICAvLyB9XHJcbiAgLy9cclxuICB0aGlzLl9fcnVsZXNfXyA9IFtdO1xyXG5cclxuICAvLyBDYWNoZWQgcnVsZSBjaGFpbnMuXHJcbiAgLy9cclxuICAvLyBGaXJzdCBsZXZlbCAtIGNoYWluIG5hbWUsICcnIGZvciBkZWZhdWx0LlxyXG4gIC8vIFNlY29uZCBsZXZlbCAtIGRpZ2luYWwgYW5jaG9yIGZvciBmYXN0IGZpbHRlcmluZyBieSBjaGFyY29kZXMuXHJcbiAgLy9cclxuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XHJcbn1cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIEhlbHBlciBtZXRob2RzLCBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHlcclxuXHJcblxyXG4vLyBGaW5kIHJ1bGUgaW5kZXggYnkgbmFtZVxyXG4vL1xyXG5SdWxlci5wcm90b3R5cGUuX19maW5kX18gPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fX3J1bGVzX18ubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmICh0aGlzLl9fcnVsZXNfX1tpXS5uYW1lID09PSBuYW1lKSB7XHJcbiAgICAgIHJldHVybiBpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gLTE7XHJcbn07XHJcblxyXG5cclxuLy8gQnVpbGQgcnVsZXMgbG9va3VwIGNhY2hlXHJcbi8vXHJcblJ1bGVyLnByb3RvdHlwZS5fX2NvbXBpbGVfXyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgdmFyIGNoYWlucyA9IFsgJycgXTtcclxuXHJcbiAgLy8gY29sbGVjdCB1bmlxdWUgbmFtZXNcclxuICBzZWxmLl9fcnVsZXNfXy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XHJcbiAgICBpZiAoIXJ1bGUuZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgICBydWxlLmFsdC5mb3JFYWNoKGZ1bmN0aW9uIChhbHROYW1lKSB7XHJcbiAgICAgIGlmIChjaGFpbnMuaW5kZXhPZihhbHROYW1lKSA8IDApIHtcclxuICAgICAgICBjaGFpbnMucHVzaChhbHROYW1lKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIHNlbGYuX19jYWNoZV9fID0ge307XHJcblxyXG4gIGNoYWlucy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFpbikge1xyXG4gICAgc2VsZi5fX2NhY2hlX19bY2hhaW5dID0gW107XHJcbiAgICBzZWxmLl9fcnVsZXNfXy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XHJcbiAgICAgIGlmICghcnVsZS5lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgaWYgKGNoYWluICYmIHJ1bGUuYWx0LmluZGV4T2YoY2hhaW4pIDwgMCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgIHNlbGYuX19jYWNoZV9fW2NoYWluXS5wdXNoKHJ1bGUuZm4pO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFJ1bGVyLmF0KG5hbWUsIGZuIFssIG9wdGlvbnNdKVxyXG4gKiAtIG5hbWUgKFN0cmluZyk6IHJ1bGUgbmFtZSB0byByZXBsYWNlLlxyXG4gKiAtIGZuIChGdW5jdGlvbik6IG5ldyBydWxlIGZ1bmN0aW9uLlxyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IG5ldyBydWxlIG9wdGlvbnMgKG5vdCBtYW5kYXRvcnkpLlxyXG4gKlxyXG4gKiBSZXBsYWNlIHJ1bGUgYnkgbmFtZSB3aXRoIG5ldyBmdW5jdGlvbiAmIG9wdGlvbnMuIFRocm93cyBlcnJvciBpZiBuYW1lIG5vdFxyXG4gKiBmb3VuZC5cclxuICpcclxuICogIyMjIyMgT3B0aW9uczpcclxuICpcclxuICogLSBfX2FsdF9fIC0gYXJyYXkgd2l0aCBuYW1lcyBvZiBcImFsdGVybmF0ZVwiIGNoYWlucy5cclxuICpcclxuICogIyMjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBSZXBsYWNlIGV4aXN0aW5nIHR5cG9yZ2FwaGVyIHJlcGxhY2VtZW50IHJ1bGUgd2l0aCBuZXcgb25lOlxyXG4gKlxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcclxuICpcclxuICogbWQuY29yZS5ydWxlci5hdCgncmVwbGFjZW1lbnRzJywgZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xyXG4gKiAgIC8vLi4uXHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICoqL1xyXG5SdWxlci5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAobmFtZSwgZm4sIG9wdGlvbnMpIHtcclxuICB2YXIgaW5kZXggPSB0aGlzLl9fZmluZF9fKG5hbWUpO1xyXG4gIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICBpZiAoaW5kZXggPT09IC0xKSB7IHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgbmFtZSk7IH1cclxuXHJcbiAgdGhpcy5fX3J1bGVzX19baW5kZXhdLmZuID0gZm47XHJcbiAgdGhpcy5fX3J1bGVzX19baW5kZXhdLmFsdCA9IG9wdC5hbHQgfHwgW107XHJcbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSdWxlci5iZWZvcmUoYmVmb3JlTmFtZSwgcnVsZU5hbWUsIGZuIFssIG9wdGlvbnNdKVxyXG4gKiAtIGJlZm9yZU5hbWUgKFN0cmluZyk6IG5ldyBydWxlIHdpbGwgYmUgYWRkZWQgYmVmb3JlIHRoaXMgb25lLlxyXG4gKiAtIHJ1bGVOYW1lIChTdHJpbmcpOiBuYW1lIG9mIGFkZGVkIHJ1bGUuXHJcbiAqIC0gZm4gKEZ1bmN0aW9uKTogcnVsZSBmdW5jdGlvbi5cclxuICogLSBvcHRpb25zIChPYmplY3QpOiBydWxlIG9wdGlvbnMgKG5vdCBtYW5kYXRvcnkpLlxyXG4gKlxyXG4gKiBBZGQgbmV3IHJ1bGUgdG8gY2hhaW4gYmVmb3JlIG9uZSB3aXRoIGdpdmVuIG5hbWUuIFNlZSBhbHNvXHJcbiAqIFtbUnVsZXIuYWZ0ZXJdXSwgW1tSdWxlci5wdXNoXV0uXHJcbiAqXHJcbiAqICMjIyMjIE9wdGlvbnM6XHJcbiAqXHJcbiAqIC0gX19hbHRfXyAtIGFycmF5IHdpdGggbmFtZXMgb2YgXCJhbHRlcm5hdGVcIiBjaGFpbnMuXHJcbiAqXHJcbiAqICMjIyMjIEV4YW1wbGVcclxuICpcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XHJcbiAqXHJcbiAqIG1kLmJsb2NrLnJ1bGVyLmJlZm9yZSgncGFyYWdyYXBoJywgJ215X3J1bGUnLCBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XHJcbiAqICAgLy8uLi5cclxuICogfSk7XHJcbiAqIGBgYFxyXG4gKiovXHJcblJ1bGVyLnByb3RvdHlwZS5iZWZvcmUgPSBmdW5jdGlvbiAoYmVmb3JlTmFtZSwgcnVsZU5hbWUsIGZuLCBvcHRpb25zKSB7XHJcbiAgdmFyIGluZGV4ID0gdGhpcy5fX2ZpbmRfXyhiZWZvcmVOYW1lKTtcclxuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgaWYgKGluZGV4ID09PSAtMSkgeyB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlciBydWxlIG5vdCBmb3VuZDogJyArIGJlZm9yZU5hbWUpOyB9XHJcblxyXG4gIHRoaXMuX19ydWxlc19fLnNwbGljZShpbmRleCwgMCwge1xyXG4gICAgbmFtZTogcnVsZU5hbWUsXHJcbiAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgZm46IGZuLFxyXG4gICAgYWx0OiBvcHQuYWx0IHx8IFtdXHJcbiAgfSk7XHJcblxyXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogUnVsZXIuYWZ0ZXIoYWZ0ZXJOYW1lLCBydWxlTmFtZSwgZm4gWywgb3B0aW9uc10pXHJcbiAqIC0gYWZ0ZXJOYW1lIChTdHJpbmcpOiBuZXcgcnVsZSB3aWxsIGJlIGFkZGVkIGFmdGVyIHRoaXMgb25lLlxyXG4gKiAtIHJ1bGVOYW1lIChTdHJpbmcpOiBuYW1lIG9mIGFkZGVkIHJ1bGUuXHJcbiAqIC0gZm4gKEZ1bmN0aW9uKTogcnVsZSBmdW5jdGlvbi5cclxuICogLSBvcHRpb25zIChPYmplY3QpOiBydWxlIG9wdGlvbnMgKG5vdCBtYW5kYXRvcnkpLlxyXG4gKlxyXG4gKiBBZGQgbmV3IHJ1bGUgdG8gY2hhaW4gYWZ0ZXIgb25lIHdpdGggZ2l2ZW4gbmFtZS4gU2VlIGFsc29cclxuICogW1tSdWxlci5iZWZvcmVdXSwgW1tSdWxlci5wdXNoXV0uXHJcbiAqXHJcbiAqICMjIyMjIE9wdGlvbnM6XHJcbiAqXHJcbiAqIC0gX19hbHRfXyAtIGFycmF5IHdpdGggbmFtZXMgb2YgXCJhbHRlcm5hdGVcIiBjaGFpbnMuXHJcbiAqXHJcbiAqICMjIyMjIEV4YW1wbGVcclxuICpcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XHJcbiAqXHJcbiAqIG1kLmlubGluZS5ydWxlci5hZnRlcigndGV4dCcsICdteV9ydWxlJywgZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xyXG4gKiAgIC8vLi4uXHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICoqL1xyXG5SdWxlci5wcm90b3R5cGUuYWZ0ZXIgPSBmdW5jdGlvbiAoYWZ0ZXJOYW1lLCBydWxlTmFtZSwgZm4sIG9wdGlvbnMpIHtcclxuICB2YXIgaW5kZXggPSB0aGlzLl9fZmluZF9fKGFmdGVyTmFtZSk7XHJcbiAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIGlmIChpbmRleCA9PT0gLTEpIHsgdGhyb3cgbmV3IEVycm9yKCdQYXJzZXIgcnVsZSBub3QgZm91bmQ6ICcgKyBhZnRlck5hbWUpOyB9XHJcblxyXG4gIHRoaXMuX19ydWxlc19fLnNwbGljZShpbmRleCArIDEsIDAsIHtcclxuICAgIG5hbWU6IHJ1bGVOYW1lLFxyXG4gICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgIGZuOiBmbixcclxuICAgIGFsdDogb3B0LmFsdCB8fCBbXVxyXG4gIH0pO1xyXG5cclxuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XHJcbn07XHJcblxyXG4vKipcclxuICogUnVsZXIucHVzaChydWxlTmFtZSwgZm4gWywgb3B0aW9uc10pXHJcbiAqIC0gcnVsZU5hbWUgKFN0cmluZyk6IG5hbWUgb2YgYWRkZWQgcnVsZS5cclxuICogLSBmbiAoRnVuY3Rpb24pOiBydWxlIGZ1bmN0aW9uLlxyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHJ1bGUgb3B0aW9ucyAobm90IG1hbmRhdG9yeSkuXHJcbiAqXHJcbiAqIFB1c2ggbmV3IHJ1bGUgdG8gdGhlIGVuZCBvZiBjaGFpbi4gU2VlIGFsc29cclxuICogW1tSdWxlci5iZWZvcmVdXSwgW1tSdWxlci5hZnRlcl1dLlxyXG4gKlxyXG4gKiAjIyMjIyBPcHRpb25zOlxyXG4gKlxyXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxyXG4gKlxyXG4gKiAjIyMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xyXG4gKlxyXG4gKiBtZC5jb3JlLnJ1bGVyLnB1c2goJ215X3J1bGUnLCBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XHJcbiAqICAgLy8uLi5cclxuICogfSk7XHJcbiAqIGBgYFxyXG4gKiovXHJcblJ1bGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xyXG4gIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICB0aGlzLl9fcnVsZXNfXy5wdXNoKHtcclxuICAgIG5hbWU6IHJ1bGVOYW1lLFxyXG4gICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgIGZuOiBmbixcclxuICAgIGFsdDogb3B0LmFsdCB8fCBbXVxyXG4gIH0pO1xyXG5cclxuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFJ1bGVyLmVuYWJsZShsaXN0IFssIGlnbm9yZUludmFsaWRdKSAtPiBBcnJheVxyXG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBlbmFibGUuXHJcbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxyXG4gKlxyXG4gKiBFbmFibGUgcnVsZXMgd2l0aCBnaXZlbiBuYW1lcy4gSWYgYW55IHJ1bGUgbmFtZSBub3QgZm91bmQgLSB0aHJvdyBFcnJvci5cclxuICogRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXHJcbiAqXHJcbiAqIFJldHVybnMgbGlzdCBvZiBmb3VuZCBydWxlIG5hbWVzIChpZiBubyBleGNlcHRpb24gaGFwcGVuZWQpLlxyXG4gKlxyXG4gKiBTZWUgYWxzbyBbW1J1bGVyLmRpc2FibGVdXSwgW1tSdWxlci5lbmFibGVPbmx5XV0uXHJcbiAqKi9cclxuUnVsZXIucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XHJcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxyXG5cclxuICB2YXIgcmVzdWx0ID0gW107XHJcblxyXG4gIC8vIFNlYXJjaCBieSBuYW1lIGFuZCBlbmFibGVcclxuICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgIHZhciBpZHggPSB0aGlzLl9fZmluZF9fKG5hbWUpO1xyXG5cclxuICAgIGlmIChpZHggPCAwKSB7XHJcbiAgICAgIGlmIChpZ25vcmVJbnZhbGlkKSB7IHJldHVybjsgfVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J1bGVzIG1hbmFnZXI6IGludmFsaWQgcnVsZSBuYW1lICcgKyBuYW1lKTtcclxuICAgIH1cclxuICAgIHRoaXMuX19ydWxlc19fW2lkeF0uZW5hYmxlZCA9IHRydWU7XHJcbiAgICByZXN1bHQucHVzaChuYW1lKTtcclxuICB9LCB0aGlzKTtcclxuXHJcbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFJ1bGVyLmVuYWJsZU9ubHkobGlzdCBbLCBpZ25vcmVJbnZhbGlkXSlcclxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZW5hYmxlICh3aGl0ZWxpc3QpLlxyXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cclxuICpcclxuICogRW5hYmxlIHJ1bGVzIHdpdGggZ2l2ZW4gbmFtZXMsIGFuZCBkaXNhYmxlIGV2ZXJ5dGhpbmcgZWxzZS4gSWYgYW55IHJ1bGUgbmFtZVxyXG4gKiBub3QgZm91bmQgLSB0aHJvdyBFcnJvci4gRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXHJcbiAqXHJcbiAqIFNlZSBhbHNvIFtbUnVsZXIuZGlzYWJsZV1dLCBbW1J1bGVyLmVuYWJsZV1dLlxyXG4gKiovXHJcblJ1bGVyLnByb3RvdHlwZS5lbmFibGVPbmx5ID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcclxuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHsgbGlzdCA9IFsgbGlzdCBdOyB9XHJcblxyXG4gIHRoaXMuX19ydWxlc19fLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHsgcnVsZS5lbmFibGVkID0gZmFsc2U7IH0pO1xyXG5cclxuICB0aGlzLmVuYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogUnVsZXIuZGlzYWJsZShsaXN0IFssIGlnbm9yZUludmFsaWRdKSAtPiBBcnJheVxyXG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBkaXNhYmxlLlxyXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cclxuICpcclxuICogRGlzYWJsZSBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBhbnkgcnVsZSBuYW1lIG5vdCBmb3VuZCAtIHRocm93IEVycm9yLlxyXG4gKiBFcnJvcnMgY2FuIGJlIGRpc2FibGVkIGJ5IHNlY29uZCBwYXJhbS5cclxuICpcclxuICogUmV0dXJucyBsaXN0IG9mIGZvdW5kIHJ1bGUgbmFtZXMgKGlmIG5vIGV4Y2VwdGlvbiBoYXBwZW5lZCkuXHJcbiAqXHJcbiAqIFNlZSBhbHNvIFtbUnVsZXIuZW5hYmxlXV0sIFtbUnVsZXIuZW5hYmxlT25seV1dLlxyXG4gKiovXHJcblJ1bGVyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcclxuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHsgbGlzdCA9IFsgbGlzdCBdOyB9XHJcblxyXG4gIHZhciByZXN1bHQgPSBbXTtcclxuXHJcbiAgLy8gU2VhcmNoIGJ5IG5hbWUgYW5kIGRpc2FibGVcclxuICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgIHZhciBpZHggPSB0aGlzLl9fZmluZF9fKG5hbWUpO1xyXG5cclxuICAgIGlmIChpZHggPCAwKSB7XHJcbiAgICAgIGlmIChpZ25vcmVJbnZhbGlkKSB7IHJldHVybjsgfVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J1bGVzIG1hbmFnZXI6IGludmFsaWQgcnVsZSBuYW1lICcgKyBuYW1lKTtcclxuICAgIH1cclxuICAgIHRoaXMuX19ydWxlc19fW2lkeF0uZW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgcmVzdWx0LnB1c2gobmFtZSk7XHJcbiAgfSwgdGhpcyk7XHJcblxyXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSdWxlci5nZXRSdWxlcyhjaGFpbk5hbWUpIC0+IEFycmF5XHJcbiAqXHJcbiAqIFJldHVybiBhcnJheSBvZiBhY3RpdmUgZnVuY3Rpb25zIChydWxlcykgZm9yIGdpdmVuIGNoYWluIG5hbWUuIEl0IGFuYWx5emVzXHJcbiAqIHJ1bGVzIGNvbmZpZ3VyYXRpb24sIGNvbXBpbGVzIGNhY2hlcyBpZiBub3QgZXhpc3RzIGFuZCByZXR1cm5zIHJlc3VsdC5cclxuICpcclxuICogRGVmYXVsdCBjaGFpbiBuYW1lIGlzIGAnJ2AgKGVtcHR5IHN0cmluZykuIEl0IGNhbid0IGJlIHNraXBwZWQuIFRoYXQnc1xyXG4gKiBkb25lIGludGVudGlvbmFsbHksIHRvIGtlZXAgc2lnbmF0dXJlIG1vbm9tb3JwaGljIGZvciBoaWdoIHNwZWVkLlxyXG4gKiovXHJcblJ1bGVyLnByb3RvdHlwZS5nZXRSdWxlcyA9IGZ1bmN0aW9uIChjaGFpbk5hbWUpIHtcclxuICBpZiAodGhpcy5fX2NhY2hlX18gPT09IG51bGwpIHtcclxuICAgIHRoaXMuX19jb21waWxlX18oKTtcclxuICB9XHJcblxyXG4gIC8vIENoYWluIGNhbiBiZSBlbXB0eSwgaWYgcnVsZXMgZGlzYWJsZWQuIEJ1dCB3ZSBzdGlsbCBoYXZlIHRvIHJldHVybiBBcnJheS5cclxuICByZXR1cm4gdGhpcy5fX2NhY2hlX19bY2hhaW5OYW1lXSB8fCBbXTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUnVsZXI7XHJcblxyXG59LHt9XSwxOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8vIEJsb2NrIHF1b3Rlc1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmxvY2txdW90ZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcclxuICB2YXIgbmV4dExpbmUsIGxhc3RMaW5lRW1wdHksIG9sZFRTaGlmdCwgb2xkQk1hcmtzLCBvbGRJbmRlbnQsIG9sZFBhcmVudFR5cGUsIGxpbmVzLFxyXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMsIHRva2VuLFxyXG4gICAgICBpLCBsLCB0ZXJtaW5hdGUsXHJcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXHJcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xyXG5cclxuICAvLyBjaGVjayB0aGUgYmxvY2sgcXVvdGUgbWFya2VyXHJcbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKSAhPT0gMHgzRS8qID4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIC8vIHdlIGtub3cgdGhhdCBpdCdzIGdvaW5nIHRvIGJlIGEgdmFsaWQgYmxvY2txdW90ZSxcclxuICAvLyBzbyBubyBwb2ludCB0cnlpbmcgdG8gZmluZCB0aGUgZW5kIG9mIGl0IGluIHNpbGVudCBtb2RlXHJcbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuICAvLyBza2lwIG9uZSBvcHRpb25hbCBzcGFjZSBhZnRlciAnPidcclxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyMCkgeyBwb3MrKzsgfVxyXG5cclxuICBvbGRJbmRlbnQgPSBzdGF0ZS5ibGtJbmRlbnQ7XHJcbiAgc3RhdGUuYmxrSW5kZW50ID0gMDtcclxuXHJcbiAgb2xkQk1hcmtzID0gWyBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSBdO1xyXG4gIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdID0gcG9zO1xyXG5cclxuICAvLyBjaGVjayBpZiB3ZSBoYXZlIGFuIGVtcHR5IGJsb2NrcXVvdGVcclxuICBwb3MgPSBwb3MgPCBtYXggPyBzdGF0ZS5za2lwU3BhY2VzKHBvcykgOiBwb3M7XHJcbiAgbGFzdExpbmVFbXB0eSA9IHBvcyA+PSBtYXg7XHJcblxyXG4gIG9sZFRTaGlmdCA9IFsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gXTtcclxuICBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSA9IHBvcyAtIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdO1xyXG5cclxuICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygnYmxvY2txdW90ZScpO1xyXG5cclxuICAvLyBTZWFyY2ggdGhlIGVuZCBvZiB0aGUgYmxvY2tcclxuICAvL1xyXG4gIC8vIEJsb2NrIGVuZHMgd2l0aCBlaXRoZXI6XHJcbiAgLy8gIDEuIGFuIGVtcHR5IGxpbmUgb3V0c2lkZTpcclxuICAvLyAgICAgYGBgXHJcbiAgLy8gICAgID4gdGVzdFxyXG4gIC8vXHJcbiAgLy8gICAgIGBgYFxyXG4gIC8vICAyLiBhbiBlbXB0eSBsaW5lIGluc2lkZTpcclxuICAvLyAgICAgYGBgXHJcbiAgLy8gICAgID5cclxuICAvLyAgICAgdGVzdFxyXG4gIC8vICAgICBgYGBcclxuICAvLyAgMy4gYW5vdGhlciB0YWdcclxuICAvLyAgICAgYGBgXHJcbiAgLy8gICAgID4gdGVzdFxyXG4gIC8vICAgICAgLSAtIC1cclxuICAvLyAgICAgYGBgXHJcbiAgZm9yIChuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7IG5leHRMaW5lIDwgZW5kTGluZTsgbmV4dExpbmUrKykge1xyXG4gICAgcG9zID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XHJcbiAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xyXG5cclxuICAgIGlmIChwb3MgPj0gbWF4KSB7XHJcbiAgICAgIC8vIENhc2UgMTogbGluZSBpcyBub3QgaW5zaWRlIHRoZSBibG9ja3F1b3RlLCBhbmQgdGhpcyBsaW5lIGlzIGVtcHR5LlxyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspID09PSAweDNFLyogPiAqLykge1xyXG4gICAgICAvLyBUaGlzIGxpbmUgaXMgaW5zaWRlIHRoZSBibG9ja3F1b3RlLlxyXG5cclxuICAgICAgLy8gc2tpcCBvbmUgb3B0aW9uYWwgc3BhY2UgYWZ0ZXIgJz4nXHJcbiAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDIwKSB7IHBvcysrOyB9XHJcblxyXG4gICAgICBvbGRCTWFya3MucHVzaChzdGF0ZS5iTWFya3NbbmV4dExpbmVdKTtcclxuICAgICAgc3RhdGUuYk1hcmtzW25leHRMaW5lXSA9IHBvcztcclxuXHJcbiAgICAgIHBvcyA9IHBvcyA8IG1heCA/IHN0YXRlLnNraXBTcGFjZXMocG9zKSA6IHBvcztcclxuICAgICAgbGFzdExpbmVFbXB0eSA9IHBvcyA+PSBtYXg7XHJcblxyXG4gICAgICBvbGRUU2hpZnQucHVzaChzdGF0ZS50U2hpZnRbbmV4dExpbmVdKTtcclxuICAgICAgc3RhdGUudFNoaWZ0W25leHRMaW5lXSA9IHBvcyAtIHN0YXRlLmJNYXJrc1tuZXh0TGluZV07XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENhc2UgMjogbGluZSBpcyBub3QgaW5zaWRlIHRoZSBibG9ja3F1b3RlLCBhbmQgdGhlIGxhc3QgbGluZSB3YXMgZW1wdHkuXHJcbiAgICBpZiAobGFzdExpbmVFbXB0eSkgeyBicmVhazsgfVxyXG5cclxuICAgIC8vIENhc2UgMzogYW5vdGhlciB0YWcgZm91bmQuXHJcbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcclxuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xyXG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0ZXJtaW5hdGUpIHsgYnJlYWs7IH1cclxuXHJcbiAgICBvbGRCTWFya3MucHVzaChzdGF0ZS5iTWFya3NbbmV4dExpbmVdKTtcclxuICAgIG9sZFRTaGlmdC5wdXNoKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pO1xyXG5cclxuICAgIC8vIEEgbmVnYXRpdmUgbnVtYmVyIG1lYW5zIHRoYXQgdGhpcyBpcyBhIHBhcmFncmFwaCBjb250aW51YXRpb247XHJcbiAgICAvL1xyXG4gICAgLy8gQW55IG5lZ2F0aXZlIG51bWJlciB3aWxsIGRvIHRoZSBqb2IgaGVyZSwgYnV0IGl0J3MgYmV0dGVyIGZvciBpdFxyXG4gICAgLy8gdG8gYmUgbGFyZ2UgZW5vdWdoIHRvIG1ha2UgYW55IGJ1Z3Mgb2J2aW91cy5cclxuICAgIHN0YXRlLnRTaGlmdFtuZXh0TGluZV0gPSAtMTMzNztcclxuICB9XHJcblxyXG4gIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xyXG4gIHN0YXRlLnBhcmVudFR5cGUgPSAnYmxvY2txdW90ZSc7XHJcblxyXG4gIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2Jsb2NrcXVvdGVfb3BlbicsICdibG9ja3F1b3RlJywgMSk7XHJcbiAgdG9rZW4ubWFya3VwID0gJz4nO1xyXG4gIHRva2VuLm1hcCAgICA9IGxpbmVzID0gWyBzdGFydExpbmUsIDAgXTtcclxuXHJcbiAgc3RhdGUubWQuYmxvY2sudG9rZW5pemUoc3RhdGUsIHN0YXJ0TGluZSwgbmV4dExpbmUpO1xyXG5cclxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdibG9ja3F1b3RlX2Nsb3NlJywgJ2Jsb2NrcXVvdGUnLCAtMSk7XHJcbiAgdG9rZW4ubWFya3VwID0gJz4nO1xyXG5cclxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcclxuICBsaW5lc1sxXSA9IHN0YXRlLmxpbmU7XHJcblxyXG4gIC8vIFJlc3RvcmUgb3JpZ2luYWwgdFNoaWZ0OyB0aGlzIG1pZ2h0IG5vdCBiZSBuZWNlc3Nhcnkgc2luY2UgdGhlIHBhcnNlclxyXG4gIC8vIGhhcyBhbHJlYWR5IGJlZW4gaGVyZSwgYnV0IGp1c3QgdG8gbWFrZSBzdXJlIHdlIGNhbiBkbyB0aGF0LlxyXG4gIGZvciAoaSA9IDA7IGkgPCBvbGRUU2hpZnQubGVuZ3RoOyBpKyspIHtcclxuICAgIHN0YXRlLmJNYXJrc1tpICsgc3RhcnRMaW5lXSA9IG9sZEJNYXJrc1tpXTtcclxuICAgIHN0YXRlLnRTaGlmdFtpICsgc3RhcnRMaW5lXSA9IG9sZFRTaGlmdFtpXTtcclxuICB9XHJcbiAgc3RhdGUuYmxrSW5kZW50ID0gb2xkSW5kZW50O1xyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbn0se31dLDIwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLy8gQ29kZSBibG9jayAoNCBzcGFjZXMgcGFkZGVkKVxyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29kZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLyosIHNpbGVudCovKSB7XHJcbiAgdmFyIG5leHRMaW5lLCBsYXN0LCB0b2tlbjtcclxuXHJcbiAgaWYgKHN0YXRlLnRTaGlmdFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50IDwgNCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgbGFzdCA9IG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcclxuXHJcbiAgd2hpbGUgKG5leHRMaW5lIDwgZW5kTGluZSkge1xyXG4gICAgaWYgKHN0YXRlLmlzRW1wdHkobmV4dExpbmUpKSB7XHJcbiAgICAgIG5leHRMaW5lKys7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkge1xyXG4gICAgICBuZXh0TGluZSsrO1xyXG4gICAgICBsYXN0ID0gbmV4dExpbmU7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgYnJlYWs7XHJcbiAgfVxyXG5cclxuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XHJcblxyXG4gIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdjb2RlX2Jsb2NrJywgJ2NvZGUnLCAwKTtcclxuICB0b2tlbi5jb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBsYXN0LCA0ICsgc3RhdGUuYmxrSW5kZW50LCB0cnVlKTtcclxuICB0b2tlbi5tYXAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG59LHt9XSwyMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8vIGZlbmNlcyAoYGBgIGxhbmcsIH5+fiBsYW5nKVxyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmVuY2Uoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XHJcbiAgdmFyIG1hcmtlciwgbGVuLCBwYXJhbXMsIG5leHRMaW5lLCBtZW0sIHRva2VuLCBtYXJrdXAsXHJcbiAgICAgIGhhdmVFbmRNYXJrZXIgPSBmYWxzZSxcclxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcclxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XHJcblxyXG4gIGlmIChwb3MgKyAzID4gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xyXG5cclxuICBpZiAobWFya2VyICE9PSAweDdFLyogfiAqLyAmJiBtYXJrZXIgIT09IDB4NjAgLyogYCAqLykge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gc2NhbiBtYXJrZXIgbGVuZ3RoXHJcbiAgbWVtID0gcG9zO1xyXG4gIHBvcyA9IHN0YXRlLnNraXBDaGFycyhwb3MsIG1hcmtlcik7XHJcblxyXG4gIGxlbiA9IHBvcyAtIG1lbTtcclxuXHJcbiAgaWYgKGxlbiA8IDMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIG1hcmt1cCA9IHN0YXRlLnNyYy5zbGljZShtZW0sIHBvcyk7XHJcbiAgcGFyYW1zID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KTtcclxuXHJcbiAgaWYgKHBhcmFtcy5pbmRleE9mKCdgJykgPj0gMCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgLy8gU2luY2Ugc3RhcnQgaXMgZm91bmQsIHdlIGNhbiByZXBvcnQgc3VjY2VzcyBoZXJlIGluIHZhbGlkYXRpb24gbW9kZVxyXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcbiAgLy8gc2VhcmNoIGVuZCBvZiBibG9ja1xyXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lO1xyXG5cclxuICBmb3IgKDs7KSB7XHJcbiAgICBuZXh0TGluZSsrO1xyXG4gICAgaWYgKG5leHRMaW5lID49IGVuZExpbmUpIHtcclxuICAgICAgLy8gdW5jbG9zZWQgYmxvY2sgc2hvdWxkIGJlIGF1dG9jbG9zZWQgYnkgZW5kIG9mIGRvY3VtZW50LlxyXG4gICAgICAvLyBhbHNvIGJsb2NrIHNlZW1zIHRvIGJlIGF1dG9jbG9zZWQgYnkgZW5kIG9mIHBhcmVudFxyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICBwb3MgPSBtZW0gPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcclxuICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XHJcblxyXG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS50U2hpZnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7XHJcbiAgICAgIC8vIG5vbi1lbXB0eSBsaW5lIHdpdGggbmVnYXRpdmUgaW5kZW50IHNob3VsZCBzdG9wIHRoZSBsaXN0OlxyXG4gICAgICAvLyAtIGBgYFxyXG4gICAgICAvLyAgdGVzdFxyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gbWFya2VyKSB7IGNvbnRpbnVlOyB9XHJcblxyXG4gICAgaWYgKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkge1xyXG4gICAgICAvLyBjbG9zaW5nIGZlbmNlIHNob3VsZCBiZSBpbmRlbnRlZCBsZXNzIHRoYW4gNCBzcGFjZXNcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgcG9zID0gc3RhdGUuc2tpcENoYXJzKHBvcywgbWFya2VyKTtcclxuXHJcbiAgICAvLyBjbG9zaW5nIGNvZGUgZmVuY2UgbXVzdCBiZSBhdCBsZWFzdCBhcyBsb25nIGFzIHRoZSBvcGVuaW5nIG9uZVxyXG4gICAgaWYgKHBvcyAtIG1lbSA8IGxlbikgeyBjb250aW51ZTsgfVxyXG5cclxuICAgIC8vIG1ha2Ugc3VyZSB0YWlsIGhhcyBzcGFjZXMgb25seVxyXG4gICAgcG9zID0gc3RhdGUuc2tpcFNwYWNlcyhwb3MpO1xyXG5cclxuICAgIGlmIChwb3MgPCBtYXgpIHsgY29udGludWU7IH1cclxuXHJcbiAgICBoYXZlRW5kTWFya2VyID0gdHJ1ZTtcclxuICAgIC8vIGZvdW5kIVxyXG4gICAgYnJlYWs7XHJcbiAgfVxyXG5cclxuICAvLyBJZiBhIGZlbmNlIGhhcyBoZWFkaW5nIHNwYWNlcywgdGhleSBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIGl0cyBpbm5lciBibG9ja1xyXG4gIGxlbiA9IHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xyXG5cclxuICBzdGF0ZS5saW5lID0gbmV4dExpbmUgKyAoaGF2ZUVuZE1hcmtlciA/IDEgOiAwKTtcclxuXHJcbiAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2ZlbmNlJywgJ2NvZGUnLCAwKTtcclxuICB0b2tlbi5pbmZvICAgID0gcGFyYW1zO1xyXG4gIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUgKyAxLCBuZXh0TGluZSwgbGVuLCB0cnVlKTtcclxuICB0b2tlbi5tYXJrdXAgID0gbWFya3VwO1xyXG4gIHRva2VuLm1hcCAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbn0se31dLDIyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLy8gaGVhZGluZyAoIywgIyMsIC4uLilcclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhlYWRpbmcoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XHJcbiAgdmFyIGNoLCBsZXZlbCwgdG1wLCB0b2tlbixcclxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcclxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XHJcblxyXG4gIGNoICA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XHJcblxyXG4gIGlmIChjaCAhPT0gMHgyMy8qICMgKi8gfHwgcG9zID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgLy8gY291bnQgaGVhZGluZyBsZXZlbFxyXG4gIGxldmVsID0gMTtcclxuICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KCsrcG9zKTtcclxuICB3aGlsZSAoY2ggPT09IDB4MjMvKiAjICovICYmIHBvcyA8IG1heCAmJiBsZXZlbCA8PSA2KSB7XHJcbiAgICBsZXZlbCsrO1xyXG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdCgrK3Bvcyk7XHJcbiAgfVxyXG5cclxuICBpZiAobGV2ZWwgPiA2IHx8IChwb3MgPCBtYXggJiYgY2ggIT09IDB4MjAvKiBzcGFjZSAqLykpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcbiAgLy8gTGV0J3MgY3V0IHRhaWxzIGxpa2UgJyAgICAjIyMgICcgZnJvbSB0aGUgZW5kIG9mIHN0cmluZ1xyXG5cclxuICBtYXggPSBzdGF0ZS5za2lwQ2hhcnNCYWNrKG1heCwgMHgyMCwgcG9zKTsgLy8gc3BhY2VcclxuICB0bXAgPSBzdGF0ZS5za2lwQ2hhcnNCYWNrKG1heCwgMHgyMywgcG9zKTsgLy8gI1xyXG4gIGlmICh0bXAgPiBwb3MgJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQodG1wIC0gMSkgPT09IDB4MjAvKiBzcGFjZSAqLykge1xyXG4gICAgbWF4ID0gdG1wO1xyXG4gIH1cclxuXHJcbiAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSArIDE7XHJcblxyXG4gIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2hlYWRpbmdfb3BlbicsICdoJyArIFN0cmluZyhsZXZlbCksIDEpO1xyXG4gIHRva2VuLm1hcmt1cCA9ICcjIyMjIyMjIycuc2xpY2UoMCwgbGV2ZWwpO1xyXG4gIHRva2VuLm1hcCAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XHJcblxyXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xyXG4gIHRva2VuLmNvbnRlbnQgID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KS50cmltKCk7XHJcbiAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xyXG4gIHRva2VuLmNoaWxkcmVuID0gW107XHJcblxyXG4gIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2hlYWRpbmdfY2xvc2UnLCAnaCcgKyBTdHJpbmcobGV2ZWwpLCAtMSk7XHJcbiAgdG9rZW4ubWFya3VwID0gJyMjIyMjIyMjJy5zbGljZSgwLCBsZXZlbCk7XHJcblxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxufSx7fV0sMjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4vLyBIb3Jpem9udGFsIHJ1bGVcclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhyKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xyXG4gIHZhciBtYXJrZXIsIGNudCwgY2gsIHRva2VuLFxyXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxyXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcclxuXHJcbiAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xyXG5cclxuICAvLyBDaGVjayBociBtYXJrZXJcclxuICBpZiAobWFya2VyICE9PSAweDJBLyogKiAqLyAmJlxyXG4gICAgICBtYXJrZXIgIT09IDB4MkQvKiAtICovICYmXHJcbiAgICAgIG1hcmtlciAhPT0gMHg1Ri8qIF8gKi8pIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIG1hcmtlcnMgY2FuIGJlIG1peGVkIHdpdGggc3BhY2VzLCBidXQgdGhlcmUgc2hvdWxkIGJlIGF0IGxlYXN0IDMgb25lXHJcblxyXG4gIGNudCA9IDE7XHJcbiAgd2hpbGUgKHBvcyA8IG1heCkge1xyXG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XHJcbiAgICBpZiAoY2ggIT09IG1hcmtlciAmJiBjaCAhPT0gMHgyMC8qIHNwYWNlICovKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgaWYgKGNoID09PSBtYXJrZXIpIHsgY250Kys7IH1cclxuICB9XHJcblxyXG4gIGlmIChjbnQgPCAzKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG4gIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgKyAxO1xyXG5cclxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdocicsICdocicsIDApO1xyXG4gIHRva2VuLm1hcCAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XHJcbiAgdG9rZW4ubWFya3VwID0gQXJyYXkoY250ICsgMSkuam9pbihTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcikpO1xyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbn0se31dLDI0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLy8gSFRNTCBibG9ja1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBibG9ja19uYW1lcyA9IHJlcXVpcmUoJy4uL2NvbW1vbi9odG1sX2Jsb2NrcycpO1xyXG5cclxuXHJcbnZhciBIVE1MX1RBR19PUEVOX1JFID0gL148KFthLXpBLVpdW2EtekEtWjAtOV17MCwxNH0pW1xcc1xcLz5dLztcclxudmFyIEhUTUxfVEFHX0NMT1NFX1JFID0gL148XFwvKFthLXpBLVpdW2EtekEtWjAtOV17MCwxNH0pW1xccz5dLztcclxuXHJcbmZ1bmN0aW9uIGlzTGV0dGVyKGNoKSB7XHJcbiAgLyplc2xpbnQgbm8tYml0d2lzZTowKi9cclxuICB2YXIgbGMgPSBjaCB8IDB4MjA7IC8vIHRvIGxvd2VyIGNhc2VcclxuICByZXR1cm4gKGxjID49IDB4NjEvKiBhICovKSAmJiAobGMgPD0gMHg3YS8qIHogKi8pO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGh0bWxfYmxvY2soc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XHJcbiAgdmFyIGNoLCBtYXRjaCwgbmV4dExpbmUsIHRva2VuLFxyXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSxcclxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV0sXHJcbiAgICAgIHNoaWZ0ID0gc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV07XHJcblxyXG4gIHBvcyArPSBzaGlmdDtcclxuXHJcbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmh0bWwpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIGlmIChzaGlmdCA+IDMgfHwgcG9zICsgMiA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDNDLyogPCAqLykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgKyAxKTtcclxuXHJcbiAgaWYgKGNoID09PSAweDIxLyogISAqLyB8fCBjaCA9PT0gMHgzRi8qID8gKi8pIHtcclxuICAgIC8vIERpcmVjdGl2ZSBzdGFydCAvIGNvbW1lbnQgc3RhcnQgLyBwcm9jZXNzaW5nIGluc3RydWN0aW9uIHN0YXJ0XHJcbiAgICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4MkYvKiAvICovIHx8IGlzTGV0dGVyKGNoKSkge1xyXG5cclxuICAgIC8vIFByb2JhYmx5IHN0YXJ0IG9yIGVuZCBvZiB0YWdcclxuICAgIGlmIChjaCA9PT0gMHgyRi8qIFxcICovKSB7XHJcbiAgICAgIC8vIGNsb3NpbmcgdGFnXHJcbiAgICAgIG1hdGNoID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KS5tYXRjaChIVE1MX1RBR19DTE9TRV9SRSk7XHJcbiAgICAgIGlmICghbWF0Y2gpIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBvcGVuaW5nIHRhZ1xyXG4gICAgICBtYXRjaCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1heCkubWF0Y2goSFRNTF9UQUdfT1BFTl9SRSk7XHJcbiAgICAgIGlmICghbWF0Y2gpIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICB9XHJcbiAgICAvLyBNYWtlIHN1cmUgdGFnIG5hbWUgaXMgdmFsaWRcclxuICAgIGlmIChibG9ja19uYW1lc1ttYXRjaFsxXS50b0xvd2VyQ2FzZSgpXSAhPT0gdHJ1ZSkgeyByZXR1cm4gZmFsc2U7IH1cclxuICAgIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIElmIHdlIGFyZSBoZXJlIC0gd2UgZGV0ZWN0ZWQgSFRNTCBibG9jay5cclxuICAvLyBMZXQncyByb2xsIGRvd24gdGlsbCBlbXB0eSBsaW5lIChibG9jayBlbmQpLlxyXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcclxuICB3aGlsZSAobmV4dExpbmUgPCBzdGF0ZS5saW5lTWF4ICYmICFzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKSkge1xyXG4gICAgbmV4dExpbmUrKztcclxuICB9XHJcblxyXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcclxuXHJcbiAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2h0bWxfYmxvY2snLCAnJywgMCk7XHJcbiAgdG9rZW4ubWFwICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XHJcbiAgdG9rZW4uY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIDAsIHRydWUpO1xyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbn0se1wiLi4vY29tbW9uL2h0bWxfYmxvY2tzXCI6Mn1dLDI1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLy8gbGhlYWRpbmcgKC0tLSwgPT09KVxyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGhlYWRpbmcoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZS8qLCBzaWxlbnQqLykge1xyXG4gIHZhciBtYXJrZXIsIHBvcywgbWF4LCB0b2tlbiwgbGV2ZWwsXHJcbiAgICAgIG5leHQgPSBzdGFydExpbmUgKyAxO1xyXG5cclxuICBpZiAobmV4dCA+PSBlbmRMaW5lKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gIGlmIChzdGF0ZS50U2hpZnRbbmV4dF0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIC8vIFNjYW4gbmV4dCBsaW5lXHJcblxyXG4gIGlmIChzdGF0ZS50U2hpZnRbbmV4dF0gLSBzdGF0ZS5ibGtJbmRlbnQgPiAzKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dF0gKyBzdGF0ZS50U2hpZnRbbmV4dF07XHJcbiAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRdO1xyXG5cclxuICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcclxuXHJcbiAgaWYgKG1hcmtlciAhPT0gMHgyRC8qIC0gKi8gJiYgbWFya2VyICE9PSAweDNELyogPSAqLykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgcG9zID0gc3RhdGUuc2tpcENoYXJzKHBvcywgbWFya2VyKTtcclxuXHJcbiAgcG9zID0gc3RhdGUuc2tpcFNwYWNlcyhwb3MpO1xyXG5cclxuICBpZiAocG9zIDwgbWF4KSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xyXG5cclxuICBzdGF0ZS5saW5lID0gbmV4dCArIDE7XHJcbiAgbGV2ZWwgPSAobWFya2VyID09PSAweDNELyogPSAqLyA/IDEgOiAyKTtcclxuXHJcbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX29wZW4nLCAnaCcgKyBTdHJpbmcobGV2ZWwpLCAxKTtcclxuICB0b2tlbi5tYXJrdXAgICA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcclxuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XHJcblxyXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xyXG4gIHRva2VuLmNvbnRlbnQgID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV0pLnRyaW0oKTtcclxuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIC0gMSBdO1xyXG4gIHRva2VuLmNoaWxkcmVuID0gW107XHJcblxyXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaGVhZGluZ19jbG9zZScsICdoJyArIFN0cmluZyhsZXZlbCksIC0xKTtcclxuICB0b2tlbi5tYXJrdXAgICA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG59LHt9XSwyNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8vIExpc3RzXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5cclxuLy8gU2VhcmNoIGBbLSsqXVtcXG4gXWAsIHJldHVybnMgbmV4dCBwb3MgYXJ0ZXIgbWFya2VyIG9uIHN1Y2Nlc3NcclxuLy8gb3IgLTEgb24gZmFpbC5cclxuZnVuY3Rpb24gc2tpcEJ1bGxldExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkge1xyXG4gIHZhciBtYXJrZXIsIHBvcywgbWF4O1xyXG5cclxuICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xyXG4gIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xyXG5cclxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XHJcbiAgLy8gQ2hlY2sgYnVsbGV0XHJcbiAgaWYgKG1hcmtlciAhPT0gMHgyQS8qICogKi8gJiZcclxuICAgICAgbWFya2VyICE9PSAweDJELyogLSAqLyAmJlxyXG4gICAgICBtYXJrZXIgIT09IDB4MkIvKiArICovKSB7XHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfVxyXG5cclxuICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MjApIHtcclxuICAgIC8vIFwiIDEudGVzdCBcIiAtIGlzIG5vdCBhIGxpc3QgaXRlbVxyXG4gICAgcmV0dXJuIC0xO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHBvcztcclxufVxyXG5cclxuLy8gU2VhcmNoIGBcXGQrWy4pXVtcXG4gXWAsIHJldHVybnMgbmV4dCBwb3MgYXJ0ZXIgbWFya2VyIG9uIHN1Y2Nlc3NcclxuLy8gb3IgLTEgb24gZmFpbC5cclxuZnVuY3Rpb24gc2tpcE9yZGVyZWRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpIHtcclxuICB2YXIgY2gsXHJcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXHJcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xyXG5cclxuICAvLyBMaXN0IG1hcmtlciBzaG91bGQgaGF2ZSBhdCBsZWFzdCAyIGNoYXJzIChkaWdpdCArIGRvdClcclxuICBpZiAocG9zICsgMSA+PSBtYXgpIHsgcmV0dXJuIC0xOyB9XHJcblxyXG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xyXG5cclxuICBpZiAoY2ggPCAweDMwLyogMCAqLyB8fCBjaCA+IDB4MzkvKiA5ICovKSB7IHJldHVybiAtMTsgfVxyXG5cclxuICBmb3IgKDs7KSB7XHJcbiAgICAvLyBFT0wgLT4gZmFpbFxyXG4gICAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIC0xOyB9XHJcblxyXG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XHJcblxyXG4gICAgaWYgKGNoID49IDB4MzAvKiAwICovICYmIGNoIDw9IDB4MzkvKiA5ICovKSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGZvdW5kIHZhbGlkIG1hcmtlclxyXG4gICAgaWYgKGNoID09PSAweDI5LyogKSAqLyB8fCBjaCA9PT0gMHgyZS8qIC4gKi8pIHtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIC0xO1xyXG4gIH1cclxuXHJcblxyXG4gIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyMC8qIHNwYWNlICovKSB7XHJcbiAgICAvLyBcIiAxLnRlc3QgXCIgLSBpcyBub3QgYSBsaXN0IGl0ZW1cclxuICAgIHJldHVybiAtMTtcclxuICB9XHJcbiAgcmV0dXJuIHBvcztcclxufVxyXG5cclxuZnVuY3Rpb24gbWFya1RpZ2h0UGFyYWdyYXBocyhzdGF0ZSwgaWR4KSB7XHJcbiAgdmFyIGksIGwsXHJcbiAgICAgIGxldmVsID0gc3RhdGUubGV2ZWwgKyAyO1xyXG5cclxuICBmb3IgKGkgPSBpZHggKyAyLCBsID0gc3RhdGUudG9rZW5zLmxlbmd0aCAtIDI7IGkgPCBsOyBpKyspIHtcclxuICAgIGlmIChzdGF0ZS50b2tlbnNbaV0ubGV2ZWwgPT09IGxldmVsICYmIHN0YXRlLnRva2Vuc1tpXS50eXBlID09PSAncGFyYWdyYXBoX29wZW4nKSB7XHJcbiAgICAgIHN0YXRlLnRva2Vuc1tpICsgMl0uaGlkZGVuID0gdHJ1ZTtcclxuICAgICAgc3RhdGUudG9rZW5zW2ldLmhpZGRlbiA9IHRydWU7XHJcbiAgICAgIGkgKz0gMjtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpc3Qoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XHJcbiAgdmFyIG5leHRMaW5lLFxyXG4gICAgICBpbmRlbnQsXHJcbiAgICAgIG9sZFRTaGlmdCxcclxuICAgICAgb2xkSW5kZW50LFxyXG4gICAgICBvbGRUaWdodCxcclxuICAgICAgb2xkUGFyZW50VHlwZSxcclxuICAgICAgc3RhcnQsXHJcbiAgICAgIHBvc0FmdGVyTWFya2VyLFxyXG4gICAgICBtYXgsXHJcbiAgICAgIGluZGVudEFmdGVyTWFya2VyLFxyXG4gICAgICBtYXJrZXJWYWx1ZSxcclxuICAgICAgbWFya2VyQ2hhckNvZGUsXHJcbiAgICAgIGlzT3JkZXJlZCxcclxuICAgICAgY29udGVudFN0YXJ0LFxyXG4gICAgICBsaXN0VG9rSWR4LFxyXG4gICAgICBwcmV2RW1wdHlFbmQsXHJcbiAgICAgIGxpc3RMaW5lcyxcclxuICAgICAgaXRlbUxpbmVzLFxyXG4gICAgICB0aWdodCA9IHRydWUsXHJcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyxcclxuICAgICAgdG9rZW4sXHJcbiAgICAgIGksIGwsIHRlcm1pbmF0ZTtcclxuXHJcbiAgLy8gRGV0ZWN0IGxpc3QgdHlwZSBhbmQgcG9zaXRpb24gYWZ0ZXIgbWFya2VyXHJcbiAgaWYgKChwb3NBZnRlck1hcmtlciA9IHNraXBPcmRlcmVkTGlzdE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSkgPj0gMCkge1xyXG4gICAgaXNPcmRlcmVkID0gdHJ1ZTtcclxuICB9IGVsc2UgaWYgKChwb3NBZnRlck1hcmtlciA9IHNraXBCdWxsZXRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpKSA+PSAwKSB7XHJcbiAgICBpc09yZGVyZWQgPSBmYWxzZTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gV2Ugc2hvdWxkIHRlcm1pbmF0ZSBsaXN0IG9uIHN0eWxlIGNoYW5nZS4gUmVtZW1iZXIgZmlyc3Qgb25lIHRvIGNvbXBhcmUuXHJcbiAgbWFya2VyQ2hhckNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3NBZnRlck1hcmtlciAtIDEpO1xyXG5cclxuICAvLyBGb3IgdmFsaWRhdGlvbiBtb2RlIHdlIGNhbiB0ZXJtaW5hdGUgaW1tZWRpYXRlbHlcclxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG4gIC8vIFN0YXJ0IGxpc3RcclxuICBsaXN0VG9rSWR4ID0gc3RhdGUudG9rZW5zLmxlbmd0aDtcclxuXHJcbiAgaWYgKGlzT3JkZXJlZCkge1xyXG4gICAgc3RhcnQgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xyXG4gICAgbWFya2VyVmFsdWUgPSBOdW1iZXIoc3RhdGUuc3JjLnN1YnN0cihzdGFydCwgcG9zQWZ0ZXJNYXJrZXIgLSBzdGFydCAtIDEpKTtcclxuXHJcbiAgICB0b2tlbiAgICAgICA9IHN0YXRlLnB1c2goJ29yZGVyZWRfbGlzdF9vcGVuJywgJ29sJywgMSk7XHJcbiAgICBpZiAobWFya2VyVmFsdWUgPiAxKSB7XHJcbiAgICAgIHRva2VuLmF0dHJzID0gWyBbICdzdGFydCcsIG1hcmtlclZhbHVlIF0gXTtcclxuICAgIH1cclxuXHJcbiAgfSBlbHNlIHtcclxuICAgIHRva2VuICAgICAgID0gc3RhdGUucHVzaCgnYnVsbGV0X2xpc3Rfb3BlbicsICd1bCcsIDEpO1xyXG4gIH1cclxuXHJcbiAgdG9rZW4ubWFwICAgID0gbGlzdExpbmVzID0gWyBzdGFydExpbmUsIDAgXTtcclxuICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcclxuXHJcbiAgLy9cclxuICAvLyBJdGVyYXRlIGxpc3QgaXRlbXNcclxuICAvL1xyXG5cclxuICBuZXh0TGluZSA9IHN0YXJ0TGluZTtcclxuICBwcmV2RW1wdHlFbmQgPSBmYWxzZTtcclxuICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygnbGlzdCcpO1xyXG5cclxuICB3aGlsZSAobmV4dExpbmUgPCBlbmRMaW5lKSB7XHJcbiAgICBjb250ZW50U3RhcnQgPSBzdGF0ZS5za2lwU3BhY2VzKHBvc0FmdGVyTWFya2VyKTtcclxuICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XHJcblxyXG4gICAgaWYgKGNvbnRlbnRTdGFydCA+PSBtYXgpIHtcclxuICAgICAgLy8gdHJpbW1pbmcgc3BhY2UgaW4gXCItICAgIFxcbiAgM1wiIGNhc2UsIGluZGVudCBpcyAxIGhlcmVcclxuICAgICAgaW5kZW50QWZ0ZXJNYXJrZXIgPSAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaW5kZW50QWZ0ZXJNYXJrZXIgPSBjb250ZW50U3RhcnQgLSBwb3NBZnRlck1hcmtlcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiB3ZSBoYXZlIG1vcmUgdGhhbiA0IHNwYWNlcywgdGhlIGluZGVudCBpcyAxXHJcbiAgICAvLyAodGhlIHJlc3QgaXMganVzdCBpbmRlbnRlZCBjb2RlIGJsb2NrKVxyXG4gICAgaWYgKGluZGVudEFmdGVyTWFya2VyID4gNCkgeyBpbmRlbnRBZnRlck1hcmtlciA9IDE7IH1cclxuXHJcbiAgICAvLyBcIiAgLSAgdGVzdFwiXHJcbiAgICAvLyAgXl5eXl4gLSBjYWxjdWxhdGluZyB0b3RhbCBsZW5ndGggb2YgdGhpcyB0aGluZ1xyXG4gICAgaW5kZW50ID0gKHBvc0FmdGVyTWFya2VyIC0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSkgKyBpbmRlbnRBZnRlck1hcmtlcjtcclxuXHJcbiAgICAvLyBSdW4gc3VicGFyc2VyICYgd3JpdGUgdG9rZW5zXHJcbiAgICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaXN0X2l0ZW1fb3BlbicsICdsaScsIDEpO1xyXG4gICAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXJDaGFyQ29kZSk7XHJcbiAgICB0b2tlbi5tYXAgICAgPSBpdGVtTGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdO1xyXG5cclxuICAgIG9sZEluZGVudCA9IHN0YXRlLmJsa0luZGVudDtcclxuICAgIG9sZFRpZ2h0ID0gc3RhdGUudGlnaHQ7XHJcbiAgICBvbGRUU2hpZnQgPSBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcclxuICAgIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xyXG4gICAgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPSBjb250ZW50U3RhcnQgLSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXTtcclxuICAgIHN0YXRlLmJsa0luZGVudCA9IGluZGVudDtcclxuICAgIHN0YXRlLnRpZ2h0ID0gdHJ1ZTtcclxuICAgIHN0YXRlLnBhcmVudFR5cGUgPSAnbGlzdCc7XHJcblxyXG4gICAgc3RhdGUubWQuYmxvY2sudG9rZW5pemUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgdHJ1ZSk7XHJcblxyXG4gICAgLy8gSWYgYW55IG9mIGxpc3QgaXRlbSBpcyB0aWdodCwgbWFyayBsaXN0IGFzIHRpZ2h0XHJcbiAgICBpZiAoIXN0YXRlLnRpZ2h0IHx8IHByZXZFbXB0eUVuZCkge1xyXG4gICAgICB0aWdodCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gSXRlbSBiZWNvbWUgbG9vc2UgaWYgZmluaXNoIHdpdGggZW1wdHkgbGluZSxcclxuICAgIC8vIGJ1dCB3ZSBzaG91bGQgZmlsdGVyIGxhc3QgZWxlbWVudCwgYmVjYXVzZSBpdCBtZWFucyBsaXN0IGZpbmlzaFxyXG4gICAgcHJldkVtcHR5RW5kID0gKHN0YXRlLmxpbmUgLSBzdGFydExpbmUpID4gMSAmJiBzdGF0ZS5pc0VtcHR5KHN0YXRlLmxpbmUgLSAxKTtcclxuXHJcbiAgICBzdGF0ZS5ibGtJbmRlbnQgPSBvbGRJbmRlbnQ7XHJcbiAgICBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSA9IG9sZFRTaGlmdDtcclxuICAgIHN0YXRlLnRpZ2h0ID0gb2xkVGlnaHQ7XHJcbiAgICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcclxuXHJcbiAgICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaXN0X2l0ZW1fY2xvc2UnLCAnbGknLCAtMSk7XHJcbiAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcclxuXHJcbiAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSA9IHN0YXRlLmxpbmU7XHJcbiAgICBpdGVtTGluZXNbMV0gPSBuZXh0TGluZTtcclxuICAgIGNvbnRlbnRTdGFydCA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdO1xyXG5cclxuICAgIGlmIChuZXh0TGluZSA+PSBlbmRMaW5lKSB7IGJyZWFrOyB9XHJcblxyXG4gICAgaWYgKHN0YXRlLmlzRW1wdHkobmV4dExpbmUpKSB7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vXHJcbiAgICAvLyBUcnkgdG8gY2hlY2sgaWYgbGlzdCBpcyB0ZXJtaW5hdGVkIG9yIGNvbnRpbnVlZC5cclxuICAgIC8vXHJcbiAgICBpZiAoc3RhdGUudFNoaWZ0W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxyXG5cclxuICAgIC8vIGZhaWwgaWYgdGVybWluYXRpbmcgYmxvY2sgZm91bmRcclxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xyXG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XHJcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxyXG5cclxuICAgIC8vIGZhaWwgaWYgbGlzdCBoYXMgYW5vdGhlciB0eXBlXHJcbiAgICBpZiAoaXNPcmRlcmVkKSB7XHJcbiAgICAgIHBvc0FmdGVyTWFya2VyID0gc2tpcE9yZGVyZWRMaXN0TWFya2VyKHN0YXRlLCBuZXh0TGluZSk7XHJcbiAgICAgIGlmIChwb3NBZnRlck1hcmtlciA8IDApIHsgYnJlYWs7IH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBvc0FmdGVyTWFya2VyID0gc2tpcEJ1bGxldExpc3RNYXJrZXIoc3RhdGUsIG5leHRMaW5lKTtcclxuICAgICAgaWYgKHBvc0FmdGVyTWFya2VyIDwgMCkgeyBicmVhazsgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChtYXJrZXJDaGFyQ29kZSAhPT0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zQWZ0ZXJNYXJrZXIgLSAxKSkgeyBicmVhazsgfVxyXG4gIH1cclxuXHJcbiAgLy8gRmluaWxpemUgbGlzdFxyXG4gIGlmIChpc09yZGVyZWQpIHtcclxuICAgIHRva2VuID0gc3RhdGUucHVzaCgnb3JkZXJlZF9saXN0X2Nsb3NlJywgJ29sJywgLTEpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0b2tlbiA9IHN0YXRlLnB1c2goJ2J1bGxldF9saXN0X2Nsb3NlJywgJ3VsJywgLTEpO1xyXG4gIH1cclxuICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcclxuXHJcbiAgbGlzdExpbmVzWzFdID0gbmV4dExpbmU7XHJcbiAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xyXG5cclxuICAvLyBtYXJrIHBhcmFncmFwaHMgdGlnaHQgaWYgbmVlZGVkXHJcbiAgaWYgKHRpZ2h0KSB7XHJcbiAgICBtYXJrVGlnaHRQYXJhZ3JhcGhzKHN0YXRlLCBsaXN0VG9rSWR4KTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxufSx7fV0sMjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4vLyBQYXJhZ3JhcGhcclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcmFncmFwaChzdGF0ZSwgc3RhcnRMaW5lLyosIGVuZExpbmUqLykge1xyXG4gIHZhciBjb250ZW50LCB0ZXJtaW5hdGUsIGksIGwsIHRva2VuLFxyXG4gICAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDEsXHJcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdwYXJhZ3JhcGgnKSxcclxuICAgICAgZW5kTGluZSA9IHN0YXRlLmxpbmVNYXg7XHJcblxyXG4gIC8vIGp1bXAgbGluZS1ieS1saW5lIHVudGlsIGVtcHR5IG9uZSBvciBFT0ZcclxuICBmb3IgKDsgbmV4dExpbmUgPCBlbmRMaW5lICYmICFzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKTsgbmV4dExpbmUrKykge1xyXG4gICAgLy8gdGhpcyB3b3VsZCBiZSBhIGNvZGUgYmxvY2sgbm9ybWFsbHksIGJ1dCBhZnRlciBwYXJhZ3JhcGhcclxuICAgIC8vIGl0J3MgY29uc2lkZXJlZCBhIGxhenkgY29udGludWF0aW9uIHJlZ2FyZGxlc3Mgb2Ygd2hhdCdzIHRoZXJlXHJcbiAgICBpZiAoc3RhdGUudFNoaWZ0W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+IDMpIHsgY29udGludWU7IH1cclxuXHJcbiAgICAvLyBTb21lIHRhZ3MgY2FuIHRlcm1pbmF0ZSBwYXJhZ3JhcGggd2l0aG91dCBlbXB0eSBsaW5lLlxyXG4gICAgdGVybWluYXRlID0gZmFsc2U7XHJcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcclxuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XHJcbiAgfVxyXG5cclxuICBjb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCBmYWxzZSkudHJpbSgpO1xyXG5cclxuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XHJcblxyXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgncGFyYWdyYXBoX29wZW4nLCAncCcsIDEpO1xyXG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcclxuXHJcbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XHJcbiAgdG9rZW4uY29udGVudCAgPSBjb250ZW50O1xyXG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcclxuICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xyXG5cclxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3BhcmFncmFwaF9jbG9zZScsICdwJywgLTEpO1xyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbn0se31dLDI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBwYXJzZUxpbmtEZXN0aW5hdGlvbiA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcGFyc2VfbGlua19kZXN0aW5hdGlvbicpO1xyXG52YXIgcGFyc2VMaW5rVGl0bGUgICAgICAgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3BhcnNlX2xpbmtfdGl0bGUnKTtcclxudmFyIG5vcm1hbGl6ZVJlZmVyZW5jZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykubm9ybWFsaXplUmVmZXJlbmNlO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVmZXJlbmNlKHN0YXRlLCBzdGFydExpbmUsIF9lbmRMaW5lLCBzaWxlbnQpIHtcclxuICB2YXIgY2gsXHJcbiAgICAgIGRlc3RFbmRQb3MsXHJcbiAgICAgIGRlc3RFbmRMaW5lTm8sXHJcbiAgICAgIGVuZExpbmUsXHJcbiAgICAgIGhyZWYsXHJcbiAgICAgIGksXHJcbiAgICAgIGwsXHJcbiAgICAgIGxhYmVsLFxyXG4gICAgICBsYWJlbEVuZCxcclxuICAgICAgcmVzLFxyXG4gICAgICBzdGFydCxcclxuICAgICAgc3RyLFxyXG4gICAgICB0ZXJtaW5hdGUsXHJcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyxcclxuICAgICAgdGl0bGUsXHJcbiAgICAgIGxpbmVzID0gMCxcclxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcclxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV0sXHJcbiAgICAgIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcclxuXHJcbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4NUIvKiBbICovKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICAvLyBTaW1wbGUgY2hlY2sgdG8gcXVpY2tseSBpbnRlcnJ1cHQgc2NhbiBvbiBbbGlua10odXJsKSBhdCB0aGUgc3RhcnQgb2YgbGluZS5cclxuICAvLyBDYW4gYmUgdXNlZnVsIG9uIHByYWN0aWNlOiBodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvaXNzdWVzLzU0XHJcbiAgd2hpbGUgKCsrcG9zIDwgbWF4KSB7XHJcbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg1RCAvKiBdICovICYmXHJcbiAgICAgICAgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zIC0gMSkgIT09IDB4NUMvKiBcXCAqLykge1xyXG4gICAgICBpZiAocG9zICsgMSA9PT0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSkgIT09IDB4M0EvKiA6ICovKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGVuZExpbmUgPSBzdGF0ZS5saW5lTWF4O1xyXG5cclxuICAvLyBqdW1wIGxpbmUtYnktbGluZSB1bnRpbCBlbXB0eSBvbmUgb3IgRU9GXHJcbiAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ3JlZmVyZW5jZScpO1xyXG5cclxuICBmb3IgKDsgbmV4dExpbmUgPCBlbmRMaW5lICYmICFzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKTsgbmV4dExpbmUrKykge1xyXG4gICAgLy8gdGhpcyB3b3VsZCBiZSBhIGNvZGUgYmxvY2sgbm9ybWFsbHksIGJ1dCBhZnRlciBwYXJhZ3JhcGhcclxuICAgIC8vIGl0J3MgY29uc2lkZXJlZCBhIGxhenkgY29udGludWF0aW9uIHJlZ2FyZGxlc3Mgb2Ygd2hhdCdzIHRoZXJlXHJcbiAgICBpZiAoc3RhdGUudFNoaWZ0W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+IDMpIHsgY29udGludWU7IH1cclxuXHJcbiAgICAvLyBTb21lIHRhZ3MgY2FuIHRlcm1pbmF0ZSBwYXJhZ3JhcGggd2l0aG91dCBlbXB0eSBsaW5lLlxyXG4gICAgdGVybWluYXRlID0gZmFsc2U7XHJcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcclxuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XHJcbiAgfVxyXG5cclxuICBzdHIgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIG5leHRMaW5lLCBzdGF0ZS5ibGtJbmRlbnQsIGZhbHNlKS50cmltKCk7XHJcbiAgbWF4ID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgZm9yIChwb3MgPSAxOyBwb3MgPCBtYXg7IHBvcysrKSB7XHJcbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XHJcbiAgICBpZiAoY2ggPT09IDB4NUIgLyogWyAqLykge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDVEIC8qIF0gKi8pIHtcclxuICAgICAgbGFiZWxFbmQgPSBwb3M7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHgwQSAvKiBcXG4gKi8pIHtcclxuICAgICAgbGluZXMrKztcclxuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4NUMgLyogXFwgKi8pIHtcclxuICAgICAgcG9zKys7XHJcbiAgICAgIGlmIChwb3MgPCBtYXggJiYgc3RyLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwQSkge1xyXG4gICAgICAgIGxpbmVzKys7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChsYWJlbEVuZCA8IDAgfHwgc3RyLmNoYXJDb2RlQXQobGFiZWxFbmQgKyAxKSAhPT0gMHgzQS8qIDogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXHJcbiAgLy8gICAgICAgICBeXl4gc2tpcCBvcHRpb25hbCB3aGl0ZXNwYWNlIGhlcmVcclxuICBmb3IgKHBvcyA9IGxhYmVsRW5kICsgMjsgcG9zIDwgbWF4OyBwb3MrKykge1xyXG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xyXG4gICAgaWYgKGNoID09PSAweDBBKSB7XHJcbiAgICAgIGxpbmVzKys7XHJcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDIwKSB7XHJcbiAgICAgIC8qZXNsaW50IG5vLWVtcHR5OjAqL1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xyXG4gIC8vICAgICAgICAgICAgXl5eXl5eXl5eXl4gcGFyc2UgdGhpc1xyXG4gIHJlcyA9IHBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0ciwgcG9zLCBtYXgpO1xyXG4gIGlmICghcmVzLm9rKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICBocmVmID0gc3RhdGUubWQubm9ybWFsaXplTGluayhyZXMuc3RyKTtcclxuICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhocmVmKSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgcG9zID0gcmVzLnBvcztcclxuICBsaW5lcyArPSByZXMubGluZXM7XHJcblxyXG4gIC8vIHNhdmUgY3Vyc29yIHN0YXRlLCB3ZSBjb3VsZCByZXF1aXJlIHRvIHJvbGxiYWNrIGxhdGVyXHJcbiAgZGVzdEVuZFBvcyA9IHBvcztcclxuICBkZXN0RW5kTGluZU5vID0gbGluZXM7XHJcblxyXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXHJcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIF5eXiBza2lwcGluZyB0aG9zZSBzcGFjZXNcclxuICBzdGFydCA9IHBvcztcclxuICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xyXG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xyXG4gICAgaWYgKGNoID09PSAweDBBKSB7XHJcbiAgICAgIGxpbmVzKys7XHJcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDIwKSB7XHJcbiAgICAgIC8qZXNsaW50IG5vLWVtcHR5OjAqL1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xyXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl5eIHBhcnNlIHRoaXNcclxuICByZXMgPSBwYXJzZUxpbmtUaXRsZShzdHIsIHBvcywgbWF4KTtcclxuICBpZiAocG9zIDwgbWF4ICYmIHN0YXJ0ICE9PSBwb3MgJiYgcmVzLm9rKSB7XHJcbiAgICB0aXRsZSA9IHJlcy5zdHI7XHJcbiAgICBwb3MgPSByZXMucG9zO1xyXG4gICAgbGluZXMgKz0gcmVzLmxpbmVzO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aXRsZSA9ICcnO1xyXG4gICAgcG9zID0gZGVzdEVuZFBvcztcclxuICAgIGxpbmVzID0gZGVzdEVuZExpbmVObztcclxuICB9XHJcblxyXG4gIC8vIHNraXAgdHJhaWxpbmcgc3BhY2VzIHVudGlsIHRoZSByZXN0IG9mIHRoZSBsaW5lXHJcbiAgd2hpbGUgKHBvcyA8IG1heCAmJiBzdHIuY2hhckNvZGVBdChwb3MpID09PSAweDIwLyogc3BhY2UgKi8pIHsgcG9zKys7IH1cclxuXHJcbiAgaWYgKHBvcyA8IG1heCAmJiBzdHIuY2hhckNvZGVBdChwb3MpICE9PSAweDBBKSB7XHJcbiAgICAvLyBnYXJiYWdlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmVcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIFJlZmVyZW5jZSBjYW4gbm90IHRlcm1pbmF0ZSBhbnl0aGluZy4gVGhpcyBjaGVjayBpcyBmb3Igc2FmZXR5IG9ubHkuXHJcbiAgLyppc3RhbmJ1bCBpZ25vcmUgaWYqL1xyXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcbiAgbGFiZWwgPSBub3JtYWxpemVSZWZlcmVuY2Uoc3RyLnNsaWNlKDEsIGxhYmVsRW5kKSk7XHJcbiAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHN0YXRlLmVudi5yZWZlcmVuY2VzID0ge307XHJcbiAgfVxyXG4gIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXNbbGFiZWxdID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgc3RhdGUuZW52LnJlZmVyZW5jZXNbbGFiZWxdID0geyB0aXRsZTogdGl0bGUsIGhyZWY6IGhyZWYgfTtcclxuICB9XHJcblxyXG4gIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgKyBsaW5lcyArIDE7XHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG59LHtcIi4uL2NvbW1vbi91dGlsc1wiOjUsXCIuLi9oZWxwZXJzL3BhcnNlX2xpbmtfZGVzdGluYXRpb25cIjo3LFwiLi4vaGVscGVycy9wYXJzZV9saW5rX3RpdGxlXCI6OX1dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLy8gUGFyc2VyIHN0YXRlIGNsYXNzXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgVG9rZW4gPSByZXF1aXJlKCcuLi90b2tlbicpO1xyXG5cclxuXHJcbmZ1bmN0aW9uIFN0YXRlQmxvY2soc3JjLCBtZCwgZW52LCB0b2tlbnMpIHtcclxuICB2YXIgY2gsIHMsIHN0YXJ0LCBwb3MsIGxlbiwgaW5kZW50LCBpbmRlbnRfZm91bmQ7XHJcblxyXG4gIHRoaXMuc3JjID0gc3JjO1xyXG5cclxuICAvLyBsaW5rIHRvIHBhcnNlciBpbnN0YW5jZVxyXG4gIHRoaXMubWQgICAgID0gbWQ7XHJcblxyXG4gIHRoaXMuZW52ID0gZW52O1xyXG5cclxuICAvL1xyXG4gIC8vIEludGVybmFsIHN0YXRlIHZhcnRpYWJsZXNcclxuICAvL1xyXG5cclxuICB0aGlzLnRva2VucyA9IHRva2VucztcclxuXHJcbiAgdGhpcy5iTWFya3MgPSBbXTsgIC8vIGxpbmUgYmVnaW4gb2Zmc2V0cyBmb3IgZmFzdCBqdW1wc1xyXG4gIHRoaXMuZU1hcmtzID0gW107ICAvLyBsaW5lIGVuZCBvZmZzZXRzIGZvciBmYXN0IGp1bXBzXHJcbiAgdGhpcy50U2hpZnQgPSBbXTsgIC8vIGluZGVudCBmb3IgZWFjaCBsaW5lXHJcblxyXG4gIC8vIGJsb2NrIHBhcnNlciB2YXJpYWJsZXNcclxuICB0aGlzLmJsa0luZGVudCAgPSAwOyAvLyByZXF1aXJlZCBibG9jayBjb250ZW50IGluZGVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIChmb3IgZXhhbXBsZSwgaWYgd2UgYXJlIGluIGxpc3QpXHJcbiAgdGhpcy5saW5lICAgICAgID0gMDsgLy8gbGluZSBpbmRleCBpbiBzcmNcclxuICB0aGlzLmxpbmVNYXggICAgPSAwOyAvLyBsaW5lcyBjb3VudFxyXG4gIHRoaXMudGlnaHQgICAgICA9IGZhbHNlOyAgLy8gbG9vc2UvdGlnaHQgbW9kZSBmb3IgbGlzdHNcclxuICB0aGlzLnBhcmVudFR5cGUgPSAncm9vdCc7IC8vIGlmIGBsaXN0YCwgYmxvY2sgcGFyc2VyIHN0b3BzIG9uIHR3byBuZXdsaW5lc1xyXG4gIHRoaXMuZGRJbmRlbnQgICA9IC0xOyAvLyBpbmRlbnQgb2YgdGhlIGN1cnJlbnQgZGQgYmxvY2sgKC0xIGlmIHRoZXJlIGlzbid0IGFueSlcclxuXHJcbiAgdGhpcy5sZXZlbCA9IDA7XHJcblxyXG4gIC8vIHJlbmRlcmVyXHJcbiAgdGhpcy5yZXN1bHQgPSAnJztcclxuXHJcbiAgLy8gQ3JlYXRlIGNhY2hlc1xyXG4gIC8vIEdlbmVyYXRlIG1hcmtlcnMuXHJcbiAgcyA9IHRoaXMuc3JjO1xyXG4gIGluZGVudCA9IDA7XHJcbiAgaW5kZW50X2ZvdW5kID0gZmFsc2U7XHJcblxyXG4gIGZvciAoc3RhcnQgPSBwb3MgPSBpbmRlbnQgPSAwLCBsZW4gPSBzLmxlbmd0aDsgcG9zIDwgbGVuOyBwb3MrKykge1xyXG4gICAgY2ggPSBzLmNoYXJDb2RlQXQocG9zKTtcclxuXHJcbiAgICBpZiAoIWluZGVudF9mb3VuZCkge1xyXG4gICAgICBpZiAoY2ggPT09IDB4MjAvKiBzcGFjZSAqLykge1xyXG4gICAgICAgIGluZGVudCsrO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGluZGVudF9mb3VuZCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2ggPT09IDB4MEEgfHwgcG9zID09PSBsZW4gLSAxKSB7XHJcbiAgICAgIGlmIChjaCAhPT0gMHgwQSkgeyBwb3MrKzsgfVxyXG4gICAgICB0aGlzLmJNYXJrcy5wdXNoKHN0YXJ0KTtcclxuICAgICAgdGhpcy5lTWFya3MucHVzaChwb3MpO1xyXG4gICAgICB0aGlzLnRTaGlmdC5wdXNoKGluZGVudCk7XHJcblxyXG4gICAgICBpbmRlbnRfZm91bmQgPSBmYWxzZTtcclxuICAgICAgaW5kZW50ID0gMDtcclxuICAgICAgc3RhcnQgPSBwb3MgKyAxO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUHVzaCBmYWtlIGVudHJ5IHRvIHNpbXBsaWZ5IGNhY2hlIGJvdW5kcyBjaGVja3NcclxuICB0aGlzLmJNYXJrcy5wdXNoKHMubGVuZ3RoKTtcclxuICB0aGlzLmVNYXJrcy5wdXNoKHMubGVuZ3RoKTtcclxuICB0aGlzLnRTaGlmdC5wdXNoKDApO1xyXG5cclxuICB0aGlzLmxpbmVNYXggPSB0aGlzLmJNYXJrcy5sZW5ndGggLSAxOyAvLyBkb24ndCBjb3VudCBsYXN0IGZha2UgbGluZVxyXG59XHJcblxyXG4vLyBQdXNoIG5ldyB0b2tlbiB0byBcInN0cmVhbVwiLlxyXG4vL1xyXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHR5cGUsIHRhZywgbmVzdGluZykge1xyXG4gIHZhciB0b2tlbiA9IG5ldyBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpO1xyXG4gIHRva2VuLmJsb2NrID0gdHJ1ZTtcclxuXHJcbiAgaWYgKG5lc3RpbmcgPCAwKSB7IHRoaXMubGV2ZWwtLTsgfVxyXG4gIHRva2VuLmxldmVsID0gdGhpcy5sZXZlbDtcclxuICBpZiAobmVzdGluZyA+IDApIHsgdGhpcy5sZXZlbCsrOyB9XHJcblxyXG4gIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xyXG4gIHJldHVybiB0b2tlbjtcclxufTtcclxuXHJcblN0YXRlQmxvY2sucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KGxpbmUpIHtcclxuICByZXR1cm4gdGhpcy5iTWFya3NbbGluZV0gKyB0aGlzLnRTaGlmdFtsaW5lXSA+PSB0aGlzLmVNYXJrc1tsaW5lXTtcclxufTtcclxuXHJcblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBFbXB0eUxpbmVzID0gZnVuY3Rpb24gc2tpcEVtcHR5TGluZXMoZnJvbSkge1xyXG4gIGZvciAodmFyIG1heCA9IHRoaXMubGluZU1heDsgZnJvbSA8IG1heDsgZnJvbSsrKSB7XHJcbiAgICBpZiAodGhpcy5iTWFya3NbZnJvbV0gKyB0aGlzLnRTaGlmdFtmcm9tXSA8IHRoaXMuZU1hcmtzW2Zyb21dKSB7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZnJvbTtcclxufTtcclxuXHJcbi8vIFNraXAgc3BhY2VzIGZyb20gZ2l2ZW4gcG9zaXRpb24uXHJcblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBTcGFjZXMgPSBmdW5jdGlvbiBza2lwU3BhY2VzKHBvcykge1xyXG4gIGZvciAodmFyIG1heCA9IHRoaXMuc3JjLmxlbmd0aDsgcG9zIDwgbWF4OyBwb3MrKykge1xyXG4gICAgaWYgKHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyMC8qIHNwYWNlICovKSB7IGJyZWFrOyB9XHJcbiAgfVxyXG4gIHJldHVybiBwb3M7XHJcbn07XHJcblxyXG4vLyBTa2lwIGNoYXIgY29kZXMgZnJvbSBnaXZlbiBwb3NpdGlvblxyXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwQ2hhcnMgPSBmdW5jdGlvbiBza2lwQ2hhcnMocG9zLCBjb2RlKSB7XHJcbiAgZm9yICh2YXIgbWF4ID0gdGhpcy5zcmMubGVuZ3RoOyBwb3MgPCBtYXg7IHBvcysrKSB7XHJcbiAgICBpZiAodGhpcy5zcmMuY2hhckNvZGVBdChwb3MpICE9PSBjb2RlKSB7IGJyZWFrOyB9XHJcbiAgfVxyXG4gIHJldHVybiBwb3M7XHJcbn07XHJcblxyXG4vLyBTa2lwIGNoYXIgY29kZXMgcmV2ZXJzZSBmcm9tIGdpdmVuIHBvc2l0aW9uIC0gMVxyXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwQ2hhcnNCYWNrID0gZnVuY3Rpb24gc2tpcENoYXJzQmFjayhwb3MsIGNvZGUsIG1pbikge1xyXG4gIGlmIChwb3MgPD0gbWluKSB7IHJldHVybiBwb3M7IH1cclxuXHJcbiAgd2hpbGUgKHBvcyA+IG1pbikge1xyXG4gICAgaWYgKGNvZGUgIT09IHRoaXMuc3JjLmNoYXJDb2RlQXQoLS1wb3MpKSB7IHJldHVybiBwb3MgKyAxOyB9XHJcbiAgfVxyXG4gIHJldHVybiBwb3M7XHJcbn07XHJcblxyXG4vLyBjdXQgbGluZXMgcmFuZ2UgZnJvbSBzb3VyY2UuXHJcblN0YXRlQmxvY2sucHJvdG90eXBlLmdldExpbmVzID0gZnVuY3Rpb24gZ2V0TGluZXMoYmVnaW4sIGVuZCwgaW5kZW50LCBrZWVwTGFzdExGKSB7XHJcbiAgdmFyIGksIGZpcnN0LCBsYXN0LCBxdWV1ZSwgc2hpZnQsXHJcbiAgICAgIGxpbmUgPSBiZWdpbjtcclxuXHJcbiAgaWYgKGJlZ2luID49IGVuZCkge1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxuXHJcbiAgLy8gT3B0OiBkb24ndCB1c2UgcHVzaCBxdWV1ZSBmb3Igc2luZ2xlIGxpbmU7XHJcbiAgaWYgKGxpbmUgKyAxID09PSBlbmQpIHtcclxuICAgIGZpcnN0ID0gdGhpcy5iTWFya3NbbGluZV0gKyBNYXRoLm1pbih0aGlzLnRTaGlmdFtsaW5lXSwgaW5kZW50KTtcclxuICAgIGxhc3QgPSBrZWVwTGFzdExGID8gdGhpcy5iTWFya3NbZW5kXSA6IHRoaXMuZU1hcmtzW2VuZCAtIDFdO1xyXG4gICAgcmV0dXJuIHRoaXMuc3JjLnNsaWNlKGZpcnN0LCBsYXN0KTtcclxuICB9XHJcblxyXG4gIHF1ZXVlID0gbmV3IEFycmF5KGVuZCAtIGJlZ2luKTtcclxuXHJcbiAgZm9yIChpID0gMDsgbGluZSA8IGVuZDsgbGluZSsrLCBpKyspIHtcclxuICAgIHNoaWZ0ID0gdGhpcy50U2hpZnRbbGluZV07XHJcbiAgICBpZiAoc2hpZnQgPiBpbmRlbnQpIHsgc2hpZnQgPSBpbmRlbnQ7IH1cclxuICAgIGlmIChzaGlmdCA8IDApIHsgc2hpZnQgPSAwOyB9XHJcblxyXG4gICAgZmlyc3QgPSB0aGlzLmJNYXJrc1tsaW5lXSArIHNoaWZ0O1xyXG5cclxuICAgIGlmIChsaW5lICsgMSA8IGVuZCB8fCBrZWVwTGFzdExGKSB7XHJcbiAgICAgIC8vIE5vIG5lZWQgZm9yIGJvdW5kcyBjaGVjayBiZWNhdXNlIHdlIGhhdmUgZmFrZSBlbnRyeSBvbiB0YWlsLlxyXG4gICAgICBsYXN0ID0gdGhpcy5lTWFya3NbbGluZV0gKyAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGFzdCA9IHRoaXMuZU1hcmtzW2xpbmVdO1xyXG4gICAgfVxyXG5cclxuICAgIHF1ZXVlW2ldID0gdGhpcy5zcmMuc2xpY2UoZmlyc3QsIGxhc3QpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHF1ZXVlLmpvaW4oJycpO1xyXG59O1xyXG5cclxuLy8gcmUtZXhwb3J0IFRva2VuIGNsYXNzIHRvIHVzZSBpbiBibG9jayBydWxlc1xyXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5Ub2tlbiA9IFRva2VuO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3RhdGVCbG9jaztcclxuXHJcbn0se1wiLi4vdG9rZW5cIjo1MH1dLDMwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLy8gR0ZNIHRhYmxlLCBub24tc3RhbmRhcmRcclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcblxyXG5mdW5jdGlvbiBnZXRMaW5lKHN0YXRlLCBsaW5lKSB7XHJcbiAgdmFyIHBvcyA9IHN0YXRlLmJNYXJrc1tsaW5lXSArIHN0YXRlLmJsa0luZGVudCxcclxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW2xpbmVdO1xyXG5cclxuICByZXR1cm4gc3RhdGUuc3JjLnN1YnN0cihwb3MsIG1heCAtIHBvcyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVzY2FwZWRTcGxpdChzdHIpIHtcclxuICB2YXIgcmVzdWx0ID0gW10sXHJcbiAgICAgIHBvcyA9IDAsXHJcbiAgICAgIG1heCA9IHN0ci5sZW5ndGgsXHJcbiAgICAgIGNoLFxyXG4gICAgICBlc2NhcGVzID0gMCxcclxuICAgICAgbGFzdFBvcyA9IDAsXHJcbiAgICAgIGJhY2tUaWNrZWQgPSBmYWxzZSxcclxuICAgICAgbGFzdEJhY2tUaWNrID0gMDtcclxuXHJcbiAgY2ggID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcclxuXHJcbiAgd2hpbGUgKHBvcyA8IG1heCkge1xyXG4gICAgaWYgKGNoID09PSAweDYwLyogYCAqLyAmJiAoZXNjYXBlcyAlIDIgPT09IDApKSB7XHJcbiAgICAgIGJhY2tUaWNrZWQgPSAhYmFja1RpY2tlZDtcclxuICAgICAgbGFzdEJhY2tUaWNrID0gcG9zO1xyXG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHg3Yy8qIHwgKi8gJiYgKGVzY2FwZXMgJSAyID09PSAwKSAmJiAhYmFja1RpY2tlZCkge1xyXG4gICAgICByZXN1bHQucHVzaChzdHIuc3Vic3RyaW5nKGxhc3RQb3MsIHBvcykpO1xyXG4gICAgICBsYXN0UG9zID0gcG9zICsgMTtcclxuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4NWMvKiBcXCAqLykge1xyXG4gICAgICBlc2NhcGVzKys7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlc2NhcGVzID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBwb3MrKztcclxuXHJcbiAgICAvLyBJZiB0aGVyZSB3YXMgYW4gdW4tY2xvc2VkIGJhY2t0aWNrLCBnbyBiYWNrIHRvIGp1c3QgYWZ0ZXJcclxuICAgIC8vIHRoZSBsYXN0IGJhY2t0aWNrLCBidXQgYXMgaWYgaXQgd2FzIGEgbm9ybWFsIGNoYXJhY3RlclxyXG4gICAgaWYgKHBvcyA9PT0gbWF4ICYmIGJhY2tUaWNrZWQpIHtcclxuICAgICAgYmFja1RpY2tlZCA9IGZhbHNlO1xyXG4gICAgICBwb3MgPSBsYXN0QmFja1RpY2sgKyAxO1xyXG4gICAgfVxyXG5cclxuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcclxuICB9XHJcblxyXG4gIHJlc3VsdC5wdXNoKHN0ci5zdWJzdHJpbmcobGFzdFBvcykpO1xyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0YWJsZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcclxuICB2YXIgY2gsIGxpbmVUZXh0LCBwb3MsIGksIG5leHRMaW5lLCByb3dzLCB0b2tlbixcclxuICAgICAgYWxpZ25zLCB0LCB0YWJsZUxpbmVzLCB0Ym9keUxpbmVzO1xyXG5cclxuICAvLyBzaG91bGQgaGF2ZSBhdCBsZWFzdCB0aHJlZSBsaW5lc1xyXG4gIGlmIChzdGFydExpbmUgKyAyID4gZW5kTGluZSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xyXG5cclxuICBpZiAoc3RhdGUudFNoaWZ0W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgLy8gZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBzZWNvbmQgbGluZSBzaG91bGQgYmUgJ3wnIG9yICctJ1xyXG5cclxuICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcclxuICBpZiAocG9zID49IHN0YXRlLmVNYXJrc1tuZXh0TGluZV0pIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcclxuICBpZiAoY2ggIT09IDB4N0MvKiB8ICovICYmIGNoICE9PSAweDJELyogLSAqLyAmJiBjaCAhPT0gMHgzQS8qIDogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIGxpbmVUZXh0ID0gZ2V0TGluZShzdGF0ZSwgc3RhcnRMaW5lICsgMSk7XHJcbiAgaWYgKCEvXlstOnwgXSskLy50ZXN0KGxpbmVUZXh0KSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgcm93cyA9IGxpbmVUZXh0LnNwbGl0KCd8Jyk7XHJcbiAgaWYgKHJvd3MubGVuZ3RoIDwgMikgeyByZXR1cm4gZmFsc2U7IH1cclxuICBhbGlnbnMgPSBbXTtcclxuICBmb3IgKGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKykge1xyXG4gICAgdCA9IHJvd3NbaV0udHJpbSgpO1xyXG4gICAgaWYgKCF0KSB7XHJcbiAgICAgIC8vIGFsbG93IGVtcHR5IGNvbHVtbnMgYmVmb3JlIGFuZCBhZnRlciB0YWJsZSwgYnV0IG5vdCBpbiBiZXR3ZWVuIGNvbHVtbnM7XHJcbiAgICAgIC8vIGUuZy4gYWxsb3cgYCB8LS0tfCBgLCBkaXNhbGxvdyBgIC0tLXx8LS0tIGBcclxuICAgICAgaWYgKGkgPT09IDAgfHwgaSA9PT0gcm93cy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCEvXjo/LSs6PyQvLnRlc3QodCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICBpZiAodC5jaGFyQ29kZUF0KHQubGVuZ3RoIC0gMSkgPT09IDB4M0EvKiA6ICovKSB7XHJcbiAgICAgIGFsaWducy5wdXNoKHQuY2hhckNvZGVBdCgwKSA9PT0gMHgzQS8qIDogKi8gPyAnY2VudGVyJyA6ICdyaWdodCcpO1xyXG4gICAgfSBlbHNlIGlmICh0LmNoYXJDb2RlQXQoMCkgPT09IDB4M0EvKiA6ICovKSB7XHJcbiAgICAgIGFsaWducy5wdXNoKCdsZWZ0Jyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhbGlnbnMucHVzaCgnJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBsaW5lVGV4dCA9IGdldExpbmUoc3RhdGUsIHN0YXJ0TGluZSkudHJpbSgpO1xyXG4gIGlmIChsaW5lVGV4dC5pbmRleE9mKCd8JykgPT09IC0xKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gIHJvd3MgPSBlc2NhcGVkU3BsaXQobGluZVRleHQucmVwbGFjZSgvXlxcfHxcXHwkL2csICcnKSk7XHJcbiAgaWYgKGFsaWducy5sZW5ndGggIT09IHJvd3MubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndGFibGVfb3BlbicsICd0YWJsZScsIDEpO1xyXG4gIHRva2VuLm1hcCA9IHRhYmxlTGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdO1xyXG5cclxuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0aGVhZF9vcGVuJywgJ3RoZWFkJywgMSk7XHJcbiAgdG9rZW4ubWFwID0gWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXTtcclxuXHJcbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndHJfb3BlbicsICd0cicsIDEpO1xyXG4gIHRva2VuLm1hcCA9IFsgc3RhcnRMaW5lLCBzdGFydExpbmUgKyAxIF07XHJcblxyXG4gIGZvciAoaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RoX29wZW4nLCAndGgnLCAxKTtcclxuICAgIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXTtcclxuICAgIGlmIChhbGlnbnNbaV0pIHtcclxuICAgICAgdG9rZW4uYXR0cnMgID0gWyBbICdzdHlsZScsICd0ZXh0LWFsaWduOicgKyBhbGlnbnNbaV0gXSBdO1xyXG4gICAgfVxyXG5cclxuICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xyXG4gICAgdG9rZW4uY29udGVudCAgPSByb3dzW2ldLnRyaW0oKTtcclxuICAgIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXTtcclxuICAgIHRva2VuLmNoaWxkcmVuID0gW107XHJcblxyXG4gICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0aF9jbG9zZScsICd0aCcsIC0xKTtcclxuICB9XHJcblxyXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RyX2Nsb3NlJywgJ3RyJywgLTEpO1xyXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RoZWFkX2Nsb3NlJywgJ3RoZWFkJywgLTEpO1xyXG5cclxuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0Ym9keV9vcGVuJywgJ3Rib2R5JywgMSk7XHJcbiAgdG9rZW4ubWFwID0gdGJvZHlMaW5lcyA9IFsgc3RhcnRMaW5lICsgMiwgMCBdO1xyXG5cclxuICBmb3IgKG5leHRMaW5lID0gc3RhcnRMaW5lICsgMjsgbmV4dExpbmUgPCBlbmRMaW5lOyBuZXh0TGluZSsrKSB7XHJcbiAgICBpZiAoc3RhdGUudFNoaWZ0W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxyXG5cclxuICAgIGxpbmVUZXh0ID0gZ2V0TGluZShzdGF0ZSwgbmV4dExpbmUpLnRyaW0oKTtcclxuICAgIGlmIChsaW5lVGV4dC5pbmRleE9mKCd8JykgPT09IC0xKSB7IGJyZWFrOyB9XHJcbiAgICByb3dzID0gZXNjYXBlZFNwbGl0KGxpbmVUZXh0LnJlcGxhY2UoL15cXHx8XFx8JC9nLCAnJykpO1xyXG5cclxuICAgIC8vIHNldCBudW1iZXIgb2YgY29sdW1ucyB0byBudW1iZXIgb2YgY29sdW1ucyBpbiBoZWFkZXIgcm93XHJcbiAgICByb3dzLmxlbmd0aCA9IGFsaWducy5sZW5ndGg7XHJcblxyXG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCd0cl9vcGVuJywgJ3RyJywgMSk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RkX29wZW4nLCAndGQnLCAxKTtcclxuICAgICAgaWYgKGFsaWduc1tpXSkge1xyXG4gICAgICAgIHRva2VuLmF0dHJzICA9IFsgWyAnc3R5bGUnLCAndGV4dC1hbGlnbjonICsgYWxpZ25zW2ldIF0gXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XHJcbiAgICAgIHRva2VuLmNvbnRlbnQgID0gcm93c1tpXSA/IHJvd3NbaV0udHJpbSgpIDogJyc7XHJcbiAgICAgIHRva2VuLmNoaWxkcmVuID0gW107XHJcblxyXG4gICAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RkX2Nsb3NlJywgJ3RkJywgLTEpO1xyXG4gICAgfVxyXG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCd0cl9jbG9zZScsICd0cicsIC0xKTtcclxuICB9XHJcbiAgdG9rZW4gPSBzdGF0ZS5wdXNoKCd0Ym9keV9jbG9zZScsICd0Ym9keScsIC0xKTtcclxuICB0b2tlbiA9IHN0YXRlLnB1c2goJ3RhYmxlX2Nsb3NlJywgJ3RhYmxlJywgLTEpO1xyXG5cclxuICB0YWJsZUxpbmVzWzFdID0gdGJvZHlMaW5lc1sxXSA9IG5leHRMaW5lO1xyXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbn0se31dLDMxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmxvY2soc3RhdGUpIHtcclxuICB2YXIgdG9rZW47XHJcblxyXG4gIGlmIChzdGF0ZS5pbmxpbmVNb2RlKSB7XHJcbiAgICB0b2tlbiAgICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbignaW5saW5lJywgJycsIDApO1xyXG4gICAgdG9rZW4uY29udGVudCAgPSBzdGF0ZS5zcmM7XHJcbiAgICB0b2tlbi5tYXAgICAgICA9IFsgMCwgMSBdO1xyXG4gICAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcclxuICAgIHN0YXRlLnRva2Vucy5wdXNoKHRva2VuKTtcclxuICB9IGVsc2Uge1xyXG4gICAgc3RhdGUubWQuYmxvY2sucGFyc2Uoc3RhdGUuc3JjLCBzdGF0ZS5tZCwgc3RhdGUuZW52LCBzdGF0ZS50b2tlbnMpO1xyXG4gIH1cclxufTtcclxuXHJcbn0se31dLDMyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmxpbmUoc3RhdGUpIHtcclxuICB2YXIgdG9rZW5zID0gc3RhdGUudG9rZW5zLCB0b2ssIGksIGw7XHJcblxyXG4gIC8vIFBhcnNlIGlubGluZXNcclxuICBmb3IgKGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgdG9rID0gdG9rZW5zW2ldO1xyXG4gICAgaWYgKHRvay50eXBlID09PSAnaW5saW5lJykge1xyXG4gICAgICBzdGF0ZS5tZC5pbmxpbmUucGFyc2UodG9rLmNvbnRlbnQsIHN0YXRlLm1kLCBzdGF0ZS5lbnYsIHRvay5jaGlsZHJlbik7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxufSx7fV0sMzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4vLyBSZXBsYWNlIGxpbmstbGlrZSB0ZXh0cyB3aXRoIGxpbmsgbm9kZXMuXHJcbi8vXHJcbi8vIEN1cnJlbnRseSByZXN0cmljdGVkIGJ5IGBtZC52YWxpZGF0ZUxpbmsoKWAgdG8gaHR0cC9odHRwcy9mdHBcclxuLy9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBhcnJheVJlcGxhY2VBdCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmFycmF5UmVwbGFjZUF0O1xyXG5cclxuXHJcbmZ1bmN0aW9uIGlzTGlua09wZW4oc3RyKSB7XHJcbiAgcmV0dXJuIC9ePGFbPlxcc10vaS50ZXN0KHN0cik7XHJcbn1cclxuZnVuY3Rpb24gaXNMaW5rQ2xvc2Uoc3RyKSB7XHJcbiAgcmV0dXJuIC9ePFxcL2FcXHMqPi9pLnRlc3Qoc3RyKTtcclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlua2lmeShzdGF0ZSkge1xyXG4gIHZhciBpLCBqLCBsLCB0b2tlbnMsIHRva2VuLCBjdXJyZW50VG9rZW4sIG5vZGVzLCBsbiwgdGV4dCwgcG9zLCBsYXN0UG9zLFxyXG4gICAgICBsZXZlbCwgaHRtbExpbmtMZXZlbCwgdXJsLCBmdWxsVXJsLCB1cmxUZXh0LFxyXG4gICAgICBibG9ja1Rva2VucyA9IHN0YXRlLnRva2VucyxcclxuICAgICAgbGlua3M7XHJcblxyXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy5saW5raWZ5KSB7IHJldHVybjsgfVxyXG5cclxuICBmb3IgKGogPSAwLCBsID0gYmxvY2tUb2tlbnMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XHJcbiAgICBpZiAoYmxvY2tUb2tlbnNbal0udHlwZSAhPT0gJ2lubGluZScgfHxcclxuICAgICAgICAhc3RhdGUubWQubGlua2lmeS5wcmV0ZXN0KGJsb2NrVG9rZW5zW2pdLmNvbnRlbnQpKSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHRva2VucyA9IGJsb2NrVG9rZW5zW2pdLmNoaWxkcmVuO1xyXG5cclxuICAgIGh0bWxMaW5rTGV2ZWwgPSAwO1xyXG5cclxuICAgIC8vIFdlIHNjYW4gZnJvbSB0aGUgZW5kLCB0byBrZWVwIHBvc2l0aW9uIHdoZW4gbmV3IHRhZ3MgYWRkZWQuXHJcbiAgICAvLyBVc2UgcmV2ZXJzZWQgbG9naWMgaW4gbGlua3Mgc3RhcnQvZW5kIG1hdGNoXHJcbiAgICBmb3IgKGkgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgY3VycmVudFRva2VuID0gdG9rZW5zW2ldO1xyXG5cclxuICAgICAgLy8gU2tpcCBjb250ZW50IG9mIG1hcmtkb3duIGxpbmtzXHJcbiAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gJ2xpbmtfY2xvc2UnKSB7XHJcbiAgICAgICAgaS0tO1xyXG4gICAgICAgIHdoaWxlICh0b2tlbnNbaV0ubGV2ZWwgIT09IGN1cnJlbnRUb2tlbi5sZXZlbCAmJiB0b2tlbnNbaV0udHlwZSAhPT0gJ2xpbmtfb3BlbicpIHtcclxuICAgICAgICAgIGktLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNraXAgY29udGVudCBvZiBodG1sIHRhZyBsaW5rc1xyXG4gICAgICBpZiAoY3VycmVudFRva2VuLnR5cGUgPT09ICdodG1sX2lubGluZScpIHtcclxuICAgICAgICBpZiAoaXNMaW5rT3BlbihjdXJyZW50VG9rZW4uY29udGVudCkgJiYgaHRtbExpbmtMZXZlbCA+IDApIHtcclxuICAgICAgICAgIGh0bWxMaW5rTGV2ZWwtLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzTGlua0Nsb3NlKGN1cnJlbnRUb2tlbi5jb250ZW50KSkge1xyXG4gICAgICAgICAgaHRtbExpbmtMZXZlbCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoaHRtbExpbmtMZXZlbCA+IDApIHsgY29udGludWU7IH1cclxuXHJcbiAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gJ3RleHQnICYmIHN0YXRlLm1kLmxpbmtpZnkudGVzdChjdXJyZW50VG9rZW4uY29udGVudCkpIHtcclxuXHJcbiAgICAgICAgdGV4dCA9IGN1cnJlbnRUb2tlbi5jb250ZW50O1xyXG4gICAgICAgIGxpbmtzID0gc3RhdGUubWQubGlua2lmeS5tYXRjaCh0ZXh0KTtcclxuXHJcbiAgICAgICAgLy8gTm93IHNwbGl0IHN0cmluZyB0byBub2Rlc1xyXG4gICAgICAgIG5vZGVzID0gW107XHJcbiAgICAgICAgbGV2ZWwgPSBjdXJyZW50VG9rZW4ubGV2ZWw7XHJcbiAgICAgICAgbGFzdFBvcyA9IDA7XHJcblxyXG4gICAgICAgIGZvciAobG4gPSAwOyBsbiA8IGxpbmtzLmxlbmd0aDsgbG4rKykge1xyXG5cclxuICAgICAgICAgIHVybCA9IGxpbmtzW2xuXS51cmw7XHJcbiAgICAgICAgICBmdWxsVXJsID0gc3RhdGUubWQubm9ybWFsaXplTGluayh1cmwpO1xyXG4gICAgICAgICAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoZnVsbFVybCkpIHsgY29udGludWU7IH1cclxuXHJcbiAgICAgICAgICB1cmxUZXh0ID0gbGlua3NbbG5dLnRleHQ7XHJcblxyXG4gICAgICAgICAgLy8gTGlua2lmaWVyIG1pZ2h0IHNlbmQgcmF3IGhvc3RuYW1lcyBsaWtlIFwiZXhhbXBsZS5jb21cIiwgd2hlcmUgdXJsXHJcbiAgICAgICAgICAvLyBzdGFydHMgd2l0aCBkb21haW4gbmFtZS4gU28gd2UgcHJlcGVuZCBodHRwOi8vIGluIHRob3NlIGNhc2VzLFxyXG4gICAgICAgICAgLy8gYW5kIHJlbW92ZSBpdCBhZnRlcndhcmRzLlxyXG4gICAgICAgICAgLy9cclxuICAgICAgICAgIGlmICghbGlua3NbbG5dLnNjaGVtYSkge1xyXG4gICAgICAgICAgICB1cmxUZXh0ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQoJ2h0dHA6Ly8nICsgdXJsVGV4dCkucmVwbGFjZSgvXmh0dHA6XFwvXFwvLywgJycpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChsaW5rc1tsbl0uc2NoZW1hID09PSAnbWFpbHRvOicgJiYgIS9ebWFpbHRvOi9pLnRlc3QodXJsVGV4dCkpIHtcclxuICAgICAgICAgICAgdXJsVGV4dCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KCdtYWlsdG86JyArIHVybFRleHQpLnJlcGxhY2UoL15tYWlsdG86LywgJycpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdXJsVGV4dCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHVybFRleHQpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHBvcyA9IGxpbmtzW2xuXS5pbmRleDtcclxuXHJcbiAgICAgICAgICBpZiAocG9zID4gbGFzdFBvcykge1xyXG4gICAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCd0ZXh0JywgJycsIDApO1xyXG4gICAgICAgICAgICB0b2tlbi5jb250ZW50ID0gdGV4dC5zbGljZShsYXN0UG9zLCBwb3MpO1xyXG4gICAgICAgICAgICB0b2tlbi5sZXZlbCAgID0gbGV2ZWw7XHJcbiAgICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2xpbmtfb3BlbicsICdhJywgMSk7XHJcbiAgICAgICAgICB0b2tlbi5hdHRycyAgID0gWyBbICdocmVmJywgZnVsbFVybCBdIF07XHJcbiAgICAgICAgICB0b2tlbi5sZXZlbCAgID0gbGV2ZWwrKztcclxuICAgICAgICAgIHRva2VuLm1hcmt1cCAgPSAnbGlua2lmeSc7XHJcbiAgICAgICAgICB0b2tlbi5pbmZvICAgID0gJ2F1dG8nO1xyXG4gICAgICAgICAgbm9kZXMucHVzaCh0b2tlbik7XHJcblxyXG4gICAgICAgICAgdG9rZW4gICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbigndGV4dCcsICcnLCAwKTtcclxuICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSB1cmxUZXh0O1xyXG4gICAgICAgICAgdG9rZW4ubGV2ZWwgICA9IGxldmVsO1xyXG4gICAgICAgICAgbm9kZXMucHVzaCh0b2tlbik7XHJcblxyXG4gICAgICAgICAgdG9rZW4gICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbignbGlua19jbG9zZScsICdhJywgLTEpO1xyXG4gICAgICAgICAgdG9rZW4ubGV2ZWwgICA9IC0tbGV2ZWw7XHJcbiAgICAgICAgICB0b2tlbi5tYXJrdXAgID0gJ2xpbmtpZnknO1xyXG4gICAgICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcclxuICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xyXG5cclxuICAgICAgICAgIGxhc3RQb3MgPSBsaW5rc1tsbl0ubGFzdEluZGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFzdFBvcyA8IHRleHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCd0ZXh0JywgJycsIDApO1xyXG4gICAgICAgICAgdG9rZW4uY29udGVudCA9IHRleHQuc2xpY2UobGFzdFBvcyk7XHJcbiAgICAgICAgICB0b2tlbi5sZXZlbCAgID0gbGV2ZWw7XHJcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlcGxhY2UgY3VycmVudCBub2RlXHJcbiAgICAgICAgYmxvY2tUb2tlbnNbal0uY2hpbGRyZW4gPSB0b2tlbnMgPSBhcnJheVJlcGxhY2VBdCh0b2tlbnMsIGksIG5vZGVzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbn0se1wiLi4vY29tbW9uL3V0aWxzXCI6NX1dLDM0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLy8gTm9ybWFsaXplIGlucHV0IHN0cmluZ1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBUQUJTX1NDQU5fUkUgPSAvW1xcblxcdF0vZztcclxudmFyIE5FV0xJTkVTX1JFICA9IC9cXHJbXFxuXFx1MDA4NV18W1xcdTI0MjRcXHUyMDI4XFx1MDA4NV0vZztcclxudmFyIE5VTExfUkUgICAgICA9IC9cXHUwMDAwL2c7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmxpbmUoc3RhdGUpIHtcclxuICB2YXIgc3RyLCBsaW5lU3RhcnQsIGxhc3RUYWJQb3M7XHJcblxyXG4gIC8vIE5vcm1hbGl6ZSBuZXdsaW5lc1xyXG4gIHN0ciA9IHN0YXRlLnNyYy5yZXBsYWNlKE5FV0xJTkVTX1JFLCAnXFxuJyk7XHJcblxyXG4gIC8vIFJlcGxhY2UgTlVMTCBjaGFyYWN0ZXJzXHJcbiAgc3RyID0gc3RyLnJlcGxhY2UoTlVMTF9SRSwgJ1xcdUZGRkQnKTtcclxuXHJcbiAgLy8gUmVwbGFjZSB0YWJzIHdpdGggcHJvcGVyIG51bWJlciBvZiBzcGFjZXMgKDEuLjQpXHJcbiAgaWYgKHN0ci5pbmRleE9mKCdcXHQnKSA+PSAwKSB7XHJcbiAgICBsaW5lU3RhcnQgPSAwO1xyXG4gICAgbGFzdFRhYlBvcyA9IDA7XHJcblxyXG4gICAgc3RyID0gc3RyLnJlcGxhY2UoVEFCU19TQ0FOX1JFLCBmdW5jdGlvbiAobWF0Y2gsIG9mZnNldCkge1xyXG4gICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICBpZiAoc3RyLmNoYXJDb2RlQXQob2Zmc2V0KSA9PT0gMHgwQSkge1xyXG4gICAgICAgIGxpbmVTdGFydCA9IG9mZnNldCArIDE7XHJcbiAgICAgICAgbGFzdFRhYlBvcyA9IDA7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgICB9XHJcbiAgICAgIHJlc3VsdCA9ICcgICAgJy5zbGljZSgob2Zmc2V0IC0gbGluZVN0YXJ0IC0gbGFzdFRhYlBvcykgJSA0KTtcclxuICAgICAgbGFzdFRhYlBvcyA9IG9mZnNldCAtIGxpbmVTdGFydCArIDE7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHN0YXRlLnNyYyA9IHN0cjtcclxufTtcclxuXHJcbn0se31dLDM1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLy8gU2ltcGxlIHR5cG9ncmFwaHljIHJlcGxhY2VtZW50c1xyXG4vL1xyXG4vLyAnJyDihpIg4oCY4oCZXHJcbi8vIFwiXCIg4oaSIOKAnOKAnS4gU2V0ICfCq8K7JyBmb3IgUnVzc2lhbiwgJ+KAnuKAnCcgZm9yIEdlcm1hbiwgZW1wdHkgdG8gZGlzYWJsZVxyXG4vLyAoYykgKEMpIOKGkiDCqVxyXG4vLyAodG0pIChUTSkg4oaSIOKEolxyXG4vLyAocikgKFIpIOKGkiDCrlxyXG4vLyArLSDihpIgwrFcclxuLy8gKHApIChQKSAtPiDCp1xyXG4vLyAuLi4g4oaSIOKApiAoYWxzbyA/Li4uLiDihpIgPy4uLCAhLi4uLiDihpIgIS4uKVxyXG4vLyA/Pz8/Pz8/PyDihpIgPz8/LCAhISEhISDihpIgISEhLCBgLCxgIOKGkiBgLGBcclxuLy8gLS0g4oaSICZuZGFzaDssIC0tLSDihpIgJm1kYXNoO1xyXG4vL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vLyBUT0RPOlxyXG4vLyAtIGZyYWN0aW9uYWxzIDEvMiwgMS80LCAzLzQgLT4gwr0sIMK8LCDCvlxyXG4vLyAtIG1pbHRpcGxpY2F0aW9uIDIgeCA0IC0+IDIgw5cgNFxyXG5cclxudmFyIFJBUkVfUkUgPSAvXFwrLXxcXC5cXC58XFw/XFw/XFw/XFw/fCEhISF8LCx8LS0vO1xyXG5cclxuLy8gV29ya2Fyb3VuZCBmb3IgcGhhbnRvbWpzIC0gbmVlZCByZWdleCB3aXRob3V0IC9nIGZsYWcsXHJcbi8vIG9yIHJvb3QgY2hlY2sgd2lsbCBmYWlsIGV2ZXJ5IHNlY29uZCB0aW1lXHJcbnZhciBTQ09QRURfQUJCUl9URVNUX1JFID0gL1xcKChjfHRtfHJ8cClcXCkvaTtcclxuXHJcbnZhciBTQ09QRURfQUJCUl9SRSA9IC9cXCgoY3x0bXxyfHApXFwpL2lnO1xyXG52YXIgU0NPUEVEX0FCQlIgPSB7XHJcbiAgJ2MnOiAnwqknLFxyXG4gICdyJzogJ8KuJyxcclxuICAncCc6ICfCpycsXHJcbiAgJ3RtJzogJ+KEoidcclxufTtcclxuXHJcbmZ1bmN0aW9uIHJlcGxhY2VGbihtYXRjaCwgbmFtZSkge1xyXG4gIHJldHVybiBTQ09QRURfQUJCUltuYW1lLnRvTG93ZXJDYXNlKCldO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXBsYWNlX3Njb3BlZChpbmxpbmVUb2tlbnMpIHtcclxuICB2YXIgaSwgdG9rZW47XHJcblxyXG4gIGZvciAoaSA9IGlubGluZVRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgdG9rZW4gPSBpbmxpbmVUb2tlbnNbaV07XHJcbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XHJcbiAgICAgIHRva2VuLmNvbnRlbnQgPSB0b2tlbi5jb250ZW50LnJlcGxhY2UoU0NPUEVEX0FCQlJfUkUsIHJlcGxhY2VGbik7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZXBsYWNlX3JhcmUoaW5saW5lVG9rZW5zKSB7XHJcbiAgdmFyIGksIHRva2VuO1xyXG5cclxuICBmb3IgKGkgPSBpbmxpbmVUb2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgIHRva2VuID0gaW5saW5lVG9rZW5zW2ldO1xyXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xyXG4gICAgICBpZiAoUkFSRV9SRS50ZXN0KHRva2VuLmNvbnRlbnQpKSB7XHJcbiAgICAgICAgdG9rZW4uY29udGVudCA9IHRva2VuLmNvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwrLS9nLCAnwrEnKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLCAuLi4sIC4uLi4uLi4gLT4g4oCmXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0ID8uLi4uLiAmICEuLi4uLiAtPiA/Li4gJiAhLi5cclxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwuezIsfS9nLCAn4oCmJykucmVwbGFjZSgvKFs/IV0p4oCmL2csICckMS4uJylcclxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKFs/IV0pezQsfS9nLCAnJDEkMSQxJykucmVwbGFjZSgvLHsyLH0vZywgJywnKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVtLWRhc2hcclxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF58W14tXSktLS0oW14tXXwkKS9tZywgJyQxXFx1MjAxNCQyJylcclxuICAgICAgICAgICAgICAgICAgICAvLyBlbi1kYXNoXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhefFxccyktLShcXHN8JCkvbWcsICckMVxcdTIwMTMkMicpXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhefFteLVxcc10pLS0oW14tXFxzXXwkKS9tZywgJyQxXFx1MjAxMyQyJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcclxuICB2YXIgYmxrSWR4O1xyXG5cclxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMudHlwb2dyYXBoZXIpIHsgcmV0dXJuOyB9XHJcblxyXG4gIGZvciAoYmxrSWR4ID0gc3RhdGUudG9rZW5zLmxlbmd0aCAtIDE7IGJsa0lkeCA+PSAwOyBibGtJZHgtLSkge1xyXG5cclxuICAgIGlmIChzdGF0ZS50b2tlbnNbYmxrSWR4XS50eXBlICE9PSAnaW5saW5lJykgeyBjb250aW51ZTsgfVxyXG5cclxuICAgIGlmIChTQ09QRURfQUJCUl9URVNUX1JFLnRlc3Qoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY29udGVudCkpIHtcclxuICAgICAgcmVwbGFjZV9zY29wZWQoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY2hpbGRyZW4pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChSQVJFX1JFLnRlc3Qoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY29udGVudCkpIHtcclxuICAgICAgcmVwbGFjZV9yYXJlKHN0YXRlLnRva2Vuc1tibGtJZHhdLmNoaWxkcmVuKTtcclxuICAgIH1cclxuXHJcbiAgfVxyXG59O1xyXG5cclxufSx7fV0sMzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4vLyBDb252ZXJ0IHN0cmFpZ2h0IHF1b3RhdGlvbiBtYXJrcyB0byB0eXBvZ3JhcGhpYyBvbmVzXHJcbi8vXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgaXNXaGl0ZVNwYWNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1doaXRlU3BhY2U7XHJcbnZhciBpc1B1bmN0Q2hhciAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzUHVuY3RDaGFyO1xyXG52YXIgaXNNZEFzY2lpUHVuY3QgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc01kQXNjaWlQdW5jdDtcclxuXHJcbnZhciBRVU9URV9URVNUX1JFID0gL1snXCJdLztcclxudmFyIFFVT1RFX1JFID0gL1snXCJdL2c7XHJcbnZhciBBUE9TVFJPUEhFID0gJ1xcdTIwMTknOyAvKiDigJkgKi9cclxuXHJcblxyXG5mdW5jdGlvbiByZXBsYWNlQXQoc3RyLCBpbmRleCwgY2gpIHtcclxuICByZXR1cm4gc3RyLnN1YnN0cigwLCBpbmRleCkgKyBjaCArIHN0ci5zdWJzdHIoaW5kZXggKyAxKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc19pbmxpbmVzKHRva2Vucywgc3RhdGUpIHtcclxuICB2YXIgaSwgdG9rZW4sIHRleHQsIHQsIHBvcywgbWF4LCB0aGlzTGV2ZWwsIGl0ZW0sIGxhc3RDaGFyLCBuZXh0Q2hhcixcclxuICAgICAgaXNMYXN0UHVuY3RDaGFyLCBpc05leHRQdW5jdENoYXIsIGlzTGFzdFdoaXRlU3BhY2UsIGlzTmV4dFdoaXRlU3BhY2UsXHJcbiAgICAgIGNhbk9wZW4sIGNhbkNsb3NlLCBqLCBpc1NpbmdsZSwgc3RhY2s7XHJcblxyXG4gIHN0YWNrID0gW107XHJcblxyXG4gIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuICAgIHRva2VuID0gdG9rZW5zW2ldO1xyXG5cclxuICAgIHRoaXNMZXZlbCA9IHRva2Vuc1tpXS5sZXZlbDtcclxuXHJcbiAgICBmb3IgKGogPSBzdGFjay5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xyXG4gICAgICBpZiAoc3RhY2tbal0ubGV2ZWwgPD0gdGhpc0xldmVsKSB7IGJyZWFrOyB9XHJcbiAgICB9XHJcbiAgICBzdGFjay5sZW5ndGggPSBqICsgMTtcclxuXHJcbiAgICBpZiAodG9rZW4udHlwZSAhPT0gJ3RleHQnKSB7IGNvbnRpbnVlOyB9XHJcblxyXG4gICAgdGV4dCA9IHRva2VuLmNvbnRlbnQ7XHJcbiAgICBwb3MgPSAwO1xyXG4gICAgbWF4ID0gdGV4dC5sZW5ndGg7XHJcblxyXG4gICAgLyplc2xpbnQgbm8tbGFiZWxzOjAsYmxvY2stc2NvcGVkLXZhcjowKi9cclxuICAgIE9VVEVSOlxyXG4gICAgd2hpbGUgKHBvcyA8IG1heCkge1xyXG4gICAgICBRVU9URV9SRS5sYXN0SW5kZXggPSBwb3M7XHJcbiAgICAgIHQgPSBRVU9URV9SRS5leGVjKHRleHQpO1xyXG4gICAgICBpZiAoIXQpIHsgYnJlYWs7IH1cclxuXHJcbiAgICAgIGNhbk9wZW4gPSBjYW5DbG9zZSA9IHRydWU7XHJcbiAgICAgIHBvcyA9IHQuaW5kZXggKyAxO1xyXG4gICAgICBpc1NpbmdsZSA9ICh0WzBdID09PSBcIidcIik7XHJcblxyXG4gICAgICAvLyB0cmVhdCBiZWdpbi9lbmQgb2YgdGhlIGxpbmUgYXMgYSB3aGl0ZXNwYWNlXHJcbiAgICAgIGxhc3RDaGFyID0gdC5pbmRleCAtIDEgPj0gMCA/IHRleHQuY2hhckNvZGVBdCh0LmluZGV4IC0gMSkgOiAweDIwO1xyXG4gICAgICBuZXh0Q2hhciA9IHBvcyA8IG1heCA/IHRleHQuY2hhckNvZGVBdChwb3MpIDogMHgyMDtcclxuXHJcbiAgICAgIGlzTGFzdFB1bmN0Q2hhciA9IGlzTWRBc2NpaVB1bmN0KGxhc3RDaGFyKSB8fCBpc1B1bmN0Q2hhcihTdHJpbmcuZnJvbUNoYXJDb2RlKGxhc3RDaGFyKSk7XHJcbiAgICAgIGlzTmV4dFB1bmN0Q2hhciA9IGlzTWRBc2NpaVB1bmN0KG5leHRDaGFyKSB8fCBpc1B1bmN0Q2hhcihTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyKSk7XHJcblxyXG4gICAgICBpc0xhc3RXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKGxhc3RDaGFyKTtcclxuICAgICAgaXNOZXh0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShuZXh0Q2hhcik7XHJcblxyXG4gICAgICBpZiAoaXNOZXh0V2hpdGVTcGFjZSkge1xyXG4gICAgICAgIGNhbk9wZW4gPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIGlmIChpc05leHRQdW5jdENoYXIpIHtcclxuICAgICAgICBpZiAoIShpc0xhc3RXaGl0ZVNwYWNlIHx8IGlzTGFzdFB1bmN0Q2hhcikpIHtcclxuICAgICAgICAgIGNhbk9wZW4gPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc0xhc3RXaGl0ZVNwYWNlKSB7XHJcbiAgICAgICAgY2FuQ2xvc2UgPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIGlmIChpc0xhc3RQdW5jdENoYXIpIHtcclxuICAgICAgICBpZiAoIShpc05leHRXaGl0ZVNwYWNlIHx8IGlzTmV4dFB1bmN0Q2hhcikpIHtcclxuICAgICAgICAgIGNhbkNsb3NlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobmV4dENoYXIgPT09IDB4MjIgLyogXCIgKi8gJiYgdFswXSA9PT0gJ1wiJykge1xyXG4gICAgICAgIGlmIChsYXN0Q2hhciA+PSAweDMwIC8qIDAgKi8gJiYgbGFzdENoYXIgPD0gMHgzOSAvKiA5ICovKSB7XHJcbiAgICAgICAgICAvLyBzcGVjaWFsIGNhc2U6IDFcIlwiIC0gY291bnQgZmlyc3QgcXVvdGUgYXMgYW4gaW5jaFxyXG4gICAgICAgICAgY2FuQ2xvc2UgPSBjYW5PcGVuID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY2FuT3BlbiAmJiBjYW5DbG9zZSkge1xyXG4gICAgICAgIC8vIHRyZWF0IHRoaXMgYXMgdGhlIG1pZGRsZSBvZiB0aGUgd29yZFxyXG4gICAgICAgIGNhbk9wZW4gPSBmYWxzZTtcclxuICAgICAgICBjYW5DbG9zZSA9IGlzTmV4dFB1bmN0Q2hhcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFjYW5PcGVuICYmICFjYW5DbG9zZSkge1xyXG4gICAgICAgIC8vIG1pZGRsZSBvZiB3b3JkXHJcbiAgICAgICAgaWYgKGlzU2luZ2xlKSB7XHJcbiAgICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIEFQT1NUUk9QSEUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNhbkNsb3NlKSB7XHJcbiAgICAgICAgLy8gdGhpcyBjb3VsZCBiZSBhIGNsb3NpbmcgcXVvdGUsIHJld2luZCB0aGUgc3RhY2sgdG8gZ2V0IGEgbWF0Y2hcclxuICAgICAgICBmb3IgKGogPSBzdGFjay5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xyXG4gICAgICAgICAgaXRlbSA9IHN0YWNrW2pdO1xyXG4gICAgICAgICAgaWYgKHN0YWNrW2pdLmxldmVsIDwgdGhpc0xldmVsKSB7IGJyZWFrOyB9XHJcbiAgICAgICAgICBpZiAoaXRlbS5zaW5nbGUgPT09IGlzU2luZ2xlICYmIHN0YWNrW2pdLmxldmVsID09PSB0aGlzTGV2ZWwpIHtcclxuICAgICAgICAgICAgaXRlbSA9IHN0YWNrW2pdO1xyXG4gICAgICAgICAgICBpZiAoaXNTaW5nbGUpIHtcclxuICAgICAgICAgICAgICB0b2tlbnNbaXRlbS50b2tlbl0uY29udGVudCA9IHJlcGxhY2VBdChcclxuICAgICAgICAgICAgICAgIHRva2Vuc1tpdGVtLnRva2VuXS5jb250ZW50LCBpdGVtLnBvcywgc3RhdGUubWQub3B0aW9ucy5xdW90ZXNbMl0pO1xyXG4gICAgICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSByZXBsYWNlQXQoXHJcbiAgICAgICAgICAgICAgICB0b2tlbi5jb250ZW50LCB0LmluZGV4LCBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1szXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdG9rZW5zW2l0ZW0udG9rZW5dLmNvbnRlbnQgPSByZXBsYWNlQXQoXHJcbiAgICAgICAgICAgICAgICB0b2tlbnNbaXRlbS50b2tlbl0uY29udGVudCwgaXRlbS5wb3MsIHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzBdKTtcclxuICAgICAgICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdGFjay5sZW5ndGggPSBqO1xyXG4gICAgICAgICAgICBjb250aW51ZSBPVVRFUjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjYW5PcGVuKSB7XHJcbiAgICAgICAgc3RhY2sucHVzaCh7XHJcbiAgICAgICAgICB0b2tlbjogaSxcclxuICAgICAgICAgIHBvczogdC5pbmRleCxcclxuICAgICAgICAgIHNpbmdsZTogaXNTaW5nbGUsXHJcbiAgICAgICAgICBsZXZlbDogdGhpc0xldmVsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoY2FuQ2xvc2UgJiYgaXNTaW5nbGUpIHtcclxuICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIEFQT1NUUk9QSEUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzbWFydHF1b3RlcyhzdGF0ZSkge1xyXG4gIC8qZXNsaW50IG1heC1kZXB0aDowKi9cclxuICB2YXIgYmxrSWR4O1xyXG5cclxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMudHlwb2dyYXBoZXIpIHsgcmV0dXJuOyB9XHJcblxyXG4gIGZvciAoYmxrSWR4ID0gc3RhdGUudG9rZW5zLmxlbmd0aCAtIDE7IGJsa0lkeCA+PSAwOyBibGtJZHgtLSkge1xyXG5cclxuICAgIGlmIChzdGF0ZS50b2tlbnNbYmxrSWR4XS50eXBlICE9PSAnaW5saW5lJyB8fFxyXG4gICAgICAgICFRVU9URV9URVNUX1JFLnRlc3Qoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY29udGVudCkpIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvY2Vzc19pbmxpbmVzKHN0YXRlLnRva2Vuc1tibGtJZHhdLmNoaWxkcmVuLCBzdGF0ZSk7XHJcbiAgfVxyXG59O1xyXG5cclxufSx7XCIuLi9jb21tb24vdXRpbHNcIjo1fV0sMzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4vLyBDb3JlIHN0YXRlIG9iamVjdFxyXG4vL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgVG9rZW4gPSByZXF1aXJlKCcuLi90b2tlbicpO1xyXG5cclxuXHJcbmZ1bmN0aW9uIFN0YXRlQ29yZShzcmMsIG1kLCBlbnYpIHtcclxuICB0aGlzLnNyYyA9IHNyYztcclxuICB0aGlzLmVudiA9IGVudjtcclxuICB0aGlzLnRva2VucyA9IFtdO1xyXG4gIHRoaXMuaW5saW5lTW9kZSA9IGZhbHNlO1xyXG4gIHRoaXMubWQgPSBtZDsgLy8gbGluayB0byBwYXJzZXIgaW5zdGFuY2VcclxufVxyXG5cclxuLy8gcmUtZXhwb3J0IFRva2VuIGNsYXNzIHRvIHVzZSBpbiBjb3JlIHJ1bGVzXHJcblN0YXRlQ29yZS5wcm90b3R5cGUuVG9rZW4gPSBUb2tlbjtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlQ29yZTtcclxuXHJcbn0se1wiLi4vdG9rZW5cIjo1MH1dLDM4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLy8gUHJvY2VzcyBhdXRvbGlua3MgJzxwcm90b2NvbDouLi4+J1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHVybF9zY2hlbWFzID0gcmVxdWlyZSgnLi4vY29tbW9uL3VybF9zY2hlbWFzJyk7XHJcblxyXG5cclxuLyplc2xpbnQgbWF4LWxlbjowKi9cclxudmFyIEVNQUlMX1JFICAgID0gL148KFthLXpBLVowLTkuISMkJSYnKitcXC89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSopPi87XHJcbnZhciBBVVRPTElOS19SRSA9IC9ePChbYS16QS1aLlxcLV17MSwyNX0pOihbXjw+XFx4MDAtXFx4MjBdKik+LztcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF1dG9saW5rKHN0YXRlLCBzaWxlbnQpIHtcclxuICB2YXIgdGFpbCwgbGlua01hdGNoLCBlbWFpbE1hdGNoLCB1cmwsIGZ1bGxVcmwsIHRva2VuLFxyXG4gICAgICBwb3MgPSBzdGF0ZS5wb3M7XHJcblxyXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDNDLyogPCAqLykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgdGFpbCA9IHN0YXRlLnNyYy5zbGljZShwb3MpO1xyXG5cclxuICBpZiAodGFpbC5pbmRleE9mKCc+JykgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICBpZiAoQVVUT0xJTktfUkUudGVzdCh0YWlsKSkge1xyXG4gICAgbGlua01hdGNoID0gdGFpbC5tYXRjaChBVVRPTElOS19SRSk7XHJcblxyXG4gICAgaWYgKHVybF9zY2hlbWFzLmluZGV4T2YobGlua01hdGNoWzFdLnRvTG93ZXJDYXNlKCkpIDwgMCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgICB1cmwgPSBsaW5rTWF0Y2hbMF0uc2xpY2UoMSwgLTEpO1xyXG4gICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsodXJsKTtcclxuICAgIGlmICghc3RhdGUubWQudmFsaWRhdGVMaW5rKGZ1bGxVcmwpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICAgIGlmICghc2lsZW50KSB7XHJcbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaW5rX29wZW4nLCAnYScsIDEpO1xyXG4gICAgICB0b2tlbi5hdHRycyAgID0gWyBbICdocmVmJywgZnVsbFVybCBdIF07XHJcblxyXG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgndGV4dCcsICcnLCAwKTtcclxuICAgICAgdG9rZW4uY29udGVudCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHVybCk7XHJcblxyXG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnbGlua19jbG9zZScsICdhJywgLTEpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlLnBvcyArPSBsaW5rTWF0Y2hbMF0ubGVuZ3RoO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBpZiAoRU1BSUxfUkUudGVzdCh0YWlsKSkge1xyXG4gICAgZW1haWxNYXRjaCA9IHRhaWwubWF0Y2goRU1BSUxfUkUpO1xyXG5cclxuICAgIHVybCA9IGVtYWlsTWF0Y2hbMF0uc2xpY2UoMSwgLTEpO1xyXG4gICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsoJ21haWx0bzonICsgdXJsKTtcclxuICAgIGlmICghc3RhdGUubWQudmFsaWRhdGVMaW5rKGZ1bGxVcmwpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICAgIGlmICghc2lsZW50KSB7XHJcbiAgICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaW5rX29wZW4nLCAnYScsIDEpO1xyXG4gICAgICB0b2tlbi5hdHRycyAgID0gWyBbICdocmVmJywgZnVsbFVybCBdIF07XHJcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xyXG4gICAgICB0b2tlbi5pbmZvICAgID0gJ2F1dG8nO1xyXG5cclxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XHJcbiAgICAgIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCh1cmwpO1xyXG5cclxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcclxuICAgICAgdG9rZW4ubWFya3VwICA9ICdhdXRvbGluayc7XHJcbiAgICAgIHRva2VuLmluZm8gICAgPSAnYXV0byc7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGUucG9zICs9IGVtYWlsTWF0Y2hbMF0ubGVuZ3RoO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG59LHtcIi4uL2NvbW1vbi91cmxfc2NoZW1hc1wiOjR9XSwzOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8vIFBhcnNlIGJhY2t0aWNrc1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiYWNrdGljayhzdGF0ZSwgc2lsZW50KSB7XHJcbiAgdmFyIHN0YXJ0LCBtYXgsIG1hcmtlciwgbWF0Y2hTdGFydCwgbWF0Y2hFbmQsIHRva2VuLFxyXG4gICAgICBwb3MgPSBzdGF0ZS5wb3MsXHJcbiAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcclxuXHJcbiAgaWYgKGNoICE9PSAweDYwLyogYCAqLykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgc3RhcnQgPSBwb3M7XHJcbiAgcG9zKys7XHJcbiAgbWF4ID0gc3RhdGUucG9zTWF4O1xyXG5cclxuICB3aGlsZSAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NjAvKiBgICovKSB7IHBvcysrOyB9XHJcblxyXG4gIG1hcmtlciA9IHN0YXRlLnNyYy5zbGljZShzdGFydCwgcG9zKTtcclxuXHJcbiAgbWF0Y2hTdGFydCA9IG1hdGNoRW5kID0gcG9zO1xyXG5cclxuICB3aGlsZSAoKG1hdGNoU3RhcnQgPSBzdGF0ZS5zcmMuaW5kZXhPZignYCcsIG1hdGNoRW5kKSkgIT09IC0xKSB7XHJcbiAgICBtYXRjaEVuZCA9IG1hdGNoU3RhcnQgKyAxO1xyXG5cclxuICAgIHdoaWxlIChtYXRjaEVuZCA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChtYXRjaEVuZCkgPT09IDB4NjAvKiBgICovKSB7IG1hdGNoRW5kKys7IH1cclxuXHJcbiAgICBpZiAobWF0Y2hFbmQgLSBtYXRjaFN0YXJ0ID09PSBtYXJrZXIubGVuZ3RoKSB7XHJcbiAgICAgIGlmICghc2lsZW50KSB7XHJcbiAgICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2NvZGVfaW5saW5lJywgJ2NvZGUnLCAwKTtcclxuICAgICAgICB0b2tlbi5tYXJrdXAgID0gbWFya2VyO1xyXG4gICAgICAgIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXRjaFN0YXJ0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvWyBcXG5dKy9nLCAnICcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmltKCk7XHJcbiAgICAgIH1cclxuICAgICAgc3RhdGUucG9zID0gbWF0Y2hFbmQ7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBtYXJrZXI7IH1cclxuICBzdGF0ZS5wb3MgKz0gbWFya2VyLmxlbmd0aDtcclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbn0se31dLDQwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLy8gUHJvY2VzcyAqdGhpcyogYW5kIF90aGF0X1xyXG4vL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGlzV2hpdGVTcGFjZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNXaGl0ZVNwYWNlO1xyXG52YXIgaXNQdW5jdENoYXIgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1B1bmN0Q2hhcjtcclxudmFyIGlzTWRBc2NpaVB1bmN0ID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNNZEFzY2lpUHVuY3Q7XHJcblxyXG5cclxuLy8gcGFyc2Ugc2VxdWVuY2Ugb2YgZW1waGFzaXMgbWFya2VycyxcclxuLy8gXCJzdGFydFwiIHNob3VsZCBwb2ludCBhdCBhIHZhbGlkIG1hcmtlclxyXG5mdW5jdGlvbiBzY2FuRGVsaW1zKHN0YXRlLCBzdGFydCkge1xyXG4gIHZhciBwb3MgPSBzdGFydCwgbGFzdENoYXIsIG5leHRDaGFyLCBjb3VudCxcclxuICAgICAgaXNMYXN0V2hpdGVTcGFjZSwgaXNMYXN0UHVuY3RDaGFyLFxyXG4gICAgICBpc05leHRXaGl0ZVNwYWNlLCBpc05leHRQdW5jdENoYXIsXHJcbiAgICAgIGNhbl9vcGVuID0gdHJ1ZSxcclxuICAgICAgY2FuX2Nsb3NlID0gdHJ1ZSxcclxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4LFxyXG4gICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCk7XHJcblxyXG4gIC8vIHRyZWF0IGJlZ2lubmluZyBvZiB0aGUgbGluZSBhcyBhIHdoaXRlc3BhY2VcclxuICBsYXN0Q2hhciA9IHN0YXJ0ID4gMCA/IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0IC0gMSkgOiAweDIwO1xyXG5cclxuICB3aGlsZSAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IG1hcmtlcikgeyBwb3MrKzsgfVxyXG5cclxuICBpZiAocG9zID49IG1heCkge1xyXG4gICAgY2FuX29wZW4gPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIGNvdW50ID0gcG9zIC0gc3RhcnQ7XHJcblxyXG4gIC8vIHRyZWF0IGVuZCBvZiB0aGUgbGluZSBhcyBhIHdoaXRlc3BhY2VcclxuICBuZXh0Q2hhciA9IHBvcyA8IG1heCA/IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgOiAweDIwO1xyXG5cclxuICBpc0xhc3RQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChsYXN0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShsYXN0Q2hhcikpO1xyXG4gIGlzTmV4dFB1bmN0Q2hhciA9IGlzTWRBc2NpaVB1bmN0KG5leHRDaGFyKSB8fCBpc1B1bmN0Q2hhcihTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyKSk7XHJcblxyXG4gIGlzTGFzdFdoaXRlU3BhY2UgPSBpc1doaXRlU3BhY2UobGFzdENoYXIpO1xyXG4gIGlzTmV4dFdoaXRlU3BhY2UgPSBpc1doaXRlU3BhY2UobmV4dENoYXIpO1xyXG5cclxuICBpZiAoaXNOZXh0V2hpdGVTcGFjZSkge1xyXG4gICAgY2FuX29wZW4gPSBmYWxzZTtcclxuICB9IGVsc2UgaWYgKGlzTmV4dFB1bmN0Q2hhcikge1xyXG4gICAgaWYgKCEoaXNMYXN0V2hpdGVTcGFjZSB8fCBpc0xhc3RQdW5jdENoYXIpKSB7XHJcbiAgICAgIGNhbl9vcGVuID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoaXNMYXN0V2hpdGVTcGFjZSkge1xyXG4gICAgY2FuX2Nsb3NlID0gZmFsc2U7XHJcbiAgfSBlbHNlIGlmIChpc0xhc3RQdW5jdENoYXIpIHtcclxuICAgIGlmICghKGlzTmV4dFdoaXRlU3BhY2UgfHwgaXNOZXh0UHVuY3RDaGFyKSkge1xyXG4gICAgICBjYW5fY2xvc2UgPSBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChtYXJrZXIgPT09IDB4NUYgLyogXyAqLykge1xyXG4gICAgaWYgKGNhbl9vcGVuICYmIGNhbl9jbG9zZSkge1xyXG4gICAgICAvLyBcIl9cIiBpbnNpZGUgYSB3b3JkIGNhbiBuZWl0aGVyIG9wZW4gbm9yIGNsb3NlIGFuIGVtcGhhc2lzXHJcbiAgICAgIGNhbl9vcGVuID0gZmFsc2U7XHJcbiAgICAgIGNhbl9jbG9zZSA9IGlzTmV4dFB1bmN0Q2hhcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBjYW5fb3BlbjogY2FuX29wZW4sXHJcbiAgICBjYW5fY2xvc2U6IGNhbl9jbG9zZSxcclxuICAgIGRlbGltczogY291bnRcclxuICB9O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVtcGhhc2lzKHN0YXRlLCBzaWxlbnQpIHtcclxuICB2YXIgc3RhcnRDb3VudCxcclxuICAgICAgY291bnQsXHJcbiAgICAgIGZvdW5kLFxyXG4gICAgICBvbGRDb3VudCxcclxuICAgICAgbmV3Q291bnQsXHJcbiAgICAgIHN0YWNrLFxyXG4gICAgICByZXMsXHJcbiAgICAgIHRva2VuLFxyXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXgsXHJcbiAgICAgIHN0YXJ0ID0gc3RhdGUucG9zLFxyXG4gICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCk7XHJcblxyXG4gIGlmIChtYXJrZXIgIT09IDB4NUYvKiBfICovICYmIG1hcmtlciAhPT0gMHgyQSAvKiAqICovKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGRvbid0IHJ1biBhbnkgcGFpcnMgaW4gdmFsaWRhdGlvbiBtb2RlXHJcblxyXG4gIHJlcyA9IHNjYW5EZWxpbXMoc3RhdGUsIHN0YXJ0KTtcclxuICBzdGFydENvdW50ID0gcmVzLmRlbGltcztcclxuICBpZiAoIXJlcy5jYW5fb3Blbikge1xyXG4gICAgc3RhdGUucG9zICs9IHN0YXJ0Q291bnQ7XHJcbiAgICAvLyBFYXJsaWVyIHdlIGNoZWNrZWQgIXNpbGVudCwgYnV0IHRoaXMgaW1wbGVtZW50YXRpb24gZG9lcyBub3QgbmVlZCBpdFxyXG4gICAgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHN0YXRlLnBvcyk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHN0YXRlLnBvcyA9IHN0YXJ0ICsgc3RhcnRDb3VudDtcclxuICBzdGFjayA9IFsgc3RhcnRDb3VudCBdO1xyXG5cclxuICB3aGlsZSAoc3RhdGUucG9zIDwgbWF4KSB7XHJcbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKSA9PT0gbWFya2VyKSB7XHJcbiAgICAgIHJlcyA9IHNjYW5EZWxpbXMoc3RhdGUsIHN0YXRlLnBvcyk7XHJcbiAgICAgIGNvdW50ID0gcmVzLmRlbGltcztcclxuICAgICAgaWYgKHJlcy5jYW5fY2xvc2UpIHtcclxuICAgICAgICBvbGRDb3VudCA9IHN0YWNrLnBvcCgpO1xyXG4gICAgICAgIG5ld0NvdW50ID0gY291bnQ7XHJcblxyXG4gICAgICAgIHdoaWxlIChvbGRDb3VudCAhPT0gbmV3Q291bnQpIHtcclxuICAgICAgICAgIGlmIChuZXdDb3VudCA8IG9sZENvdW50KSB7XHJcbiAgICAgICAgICAgIHN0YWNrLnB1c2gob2xkQ291bnQgLSBuZXdDb3VudCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIGFzc2VydChuZXdDb3VudCA+IG9sZENvdW50KVxyXG4gICAgICAgICAgbmV3Q291bnQgLT0gb2xkQ291bnQ7XHJcblxyXG4gICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkgeyBicmVhazsgfVxyXG4gICAgICAgICAgc3RhdGUucG9zICs9IG9sZENvdW50O1xyXG4gICAgICAgICAgb2xkQ291bnQgPSBzdGFjay5wb3AoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIHN0YXJ0Q291bnQgPSBvbGRDb3VudDtcclxuICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0ZS5wb3MgKz0gY291bnQ7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChyZXMuY2FuX29wZW4pIHsgc3RhY2sucHVzaChjb3VudCk7IH1cclxuICAgICAgc3RhdGUucG9zICs9IGNvdW50O1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0ZS5tZC5pbmxpbmUuc2tpcFRva2VuKHN0YXRlKTtcclxuICB9XHJcblxyXG4gIGlmICghZm91bmQpIHtcclxuICAgIC8vIHBhcnNlciBmYWlsZWQgdG8gZmluZCBlbmRpbmcgdGFnLCBzbyBpdCdzIG5vdCB2YWxpZCBlbXBoYXNpc1xyXG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvLyBmb3VuZCFcclxuICBzdGF0ZS5wb3NNYXggPSBzdGF0ZS5wb3M7XHJcbiAgc3RhdGUucG9zID0gc3RhcnQgKyBzdGFydENvdW50O1xyXG5cclxuICAvLyBFYXJsaWVyIHdlIGNoZWNrZWQgIXNpbGVudCwgYnV0IHRoaXMgaW1wbGVtZW50YXRpb24gZG9lcyBub3QgbmVlZCBpdFxyXG5cclxuICAvLyB3ZSBoYXZlIGBzdGFydENvdW50YCBzdGFydGluZyBhbmQgZW5kaW5nIG1hcmtlcnMsXHJcbiAgLy8gbm93IHRyeWluZyB0byBzZXJpYWxpemUgdGhlbSBpbnRvIHRva2Vuc1xyXG4gIGZvciAoY291bnQgPSBzdGFydENvdW50OyBjb3VudCA+IDE7IGNvdW50IC09IDIpIHtcclxuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ3N0cm9uZ19vcGVuJywgJ3N0cm9uZycsIDEpO1xyXG4gICAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpICsgU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpO1xyXG4gIH1cclxuICBpZiAoY291bnQgJSAyKSB7XHJcbiAgICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdlbV9vcGVuJywgJ2VtJywgMSk7XHJcbiAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XHJcbiAgfVxyXG5cclxuICBzdGF0ZS5tZC5pbmxpbmUudG9rZW5pemUoc3RhdGUpO1xyXG5cclxuICBpZiAoY291bnQgJSAyKSB7XHJcbiAgICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdlbV9jbG9zZScsICdlbScsIC0xKTtcclxuICAgIHRva2VuLm1hcmt1cCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcclxuICB9XHJcbiAgZm9yIChjb3VudCA9IHN0YXJ0Q291bnQ7IGNvdW50ID4gMTsgY291bnQgLT0gMikge1xyXG4gICAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnc3Ryb25nX2Nsb3NlJywgJ3N0cm9uZycsIC0xKTtcclxuICAgIHRva2VuLm1hcmt1cCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKSArIFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcclxuICB9XHJcblxyXG4gIHN0YXRlLnBvcyA9IHN0YXRlLnBvc01heCArIHN0YXJ0Q291bnQ7XHJcbiAgc3RhdGUucG9zTWF4ID0gbWF4O1xyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxufSx7XCIuLi9jb21tb24vdXRpbHNcIjo1fV0sNDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4vLyBQcm9jZXNzIGh0bWwgZW50aXR5IC0gJiMxMjM7LCAmI3hBRjssICZxdW90OywgLi4uXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZW50aXRpZXMgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vZW50aXRpZXMnKTtcclxudmFyIGhhcyAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaGFzO1xyXG52YXIgaXNWYWxpZEVudGl0eUNvZGUgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1ZhbGlkRW50aXR5Q29kZTtcclxudmFyIGZyb21Db2RlUG9pbnQgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuZnJvbUNvZGVQb2ludDtcclxuXHJcblxyXG52YXIgRElHSVRBTF9SRSA9IC9eJiMoKD86eFthLWYwLTldezEsOH18WzAtOV17MSw4fSkpOy9pO1xyXG52YXIgTkFNRURfUkUgICA9IC9eJihbYS16XVthLXowLTldezEsMzF9KTsvaTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVudGl0eShzdGF0ZSwgc2lsZW50KSB7XHJcbiAgdmFyIGNoLCBjb2RlLCBtYXRjaCwgcG9zID0gc3RhdGUucG9zLCBtYXggPSBzdGF0ZS5wb3NNYXg7XHJcblxyXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDI2LyogJiAqLykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgaWYgKHBvcyArIDEgPCBtYXgpIHtcclxuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSk7XHJcblxyXG4gICAgaWYgKGNoID09PSAweDIzIC8qICMgKi8pIHtcclxuICAgICAgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5tYXRjaChESUdJVEFMX1JFKTtcclxuICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgaWYgKCFzaWxlbnQpIHtcclxuICAgICAgICAgIGNvZGUgPSBtYXRjaFsxXVswXS50b0xvd2VyQ2FzZSgpID09PSAneCcgPyBwYXJzZUludChtYXRjaFsxXS5zbGljZSgxKSwgMTYpIDogcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcclxuICAgICAgICAgIHN0YXRlLnBlbmRpbmcgKz0gaXNWYWxpZEVudGl0eUNvZGUoY29kZSkgPyBmcm9tQ29kZVBvaW50KGNvZGUpIDogZnJvbUNvZGVQb2ludCgweEZGRkQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0ZS5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBtYXRjaCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLm1hdGNoKE5BTUVEX1JFKTtcclxuICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgaWYgKGhhcyhlbnRpdGllcywgbWF0Y2hbMV0pKSB7XHJcbiAgICAgICAgICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IGVudGl0aWVzW21hdGNoWzFdXTsgfVxyXG4gICAgICAgICAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSAnJic7IH1cclxuICBzdGF0ZS5wb3MrKztcclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbn0se1wiLi4vY29tbW9uL2VudGl0aWVzXCI6MSxcIi4uL2NvbW1vbi91dGlsc1wiOjV9XSw0MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8vIFByb2NlZXNzIGVzY2FwZWQgY2hhcnMgYW5kIGhhcmRicmVha3NcclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBFU0NBUEVEID0gW107XHJcblxyXG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7IEVTQ0FQRUQucHVzaCgwKTsgfVxyXG5cclxuJ1xcXFwhXCIjJCUmXFwnKCkqKywuLzo7PD0+P0BbXV5fYHt8fX4tJ1xyXG4gIC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihjaCkgeyBFU0NBUEVEW2NoLmNoYXJDb2RlQXQoMCldID0gMTsgfSk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlc2NhcGUoc3RhdGUsIHNpbGVudCkge1xyXG4gIHZhciBjaCwgcG9zID0gc3RhdGUucG9zLCBtYXggPSBzdGF0ZS5wb3NNYXg7XHJcblxyXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDVDLyogXFwgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIHBvcysrO1xyXG5cclxuICBpZiAocG9zIDwgbWF4KSB7XHJcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XHJcblxyXG4gICAgaWYgKGNoIDwgMjU2ICYmIEVTQ0FQRURbY2hdICE9PSAwKSB7XHJcbiAgICAgIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjW3Bvc107IH1cclxuICAgICAgc3RhdGUucG9zICs9IDI7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjaCA9PT0gMHgwQSkge1xyXG4gICAgICBpZiAoIXNpbGVudCkge1xyXG4gICAgICAgIHN0YXRlLnB1c2goJ2hhcmRicmVhaycsICdicicsIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwb3MrKztcclxuICAgICAgLy8gc2tpcCBsZWFkaW5nIHdoaXRlc3BhY2VzIGZyb20gbmV4dCBsaW5lXHJcbiAgICAgIHdoaWxlIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyMCkgeyBwb3MrKzsgfVxyXG5cclxuICAgICAgc3RhdGUucG9zID0gcG9zO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gJ1xcXFwnOyB9XHJcbiAgc3RhdGUucG9zKys7XHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG59LHt9XSw0MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8vIFByb2Nlc3MgaHRtbCB0YWdzXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIEhUTUxfVEFHX1JFID0gcmVxdWlyZSgnLi4vY29tbW9uL2h0bWxfcmUnKS5IVE1MX1RBR19SRTtcclxuXHJcblxyXG5mdW5jdGlvbiBpc0xldHRlcihjaCkge1xyXG4gIC8qZXNsaW50IG5vLWJpdHdpc2U6MCovXHJcbiAgdmFyIGxjID0gY2ggfCAweDIwOyAvLyB0byBsb3dlciBjYXNlXHJcbiAgcmV0dXJuIChsYyA+PSAweDYxLyogYSAqLykgJiYgKGxjIDw9IDB4N2EvKiB6ICovKTtcclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHRtbF9pbmxpbmUoc3RhdGUsIHNpbGVudCkge1xyXG4gIHZhciBjaCwgbWF0Y2gsIG1heCwgdG9rZW4sXHJcbiAgICAgIHBvcyA9IHN0YXRlLnBvcztcclxuXHJcbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmh0bWwpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIC8vIENoZWNrIHN0YXJ0XHJcbiAgbWF4ID0gc3RhdGUucG9zTWF4O1xyXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDNDLyogPCAqLyB8fFxyXG4gICAgICBwb3MgKyAyID49IG1heCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gUXVpY2sgZmFpbCBvbiBzZWNvbmQgY2hhclxyXG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSk7XHJcbiAgaWYgKGNoICE9PSAweDIxLyogISAqLyAmJlxyXG4gICAgICBjaCAhPT0gMHgzRi8qID8gKi8gJiZcclxuICAgICAgY2ggIT09IDB4MkYvKiAvICovICYmXHJcbiAgICAgICFpc0xldHRlcihjaCkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIG1hdGNoID0gc3RhdGUuc3JjLnNsaWNlKHBvcykubWF0Y2goSFRNTF9UQUdfUkUpO1xyXG4gIGlmICghbWF0Y2gpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIGlmICghc2lsZW50KSB7XHJcbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnaHRtbF9pbmxpbmUnLCAnJywgMCk7XHJcbiAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgcG9zICsgbWF0Y2hbMF0ubGVuZ3RoKTtcclxuICB9XHJcbiAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbn0se1wiLi4vY29tbW9uL2h0bWxfcmVcIjozfV0sNDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4vLyBQcm9jZXNzICFbaW1hZ2VdKDxzcmM+IFwidGl0bGVcIilcclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBwYXJzZUxpbmtMYWJlbCAgICAgICA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcGFyc2VfbGlua19sYWJlbCcpO1xyXG52YXIgcGFyc2VMaW5rRGVzdGluYXRpb24gPSByZXF1aXJlKCcuLi9oZWxwZXJzL3BhcnNlX2xpbmtfZGVzdGluYXRpb24nKTtcclxudmFyIHBhcnNlTGlua1RpdGxlICAgICAgID0gcmVxdWlyZSgnLi4vaGVscGVycy9wYXJzZV9saW5rX3RpdGxlJyk7XHJcbnZhciBub3JtYWxpemVSZWZlcmVuY2UgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLm5vcm1hbGl6ZVJlZmVyZW5jZTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGltYWdlKHN0YXRlLCBzaWxlbnQpIHtcclxuICB2YXIgYXR0cnMsXHJcbiAgICAgIGNvZGUsXHJcbiAgICAgIGxhYmVsLFxyXG4gICAgICBsYWJlbEVuZCxcclxuICAgICAgbGFiZWxTdGFydCxcclxuICAgICAgcG9zLFxyXG4gICAgICByZWYsXHJcbiAgICAgIHJlcyxcclxuICAgICAgdGl0bGUsXHJcbiAgICAgIHRva2VuLFxyXG4gICAgICB0b2tlbnMsXHJcbiAgICAgIHN0YXJ0LFxyXG4gICAgICBocmVmID0gJycsXHJcbiAgICAgIG9sZFBvcyA9IHN0YXRlLnBvcyxcclxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4O1xyXG5cclxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKSAhPT0gMHgyMS8qICEgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcyArIDEpICE9PSAweDVCLyogWyAqLykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgbGFiZWxTdGFydCA9IHN0YXRlLnBvcyArIDI7XHJcbiAgbGFiZWxFbmQgPSBwYXJzZUxpbmtMYWJlbChzdGF0ZSwgc3RhdGUucG9zICsgMSwgZmFsc2UpO1xyXG5cclxuICAvLyBwYXJzZXIgZmFpbGVkIHRvIGZpbmQgJ10nLCBzbyBpdCdzIG5vdCBhIHZhbGlkIGxpbmtcclxuICBpZiAobGFiZWxFbmQgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICBwb3MgPSBsYWJlbEVuZCArIDE7XHJcbiAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDI4LyogKCAqLykge1xyXG4gICAgLy9cclxuICAgIC8vIElubGluZSBsaW5rXHJcbiAgICAvL1xyXG5cclxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXHJcbiAgICAvLyAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXHJcbiAgICBwb3MrKztcclxuICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XHJcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xyXG4gICAgICBpZiAoY29kZSAhPT0gMHgyMCAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XHJcbiAgICB9XHJcbiAgICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxyXG4gICAgLy8gICAgICAgICAgXl5eXl5eIHBhcnNpbmcgbGluayBkZXN0aW5hdGlvblxyXG4gICAgc3RhcnQgPSBwb3M7XHJcbiAgICByZXMgPSBwYXJzZUxpbmtEZXN0aW5hdGlvbihzdGF0ZS5zcmMsIHBvcywgc3RhdGUucG9zTWF4KTtcclxuICAgIGlmIChyZXMub2spIHtcclxuICAgICAgaHJlZiA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsocmVzLnN0cik7XHJcbiAgICAgIGlmIChzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoaHJlZikpIHtcclxuICAgICAgICBwb3MgPSByZXMucG9zO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGhyZWYgPSAnJztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXHJcbiAgICAvLyAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcclxuICAgIHN0YXJ0ID0gcG9zO1xyXG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcclxuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XHJcbiAgICAgIGlmIChjb2RlICE9PSAweDIwICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxyXG4gICAgLy8gICAgICAgICAgICAgICAgICBeXl5eXl5eIHBhcnNpbmcgbGluayB0aXRsZVxyXG4gICAgcmVzID0gcGFyc2VMaW5rVGl0bGUoc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XHJcbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXJ0ICE9PSBwb3MgJiYgcmVzLm9rKSB7XHJcbiAgICAgIHRpdGxlID0gcmVzLnN0cjtcclxuICAgICAgcG9zID0gcmVzLnBvcztcclxuXHJcbiAgICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXHJcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xyXG4gICAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xyXG4gICAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xyXG4gICAgICAgIGlmIChjb2RlICE9PSAweDIwICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGl0bGUgPSAnJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAocG9zID49IG1heCB8fCBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDI5LyogKSAqLykge1xyXG4gICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHBvcysrO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvL1xyXG4gICAgLy8gTGluayByZWZlcmVuY2VcclxuICAgIC8vXHJcbiAgICBpZiAodHlwZW9mIHN0YXRlLmVudi5yZWZlcmVuY2VzID09PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgICAvLyBbZm9vXSAgW2Jhcl1cclxuICAgIC8vICAgICAgXl4gb3B0aW9uYWwgd2hpdGVzcGFjZSAoY2FuIGluY2x1ZGUgbmV3bGluZXMpXHJcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xyXG4gICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcclxuICAgICAgaWYgKGNvZGUgIT09IDB4MjAgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg1Qi8qIFsgKi8pIHtcclxuICAgICAgc3RhcnQgPSBwb3MgKyAxO1xyXG4gICAgICBwb3MgPSBwYXJzZUxpbmtMYWJlbChzdGF0ZSwgcG9zKTtcclxuICAgICAgaWYgKHBvcyA+PSAwKSB7XHJcbiAgICAgICAgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvcysrKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBvcyA9IGxhYmVsRW5kICsgMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjb3ZlcnMgbGFiZWwgPT09ICcnIGFuZCBsYWJlbCA9PT0gdW5kZWZpbmVkXHJcbiAgICAvLyAoY29sbGFwc2VkIHJlZmVyZW5jZSBsaW5rIGFuZCBzaG9ydGN1dCByZWZlcmVuY2UgbGluayByZXNwZWN0aXZlbHkpXHJcbiAgICBpZiAoIWxhYmVsKSB7IGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKGxhYmVsU3RhcnQsIGxhYmVsRW5kKTsgfVxyXG5cclxuICAgIHJlZiA9IHN0YXRlLmVudi5yZWZlcmVuY2VzW25vcm1hbGl6ZVJlZmVyZW5jZShsYWJlbCldO1xyXG4gICAgaWYgKCFyZWYpIHtcclxuICAgICAgc3RhdGUucG9zID0gb2xkUG9zO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBocmVmID0gcmVmLmhyZWY7XHJcbiAgICB0aXRsZSA9IHJlZi50aXRsZTtcclxuICB9XHJcblxyXG4gIC8vXHJcbiAgLy8gV2UgZm91bmQgdGhlIGVuZCBvZiB0aGUgbGluaywgYW5kIGtub3cgZm9yIGEgZmFjdCBpdCdzIGEgdmFsaWQgbGluaztcclxuICAvLyBzbyBhbGwgdGhhdCdzIGxlZnQgdG8gZG8gaXMgdG8gY2FsbCB0b2tlbml6ZXIuXHJcbiAgLy9cclxuICBpZiAoIXNpbGVudCkge1xyXG4gICAgc3RhdGUucG9zID0gbGFiZWxTdGFydDtcclxuICAgIHN0YXRlLnBvc01heCA9IGxhYmVsRW5kO1xyXG5cclxuICAgIHZhciBuZXdTdGF0ZSA9IG5ldyBzdGF0ZS5tZC5pbmxpbmUuU3RhdGUoXHJcbiAgICAgIHN0YXRlLnNyYy5zbGljZShsYWJlbFN0YXJ0LCBsYWJlbEVuZCksXHJcbiAgICAgIHN0YXRlLm1kLFxyXG4gICAgICBzdGF0ZS5lbnYsXHJcbiAgICAgIHRva2VucyA9IFtdXHJcbiAgICApO1xyXG4gICAgbmV3U3RhdGUubWQuaW5saW5lLnRva2VuaXplKG5ld1N0YXRlKTtcclxuXHJcbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2ltYWdlJywgJ2ltZycsIDApO1xyXG4gICAgdG9rZW4uYXR0cnMgICAgPSBhdHRycyA9IFsgWyAnc3JjJywgaHJlZiBdLCBbICdhbHQnLCAnJyBdIF07XHJcbiAgICB0b2tlbi5jaGlsZHJlbiA9IHRva2VucztcclxuICAgIGlmICh0aXRsZSkge1xyXG4gICAgICBhdHRycy5wdXNoKFsgJ3RpdGxlJywgdGl0bGUgXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdGF0ZS5wb3MgPSBwb3M7XHJcbiAgc3RhdGUucG9zTWF4ID0gbWF4O1xyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxufSx7XCIuLi9jb21tb24vdXRpbHNcIjo1LFwiLi4vaGVscGVycy9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uXCI6NyxcIi4uL2hlbHBlcnMvcGFyc2VfbGlua19sYWJlbFwiOjgsXCIuLi9oZWxwZXJzL3BhcnNlX2xpbmtfdGl0bGVcIjo5fV0sNDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4vLyBQcm9jZXNzIFtsaW5rXSg8dG8+IFwic3R1ZmZcIilcclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBwYXJzZUxpbmtMYWJlbCAgICAgICA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcGFyc2VfbGlua19sYWJlbCcpO1xyXG52YXIgcGFyc2VMaW5rRGVzdGluYXRpb24gPSByZXF1aXJlKCcuLi9oZWxwZXJzL3BhcnNlX2xpbmtfZGVzdGluYXRpb24nKTtcclxudmFyIHBhcnNlTGlua1RpdGxlICAgICAgID0gcmVxdWlyZSgnLi4vaGVscGVycy9wYXJzZV9saW5rX3RpdGxlJyk7XHJcbnZhciBub3JtYWxpemVSZWZlcmVuY2UgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLm5vcm1hbGl6ZVJlZmVyZW5jZTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpbmsoc3RhdGUsIHNpbGVudCkge1xyXG4gIHZhciBhdHRycyxcclxuICAgICAgY29kZSxcclxuICAgICAgbGFiZWwsXHJcbiAgICAgIGxhYmVsRW5kLFxyXG4gICAgICBsYWJlbFN0YXJ0LFxyXG4gICAgICBwb3MsXHJcbiAgICAgIHJlcyxcclxuICAgICAgcmVmLFxyXG4gICAgICB0aXRsZSxcclxuICAgICAgdG9rZW4sXHJcbiAgICAgIGhyZWYgPSAnJyxcclxuICAgICAgb2xkUG9zID0gc3RhdGUucG9zLFxyXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXgsXHJcbiAgICAgIHN0YXJ0ID0gc3RhdGUucG9zO1xyXG5cclxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKSAhPT0gMHg1Qi8qIFsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIGxhYmVsU3RhcnQgPSBzdGF0ZS5wb3MgKyAxO1xyXG4gIGxhYmVsRW5kID0gcGFyc2VMaW5rTGFiZWwoc3RhdGUsIHN0YXRlLnBvcywgdHJ1ZSk7XHJcblxyXG4gIC8vIHBhcnNlciBmYWlsZWQgdG8gZmluZCAnXScsIHNvIGl0J3Mgbm90IGEgdmFsaWQgbGlua1xyXG4gIGlmIChsYWJlbEVuZCA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIHBvcyA9IGxhYmVsRW5kICsgMTtcclxuICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjgvKiAoICovKSB7XHJcbiAgICAvL1xyXG4gICAgLy8gSW5saW5lIGxpbmtcclxuICAgIC8vXHJcblxyXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcclxuICAgIC8vICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcclxuICAgIHBvcysrO1xyXG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcclxuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XHJcbiAgICAgIGlmIChjb2RlICE9PSAweDIwICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cclxuICAgIH1cclxuICAgIGlmIChwb3MgPj0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXHJcbiAgICAvLyAgICAgICAgICBeXl5eXl4gcGFyc2luZyBsaW5rIGRlc3RpbmF0aW9uXHJcbiAgICBzdGFydCA9IHBvcztcclxuICAgIHJlcyA9IHBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xyXG4gICAgaWYgKHJlcy5vaykge1xyXG4gICAgICBocmVmID0gc3RhdGUubWQubm9ybWFsaXplTGluayhyZXMuc3RyKTtcclxuICAgICAgaWYgKHN0YXRlLm1kLnZhbGlkYXRlTGluayhocmVmKSkge1xyXG4gICAgICAgIHBvcyA9IHJlcy5wb3M7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaHJlZiA9ICcnO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcclxuICAgIC8vICAgICAgICAgICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xyXG4gICAgc3RhcnQgPSBwb3M7XHJcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xyXG4gICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcclxuICAgICAgaWYgKGNvZGUgIT09IDB4MjAgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXHJcbiAgICAvLyAgICAgICAgICAgICAgICAgIF5eXl5eXl4gcGFyc2luZyBsaW5rIHRpdGxlXHJcbiAgICByZXMgPSBwYXJzZUxpbmtUaXRsZShzdGF0ZS5zcmMsIHBvcywgc3RhdGUucG9zTWF4KTtcclxuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhcnQgIT09IHBvcyAmJiByZXMub2spIHtcclxuICAgICAgdGl0bGUgPSByZXMuc3RyO1xyXG4gICAgICBwb3MgPSByZXMucG9zO1xyXG5cclxuICAgICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcclxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXHJcbiAgICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XHJcbiAgICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XHJcbiAgICAgICAgaWYgKGNvZGUgIT09IDB4MjAgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aXRsZSA9ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChwb3MgPj0gbWF4IHx8IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MjkvKiApICovKSB7XHJcbiAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcG9zKys7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vXHJcbiAgICAvLyBMaW5rIHJlZmVyZW5jZVxyXG4gICAgLy9cclxuICAgIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXMgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICAgIC8vIFtmb29dICBbYmFyXVxyXG4gICAgLy8gICAgICBeXiBvcHRpb25hbCB3aGl0ZXNwYWNlIChjYW4gaW5jbHVkZSBuZXdsaW5lcylcclxuICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XHJcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xyXG4gICAgICBpZiAoY29kZSAhPT0gMHgyMCAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDVCLyogWyAqLykge1xyXG4gICAgICBzdGFydCA9IHBvcyArIDE7XHJcbiAgICAgIHBvcyA9IHBhcnNlTGlua0xhYmVsKHN0YXRlLCBwb3MpO1xyXG4gICAgICBpZiAocG9zID49IDApIHtcclxuICAgICAgICBsYWJlbCA9IHN0YXRlLnNyYy5zbGljZShzdGFydCwgcG9zKyspO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBvcyA9IGxhYmVsRW5kICsgMTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcG9zID0gbGFiZWxFbmQgKyAxO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvdmVycyBsYWJlbCA9PT0gJycgYW5kIGxhYmVsID09PSB1bmRlZmluZWRcclxuICAgIC8vIChjb2xsYXBzZWQgcmVmZXJlbmNlIGxpbmsgYW5kIHNob3J0Y3V0IHJlZmVyZW5jZSBsaW5rIHJlc3BlY3RpdmVseSlcclxuICAgIGlmICghbGFiZWwpIHsgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpOyB9XHJcblxyXG4gICAgcmVmID0gc3RhdGUuZW52LnJlZmVyZW5jZXNbbm9ybWFsaXplUmVmZXJlbmNlKGxhYmVsKV07XHJcbiAgICBpZiAoIXJlZikge1xyXG4gICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGhyZWYgPSByZWYuaHJlZjtcclxuICAgIHRpdGxlID0gcmVmLnRpdGxlO1xyXG4gIH1cclxuXHJcbiAgLy9cclxuICAvLyBXZSBmb3VuZCB0aGUgZW5kIG9mIHRoZSBsaW5rLCBhbmQga25vdyBmb3IgYSBmYWN0IGl0J3MgYSB2YWxpZCBsaW5rO1xyXG4gIC8vIHNvIGFsbCB0aGF0J3MgbGVmdCB0byBkbyBpcyB0byBjYWxsIHRva2VuaXplci5cclxuICAvL1xyXG4gIGlmICghc2lsZW50KSB7XHJcbiAgICBzdGF0ZS5wb3MgPSBsYWJlbFN0YXJ0O1xyXG4gICAgc3RhdGUucG9zTWF4ID0gbGFiZWxFbmQ7XHJcblxyXG4gICAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnbGlua19vcGVuJywgJ2EnLCAxKTtcclxuICAgIHRva2VuLmF0dHJzICA9IGF0dHJzID0gWyBbICdocmVmJywgaHJlZiBdIF07XHJcbiAgICBpZiAodGl0bGUpIHtcclxuICAgICAgYXR0cnMucHVzaChbICd0aXRsZScsIHRpdGxlIF0pO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlLm1kLmlubGluZS50b2tlbml6ZShzdGF0ZSk7XHJcblxyXG4gICAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnbGlua19jbG9zZScsICdhJywgLTEpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGUucG9zID0gcG9zO1xyXG4gIHN0YXRlLnBvc01heCA9IG1heDtcclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbn0se1wiLi4vY29tbW9uL3V0aWxzXCI6NSxcIi4uL2hlbHBlcnMvcGFyc2VfbGlua19kZXN0aW5hdGlvblwiOjcsXCIuLi9oZWxwZXJzL3BhcnNlX2xpbmtfbGFiZWxcIjo4LFwiLi4vaGVscGVycy9wYXJzZV9saW5rX3RpdGxlXCI6OX1dLDQ2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuLy8gUHJvY2Vlc3MgJ1xcbidcclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbmV3bGluZShzdGF0ZSwgc2lsZW50KSB7XHJcbiAgdmFyIHBtYXgsIG1heCwgcG9zID0gc3RhdGUucG9zO1xyXG5cclxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgwQS8qIFxcbiAqLykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgcG1heCA9IHN0YXRlLnBlbmRpbmcubGVuZ3RoIC0gMTtcclxuICBtYXggPSBzdGF0ZS5wb3NNYXg7XHJcblxyXG4gIC8vICcgIFxcbicgLT4gaGFyZGJyZWFrXHJcbiAgLy8gTG9va3VwIGluIHBlbmRpbmcgY2hhcnMgaXMgYmFkIHByYWN0aWNlISBEb24ndCBjb3B5IHRvIG90aGVyIHJ1bGVzIVxyXG4gIC8vIFBlbmRpbmcgc3RyaW5nIGlzIHN0b3JlZCBpbiBjb25jYXQgbW9kZSwgaW5kZXhlZCBsb29rdXBzIHdpbGwgY2F1c2VcclxuICAvLyBjb252ZXJ0aW9uIHRvIGZsYXQgbW9kZS5cclxuICBpZiAoIXNpbGVudCkge1xyXG4gICAgaWYgKHBtYXggPj0gMCAmJiBzdGF0ZS5wZW5kaW5nLmNoYXJDb2RlQXQocG1heCkgPT09IDB4MjApIHtcclxuICAgICAgaWYgKHBtYXggPj0gMSAmJiBzdGF0ZS5wZW5kaW5nLmNoYXJDb2RlQXQocG1heCAtIDEpID09PSAweDIwKSB7XHJcbiAgICAgICAgc3RhdGUucGVuZGluZyA9IHN0YXRlLnBlbmRpbmcucmVwbGFjZSgvICskLywgJycpO1xyXG4gICAgICAgIHN0YXRlLnB1c2goJ2hhcmRicmVhaycsICdicicsIDApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN0YXRlLnBlbmRpbmcgPSBzdGF0ZS5wZW5kaW5nLnNsaWNlKDAsIC0xKTtcclxuICAgICAgICBzdGF0ZS5wdXNoKCdzb2Z0YnJlYWsnLCAnYnInLCAwKTtcclxuICAgICAgfVxyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0YXRlLnB1c2goJ3NvZnRicmVhaycsICdicicsIDApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcG9zKys7XHJcblxyXG4gIC8vIHNraXAgaGVhZGluZyBzcGFjZXMgZm9yIG5leHQgbGluZVxyXG4gIHdoaWxlIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyMCkgeyBwb3MrKzsgfVxyXG5cclxuICBzdGF0ZS5wb3MgPSBwb3M7XHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG59LHt9XSw0NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8vIElubGluZSBwYXJzZXIgc3RhdGVcclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgVG9rZW4gPSByZXF1aXJlKCcuLi90b2tlbicpO1xyXG5cclxuZnVuY3Rpb24gU3RhdGVJbmxpbmUoc3JjLCBtZCwgZW52LCBvdXRUb2tlbnMpIHtcclxuICB0aGlzLnNyYyA9IHNyYztcclxuICB0aGlzLmVudiA9IGVudjtcclxuICB0aGlzLm1kID0gbWQ7XHJcbiAgdGhpcy50b2tlbnMgPSBvdXRUb2tlbnM7XHJcblxyXG4gIHRoaXMucG9zID0gMDtcclxuICB0aGlzLnBvc01heCA9IHRoaXMuc3JjLmxlbmd0aDtcclxuICB0aGlzLmxldmVsID0gMDtcclxuICB0aGlzLnBlbmRpbmcgPSAnJztcclxuICB0aGlzLnBlbmRpbmdMZXZlbCA9IDA7XHJcblxyXG4gIHRoaXMuY2FjaGUgPSB7fTsgICAgICAgIC8vIFN0b3JlcyB7IHN0YXJ0OiBlbmQgfSBwYWlycy4gVXNlZnVsIGZvciBiYWNrdHJhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvcHRpbWl6YXRpb24gb2YgcGFpcnMgcGFyc2UgKGVtcGhhc2lzLCBzdHJpa2VzKS5cclxufVxyXG5cclxuXHJcbi8vIEZsdXNoIHBlbmRpbmcgdGV4dFxyXG4vL1xyXG5TdGF0ZUlubGluZS5wcm90b3R5cGUucHVzaFBlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHRva2VuID0gbmV3IFRva2VuKCd0ZXh0JywgJycsIDApO1xyXG4gIHRva2VuLmNvbnRlbnQgPSB0aGlzLnBlbmRpbmc7XHJcbiAgdG9rZW4ubGV2ZWwgPSB0aGlzLnBlbmRpbmdMZXZlbDtcclxuICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcclxuICB0aGlzLnBlbmRpbmcgPSAnJztcclxuICByZXR1cm4gdG9rZW47XHJcbn07XHJcblxyXG5cclxuLy8gUHVzaCBuZXcgdG9rZW4gdG8gXCJzdHJlYW1cIi5cclxuLy8gSWYgcGVuZGluZyB0ZXh0IGV4aXN0cyAtIGZsdXNoIGl0IGFzIHRleHQgdG9rZW5cclxuLy9cclxuU3RhdGVJbmxpbmUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodHlwZSwgdGFnLCBuZXN0aW5nKSB7XHJcbiAgaWYgKHRoaXMucGVuZGluZykge1xyXG4gICAgdGhpcy5wdXNoUGVuZGluZygpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHRva2VuID0gbmV3IFRva2VuKHR5cGUsIHRhZywgbmVzdGluZyk7XHJcblxyXG4gIGlmIChuZXN0aW5nIDwgMCkgeyB0aGlzLmxldmVsLS07IH1cclxuICB0b2tlbi5sZXZlbCA9IHRoaXMubGV2ZWw7XHJcbiAgaWYgKG5lc3RpbmcgPiAwKSB7IHRoaXMubGV2ZWwrKzsgfVxyXG5cclxuICB0aGlzLnBlbmRpbmdMZXZlbCA9IHRoaXMubGV2ZWw7XHJcbiAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XHJcbiAgcmV0dXJuIHRva2VuO1xyXG59O1xyXG5cclxuLy8gcmUtZXhwb3J0IFRva2VuIGNsYXNzIHRvIHVzZSBpbiBibG9jayBydWxlc1xyXG5TdGF0ZUlubGluZS5wcm90b3R5cGUuVG9rZW4gPSBUb2tlbjtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlSW5saW5lO1xyXG5cclxufSx7XCIuLi90b2tlblwiOjUwfV0sNDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4vLyB+fnN0cmlrZSB0aHJvdWdofn5cclxuLy9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBpc1doaXRlU3BhY2UgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzV2hpdGVTcGFjZTtcclxudmFyIGlzUHVuY3RDaGFyICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNQdW5jdENoYXI7XHJcbnZhciBpc01kQXNjaWlQdW5jdCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzTWRBc2NpaVB1bmN0O1xyXG5cclxuXHJcbi8vIHBhcnNlIHNlcXVlbmNlIG9mIG1hcmtlcnMsXHJcbi8vIFwic3RhcnRcIiBzaG91bGQgcG9pbnQgYXQgYSB2YWxpZCBtYXJrZXJcclxuZnVuY3Rpb24gc2NhbkRlbGltcyhzdGF0ZSwgc3RhcnQpIHtcclxuICB2YXIgcG9zID0gc3RhcnQsIGxhc3RDaGFyLCBuZXh0Q2hhciwgY291bnQsXHJcbiAgICAgIGlzTGFzdFdoaXRlU3BhY2UsIGlzTGFzdFB1bmN0Q2hhcixcclxuICAgICAgaXNOZXh0V2hpdGVTcGFjZSwgaXNOZXh0UHVuY3RDaGFyLFxyXG4gICAgICBjYW5fb3BlbiA9IHRydWUsXHJcbiAgICAgIGNhbl9jbG9zZSA9IHRydWUsXHJcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heCxcclxuICAgICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQpO1xyXG5cclxuICAvLyB0cmVhdCBiZWdpbm5pbmcgb2YgdGhlIGxpbmUgYXMgYSB3aGl0ZXNwYWNlXHJcbiAgbGFzdENoYXIgPSBzdGFydCA+IDAgPyBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCAtIDEpIDogMHgyMDtcclxuXHJcbiAgd2hpbGUgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSBtYXJrZXIpIHsgcG9zKys7IH1cclxuXHJcbiAgaWYgKHBvcyA+PSBtYXgpIHtcclxuICAgIGNhbl9vcGVuID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBjb3VudCA9IHBvcyAtIHN0YXJ0O1xyXG5cclxuICAvLyB0cmVhdCBlbmQgb2YgdGhlIGxpbmUgYXMgYSB3aGl0ZXNwYWNlXHJcbiAgbmV4dENoYXIgPSBwb3MgPCBtYXggPyBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpIDogMHgyMDtcclxuXHJcbiAgaXNMYXN0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobGFzdENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobGFzdENoYXIpKTtcclxuICBpc05leHRQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChuZXh0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhcikpO1xyXG5cclxuICBpc0xhc3RXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKGxhc3RDaGFyKTtcclxuICBpc05leHRXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKG5leHRDaGFyKTtcclxuXHJcbiAgaWYgKGlzTmV4dFdoaXRlU3BhY2UpIHtcclxuICAgIGNhbl9vcGVuID0gZmFsc2U7XHJcbiAgfSBlbHNlIGlmIChpc05leHRQdW5jdENoYXIpIHtcclxuICAgIGlmICghKGlzTGFzdFdoaXRlU3BhY2UgfHwgaXNMYXN0UHVuY3RDaGFyKSkge1xyXG4gICAgICBjYW5fb3BlbiA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGlzTGFzdFdoaXRlU3BhY2UpIHtcclxuICAgIGNhbl9jbG9zZSA9IGZhbHNlO1xyXG4gIH0gZWxzZSBpZiAoaXNMYXN0UHVuY3RDaGFyKSB7XHJcbiAgICBpZiAoIShpc05leHRXaGl0ZVNwYWNlIHx8IGlzTmV4dFB1bmN0Q2hhcikpIHtcclxuICAgICAgY2FuX2Nsb3NlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgY2FuX29wZW46IGNhbl9vcGVuLFxyXG4gICAgY2FuX2Nsb3NlOiBjYW5fY2xvc2UsXHJcbiAgICBkZWxpbXM6IGNvdW50XHJcbiAgfTtcclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaWtldGhyb3VnaChzdGF0ZSwgc2lsZW50KSB7XHJcbiAgdmFyIHN0YXJ0Q291bnQsXHJcbiAgICAgIGNvdW50LFxyXG4gICAgICB0YWdDb3VudCxcclxuICAgICAgZm91bmQsXHJcbiAgICAgIHN0YWNrLFxyXG4gICAgICByZXMsXHJcbiAgICAgIHRva2VuLFxyXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXgsXHJcbiAgICAgIHN0YXJ0ID0gc3RhdGUucG9zLFxyXG4gICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCk7XHJcblxyXG4gIGlmIChtYXJrZXIgIT09IDB4N0UvKiB+ICovKSB7IHJldHVybiBmYWxzZTsgfVxyXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGRvbid0IHJ1biBhbnkgcGFpcnMgaW4gdmFsaWRhdGlvbiBtb2RlXHJcblxyXG4gIHJlcyA9IHNjYW5EZWxpbXMoc3RhdGUsIHN0YXJ0KTtcclxuICBzdGFydENvdW50ID0gcmVzLmRlbGltcztcclxuICBpZiAoIXJlcy5jYW5fb3Blbikge1xyXG4gICAgc3RhdGUucG9zICs9IHN0YXJ0Q291bnQ7XHJcbiAgICAvLyBFYXJsaWVyIHdlIGNoZWNrZWQgIXNpbGVudCwgYnV0IHRoaXMgaW1wbGVtZW50YXRpb24gZG9lcyBub3QgbmVlZCBpdFxyXG4gICAgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHN0YXRlLnBvcyk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHN0YWNrID0gTWF0aC5mbG9vcihzdGFydENvdW50IC8gMik7XHJcbiAgaWYgKHN0YWNrIDw9IDApIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgc3RhdGUucG9zID0gc3RhcnQgKyBzdGFydENvdW50O1xyXG5cclxuICB3aGlsZSAoc3RhdGUucG9zIDwgbWF4KSB7XHJcbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKSA9PT0gbWFya2VyKSB7XHJcbiAgICAgIHJlcyA9IHNjYW5EZWxpbXMoc3RhdGUsIHN0YXRlLnBvcyk7XHJcbiAgICAgIGNvdW50ID0gcmVzLmRlbGltcztcclxuICAgICAgdGFnQ291bnQgPSBNYXRoLmZsb29yKGNvdW50IC8gMik7XHJcbiAgICAgIGlmIChyZXMuY2FuX2Nsb3NlKSB7XHJcbiAgICAgICAgaWYgKHRhZ0NvdW50ID49IHN0YWNrKSB7XHJcbiAgICAgICAgICBzdGF0ZS5wb3MgKz0gY291bnQgLSAyO1xyXG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YWNrIC09IHRhZ0NvdW50O1xyXG4gICAgICAgIHN0YXRlLnBvcyArPSBjb3VudDtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJlcy5jYW5fb3BlbikgeyBzdGFjayArPSB0YWdDb3VudDsgfVxyXG4gICAgICBzdGF0ZS5wb3MgKz0gY291bnQ7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlLm1kLmlubGluZS5za2lwVG9rZW4oc3RhdGUpO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFmb3VuZCkge1xyXG4gICAgLy8gcGFyc2VyIGZhaWxlZCB0byBmaW5kIGVuZGluZyB0YWcsIHNvIGl0J3Mgbm90IHZhbGlkIGVtcGhhc2lzXHJcbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIGZvdW5kIVxyXG4gIHN0YXRlLnBvc01heCA9IHN0YXRlLnBvcztcclxuICBzdGF0ZS5wb3MgPSBzdGFydCArIDI7XHJcblxyXG4gIC8vIEVhcmxpZXIgd2UgY2hlY2tlZCAhc2lsZW50LCBidXQgdGhpcyBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCBuZWVkIGl0XHJcbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnc19vcGVuJywgJ3MnLCAxKTtcclxuICB0b2tlbi5tYXJrdXAgPSAnfn4nO1xyXG5cclxuICBzdGF0ZS5tZC5pbmxpbmUudG9rZW5pemUoc3RhdGUpO1xyXG5cclxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdzX2Nsb3NlJywgJ3MnLCAtMSk7XHJcbiAgdG9rZW4ubWFya3VwID0gJ35+JztcclxuXHJcbiAgc3RhdGUucG9zID0gc3RhdGUucG9zTWF4ICsgMjtcclxuICBzdGF0ZS5wb3NNYXggPSBtYXg7XHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG59LHtcIi4uL2NvbW1vbi91dGlsc1wiOjV9XSw0OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8vIFNraXAgdGV4dCBjaGFyYWN0ZXJzIGZvciB0ZXh0IHRva2VuLCBwbGFjZSB0aG9zZSB0byBwZW5kaW5nIGJ1ZmZlclxyXG4vLyBhbmQgaW5jcmVtZW50IGN1cnJlbnQgcG9zXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5cclxuLy8gUnVsZSB0byBza2lwIHB1cmUgdGV4dFxyXG4vLyAne30kJUB+Kz06JyByZXNlcnZlZCBmb3IgZXh0ZW50aW9uc1xyXG5cclxuLy8gISwgXCIsICMsICQsICUsICYsICcsICgsICksICosICssICwsIC0sIC4sIC8sIDosIDssIDwsID0sID4sID8sIEAsIFssIFxcLCBdLCBeLCBfLCBgLCB7LCB8LCB9LCBvciB+XHJcblxyXG4vLyAhISEhIERvbid0IGNvbmZ1c2Ugd2l0aCBcIk1hcmtkb3duIEFTQ0lJIFB1bmN0dWF0aW9uXCIgY2hhcnNcclxuLy8gaHR0cDovL3NwZWMuY29tbW9ubWFyay5vcmcvMC4xNS8jYXNjaWktcHVuY3R1YXRpb24tY2hhcmFjdGVyXHJcbmZ1bmN0aW9uIGlzVGVybWluYXRvckNoYXIoY2gpIHtcclxuICBzd2l0Y2ggKGNoKSB7XHJcbiAgICBjYXNlIDB4MEEvKiBcXG4gKi86XHJcbiAgICBjYXNlIDB4MjEvKiAhICovOlxyXG4gICAgY2FzZSAweDIzLyogIyAqLzpcclxuICAgIGNhc2UgMHgyNC8qICQgKi86XHJcbiAgICBjYXNlIDB4MjUvKiAlICovOlxyXG4gICAgY2FzZSAweDI2LyogJiAqLzpcclxuICAgIGNhc2UgMHgyQS8qICogKi86XHJcbiAgICBjYXNlIDB4MkIvKiArICovOlxyXG4gICAgY2FzZSAweDJELyogLSAqLzpcclxuICAgIGNhc2UgMHgzQS8qIDogKi86XHJcbiAgICBjYXNlIDB4M0MvKiA8ICovOlxyXG4gICAgY2FzZSAweDNELyogPSAqLzpcclxuICAgIGNhc2UgMHgzRS8qID4gKi86XHJcbiAgICBjYXNlIDB4NDAvKiBAICovOlxyXG4gICAgY2FzZSAweDVCLyogWyAqLzpcclxuICAgIGNhc2UgMHg1Qy8qIFxcICovOlxyXG4gICAgY2FzZSAweDVELyogXSAqLzpcclxuICAgIGNhc2UgMHg1RS8qIF4gKi86XHJcbiAgICBjYXNlIDB4NUYvKiBfICovOlxyXG4gICAgY2FzZSAweDYwLyogYCAqLzpcclxuICAgIGNhc2UgMHg3Qi8qIHsgKi86XHJcbiAgICBjYXNlIDB4N0QvKiB9ICovOlxyXG4gICAgY2FzZSAweDdFLyogfiAqLzpcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRleHQoc3RhdGUsIHNpbGVudCkge1xyXG4gIHZhciBwb3MgPSBzdGF0ZS5wb3M7XHJcblxyXG4gIHdoaWxlIChwb3MgPCBzdGF0ZS5wb3NNYXggJiYgIWlzVGVybWluYXRvckNoYXIoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSkpIHtcclxuICAgIHBvcysrO1xyXG4gIH1cclxuXHJcbiAgaWYgKHBvcyA9PT0gc3RhdGUucG9zKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyYy5zbGljZShzdGF0ZS5wb3MsIHBvcyk7IH1cclxuXHJcbiAgc3RhdGUucG9zID0gcG9zO1xyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbi8vIEFsdGVybmF0aXZlIGltcGxlbWVudGF0aW9uLCBmb3IgbWVtb3J5LlxyXG4vL1xyXG4vLyBJdCBjb3N0cyAxMCUgb2YgcGVyZm9ybWFuY2UsIGJ1dCBhbGxvd3MgZXh0ZW5kIHRlcm1pbmF0b3JzIGxpc3QsIGlmIHBsYWNlIGl0XHJcbi8vIHRvIGBQYXJjZXJJbmxpbmVgIHByb3BlcnR5LiBQcm9iYWJseSwgd2lsbCBzd2l0Y2ggdG8gaXQgc29tZXRpbWUsIHN1Y2hcclxuLy8gZmxleGliaWxpdHkgcmVxdWlyZWQuXHJcblxyXG4vKlxyXG52YXIgVEVSTUlOQVRPUl9SRSA9IC9bXFxuISMkJSYqK1xcLTo8PT5AW1xcXFxcXF1eX2B7fX5dLztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGV4dChzdGF0ZSwgc2lsZW50KSB7XHJcbiAgdmFyIHBvcyA9IHN0YXRlLnBvcyxcclxuICAgICAgaWR4ID0gc3RhdGUuc3JjLnNsaWNlKHBvcykuc2VhcmNoKFRFUk1JTkFUT1JfUkUpO1xyXG5cclxuICAvLyBmaXJzdCBjaGFyIGlzIHRlcm1pbmF0b3IgLT4gZW1wdHkgdGV4dFxyXG4gIGlmIChpZHggPT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIC8vIG5vIHRlcm1pbmF0b3IgLT4gdGV4dCB0aWxsIGVuZCBvZiBzdHJpbmdcclxuICBpZiAoaWR4IDwgMCkge1xyXG4gICAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmMuc2xpY2UocG9zKTsgfVxyXG4gICAgc3RhdGUucG9zID0gc3RhdGUuc3JjLmxlbmd0aDtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBwb3MgKyBpZHgpOyB9XHJcblxyXG4gIHN0YXRlLnBvcyArPSBpZHg7XHJcblxyXG4gIHJldHVybiB0cnVlO1xyXG59OyovXHJcblxyXG59LHt9XSw1MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8vIFRva2VuIGNsYXNzXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5cclxuLyoqXHJcbiAqIGNsYXNzIFRva2VuXHJcbiAqKi9cclxuXHJcbi8qKlxyXG4gKiBuZXcgVG9rZW4odHlwZSwgdGFnLCBuZXN0aW5nKVxyXG4gKlxyXG4gKiBDcmVhdGUgbmV3IHRva2VuIGFuZCBmaWxsIHBhc3NlZCBwcm9wZXJ0aWVzLlxyXG4gKiovXHJcbmZ1bmN0aW9uIFRva2VuKHR5cGUsIHRhZywgbmVzdGluZykge1xyXG4gIC8qKlxyXG4gICAqIFRva2VuI3R5cGUgLT4gU3RyaW5nXHJcbiAgICpcclxuICAgKiBUeXBlIG9mIHRoZSB0b2tlbiAoc3RyaW5nLCBlLmcuIFwicGFyYWdyYXBoX29wZW5cIilcclxuICAgKiovXHJcbiAgdGhpcy50eXBlICAgICA9IHR5cGU7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRva2VuI3RhZyAtPiBTdHJpbmdcclxuICAgKlxyXG4gICAqIGh0bWwgdGFnIG5hbWUsIGUuZy4gXCJwXCJcclxuICAgKiovXHJcbiAgdGhpcy50YWcgICAgICA9IHRhZztcclxuXHJcbiAgLyoqXHJcbiAgICogVG9rZW4jYXR0cnMgLT4gQXJyYXlcclxuICAgKlxyXG4gICAqIEh0bWwgYXR0cmlidXRlcy4gRm9ybWF0OiBgWyBbIG5hbWUxLCB2YWx1ZTEgXSwgWyBuYW1lMiwgdmFsdWUyIF0gXWBcclxuICAgKiovXHJcbiAgdGhpcy5hdHRycyAgICA9IG51bGw7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRva2VuI21hcCAtPiBBcnJheVxyXG4gICAqXHJcbiAgICogU291cmNlIG1hcCBpbmZvLiBGb3JtYXQ6IGBbIGxpbmVfYmVnaW4sIGxpbmVfZW5kIF1gXHJcbiAgICoqL1xyXG4gIHRoaXMubWFwICAgICAgPSBudWxsO1xyXG5cclxuICAvKipcclxuICAgKiBUb2tlbiNuZXN0aW5nIC0+IE51bWJlclxyXG4gICAqXHJcbiAgICogTGV2ZWwgY2hhbmdlIChudW1iZXIgaW4gey0xLCAwLCAxfSBzZXQpLCB3aGVyZTpcclxuICAgKlxyXG4gICAqIC0gIGAxYCBtZWFucyB0aGUgdGFnIGlzIG9wZW5pbmdcclxuICAgKiAtICBgMGAgbWVhbnMgdGhlIHRhZyBpcyBzZWxmLWNsb3NpbmdcclxuICAgKiAtIGAtMWAgbWVhbnMgdGhlIHRhZyBpcyBjbG9zaW5nXHJcbiAgICoqL1xyXG4gIHRoaXMubmVzdGluZyAgPSBuZXN0aW5nO1xyXG5cclxuICAvKipcclxuICAgKiBUb2tlbiNsZXZlbCAtPiBOdW1iZXJcclxuICAgKlxyXG4gICAqIG5lc3RpbmcgbGV2ZWwsIHRoZSBzYW1lIGFzIGBzdGF0ZS5sZXZlbGBcclxuICAgKiovXHJcbiAgdGhpcy5sZXZlbCAgICA9IDA7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRva2VuI2NoaWxkcmVuIC0+IEFycmF5XHJcbiAgICpcclxuICAgKiBBbiBhcnJheSBvZiBjaGlsZCBub2RlcyAoaW5saW5lIGFuZCBpbWcgdG9rZW5zKVxyXG4gICAqKi9cclxuICB0aGlzLmNoaWxkcmVuID0gbnVsbDtcclxuXHJcbiAgLyoqXHJcbiAgICogVG9rZW4jY29udGVudCAtPiBTdHJpbmdcclxuICAgKlxyXG4gICAqIEluIGEgY2FzZSBvZiBzZWxmLWNsb3NpbmcgdGFnIChjb2RlLCBodG1sLCBmZW5jZSwgZXRjLiksXHJcbiAgICogaXQgaGFzIGNvbnRlbnRzIG9mIHRoaXMgdGFnLlxyXG4gICAqKi9cclxuICB0aGlzLmNvbnRlbnQgID0gJyc7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRva2VuI21hcmt1cCAtPiBTdHJpbmdcclxuICAgKlxyXG4gICAqICcqJyBvciAnXycgZm9yIGVtcGhhc2lzLCBmZW5jZSBzdHJpbmcgZm9yIGZlbmNlLCBldGMuXHJcbiAgICoqL1xyXG4gIHRoaXMubWFya3VwICAgPSAnJztcclxuXHJcbiAgLyoqXHJcbiAgICogVG9rZW4jaW5mbyAtPiBTdHJpbmdcclxuICAgKlxyXG4gICAqIGZlbmNlIGluZm9zdHJpbmdcclxuICAgKiovXHJcbiAgdGhpcy5pbmZvICAgICA9ICcnO1xyXG5cclxuICAvKipcclxuICAgKiBUb2tlbiNtZXRhIC0+IE9iamVjdFxyXG4gICAqXHJcbiAgICogQSBwbGFjZSBmb3IgcGx1Z2lucyB0byBzdG9yZSBhbiBhcmJpdHJhcnkgZGF0YVxyXG4gICAqKi9cclxuICB0aGlzLm1ldGEgICAgID0gbnVsbDtcclxuXHJcbiAgLyoqXHJcbiAgICogVG9rZW4jYmxvY2sgLT4gQm9vbGVhblxyXG4gICAqXHJcbiAgICogVHJ1ZSBmb3IgYmxvY2stbGV2ZWwgdG9rZW5zLCBmYWxzZSBmb3IgaW5saW5lIHRva2Vucy5cclxuICAgKiBVc2VkIGluIHJlbmRlcmVyIHRvIGNhbGN1bGF0ZSBsaW5lIGJyZWFrc1xyXG4gICAqKi9cclxuICB0aGlzLmJsb2NrICAgID0gZmFsc2U7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRva2VuI2hpZGRlbiAtPiBCb29sZWFuXHJcbiAgICpcclxuICAgKiBJZiBpdCdzIHRydWUsIGlnbm9yZSB0aGlzIGVsZW1lbnQgd2hlbiByZW5kZXJpbmcuIFVzZWQgZm9yIHRpZ2h0IGxpc3RzXHJcbiAgICogdG8gaGlkZSBwYXJhZ3JhcGhzLlxyXG4gICAqKi9cclxuICB0aGlzLmhpZGRlbiAgID0gZmFsc2U7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogVG9rZW4uYXR0ckluZGV4KG5hbWUpIC0+IE51bWJlclxyXG4gKlxyXG4gKiBTZWFyY2ggYXR0cmlidXRlIGluZGV4IGJ5IG5hbWUuXHJcbiAqKi9cclxuVG9rZW4ucHJvdG90eXBlLmF0dHJJbmRleCA9IGZ1bmN0aW9uIGF0dHJJbmRleChuYW1lKSB7XHJcbiAgdmFyIGF0dHJzLCBpLCBsZW47XHJcblxyXG4gIGlmICghdGhpcy5hdHRycykgeyByZXR1cm4gLTE7IH1cclxuXHJcbiAgYXR0cnMgPSB0aGlzLmF0dHJzO1xyXG5cclxuICBmb3IgKGkgPSAwLCBsZW4gPSBhdHRycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgaWYgKGF0dHJzW2ldWzBdID09PSBuYW1lKSB7IHJldHVybiBpOyB9XHJcbiAgfVxyXG4gIHJldHVybiAtMTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogVG9rZW4uYXR0clB1c2goYXR0ckRhdGEpXHJcbiAqXHJcbiAqIEFkZCBgWyBuYW1lLCB2YWx1ZSBdYCBhdHRyaWJ1dGUgdG8gbGlzdC4gSW5pdCBhdHRycyBpZiBuZWNlc3NhcnlcclxuICoqL1xyXG5Ub2tlbi5wcm90b3R5cGUuYXR0clB1c2ggPSBmdW5jdGlvbiBhdHRyUHVzaChhdHRyRGF0YSkge1xyXG4gIGlmICh0aGlzLmF0dHJzKSB7XHJcbiAgICB0aGlzLmF0dHJzLnB1c2goYXR0ckRhdGEpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLmF0dHJzID0gWyBhdHRyRGF0YSBdO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRva2VuO1xyXG5cclxufSx7fV0sNTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKGdsb2JhbCl7XHJcbi8qISBodHRwOi8vbXRocy5iZS9wdW55Y29kZSB2MS4yLjQgYnkgQG1hdGhpYXMgKi9cclxuOyhmdW5jdGlvbihyb290KSB7XHJcblxyXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cclxuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xyXG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcclxuXHRcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcclxuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xyXG5cdGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkge1xyXG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXHJcblx0ICogQG5hbWUgcHVueWNvZGVcclxuXHQgKiBAdHlwZSBPYmplY3RcclxuXHQgKi9cclxuXHR2YXIgcHVueWNvZGUsXHJcblxyXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cclxuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXHJcblxyXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cclxuXHRiYXNlID0gMzYsXHJcblx0dE1pbiA9IDEsXHJcblx0dE1heCA9IDI2LFxyXG5cdHNrZXcgPSAzOCxcclxuXHRkYW1wID0gNzAwLFxyXG5cdGluaXRpYWxCaWFzID0gNzIsXHJcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcclxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcclxuXHJcblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cclxuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcclxuXHRyZWdleE5vbkFTQ0lJID0gL1teIC1+XS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXHJcblx0cmVnZXhTZXBhcmF0b3JzID0gL1xceDJFfFxcdTMwMDJ8XFx1RkYwRXxcXHVGRjYxL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcclxuXHJcblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXHJcblx0ZXJyb3JzID0ge1xyXG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcclxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXHJcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xyXG5cdH0sXHJcblxyXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cclxuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXHJcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxyXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXHJcblxyXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cclxuXHRrZXk7XHJcblxyXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5cclxuXHQvKipcclxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxyXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cclxuXHQgKi9cclxuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XHJcblx0XHR0aHJvdyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XHJcblx0ICogaXRlbS5cclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xyXG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcclxuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xyXG5cdFx0XHRhcnJheVtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYXJyYXk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3MuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZS5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcclxuXHQgKiBjaGFyYWN0ZXIuXHJcblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcclxuXHQgKiBmdW5jdGlvbi5cclxuXHQgKi9cclxuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xyXG5cdFx0cmV0dXJuIG1hcChzdHJpbmcuc3BsaXQocmVnZXhTZXBhcmF0b3JzKSwgZm4pLmpvaW4oJy4nKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcclxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXHJcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcclxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcclxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXHJcblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXHJcblx0ICogQHNlZSA8aHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cclxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxyXG5cdCAqIEBuYW1lIGRlY29kZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXHJcblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XHJcblx0XHR2YXIgb3V0cHV0ID0gW10sXHJcblx0XHQgICAgY291bnRlciA9IDAsXHJcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcclxuXHRcdCAgICB2YWx1ZSxcclxuXHRcdCAgICBleHRyYTtcclxuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XHJcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcclxuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xyXG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcclxuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcclxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xyXG5cdFx0XHRcdFx0Y291bnRlci0tO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBvdXRwdXQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXHJcblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXHJcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcclxuXHQgKiBAbmFtZSBlbmNvZGVcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxyXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cclxuXHQgKi9cclxuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XHJcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XHJcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xyXG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XHJcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XHJcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xyXG5cdFx0XHR9XHJcblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xyXG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xyXG5cdFx0fSkuam9pbignJyk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXHJcblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXHJcblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXHJcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxyXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcclxuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XHJcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcclxuXHRcdH1cclxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XHJcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcclxuXHRcdH1cclxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XHJcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5NztcclxuXHRcdH1cclxuXHRcdHJldHVybiBiYXNlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxyXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cclxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxyXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXHJcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXHJcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcclxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xyXG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcclxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxyXG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXHJcblx0ICogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XHJcblx0XHR2YXIgayA9IDA7XHJcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xyXG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xyXG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcclxuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxyXG5cdCAqIHN5bWJvbHMuXHJcblx0ICogQG1lbWJlck9mIHB1bnljb2RlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxyXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cclxuXHQgKi9cclxuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcclxuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxyXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxyXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxyXG5cdFx0ICAgIG91dCxcclxuXHRcdCAgICBpID0gMCxcclxuXHRcdCAgICBuID0gaW5pdGlhbE4sXHJcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxyXG5cdFx0ICAgIGJhc2ljLFxyXG5cdFx0ICAgIGosXHJcblx0XHQgICAgaW5kZXgsXHJcblx0XHQgICAgb2xkaSxcclxuXHRcdCAgICB3LFxyXG5cdFx0ICAgIGssXHJcblx0XHQgICAgZGlnaXQsXHJcblx0XHQgICAgdCxcclxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cclxuXHRcdCAgICBiYXNlTWludXNUO1xyXG5cclxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxyXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcclxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxyXG5cclxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcclxuXHRcdGlmIChiYXNpYyA8IDApIHtcclxuXHRcdFx0YmFzaWMgPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XHJcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxyXG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XHJcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcclxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXHJcblxyXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcclxuXHJcblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cclxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxyXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xyXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxyXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XHJcblxyXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xyXG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xyXG5cclxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XHJcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xyXG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xyXG5cclxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcclxuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XHJcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xyXG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcclxuXHJcblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXHJcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XHJcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcclxuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcclxuXHRcdFx0aSAlPSBvdXQ7XHJcblxyXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XHJcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyB0byBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5XHJcblx0ICogc3ltYm9scy5cclxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXHJcblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xyXG5cdFx0dmFyIG4sXHJcblx0XHQgICAgZGVsdGEsXHJcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXHJcblx0XHQgICAgYmFzaWNMZW5ndGgsXHJcblx0XHQgICAgYmlhcyxcclxuXHRcdCAgICBqLFxyXG5cdFx0ICAgIG0sXHJcblx0XHQgICAgcSxcclxuXHRcdCAgICBrLFxyXG5cdFx0ICAgIHQsXHJcblx0XHQgICAgY3VycmVudFZhbHVlLFxyXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxyXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXHJcblx0XHQgICAgaW5wdXRMZW5ndGgsXHJcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXHJcblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxyXG5cdFx0ICAgIGJhc2VNaW51c1QsXHJcblx0XHQgICAgcU1pbnVzVDtcclxuXHJcblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXHJcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xyXG5cclxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcclxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xyXG5cclxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXHJcblx0XHRuID0gaW5pdGlhbE47XHJcblx0XHRkZWx0YSA9IDA7XHJcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XHJcblxyXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xyXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcclxuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XHJcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XHJcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XHJcblxyXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XHJcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXHJcblxyXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXHJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcclxuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XHJcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xyXG5cclxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxyXG5cdFx0XHQvLyBsYXJnZXIgb25lOlxyXG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xyXG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xyXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XHJcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxyXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xyXG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XHJcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XHJcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XHJcblx0XHRcdG4gPSBtO1xyXG5cclxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcclxuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcclxuXHJcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xyXG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcclxuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXHJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XHJcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xyXG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XHJcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcclxuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXHJcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxyXG5cdFx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcclxuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XHJcblx0XHRcdFx0XHRkZWx0YSA9IDA7XHJcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0KytkZWx0YTtcclxuXHRcdFx0KytuO1xyXG5cclxuXHRcdH1cclxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSB0byBVbmljb2RlLiBPbmx5IHRoZVxyXG5cdCAqIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS4gaXQgZG9lc24ndFxyXG5cdCAqIG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gY29udmVydGVkIHRvXHJcblx0ICogVW5pY29kZS5cclxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBQdW55Y29kZSBkb21haW4gbmFtZSB0byBjb252ZXJ0IHRvIFVuaWNvZGUuXHJcblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXHJcblx0ICogc3RyaW5nLlxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShkb21haW4pIHtcclxuXHRcdHJldHVybiBtYXBEb21haW4oZG9tYWluLCBmdW5jdGlvbihzdHJpbmcpIHtcclxuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXHJcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXHJcblx0XHRcdFx0OiBzdHJpbmc7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgdG8gUHVueWNvZGUuIE9ubHkgdGhlXHJcblx0ICogbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLiBpdCBkb2Vzbid0XHJcblx0ICogbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW4gQVNDSUkuXHJcblx0ICogQG1lbWJlck9mIHB1bnljb2RlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgdG8gY29udmVydCwgYXMgYSBVbmljb2RlIHN0cmluZy5cclxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lLlxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIHRvQVNDSUkoZG9tYWluKSB7XHJcblx0XHRyZXR1cm4gbWFwRG9tYWluKGRvbWFpbiwgZnVuY3Rpb24oc3RyaW5nKSB7XHJcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxyXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcclxuXHRcdFx0XHQ6IHN0cmluZztcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cclxuXHRwdW55Y29kZSA9IHtcclxuXHRcdC8qKlxyXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxyXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXHJcblx0XHQgKiBAdHlwZSBTdHJpbmdcclxuXHRcdCAqL1xyXG5cdFx0J3ZlcnNpb24nOiAnMS4yLjQnLFxyXG5cdFx0LyoqXHJcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cclxuXHRcdCAqIEBzZWUgPGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XHJcblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcclxuXHRcdCAqIEB0eXBlIE9iamVjdFxyXG5cdFx0ICovXHJcblx0XHQndWNzMic6IHtcclxuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXHJcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXHJcblx0XHR9LFxyXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcclxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXHJcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXHJcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXHJcblx0fTtcclxuXHJcblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXHJcblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXHJcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxyXG5cdGlmIChcclxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxyXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcclxuXHRcdGRlZmluZS5hbWRcclxuXHQpIHtcclxuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xyXG5cdFx0fSk7XHJcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcclxuXHRcdGlmIChmcmVlTW9kdWxlKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXHJcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xyXG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cclxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcclxuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXHJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XHJcblx0fVxyXG5cclxufSh0aGlzKSk7XHJcblxyXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxufSx7fV0sNTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cz17XCJBYWN1dGVcIjpcIlxcdTAwQzFcIixcImFhY3V0ZVwiOlwiXFx1MDBFMVwiLFwiQWJyZXZlXCI6XCJcXHUwMTAyXCIsXCJhYnJldmVcIjpcIlxcdTAxMDNcIixcImFjXCI6XCJcXHUyMjNFXCIsXCJhY2RcIjpcIlxcdTIyM0ZcIixcImFjRVwiOlwiXFx1MjIzRVxcdTAzMzNcIixcIkFjaXJjXCI6XCJcXHUwMEMyXCIsXCJhY2lyY1wiOlwiXFx1MDBFMlwiLFwiYWN1dGVcIjpcIlxcdTAwQjRcIixcIkFjeVwiOlwiXFx1MDQxMFwiLFwiYWN5XCI6XCJcXHUwNDMwXCIsXCJBRWxpZ1wiOlwiXFx1MDBDNlwiLFwiYWVsaWdcIjpcIlxcdTAwRTZcIixcImFmXCI6XCJcXHUyMDYxXCIsXCJBZnJcIjpcIlxcdUQ4MzVcXHVERDA0XCIsXCJhZnJcIjpcIlxcdUQ4MzVcXHVERDFFXCIsXCJBZ3JhdmVcIjpcIlxcdTAwQzBcIixcImFncmF2ZVwiOlwiXFx1MDBFMFwiLFwiYWxlZnN5bVwiOlwiXFx1MjEzNVwiLFwiYWxlcGhcIjpcIlxcdTIxMzVcIixcIkFscGhhXCI6XCJcXHUwMzkxXCIsXCJhbHBoYVwiOlwiXFx1MDNCMVwiLFwiQW1hY3JcIjpcIlxcdTAxMDBcIixcImFtYWNyXCI6XCJcXHUwMTAxXCIsXCJhbWFsZ1wiOlwiXFx1MkEzRlwiLFwiYW1wXCI6XCImXCIsXCJBTVBcIjpcIiZcIixcImFuZGFuZFwiOlwiXFx1MkE1NVwiLFwiQW5kXCI6XCJcXHUyQTUzXCIsXCJhbmRcIjpcIlxcdTIyMjdcIixcImFuZGRcIjpcIlxcdTJBNUNcIixcImFuZHNsb3BlXCI6XCJcXHUyQTU4XCIsXCJhbmR2XCI6XCJcXHUyQTVBXCIsXCJhbmdcIjpcIlxcdTIyMjBcIixcImFuZ2VcIjpcIlxcdTI5QTRcIixcImFuZ2xlXCI6XCJcXHUyMjIwXCIsXCJhbmdtc2RhYVwiOlwiXFx1MjlBOFwiLFwiYW5nbXNkYWJcIjpcIlxcdTI5QTlcIixcImFuZ21zZGFjXCI6XCJcXHUyOUFBXCIsXCJhbmdtc2RhZFwiOlwiXFx1MjlBQlwiLFwiYW5nbXNkYWVcIjpcIlxcdTI5QUNcIixcImFuZ21zZGFmXCI6XCJcXHUyOUFEXCIsXCJhbmdtc2RhZ1wiOlwiXFx1MjlBRVwiLFwiYW5nbXNkYWhcIjpcIlxcdTI5QUZcIixcImFuZ21zZFwiOlwiXFx1MjIyMVwiLFwiYW5ncnRcIjpcIlxcdTIyMUZcIixcImFuZ3J0dmJcIjpcIlxcdTIyQkVcIixcImFuZ3J0dmJkXCI6XCJcXHUyOTlEXCIsXCJhbmdzcGhcIjpcIlxcdTIyMjJcIixcImFuZ3N0XCI6XCJcXHUwMEM1XCIsXCJhbmd6YXJyXCI6XCJcXHUyMzdDXCIsXCJBb2dvblwiOlwiXFx1MDEwNFwiLFwiYW9nb25cIjpcIlxcdTAxMDVcIixcIkFvcGZcIjpcIlxcdUQ4MzVcXHVERDM4XCIsXCJhb3BmXCI6XCJcXHVEODM1XFx1REQ1MlwiLFwiYXBhY2lyXCI6XCJcXHUyQTZGXCIsXCJhcFwiOlwiXFx1MjI0OFwiLFwiYXBFXCI6XCJcXHUyQTcwXCIsXCJhcGVcIjpcIlxcdTIyNEFcIixcImFwaWRcIjpcIlxcdTIyNEJcIixcImFwb3NcIjpcIidcIixcIkFwcGx5RnVuY3Rpb25cIjpcIlxcdTIwNjFcIixcImFwcHJveFwiOlwiXFx1MjI0OFwiLFwiYXBwcm94ZXFcIjpcIlxcdTIyNEFcIixcIkFyaW5nXCI6XCJcXHUwMEM1XCIsXCJhcmluZ1wiOlwiXFx1MDBFNVwiLFwiQXNjclwiOlwiXFx1RDgzNVxcdURDOUNcIixcImFzY3JcIjpcIlxcdUQ4MzVcXHVEQ0I2XCIsXCJBc3NpZ25cIjpcIlxcdTIyNTRcIixcImFzdFwiOlwiKlwiLFwiYXN5bXBcIjpcIlxcdTIyNDhcIixcImFzeW1wZXFcIjpcIlxcdTIyNERcIixcIkF0aWxkZVwiOlwiXFx1MDBDM1wiLFwiYXRpbGRlXCI6XCJcXHUwMEUzXCIsXCJBdW1sXCI6XCJcXHUwMEM0XCIsXCJhdW1sXCI6XCJcXHUwMEU0XCIsXCJhd2NvbmludFwiOlwiXFx1MjIzM1wiLFwiYXdpbnRcIjpcIlxcdTJBMTFcIixcImJhY2tjb25nXCI6XCJcXHUyMjRDXCIsXCJiYWNrZXBzaWxvblwiOlwiXFx1MDNGNlwiLFwiYmFja3ByaW1lXCI6XCJcXHUyMDM1XCIsXCJiYWNrc2ltXCI6XCJcXHUyMjNEXCIsXCJiYWNrc2ltZXFcIjpcIlxcdTIyQ0RcIixcIkJhY2tzbGFzaFwiOlwiXFx1MjIxNlwiLFwiQmFydlwiOlwiXFx1MkFFN1wiLFwiYmFydmVlXCI6XCJcXHUyMkJEXCIsXCJiYXJ3ZWRcIjpcIlxcdTIzMDVcIixcIkJhcndlZFwiOlwiXFx1MjMwNlwiLFwiYmFyd2VkZ2VcIjpcIlxcdTIzMDVcIixcImJicmtcIjpcIlxcdTIzQjVcIixcImJicmt0YnJrXCI6XCJcXHUyM0I2XCIsXCJiY29uZ1wiOlwiXFx1MjI0Q1wiLFwiQmN5XCI6XCJcXHUwNDExXCIsXCJiY3lcIjpcIlxcdTA0MzFcIixcImJkcXVvXCI6XCJcXHUyMDFFXCIsXCJiZWNhdXNcIjpcIlxcdTIyMzVcIixcImJlY2F1c2VcIjpcIlxcdTIyMzVcIixcIkJlY2F1c2VcIjpcIlxcdTIyMzVcIixcImJlbXB0eXZcIjpcIlxcdTI5QjBcIixcImJlcHNpXCI6XCJcXHUwM0Y2XCIsXCJiZXJub3VcIjpcIlxcdTIxMkNcIixcIkJlcm5vdWxsaXNcIjpcIlxcdTIxMkNcIixcIkJldGFcIjpcIlxcdTAzOTJcIixcImJldGFcIjpcIlxcdTAzQjJcIixcImJldGhcIjpcIlxcdTIxMzZcIixcImJldHdlZW5cIjpcIlxcdTIyNkNcIixcIkJmclwiOlwiXFx1RDgzNVxcdUREMDVcIixcImJmclwiOlwiXFx1RDgzNVxcdUREMUZcIixcImJpZ2NhcFwiOlwiXFx1MjJDMlwiLFwiYmlnY2lyY1wiOlwiXFx1MjVFRlwiLFwiYmlnY3VwXCI6XCJcXHUyMkMzXCIsXCJiaWdvZG90XCI6XCJcXHUyQTAwXCIsXCJiaWdvcGx1c1wiOlwiXFx1MkEwMVwiLFwiYmlnb3RpbWVzXCI6XCJcXHUyQTAyXCIsXCJiaWdzcWN1cFwiOlwiXFx1MkEwNlwiLFwiYmlnc3RhclwiOlwiXFx1MjYwNVwiLFwiYmlndHJpYW5nbGVkb3duXCI6XCJcXHUyNUJEXCIsXCJiaWd0cmlhbmdsZXVwXCI6XCJcXHUyNUIzXCIsXCJiaWd1cGx1c1wiOlwiXFx1MkEwNFwiLFwiYmlndmVlXCI6XCJcXHUyMkMxXCIsXCJiaWd3ZWRnZVwiOlwiXFx1MjJDMFwiLFwiYmthcm93XCI6XCJcXHUyOTBEXCIsXCJibGFja2xvemVuZ2VcIjpcIlxcdTI5RUJcIixcImJsYWNrc3F1YXJlXCI6XCJcXHUyNUFBXCIsXCJibGFja3RyaWFuZ2xlXCI6XCJcXHUyNUI0XCIsXCJibGFja3RyaWFuZ2xlZG93blwiOlwiXFx1MjVCRVwiLFwiYmxhY2t0cmlhbmdsZWxlZnRcIjpcIlxcdTI1QzJcIixcImJsYWNrdHJpYW5nbGVyaWdodFwiOlwiXFx1MjVCOFwiLFwiYmxhbmtcIjpcIlxcdTI0MjNcIixcImJsazEyXCI6XCJcXHUyNTkyXCIsXCJibGsxNFwiOlwiXFx1MjU5MVwiLFwiYmxrMzRcIjpcIlxcdTI1OTNcIixcImJsb2NrXCI6XCJcXHUyNTg4XCIsXCJibmVcIjpcIj1cXHUyMEU1XCIsXCJibmVxdWl2XCI6XCJcXHUyMjYxXFx1MjBFNVwiLFwiYk5vdFwiOlwiXFx1MkFFRFwiLFwiYm5vdFwiOlwiXFx1MjMxMFwiLFwiQm9wZlwiOlwiXFx1RDgzNVxcdUREMzlcIixcImJvcGZcIjpcIlxcdUQ4MzVcXHVERDUzXCIsXCJib3RcIjpcIlxcdTIyQTVcIixcImJvdHRvbVwiOlwiXFx1MjJBNVwiLFwiYm93dGllXCI6XCJcXHUyMkM4XCIsXCJib3hib3hcIjpcIlxcdTI5QzlcIixcImJveGRsXCI6XCJcXHUyNTEwXCIsXCJib3hkTFwiOlwiXFx1MjU1NVwiLFwiYm94RGxcIjpcIlxcdTI1NTZcIixcImJveERMXCI6XCJcXHUyNTU3XCIsXCJib3hkclwiOlwiXFx1MjUwQ1wiLFwiYm94ZFJcIjpcIlxcdTI1NTJcIixcImJveERyXCI6XCJcXHUyNTUzXCIsXCJib3hEUlwiOlwiXFx1MjU1NFwiLFwiYm94aFwiOlwiXFx1MjUwMFwiLFwiYm94SFwiOlwiXFx1MjU1MFwiLFwiYm94aGRcIjpcIlxcdTI1MkNcIixcImJveEhkXCI6XCJcXHUyNTY0XCIsXCJib3hoRFwiOlwiXFx1MjU2NVwiLFwiYm94SERcIjpcIlxcdTI1NjZcIixcImJveGh1XCI6XCJcXHUyNTM0XCIsXCJib3hIdVwiOlwiXFx1MjU2N1wiLFwiYm94aFVcIjpcIlxcdTI1NjhcIixcImJveEhVXCI6XCJcXHUyNTY5XCIsXCJib3htaW51c1wiOlwiXFx1MjI5RlwiLFwiYm94cGx1c1wiOlwiXFx1MjI5RVwiLFwiYm94dGltZXNcIjpcIlxcdTIyQTBcIixcImJveHVsXCI6XCJcXHUyNTE4XCIsXCJib3h1TFwiOlwiXFx1MjU1QlwiLFwiYm94VWxcIjpcIlxcdTI1NUNcIixcImJveFVMXCI6XCJcXHUyNTVEXCIsXCJib3h1clwiOlwiXFx1MjUxNFwiLFwiYm94dVJcIjpcIlxcdTI1NThcIixcImJveFVyXCI6XCJcXHUyNTU5XCIsXCJib3hVUlwiOlwiXFx1MjU1QVwiLFwiYm94dlwiOlwiXFx1MjUwMlwiLFwiYm94VlwiOlwiXFx1MjU1MVwiLFwiYm94dmhcIjpcIlxcdTI1M0NcIixcImJveHZIXCI6XCJcXHUyNTZBXCIsXCJib3hWaFwiOlwiXFx1MjU2QlwiLFwiYm94VkhcIjpcIlxcdTI1NkNcIixcImJveHZsXCI6XCJcXHUyNTI0XCIsXCJib3h2TFwiOlwiXFx1MjU2MVwiLFwiYm94VmxcIjpcIlxcdTI1NjJcIixcImJveFZMXCI6XCJcXHUyNTYzXCIsXCJib3h2clwiOlwiXFx1MjUxQ1wiLFwiYm94dlJcIjpcIlxcdTI1NUVcIixcImJveFZyXCI6XCJcXHUyNTVGXCIsXCJib3hWUlwiOlwiXFx1MjU2MFwiLFwiYnByaW1lXCI6XCJcXHUyMDM1XCIsXCJicmV2ZVwiOlwiXFx1MDJEOFwiLFwiQnJldmVcIjpcIlxcdTAyRDhcIixcImJydmJhclwiOlwiXFx1MDBBNlwiLFwiYnNjclwiOlwiXFx1RDgzNVxcdURDQjdcIixcIkJzY3JcIjpcIlxcdTIxMkNcIixcImJzZW1pXCI6XCJcXHUyMDRGXCIsXCJic2ltXCI6XCJcXHUyMjNEXCIsXCJic2ltZVwiOlwiXFx1MjJDRFwiLFwiYnNvbGJcIjpcIlxcdTI5QzVcIixcImJzb2xcIjpcIlxcXFxcIixcImJzb2xoc3ViXCI6XCJcXHUyN0M4XCIsXCJidWxsXCI6XCJcXHUyMDIyXCIsXCJidWxsZXRcIjpcIlxcdTIwMjJcIixcImJ1bXBcIjpcIlxcdTIyNEVcIixcImJ1bXBFXCI6XCJcXHUyQUFFXCIsXCJidW1wZVwiOlwiXFx1MjI0RlwiLFwiQnVtcGVxXCI6XCJcXHUyMjRFXCIsXCJidW1wZXFcIjpcIlxcdTIyNEZcIixcIkNhY3V0ZVwiOlwiXFx1MDEwNlwiLFwiY2FjdXRlXCI6XCJcXHUwMTA3XCIsXCJjYXBhbmRcIjpcIlxcdTJBNDRcIixcImNhcGJyY3VwXCI6XCJcXHUyQTQ5XCIsXCJjYXBjYXBcIjpcIlxcdTJBNEJcIixcImNhcFwiOlwiXFx1MjIyOVwiLFwiQ2FwXCI6XCJcXHUyMkQyXCIsXCJjYXBjdXBcIjpcIlxcdTJBNDdcIixcImNhcGRvdFwiOlwiXFx1MkE0MFwiLFwiQ2FwaXRhbERpZmZlcmVudGlhbERcIjpcIlxcdTIxNDVcIixcImNhcHNcIjpcIlxcdTIyMjlcXHVGRTAwXCIsXCJjYXJldFwiOlwiXFx1MjA0MVwiLFwiY2Fyb25cIjpcIlxcdTAyQzdcIixcIkNheWxleXNcIjpcIlxcdTIxMkRcIixcImNjYXBzXCI6XCJcXHUyQTREXCIsXCJDY2Fyb25cIjpcIlxcdTAxMENcIixcImNjYXJvblwiOlwiXFx1MDEwRFwiLFwiQ2NlZGlsXCI6XCJcXHUwMEM3XCIsXCJjY2VkaWxcIjpcIlxcdTAwRTdcIixcIkNjaXJjXCI6XCJcXHUwMTA4XCIsXCJjY2lyY1wiOlwiXFx1MDEwOVwiLFwiQ2NvbmludFwiOlwiXFx1MjIzMFwiLFwiY2N1cHNcIjpcIlxcdTJBNENcIixcImNjdXBzc21cIjpcIlxcdTJBNTBcIixcIkNkb3RcIjpcIlxcdTAxMEFcIixcImNkb3RcIjpcIlxcdTAxMEJcIixcImNlZGlsXCI6XCJcXHUwMEI4XCIsXCJDZWRpbGxhXCI6XCJcXHUwMEI4XCIsXCJjZW1wdHl2XCI6XCJcXHUyOUIyXCIsXCJjZW50XCI6XCJcXHUwMEEyXCIsXCJjZW50ZXJkb3RcIjpcIlxcdTAwQjdcIixcIkNlbnRlckRvdFwiOlwiXFx1MDBCN1wiLFwiY2ZyXCI6XCJcXHVEODM1XFx1REQyMFwiLFwiQ2ZyXCI6XCJcXHUyMTJEXCIsXCJDSGN5XCI6XCJcXHUwNDI3XCIsXCJjaGN5XCI6XCJcXHUwNDQ3XCIsXCJjaGVja1wiOlwiXFx1MjcxM1wiLFwiY2hlY2ttYXJrXCI6XCJcXHUyNzEzXCIsXCJDaGlcIjpcIlxcdTAzQTdcIixcImNoaVwiOlwiXFx1MDNDN1wiLFwiY2lyY1wiOlwiXFx1MDJDNlwiLFwiY2lyY2VxXCI6XCJcXHUyMjU3XCIsXCJjaXJjbGVhcnJvd2xlZnRcIjpcIlxcdTIxQkFcIixcImNpcmNsZWFycm93cmlnaHRcIjpcIlxcdTIxQkJcIixcImNpcmNsZWRhc3RcIjpcIlxcdTIyOUJcIixcImNpcmNsZWRjaXJjXCI6XCJcXHUyMjlBXCIsXCJjaXJjbGVkZGFzaFwiOlwiXFx1MjI5RFwiLFwiQ2lyY2xlRG90XCI6XCJcXHUyMjk5XCIsXCJjaXJjbGVkUlwiOlwiXFx1MDBBRVwiLFwiY2lyY2xlZFNcIjpcIlxcdTI0QzhcIixcIkNpcmNsZU1pbnVzXCI6XCJcXHUyMjk2XCIsXCJDaXJjbGVQbHVzXCI6XCJcXHUyMjk1XCIsXCJDaXJjbGVUaW1lc1wiOlwiXFx1MjI5N1wiLFwiY2lyXCI6XCJcXHUyNUNCXCIsXCJjaXJFXCI6XCJcXHUyOUMzXCIsXCJjaXJlXCI6XCJcXHUyMjU3XCIsXCJjaXJmbmludFwiOlwiXFx1MkExMFwiLFwiY2lybWlkXCI6XCJcXHUyQUVGXCIsXCJjaXJzY2lyXCI6XCJcXHUyOUMyXCIsXCJDbG9ja3dpc2VDb250b3VySW50ZWdyYWxcIjpcIlxcdTIyMzJcIixcIkNsb3NlQ3VybHlEb3VibGVRdW90ZVwiOlwiXFx1MjAxRFwiLFwiQ2xvc2VDdXJseVF1b3RlXCI6XCJcXHUyMDE5XCIsXCJjbHVic1wiOlwiXFx1MjY2M1wiLFwiY2x1YnN1aXRcIjpcIlxcdTI2NjNcIixcImNvbG9uXCI6XCI6XCIsXCJDb2xvblwiOlwiXFx1MjIzN1wiLFwiQ29sb25lXCI6XCJcXHUyQTc0XCIsXCJjb2xvbmVcIjpcIlxcdTIyNTRcIixcImNvbG9uZXFcIjpcIlxcdTIyNTRcIixcImNvbW1hXCI6XCIsXCIsXCJjb21tYXRcIjpcIkBcIixcImNvbXBcIjpcIlxcdTIyMDFcIixcImNvbXBmblwiOlwiXFx1MjIxOFwiLFwiY29tcGxlbWVudFwiOlwiXFx1MjIwMVwiLFwiY29tcGxleGVzXCI6XCJcXHUyMTAyXCIsXCJjb25nXCI6XCJcXHUyMjQ1XCIsXCJjb25nZG90XCI6XCJcXHUyQTZEXCIsXCJDb25ncnVlbnRcIjpcIlxcdTIyNjFcIixcImNvbmludFwiOlwiXFx1MjIyRVwiLFwiQ29uaW50XCI6XCJcXHUyMjJGXCIsXCJDb250b3VySW50ZWdyYWxcIjpcIlxcdTIyMkVcIixcImNvcGZcIjpcIlxcdUQ4MzVcXHVERDU0XCIsXCJDb3BmXCI6XCJcXHUyMTAyXCIsXCJjb3Byb2RcIjpcIlxcdTIyMTBcIixcIkNvcHJvZHVjdFwiOlwiXFx1MjIxMFwiLFwiY29weVwiOlwiXFx1MDBBOVwiLFwiQ09QWVwiOlwiXFx1MDBBOVwiLFwiY29weXNyXCI6XCJcXHUyMTE3XCIsXCJDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsXCI6XCJcXHUyMjMzXCIsXCJjcmFyclwiOlwiXFx1MjFCNVwiLFwiY3Jvc3NcIjpcIlxcdTI3MTdcIixcIkNyb3NzXCI6XCJcXHUyQTJGXCIsXCJDc2NyXCI6XCJcXHVEODM1XFx1REM5RVwiLFwiY3NjclwiOlwiXFx1RDgzNVxcdURDQjhcIixcImNzdWJcIjpcIlxcdTJBQ0ZcIixcImNzdWJlXCI6XCJcXHUyQUQxXCIsXCJjc3VwXCI6XCJcXHUyQUQwXCIsXCJjc3VwZVwiOlwiXFx1MkFEMlwiLFwiY3Rkb3RcIjpcIlxcdTIyRUZcIixcImN1ZGFycmxcIjpcIlxcdTI5MzhcIixcImN1ZGFycnJcIjpcIlxcdTI5MzVcIixcImN1ZXByXCI6XCJcXHUyMkRFXCIsXCJjdWVzY1wiOlwiXFx1MjJERlwiLFwiY3VsYXJyXCI6XCJcXHUyMUI2XCIsXCJjdWxhcnJwXCI6XCJcXHUyOTNEXCIsXCJjdXBicmNhcFwiOlwiXFx1MkE0OFwiLFwiY3VwY2FwXCI6XCJcXHUyQTQ2XCIsXCJDdXBDYXBcIjpcIlxcdTIyNERcIixcImN1cFwiOlwiXFx1MjIyQVwiLFwiQ3VwXCI6XCJcXHUyMkQzXCIsXCJjdXBjdXBcIjpcIlxcdTJBNEFcIixcImN1cGRvdFwiOlwiXFx1MjI4RFwiLFwiY3Vwb3JcIjpcIlxcdTJBNDVcIixcImN1cHNcIjpcIlxcdTIyMkFcXHVGRTAwXCIsXCJjdXJhcnJcIjpcIlxcdTIxQjdcIixcImN1cmFycm1cIjpcIlxcdTI5M0NcIixcImN1cmx5ZXFwcmVjXCI6XCJcXHUyMkRFXCIsXCJjdXJseWVxc3VjY1wiOlwiXFx1MjJERlwiLFwiY3VybHl2ZWVcIjpcIlxcdTIyQ0VcIixcImN1cmx5d2VkZ2VcIjpcIlxcdTIyQ0ZcIixcImN1cnJlblwiOlwiXFx1MDBBNFwiLFwiY3VydmVhcnJvd2xlZnRcIjpcIlxcdTIxQjZcIixcImN1cnZlYXJyb3dyaWdodFwiOlwiXFx1MjFCN1wiLFwiY3V2ZWVcIjpcIlxcdTIyQ0VcIixcImN1d2VkXCI6XCJcXHUyMkNGXCIsXCJjd2NvbmludFwiOlwiXFx1MjIzMlwiLFwiY3dpbnRcIjpcIlxcdTIyMzFcIixcImN5bGN0eVwiOlwiXFx1MjMyRFwiLFwiZGFnZ2VyXCI6XCJcXHUyMDIwXCIsXCJEYWdnZXJcIjpcIlxcdTIwMjFcIixcImRhbGV0aFwiOlwiXFx1MjEzOFwiLFwiZGFyclwiOlwiXFx1MjE5M1wiLFwiRGFyclwiOlwiXFx1MjFBMVwiLFwiZEFyclwiOlwiXFx1MjFEM1wiLFwiZGFzaFwiOlwiXFx1MjAxMFwiLFwiRGFzaHZcIjpcIlxcdTJBRTRcIixcImRhc2h2XCI6XCJcXHUyMkEzXCIsXCJkYmthcm93XCI6XCJcXHUyOTBGXCIsXCJkYmxhY1wiOlwiXFx1MDJERFwiLFwiRGNhcm9uXCI6XCJcXHUwMTBFXCIsXCJkY2Fyb25cIjpcIlxcdTAxMEZcIixcIkRjeVwiOlwiXFx1MDQxNFwiLFwiZGN5XCI6XCJcXHUwNDM0XCIsXCJkZGFnZ2VyXCI6XCJcXHUyMDIxXCIsXCJkZGFyclwiOlwiXFx1MjFDQVwiLFwiRERcIjpcIlxcdTIxNDVcIixcImRkXCI6XCJcXHUyMTQ2XCIsXCJERG90cmFoZFwiOlwiXFx1MjkxMVwiLFwiZGRvdHNlcVwiOlwiXFx1MkE3N1wiLFwiZGVnXCI6XCJcXHUwMEIwXCIsXCJEZWxcIjpcIlxcdTIyMDdcIixcIkRlbHRhXCI6XCJcXHUwMzk0XCIsXCJkZWx0YVwiOlwiXFx1MDNCNFwiLFwiZGVtcHR5dlwiOlwiXFx1MjlCMVwiLFwiZGZpc2h0XCI6XCJcXHUyOTdGXCIsXCJEZnJcIjpcIlxcdUQ4MzVcXHVERDA3XCIsXCJkZnJcIjpcIlxcdUQ4MzVcXHVERDIxXCIsXCJkSGFyXCI6XCJcXHUyOTY1XCIsXCJkaGFybFwiOlwiXFx1MjFDM1wiLFwiZGhhcnJcIjpcIlxcdTIxQzJcIixcIkRpYWNyaXRpY2FsQWN1dGVcIjpcIlxcdTAwQjRcIixcIkRpYWNyaXRpY2FsRG90XCI6XCJcXHUwMkQ5XCIsXCJEaWFjcml0aWNhbERvdWJsZUFjdXRlXCI6XCJcXHUwMkREXCIsXCJEaWFjcml0aWNhbEdyYXZlXCI6XCJgXCIsXCJEaWFjcml0aWNhbFRpbGRlXCI6XCJcXHUwMkRDXCIsXCJkaWFtXCI6XCJcXHUyMkM0XCIsXCJkaWFtb25kXCI6XCJcXHUyMkM0XCIsXCJEaWFtb25kXCI6XCJcXHUyMkM0XCIsXCJkaWFtb25kc3VpdFwiOlwiXFx1MjY2NlwiLFwiZGlhbXNcIjpcIlxcdTI2NjZcIixcImRpZVwiOlwiXFx1MDBBOFwiLFwiRGlmZmVyZW50aWFsRFwiOlwiXFx1MjE0NlwiLFwiZGlnYW1tYVwiOlwiXFx1MDNERFwiLFwiZGlzaW5cIjpcIlxcdTIyRjJcIixcImRpdlwiOlwiXFx1MDBGN1wiLFwiZGl2aWRlXCI6XCJcXHUwMEY3XCIsXCJkaXZpZGVvbnRpbWVzXCI6XCJcXHUyMkM3XCIsXCJkaXZvbnhcIjpcIlxcdTIyQzdcIixcIkRKY3lcIjpcIlxcdTA0MDJcIixcImRqY3lcIjpcIlxcdTA0NTJcIixcImRsY29yblwiOlwiXFx1MjMxRVwiLFwiZGxjcm9wXCI6XCJcXHUyMzBEXCIsXCJkb2xsYXJcIjpcIiRcIixcIkRvcGZcIjpcIlxcdUQ4MzVcXHVERDNCXCIsXCJkb3BmXCI6XCJcXHVEODM1XFx1REQ1NVwiLFwiRG90XCI6XCJcXHUwMEE4XCIsXCJkb3RcIjpcIlxcdTAyRDlcIixcIkRvdERvdFwiOlwiXFx1MjBEQ1wiLFwiZG90ZXFcIjpcIlxcdTIyNTBcIixcImRvdGVxZG90XCI6XCJcXHUyMjUxXCIsXCJEb3RFcXVhbFwiOlwiXFx1MjI1MFwiLFwiZG90bWludXNcIjpcIlxcdTIyMzhcIixcImRvdHBsdXNcIjpcIlxcdTIyMTRcIixcImRvdHNxdWFyZVwiOlwiXFx1MjJBMVwiLFwiZG91YmxlYmFyd2VkZ2VcIjpcIlxcdTIzMDZcIixcIkRvdWJsZUNvbnRvdXJJbnRlZ3JhbFwiOlwiXFx1MjIyRlwiLFwiRG91YmxlRG90XCI6XCJcXHUwMEE4XCIsXCJEb3VibGVEb3duQXJyb3dcIjpcIlxcdTIxRDNcIixcIkRvdWJsZUxlZnRBcnJvd1wiOlwiXFx1MjFEMFwiLFwiRG91YmxlTGVmdFJpZ2h0QXJyb3dcIjpcIlxcdTIxRDRcIixcIkRvdWJsZUxlZnRUZWVcIjpcIlxcdTJBRTRcIixcIkRvdWJsZUxvbmdMZWZ0QXJyb3dcIjpcIlxcdTI3RjhcIixcIkRvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvd1wiOlwiXFx1MjdGQVwiLFwiRG91YmxlTG9uZ1JpZ2h0QXJyb3dcIjpcIlxcdTI3RjlcIixcIkRvdWJsZVJpZ2h0QXJyb3dcIjpcIlxcdTIxRDJcIixcIkRvdWJsZVJpZ2h0VGVlXCI6XCJcXHUyMkE4XCIsXCJEb3VibGVVcEFycm93XCI6XCJcXHUyMUQxXCIsXCJEb3VibGVVcERvd25BcnJvd1wiOlwiXFx1MjFENVwiLFwiRG91YmxlVmVydGljYWxCYXJcIjpcIlxcdTIyMjVcIixcIkRvd25BcnJvd0JhclwiOlwiXFx1MjkxM1wiLFwiZG93bmFycm93XCI6XCJcXHUyMTkzXCIsXCJEb3duQXJyb3dcIjpcIlxcdTIxOTNcIixcIkRvd25hcnJvd1wiOlwiXFx1MjFEM1wiLFwiRG93bkFycm93VXBBcnJvd1wiOlwiXFx1MjFGNVwiLFwiRG93bkJyZXZlXCI6XCJcXHUwMzExXCIsXCJkb3duZG93bmFycm93c1wiOlwiXFx1MjFDQVwiLFwiZG93bmhhcnBvb25sZWZ0XCI6XCJcXHUyMUMzXCIsXCJkb3duaGFycG9vbnJpZ2h0XCI6XCJcXHUyMUMyXCIsXCJEb3duTGVmdFJpZ2h0VmVjdG9yXCI6XCJcXHUyOTUwXCIsXCJEb3duTGVmdFRlZVZlY3RvclwiOlwiXFx1Mjk1RVwiLFwiRG93bkxlZnRWZWN0b3JCYXJcIjpcIlxcdTI5NTZcIixcIkRvd25MZWZ0VmVjdG9yXCI6XCJcXHUyMUJEXCIsXCJEb3duUmlnaHRUZWVWZWN0b3JcIjpcIlxcdTI5NUZcIixcIkRvd25SaWdodFZlY3RvckJhclwiOlwiXFx1Mjk1N1wiLFwiRG93blJpZ2h0VmVjdG9yXCI6XCJcXHUyMUMxXCIsXCJEb3duVGVlQXJyb3dcIjpcIlxcdTIxQTdcIixcIkRvd25UZWVcIjpcIlxcdTIyQTRcIixcImRyYmthcm93XCI6XCJcXHUyOTEwXCIsXCJkcmNvcm5cIjpcIlxcdTIzMUZcIixcImRyY3JvcFwiOlwiXFx1MjMwQ1wiLFwiRHNjclwiOlwiXFx1RDgzNVxcdURDOUZcIixcImRzY3JcIjpcIlxcdUQ4MzVcXHVEQ0I5XCIsXCJEU2N5XCI6XCJcXHUwNDA1XCIsXCJkc2N5XCI6XCJcXHUwNDU1XCIsXCJkc29sXCI6XCJcXHUyOUY2XCIsXCJEc3Ryb2tcIjpcIlxcdTAxMTBcIixcImRzdHJva1wiOlwiXFx1MDExMVwiLFwiZHRkb3RcIjpcIlxcdTIyRjFcIixcImR0cmlcIjpcIlxcdTI1QkZcIixcImR0cmlmXCI6XCJcXHUyNUJFXCIsXCJkdWFyclwiOlwiXFx1MjFGNVwiLFwiZHVoYXJcIjpcIlxcdTI5NkZcIixcImR3YW5nbGVcIjpcIlxcdTI5QTZcIixcIkRaY3lcIjpcIlxcdTA0MEZcIixcImR6Y3lcIjpcIlxcdTA0NUZcIixcImR6aWdyYXJyXCI6XCJcXHUyN0ZGXCIsXCJFYWN1dGVcIjpcIlxcdTAwQzlcIixcImVhY3V0ZVwiOlwiXFx1MDBFOVwiLFwiZWFzdGVyXCI6XCJcXHUyQTZFXCIsXCJFY2Fyb25cIjpcIlxcdTAxMUFcIixcImVjYXJvblwiOlwiXFx1MDExQlwiLFwiRWNpcmNcIjpcIlxcdTAwQ0FcIixcImVjaXJjXCI6XCJcXHUwMEVBXCIsXCJlY2lyXCI6XCJcXHUyMjU2XCIsXCJlY29sb25cIjpcIlxcdTIyNTVcIixcIkVjeVwiOlwiXFx1MDQyRFwiLFwiZWN5XCI6XCJcXHUwNDREXCIsXCJlRERvdFwiOlwiXFx1MkE3N1wiLFwiRWRvdFwiOlwiXFx1MDExNlwiLFwiZWRvdFwiOlwiXFx1MDExN1wiLFwiZURvdFwiOlwiXFx1MjI1MVwiLFwiZWVcIjpcIlxcdTIxNDdcIixcImVmRG90XCI6XCJcXHUyMjUyXCIsXCJFZnJcIjpcIlxcdUQ4MzVcXHVERDA4XCIsXCJlZnJcIjpcIlxcdUQ4MzVcXHVERDIyXCIsXCJlZ1wiOlwiXFx1MkE5QVwiLFwiRWdyYXZlXCI6XCJcXHUwMEM4XCIsXCJlZ3JhdmVcIjpcIlxcdTAwRThcIixcImVnc1wiOlwiXFx1MkE5NlwiLFwiZWdzZG90XCI6XCJcXHUyQTk4XCIsXCJlbFwiOlwiXFx1MkE5OVwiLFwiRWxlbWVudFwiOlwiXFx1MjIwOFwiLFwiZWxpbnRlcnNcIjpcIlxcdTIzRTdcIixcImVsbFwiOlwiXFx1MjExM1wiLFwiZWxzXCI6XCJcXHUyQTk1XCIsXCJlbHNkb3RcIjpcIlxcdTJBOTdcIixcIkVtYWNyXCI6XCJcXHUwMTEyXCIsXCJlbWFjclwiOlwiXFx1MDExM1wiLFwiZW1wdHlcIjpcIlxcdTIyMDVcIixcImVtcHR5c2V0XCI6XCJcXHUyMjA1XCIsXCJFbXB0eVNtYWxsU3F1YXJlXCI6XCJcXHUyNUZCXCIsXCJlbXB0eXZcIjpcIlxcdTIyMDVcIixcIkVtcHR5VmVyeVNtYWxsU3F1YXJlXCI6XCJcXHUyNUFCXCIsXCJlbXNwMTNcIjpcIlxcdTIwMDRcIixcImVtc3AxNFwiOlwiXFx1MjAwNVwiLFwiZW1zcFwiOlwiXFx1MjAwM1wiLFwiRU5HXCI6XCJcXHUwMTRBXCIsXCJlbmdcIjpcIlxcdTAxNEJcIixcImVuc3BcIjpcIlxcdTIwMDJcIixcIkVvZ29uXCI6XCJcXHUwMTE4XCIsXCJlb2dvblwiOlwiXFx1MDExOVwiLFwiRW9wZlwiOlwiXFx1RDgzNVxcdUREM0NcIixcImVvcGZcIjpcIlxcdUQ4MzVcXHVERDU2XCIsXCJlcGFyXCI6XCJcXHUyMkQ1XCIsXCJlcGFyc2xcIjpcIlxcdTI5RTNcIixcImVwbHVzXCI6XCJcXHUyQTcxXCIsXCJlcHNpXCI6XCJcXHUwM0I1XCIsXCJFcHNpbG9uXCI6XCJcXHUwMzk1XCIsXCJlcHNpbG9uXCI6XCJcXHUwM0I1XCIsXCJlcHNpdlwiOlwiXFx1MDNGNVwiLFwiZXFjaXJjXCI6XCJcXHUyMjU2XCIsXCJlcWNvbG9uXCI6XCJcXHUyMjU1XCIsXCJlcXNpbVwiOlwiXFx1MjI0MlwiLFwiZXFzbGFudGd0clwiOlwiXFx1MkE5NlwiLFwiZXFzbGFudGxlc3NcIjpcIlxcdTJBOTVcIixcIkVxdWFsXCI6XCJcXHUyQTc1XCIsXCJlcXVhbHNcIjpcIj1cIixcIkVxdWFsVGlsZGVcIjpcIlxcdTIyNDJcIixcImVxdWVzdFwiOlwiXFx1MjI1RlwiLFwiRXF1aWxpYnJpdW1cIjpcIlxcdTIxQ0NcIixcImVxdWl2XCI6XCJcXHUyMjYxXCIsXCJlcXVpdkREXCI6XCJcXHUyQTc4XCIsXCJlcXZwYXJzbFwiOlwiXFx1MjlFNVwiLFwiZXJhcnJcIjpcIlxcdTI5NzFcIixcImVyRG90XCI6XCJcXHUyMjUzXCIsXCJlc2NyXCI6XCJcXHUyMTJGXCIsXCJFc2NyXCI6XCJcXHUyMTMwXCIsXCJlc2RvdFwiOlwiXFx1MjI1MFwiLFwiRXNpbVwiOlwiXFx1MkE3M1wiLFwiZXNpbVwiOlwiXFx1MjI0MlwiLFwiRXRhXCI6XCJcXHUwMzk3XCIsXCJldGFcIjpcIlxcdTAzQjdcIixcIkVUSFwiOlwiXFx1MDBEMFwiLFwiZXRoXCI6XCJcXHUwMEYwXCIsXCJFdW1sXCI6XCJcXHUwMENCXCIsXCJldW1sXCI6XCJcXHUwMEVCXCIsXCJldXJvXCI6XCJcXHUyMEFDXCIsXCJleGNsXCI6XCIhXCIsXCJleGlzdFwiOlwiXFx1MjIwM1wiLFwiRXhpc3RzXCI6XCJcXHUyMjAzXCIsXCJleHBlY3RhdGlvblwiOlwiXFx1MjEzMFwiLFwiZXhwb25lbnRpYWxlXCI6XCJcXHUyMTQ3XCIsXCJFeHBvbmVudGlhbEVcIjpcIlxcdTIxNDdcIixcImZhbGxpbmdkb3RzZXFcIjpcIlxcdTIyNTJcIixcIkZjeVwiOlwiXFx1MDQyNFwiLFwiZmN5XCI6XCJcXHUwNDQ0XCIsXCJmZW1hbGVcIjpcIlxcdTI2NDBcIixcImZmaWxpZ1wiOlwiXFx1RkIwM1wiLFwiZmZsaWdcIjpcIlxcdUZCMDBcIixcImZmbGxpZ1wiOlwiXFx1RkIwNFwiLFwiRmZyXCI6XCJcXHVEODM1XFx1REQwOVwiLFwiZmZyXCI6XCJcXHVEODM1XFx1REQyM1wiLFwiZmlsaWdcIjpcIlxcdUZCMDFcIixcIkZpbGxlZFNtYWxsU3F1YXJlXCI6XCJcXHUyNUZDXCIsXCJGaWxsZWRWZXJ5U21hbGxTcXVhcmVcIjpcIlxcdTI1QUFcIixcImZqbGlnXCI6XCJmalwiLFwiZmxhdFwiOlwiXFx1MjY2RFwiLFwiZmxsaWdcIjpcIlxcdUZCMDJcIixcImZsdG5zXCI6XCJcXHUyNUIxXCIsXCJmbm9mXCI6XCJcXHUwMTkyXCIsXCJGb3BmXCI6XCJcXHVEODM1XFx1REQzRFwiLFwiZm9wZlwiOlwiXFx1RDgzNVxcdURENTdcIixcImZvcmFsbFwiOlwiXFx1MjIwMFwiLFwiRm9yQWxsXCI6XCJcXHUyMjAwXCIsXCJmb3JrXCI6XCJcXHUyMkQ0XCIsXCJmb3JrdlwiOlwiXFx1MkFEOVwiLFwiRm91cmllcnRyZlwiOlwiXFx1MjEzMVwiLFwiZnBhcnRpbnRcIjpcIlxcdTJBMERcIixcImZyYWMxMlwiOlwiXFx1MDBCRFwiLFwiZnJhYzEzXCI6XCJcXHUyMTUzXCIsXCJmcmFjMTRcIjpcIlxcdTAwQkNcIixcImZyYWMxNVwiOlwiXFx1MjE1NVwiLFwiZnJhYzE2XCI6XCJcXHUyMTU5XCIsXCJmcmFjMThcIjpcIlxcdTIxNUJcIixcImZyYWMyM1wiOlwiXFx1MjE1NFwiLFwiZnJhYzI1XCI6XCJcXHUyMTU2XCIsXCJmcmFjMzRcIjpcIlxcdTAwQkVcIixcImZyYWMzNVwiOlwiXFx1MjE1N1wiLFwiZnJhYzM4XCI6XCJcXHUyMTVDXCIsXCJmcmFjNDVcIjpcIlxcdTIxNThcIixcImZyYWM1NlwiOlwiXFx1MjE1QVwiLFwiZnJhYzU4XCI6XCJcXHUyMTVEXCIsXCJmcmFjNzhcIjpcIlxcdTIxNUVcIixcImZyYXNsXCI6XCJcXHUyMDQ0XCIsXCJmcm93blwiOlwiXFx1MjMyMlwiLFwiZnNjclwiOlwiXFx1RDgzNVxcdURDQkJcIixcIkZzY3JcIjpcIlxcdTIxMzFcIixcImdhY3V0ZVwiOlwiXFx1MDFGNVwiLFwiR2FtbWFcIjpcIlxcdTAzOTNcIixcImdhbW1hXCI6XCJcXHUwM0IzXCIsXCJHYW1tYWRcIjpcIlxcdTAzRENcIixcImdhbW1hZFwiOlwiXFx1MDNERFwiLFwiZ2FwXCI6XCJcXHUyQTg2XCIsXCJHYnJldmVcIjpcIlxcdTAxMUVcIixcImdicmV2ZVwiOlwiXFx1MDExRlwiLFwiR2NlZGlsXCI6XCJcXHUwMTIyXCIsXCJHY2lyY1wiOlwiXFx1MDExQ1wiLFwiZ2NpcmNcIjpcIlxcdTAxMURcIixcIkdjeVwiOlwiXFx1MDQxM1wiLFwiZ2N5XCI6XCJcXHUwNDMzXCIsXCJHZG90XCI6XCJcXHUwMTIwXCIsXCJnZG90XCI6XCJcXHUwMTIxXCIsXCJnZVwiOlwiXFx1MjI2NVwiLFwiZ0VcIjpcIlxcdTIyNjdcIixcImdFbFwiOlwiXFx1MkE4Q1wiLFwiZ2VsXCI6XCJcXHUyMkRCXCIsXCJnZXFcIjpcIlxcdTIyNjVcIixcImdlcXFcIjpcIlxcdTIyNjdcIixcImdlcXNsYW50XCI6XCJcXHUyQTdFXCIsXCJnZXNjY1wiOlwiXFx1MkFBOVwiLFwiZ2VzXCI6XCJcXHUyQTdFXCIsXCJnZXNkb3RcIjpcIlxcdTJBODBcIixcImdlc2RvdG9cIjpcIlxcdTJBODJcIixcImdlc2RvdG9sXCI6XCJcXHUyQTg0XCIsXCJnZXNsXCI6XCJcXHUyMkRCXFx1RkUwMFwiLFwiZ2VzbGVzXCI6XCJcXHUyQTk0XCIsXCJHZnJcIjpcIlxcdUQ4MzVcXHVERDBBXCIsXCJnZnJcIjpcIlxcdUQ4MzVcXHVERDI0XCIsXCJnZ1wiOlwiXFx1MjI2QlwiLFwiR2dcIjpcIlxcdTIyRDlcIixcImdnZ1wiOlwiXFx1MjJEOVwiLFwiZ2ltZWxcIjpcIlxcdTIxMzdcIixcIkdKY3lcIjpcIlxcdTA0MDNcIixcImdqY3lcIjpcIlxcdTA0NTNcIixcImdsYVwiOlwiXFx1MkFBNVwiLFwiZ2xcIjpcIlxcdTIyNzdcIixcImdsRVwiOlwiXFx1MkE5MlwiLFwiZ2xqXCI6XCJcXHUyQUE0XCIsXCJnbmFwXCI6XCJcXHUyQThBXCIsXCJnbmFwcHJveFwiOlwiXFx1MkE4QVwiLFwiZ25lXCI6XCJcXHUyQTg4XCIsXCJnbkVcIjpcIlxcdTIyNjlcIixcImduZXFcIjpcIlxcdTJBODhcIixcImduZXFxXCI6XCJcXHUyMjY5XCIsXCJnbnNpbVwiOlwiXFx1MjJFN1wiLFwiR29wZlwiOlwiXFx1RDgzNVxcdUREM0VcIixcImdvcGZcIjpcIlxcdUQ4MzVcXHVERDU4XCIsXCJncmF2ZVwiOlwiYFwiLFwiR3JlYXRlckVxdWFsXCI6XCJcXHUyMjY1XCIsXCJHcmVhdGVyRXF1YWxMZXNzXCI6XCJcXHUyMkRCXCIsXCJHcmVhdGVyRnVsbEVxdWFsXCI6XCJcXHUyMjY3XCIsXCJHcmVhdGVyR3JlYXRlclwiOlwiXFx1MkFBMlwiLFwiR3JlYXRlckxlc3NcIjpcIlxcdTIyNzdcIixcIkdyZWF0ZXJTbGFudEVxdWFsXCI6XCJcXHUyQTdFXCIsXCJHcmVhdGVyVGlsZGVcIjpcIlxcdTIyNzNcIixcIkdzY3JcIjpcIlxcdUQ4MzVcXHVEQ0EyXCIsXCJnc2NyXCI6XCJcXHUyMTBBXCIsXCJnc2ltXCI6XCJcXHUyMjczXCIsXCJnc2ltZVwiOlwiXFx1MkE4RVwiLFwiZ3NpbWxcIjpcIlxcdTJBOTBcIixcImd0Y2NcIjpcIlxcdTJBQTdcIixcImd0Y2lyXCI6XCJcXHUyQTdBXCIsXCJndFwiOlwiPlwiLFwiR1RcIjpcIj5cIixcIkd0XCI6XCJcXHUyMjZCXCIsXCJndGRvdFwiOlwiXFx1MjJEN1wiLFwiZ3RsUGFyXCI6XCJcXHUyOTk1XCIsXCJndHF1ZXN0XCI6XCJcXHUyQTdDXCIsXCJndHJhcHByb3hcIjpcIlxcdTJBODZcIixcImd0cmFyclwiOlwiXFx1Mjk3OFwiLFwiZ3RyZG90XCI6XCJcXHUyMkQ3XCIsXCJndHJlcWxlc3NcIjpcIlxcdTIyREJcIixcImd0cmVxcWxlc3NcIjpcIlxcdTJBOENcIixcImd0cmxlc3NcIjpcIlxcdTIyNzdcIixcImd0cnNpbVwiOlwiXFx1MjI3M1wiLFwiZ3ZlcnRuZXFxXCI6XCJcXHUyMjY5XFx1RkUwMFwiLFwiZ3ZuRVwiOlwiXFx1MjI2OVxcdUZFMDBcIixcIkhhY2VrXCI6XCJcXHUwMkM3XCIsXCJoYWlyc3BcIjpcIlxcdTIwMEFcIixcImhhbGZcIjpcIlxcdTAwQkRcIixcImhhbWlsdFwiOlwiXFx1MjEwQlwiLFwiSEFSRGN5XCI6XCJcXHUwNDJBXCIsXCJoYXJkY3lcIjpcIlxcdTA0NEFcIixcImhhcnJjaXJcIjpcIlxcdTI5NDhcIixcImhhcnJcIjpcIlxcdTIxOTRcIixcImhBcnJcIjpcIlxcdTIxRDRcIixcImhhcnJ3XCI6XCJcXHUyMUFEXCIsXCJIYXRcIjpcIl5cIixcImhiYXJcIjpcIlxcdTIxMEZcIixcIkhjaXJjXCI6XCJcXHUwMTI0XCIsXCJoY2lyY1wiOlwiXFx1MDEyNVwiLFwiaGVhcnRzXCI6XCJcXHUyNjY1XCIsXCJoZWFydHN1aXRcIjpcIlxcdTI2NjVcIixcImhlbGxpcFwiOlwiXFx1MjAyNlwiLFwiaGVyY29uXCI6XCJcXHUyMkI5XCIsXCJoZnJcIjpcIlxcdUQ4MzVcXHVERDI1XCIsXCJIZnJcIjpcIlxcdTIxMENcIixcIkhpbGJlcnRTcGFjZVwiOlwiXFx1MjEwQlwiLFwiaGtzZWFyb3dcIjpcIlxcdTI5MjVcIixcImhrc3dhcm93XCI6XCJcXHUyOTI2XCIsXCJob2FyclwiOlwiXFx1MjFGRlwiLFwiaG9tdGh0XCI6XCJcXHUyMjNCXCIsXCJob29rbGVmdGFycm93XCI6XCJcXHUyMUE5XCIsXCJob29rcmlnaHRhcnJvd1wiOlwiXFx1MjFBQVwiLFwiaG9wZlwiOlwiXFx1RDgzNVxcdURENTlcIixcIkhvcGZcIjpcIlxcdTIxMERcIixcImhvcmJhclwiOlwiXFx1MjAxNVwiLFwiSG9yaXpvbnRhbExpbmVcIjpcIlxcdTI1MDBcIixcImhzY3JcIjpcIlxcdUQ4MzVcXHVEQ0JEXCIsXCJIc2NyXCI6XCJcXHUyMTBCXCIsXCJoc2xhc2hcIjpcIlxcdTIxMEZcIixcIkhzdHJva1wiOlwiXFx1MDEyNlwiLFwiaHN0cm9rXCI6XCJcXHUwMTI3XCIsXCJIdW1wRG93bkh1bXBcIjpcIlxcdTIyNEVcIixcIkh1bXBFcXVhbFwiOlwiXFx1MjI0RlwiLFwiaHlidWxsXCI6XCJcXHUyMDQzXCIsXCJoeXBoZW5cIjpcIlxcdTIwMTBcIixcIklhY3V0ZVwiOlwiXFx1MDBDRFwiLFwiaWFjdXRlXCI6XCJcXHUwMEVEXCIsXCJpY1wiOlwiXFx1MjA2M1wiLFwiSWNpcmNcIjpcIlxcdTAwQ0VcIixcImljaXJjXCI6XCJcXHUwMEVFXCIsXCJJY3lcIjpcIlxcdTA0MThcIixcImljeVwiOlwiXFx1MDQzOFwiLFwiSWRvdFwiOlwiXFx1MDEzMFwiLFwiSUVjeVwiOlwiXFx1MDQxNVwiLFwiaWVjeVwiOlwiXFx1MDQzNVwiLFwiaWV4Y2xcIjpcIlxcdTAwQTFcIixcImlmZlwiOlwiXFx1MjFENFwiLFwiaWZyXCI6XCJcXHVEODM1XFx1REQyNlwiLFwiSWZyXCI6XCJcXHUyMTExXCIsXCJJZ3JhdmVcIjpcIlxcdTAwQ0NcIixcImlncmF2ZVwiOlwiXFx1MDBFQ1wiLFwiaWlcIjpcIlxcdTIxNDhcIixcImlpaWludFwiOlwiXFx1MkEwQ1wiLFwiaWlpbnRcIjpcIlxcdTIyMkRcIixcImlpbmZpblwiOlwiXFx1MjlEQ1wiLFwiaWlvdGFcIjpcIlxcdTIxMjlcIixcIklKbGlnXCI6XCJcXHUwMTMyXCIsXCJpamxpZ1wiOlwiXFx1MDEzM1wiLFwiSW1hY3JcIjpcIlxcdTAxMkFcIixcImltYWNyXCI6XCJcXHUwMTJCXCIsXCJpbWFnZVwiOlwiXFx1MjExMVwiLFwiSW1hZ2luYXJ5SVwiOlwiXFx1MjE0OFwiLFwiaW1hZ2xpbmVcIjpcIlxcdTIxMTBcIixcImltYWdwYXJ0XCI6XCJcXHUyMTExXCIsXCJpbWF0aFwiOlwiXFx1MDEzMVwiLFwiSW1cIjpcIlxcdTIxMTFcIixcImltb2ZcIjpcIlxcdTIyQjdcIixcImltcGVkXCI6XCJcXHUwMUI1XCIsXCJJbXBsaWVzXCI6XCJcXHUyMUQyXCIsXCJpbmNhcmVcIjpcIlxcdTIxMDVcIixcImluXCI6XCJcXHUyMjA4XCIsXCJpbmZpblwiOlwiXFx1MjIxRVwiLFwiaW5maW50aWVcIjpcIlxcdTI5RERcIixcImlub2RvdFwiOlwiXFx1MDEzMVwiLFwiaW50Y2FsXCI6XCJcXHUyMkJBXCIsXCJpbnRcIjpcIlxcdTIyMkJcIixcIkludFwiOlwiXFx1MjIyQ1wiLFwiaW50ZWdlcnNcIjpcIlxcdTIxMjRcIixcIkludGVncmFsXCI6XCJcXHUyMjJCXCIsXCJpbnRlcmNhbFwiOlwiXFx1MjJCQVwiLFwiSW50ZXJzZWN0aW9uXCI6XCJcXHUyMkMyXCIsXCJpbnRsYXJoa1wiOlwiXFx1MkExN1wiLFwiaW50cHJvZFwiOlwiXFx1MkEzQ1wiLFwiSW52aXNpYmxlQ29tbWFcIjpcIlxcdTIwNjNcIixcIkludmlzaWJsZVRpbWVzXCI6XCJcXHUyMDYyXCIsXCJJT2N5XCI6XCJcXHUwNDAxXCIsXCJpb2N5XCI6XCJcXHUwNDUxXCIsXCJJb2dvblwiOlwiXFx1MDEyRVwiLFwiaW9nb25cIjpcIlxcdTAxMkZcIixcIklvcGZcIjpcIlxcdUQ4MzVcXHVERDQwXCIsXCJpb3BmXCI6XCJcXHVEODM1XFx1REQ1QVwiLFwiSW90YVwiOlwiXFx1MDM5OVwiLFwiaW90YVwiOlwiXFx1MDNCOVwiLFwiaXByb2RcIjpcIlxcdTJBM0NcIixcImlxdWVzdFwiOlwiXFx1MDBCRlwiLFwiaXNjclwiOlwiXFx1RDgzNVxcdURDQkVcIixcIklzY3JcIjpcIlxcdTIxMTBcIixcImlzaW5cIjpcIlxcdTIyMDhcIixcImlzaW5kb3RcIjpcIlxcdTIyRjVcIixcImlzaW5FXCI6XCJcXHUyMkY5XCIsXCJpc2luc1wiOlwiXFx1MjJGNFwiLFwiaXNpbnN2XCI6XCJcXHUyMkYzXCIsXCJpc2ludlwiOlwiXFx1MjIwOFwiLFwiaXRcIjpcIlxcdTIwNjJcIixcIkl0aWxkZVwiOlwiXFx1MDEyOFwiLFwiaXRpbGRlXCI6XCJcXHUwMTI5XCIsXCJJdWtjeVwiOlwiXFx1MDQwNlwiLFwiaXVrY3lcIjpcIlxcdTA0NTZcIixcIkl1bWxcIjpcIlxcdTAwQ0ZcIixcIml1bWxcIjpcIlxcdTAwRUZcIixcIkpjaXJjXCI6XCJcXHUwMTM0XCIsXCJqY2lyY1wiOlwiXFx1MDEzNVwiLFwiSmN5XCI6XCJcXHUwNDE5XCIsXCJqY3lcIjpcIlxcdTA0MzlcIixcIkpmclwiOlwiXFx1RDgzNVxcdUREMERcIixcImpmclwiOlwiXFx1RDgzNVxcdUREMjdcIixcImptYXRoXCI6XCJcXHUwMjM3XCIsXCJKb3BmXCI6XCJcXHVEODM1XFx1REQ0MVwiLFwiam9wZlwiOlwiXFx1RDgzNVxcdURENUJcIixcIkpzY3JcIjpcIlxcdUQ4MzVcXHVEQ0E1XCIsXCJqc2NyXCI6XCJcXHVEODM1XFx1RENCRlwiLFwiSnNlcmN5XCI6XCJcXHUwNDA4XCIsXCJqc2VyY3lcIjpcIlxcdTA0NThcIixcIkp1a2N5XCI6XCJcXHUwNDA0XCIsXCJqdWtjeVwiOlwiXFx1MDQ1NFwiLFwiS2FwcGFcIjpcIlxcdTAzOUFcIixcImthcHBhXCI6XCJcXHUwM0JBXCIsXCJrYXBwYXZcIjpcIlxcdTAzRjBcIixcIktjZWRpbFwiOlwiXFx1MDEzNlwiLFwia2NlZGlsXCI6XCJcXHUwMTM3XCIsXCJLY3lcIjpcIlxcdTA0MUFcIixcImtjeVwiOlwiXFx1MDQzQVwiLFwiS2ZyXCI6XCJcXHVEODM1XFx1REQwRVwiLFwia2ZyXCI6XCJcXHVEODM1XFx1REQyOFwiLFwia2dyZWVuXCI6XCJcXHUwMTM4XCIsXCJLSGN5XCI6XCJcXHUwNDI1XCIsXCJraGN5XCI6XCJcXHUwNDQ1XCIsXCJLSmN5XCI6XCJcXHUwNDBDXCIsXCJramN5XCI6XCJcXHUwNDVDXCIsXCJLb3BmXCI6XCJcXHVEODM1XFx1REQ0MlwiLFwia29wZlwiOlwiXFx1RDgzNVxcdURENUNcIixcIktzY3JcIjpcIlxcdUQ4MzVcXHVEQ0E2XCIsXCJrc2NyXCI6XCJcXHVEODM1XFx1RENDMFwiLFwibEFhcnJcIjpcIlxcdTIxREFcIixcIkxhY3V0ZVwiOlwiXFx1MDEzOVwiLFwibGFjdXRlXCI6XCJcXHUwMTNBXCIsXCJsYWVtcHR5dlwiOlwiXFx1MjlCNFwiLFwibGFncmFuXCI6XCJcXHUyMTEyXCIsXCJMYW1iZGFcIjpcIlxcdTAzOUJcIixcImxhbWJkYVwiOlwiXFx1MDNCQlwiLFwibGFuZ1wiOlwiXFx1MjdFOFwiLFwiTGFuZ1wiOlwiXFx1MjdFQVwiLFwibGFuZ2RcIjpcIlxcdTI5OTFcIixcImxhbmdsZVwiOlwiXFx1MjdFOFwiLFwibGFwXCI6XCJcXHUyQTg1XCIsXCJMYXBsYWNldHJmXCI6XCJcXHUyMTEyXCIsXCJsYXF1b1wiOlwiXFx1MDBBQlwiLFwibGFycmJcIjpcIlxcdTIxRTRcIixcImxhcnJiZnNcIjpcIlxcdTI5MUZcIixcImxhcnJcIjpcIlxcdTIxOTBcIixcIkxhcnJcIjpcIlxcdTIxOUVcIixcImxBcnJcIjpcIlxcdTIxRDBcIixcImxhcnJmc1wiOlwiXFx1MjkxRFwiLFwibGFycmhrXCI6XCJcXHUyMUE5XCIsXCJsYXJybHBcIjpcIlxcdTIxQUJcIixcImxhcnJwbFwiOlwiXFx1MjkzOVwiLFwibGFycnNpbVwiOlwiXFx1Mjk3M1wiLFwibGFycnRsXCI6XCJcXHUyMUEyXCIsXCJsYXRhaWxcIjpcIlxcdTI5MTlcIixcImxBdGFpbFwiOlwiXFx1MjkxQlwiLFwibGF0XCI6XCJcXHUyQUFCXCIsXCJsYXRlXCI6XCJcXHUyQUFEXCIsXCJsYXRlc1wiOlwiXFx1MkFBRFxcdUZFMDBcIixcImxiYXJyXCI6XCJcXHUyOTBDXCIsXCJsQmFyclwiOlwiXFx1MjkwRVwiLFwibGJicmtcIjpcIlxcdTI3NzJcIixcImxicmFjZVwiOlwie1wiLFwibGJyYWNrXCI6XCJbXCIsXCJsYnJrZVwiOlwiXFx1Mjk4QlwiLFwibGJya3NsZFwiOlwiXFx1Mjk4RlwiLFwibGJya3NsdVwiOlwiXFx1Mjk4RFwiLFwiTGNhcm9uXCI6XCJcXHUwMTNEXCIsXCJsY2Fyb25cIjpcIlxcdTAxM0VcIixcIkxjZWRpbFwiOlwiXFx1MDEzQlwiLFwibGNlZGlsXCI6XCJcXHUwMTNDXCIsXCJsY2VpbFwiOlwiXFx1MjMwOFwiLFwibGN1YlwiOlwie1wiLFwiTGN5XCI6XCJcXHUwNDFCXCIsXCJsY3lcIjpcIlxcdTA0M0JcIixcImxkY2FcIjpcIlxcdTI5MzZcIixcImxkcXVvXCI6XCJcXHUyMDFDXCIsXCJsZHF1b3JcIjpcIlxcdTIwMUVcIixcImxkcmRoYXJcIjpcIlxcdTI5NjdcIixcImxkcnVzaGFyXCI6XCJcXHUyOTRCXCIsXCJsZHNoXCI6XCJcXHUyMUIyXCIsXCJsZVwiOlwiXFx1MjI2NFwiLFwibEVcIjpcIlxcdTIyNjZcIixcIkxlZnRBbmdsZUJyYWNrZXRcIjpcIlxcdTI3RThcIixcIkxlZnRBcnJvd0JhclwiOlwiXFx1MjFFNFwiLFwibGVmdGFycm93XCI6XCJcXHUyMTkwXCIsXCJMZWZ0QXJyb3dcIjpcIlxcdTIxOTBcIixcIkxlZnRhcnJvd1wiOlwiXFx1MjFEMFwiLFwiTGVmdEFycm93UmlnaHRBcnJvd1wiOlwiXFx1MjFDNlwiLFwibGVmdGFycm93dGFpbFwiOlwiXFx1MjFBMlwiLFwiTGVmdENlaWxpbmdcIjpcIlxcdTIzMDhcIixcIkxlZnREb3VibGVCcmFja2V0XCI6XCJcXHUyN0U2XCIsXCJMZWZ0RG93blRlZVZlY3RvclwiOlwiXFx1Mjk2MVwiLFwiTGVmdERvd25WZWN0b3JCYXJcIjpcIlxcdTI5NTlcIixcIkxlZnREb3duVmVjdG9yXCI6XCJcXHUyMUMzXCIsXCJMZWZ0Rmxvb3JcIjpcIlxcdTIzMEFcIixcImxlZnRoYXJwb29uZG93blwiOlwiXFx1MjFCRFwiLFwibGVmdGhhcnBvb251cFwiOlwiXFx1MjFCQ1wiLFwibGVmdGxlZnRhcnJvd3NcIjpcIlxcdTIxQzdcIixcImxlZnRyaWdodGFycm93XCI6XCJcXHUyMTk0XCIsXCJMZWZ0UmlnaHRBcnJvd1wiOlwiXFx1MjE5NFwiLFwiTGVmdHJpZ2h0YXJyb3dcIjpcIlxcdTIxRDRcIixcImxlZnRyaWdodGFycm93c1wiOlwiXFx1MjFDNlwiLFwibGVmdHJpZ2h0aGFycG9vbnNcIjpcIlxcdTIxQ0JcIixcImxlZnRyaWdodHNxdWlnYXJyb3dcIjpcIlxcdTIxQURcIixcIkxlZnRSaWdodFZlY3RvclwiOlwiXFx1Mjk0RVwiLFwiTGVmdFRlZUFycm93XCI6XCJcXHUyMUE0XCIsXCJMZWZ0VGVlXCI6XCJcXHUyMkEzXCIsXCJMZWZ0VGVlVmVjdG9yXCI6XCJcXHUyOTVBXCIsXCJsZWZ0dGhyZWV0aW1lc1wiOlwiXFx1MjJDQlwiLFwiTGVmdFRyaWFuZ2xlQmFyXCI6XCJcXHUyOUNGXCIsXCJMZWZ0VHJpYW5nbGVcIjpcIlxcdTIyQjJcIixcIkxlZnRUcmlhbmdsZUVxdWFsXCI6XCJcXHUyMkI0XCIsXCJMZWZ0VXBEb3duVmVjdG9yXCI6XCJcXHUyOTUxXCIsXCJMZWZ0VXBUZWVWZWN0b3JcIjpcIlxcdTI5NjBcIixcIkxlZnRVcFZlY3RvckJhclwiOlwiXFx1Mjk1OFwiLFwiTGVmdFVwVmVjdG9yXCI6XCJcXHUyMUJGXCIsXCJMZWZ0VmVjdG9yQmFyXCI6XCJcXHUyOTUyXCIsXCJMZWZ0VmVjdG9yXCI6XCJcXHUyMUJDXCIsXCJsRWdcIjpcIlxcdTJBOEJcIixcImxlZ1wiOlwiXFx1MjJEQVwiLFwibGVxXCI6XCJcXHUyMjY0XCIsXCJsZXFxXCI6XCJcXHUyMjY2XCIsXCJsZXFzbGFudFwiOlwiXFx1MkE3RFwiLFwibGVzY2NcIjpcIlxcdTJBQThcIixcImxlc1wiOlwiXFx1MkE3RFwiLFwibGVzZG90XCI6XCJcXHUyQTdGXCIsXCJsZXNkb3RvXCI6XCJcXHUyQTgxXCIsXCJsZXNkb3RvclwiOlwiXFx1MkE4M1wiLFwibGVzZ1wiOlwiXFx1MjJEQVxcdUZFMDBcIixcImxlc2dlc1wiOlwiXFx1MkE5M1wiLFwibGVzc2FwcHJveFwiOlwiXFx1MkE4NVwiLFwibGVzc2RvdFwiOlwiXFx1MjJENlwiLFwibGVzc2VxZ3RyXCI6XCJcXHUyMkRBXCIsXCJsZXNzZXFxZ3RyXCI6XCJcXHUyQThCXCIsXCJMZXNzRXF1YWxHcmVhdGVyXCI6XCJcXHUyMkRBXCIsXCJMZXNzRnVsbEVxdWFsXCI6XCJcXHUyMjY2XCIsXCJMZXNzR3JlYXRlclwiOlwiXFx1MjI3NlwiLFwibGVzc2d0clwiOlwiXFx1MjI3NlwiLFwiTGVzc0xlc3NcIjpcIlxcdTJBQTFcIixcImxlc3NzaW1cIjpcIlxcdTIyNzJcIixcIkxlc3NTbGFudEVxdWFsXCI6XCJcXHUyQTdEXCIsXCJMZXNzVGlsZGVcIjpcIlxcdTIyNzJcIixcImxmaXNodFwiOlwiXFx1Mjk3Q1wiLFwibGZsb29yXCI6XCJcXHUyMzBBXCIsXCJMZnJcIjpcIlxcdUQ4MzVcXHVERDBGXCIsXCJsZnJcIjpcIlxcdUQ4MzVcXHVERDI5XCIsXCJsZ1wiOlwiXFx1MjI3NlwiLFwibGdFXCI6XCJcXHUyQTkxXCIsXCJsSGFyXCI6XCJcXHUyOTYyXCIsXCJsaGFyZFwiOlwiXFx1MjFCRFwiLFwibGhhcnVcIjpcIlxcdTIxQkNcIixcImxoYXJ1bFwiOlwiXFx1Mjk2QVwiLFwibGhibGtcIjpcIlxcdTI1ODRcIixcIkxKY3lcIjpcIlxcdTA0MDlcIixcImxqY3lcIjpcIlxcdTA0NTlcIixcImxsYXJyXCI6XCJcXHUyMUM3XCIsXCJsbFwiOlwiXFx1MjI2QVwiLFwiTGxcIjpcIlxcdTIyRDhcIixcImxsY29ybmVyXCI6XCJcXHUyMzFFXCIsXCJMbGVmdGFycm93XCI6XCJcXHUyMURBXCIsXCJsbGhhcmRcIjpcIlxcdTI5NkJcIixcImxsdHJpXCI6XCJcXHUyNUZBXCIsXCJMbWlkb3RcIjpcIlxcdTAxM0ZcIixcImxtaWRvdFwiOlwiXFx1MDE0MFwiLFwibG1vdXN0YWNoZVwiOlwiXFx1MjNCMFwiLFwibG1vdXN0XCI6XCJcXHUyM0IwXCIsXCJsbmFwXCI6XCJcXHUyQTg5XCIsXCJsbmFwcHJveFwiOlwiXFx1MkE4OVwiLFwibG5lXCI6XCJcXHUyQTg3XCIsXCJsbkVcIjpcIlxcdTIyNjhcIixcImxuZXFcIjpcIlxcdTJBODdcIixcImxuZXFxXCI6XCJcXHUyMjY4XCIsXCJsbnNpbVwiOlwiXFx1MjJFNlwiLFwibG9hbmdcIjpcIlxcdTI3RUNcIixcImxvYXJyXCI6XCJcXHUyMUZEXCIsXCJsb2Jya1wiOlwiXFx1MjdFNlwiLFwibG9uZ2xlZnRhcnJvd1wiOlwiXFx1MjdGNVwiLFwiTG9uZ0xlZnRBcnJvd1wiOlwiXFx1MjdGNVwiLFwiTG9uZ2xlZnRhcnJvd1wiOlwiXFx1MjdGOFwiLFwibG9uZ2xlZnRyaWdodGFycm93XCI6XCJcXHUyN0Y3XCIsXCJMb25nTGVmdFJpZ2h0QXJyb3dcIjpcIlxcdTI3RjdcIixcIkxvbmdsZWZ0cmlnaHRhcnJvd1wiOlwiXFx1MjdGQVwiLFwibG9uZ21hcHN0b1wiOlwiXFx1MjdGQ1wiLFwibG9uZ3JpZ2h0YXJyb3dcIjpcIlxcdTI3RjZcIixcIkxvbmdSaWdodEFycm93XCI6XCJcXHUyN0Y2XCIsXCJMb25ncmlnaHRhcnJvd1wiOlwiXFx1MjdGOVwiLFwibG9vcGFycm93bGVmdFwiOlwiXFx1MjFBQlwiLFwibG9vcGFycm93cmlnaHRcIjpcIlxcdTIxQUNcIixcImxvcGFyXCI6XCJcXHUyOTg1XCIsXCJMb3BmXCI6XCJcXHVEODM1XFx1REQ0M1wiLFwibG9wZlwiOlwiXFx1RDgzNVxcdURENURcIixcImxvcGx1c1wiOlwiXFx1MkEyRFwiLFwibG90aW1lc1wiOlwiXFx1MkEzNFwiLFwibG93YXN0XCI6XCJcXHUyMjE3XCIsXCJsb3diYXJcIjpcIl9cIixcIkxvd2VyTGVmdEFycm93XCI6XCJcXHUyMTk5XCIsXCJMb3dlclJpZ2h0QXJyb3dcIjpcIlxcdTIxOThcIixcImxvelwiOlwiXFx1MjVDQVwiLFwibG96ZW5nZVwiOlwiXFx1MjVDQVwiLFwibG96ZlwiOlwiXFx1MjlFQlwiLFwibHBhclwiOlwiKFwiLFwibHBhcmx0XCI6XCJcXHUyOTkzXCIsXCJscmFyclwiOlwiXFx1MjFDNlwiLFwibHJjb3JuZXJcIjpcIlxcdTIzMUZcIixcImxyaGFyXCI6XCJcXHUyMUNCXCIsXCJscmhhcmRcIjpcIlxcdTI5NkRcIixcImxybVwiOlwiXFx1MjAwRVwiLFwibHJ0cmlcIjpcIlxcdTIyQkZcIixcImxzYXF1b1wiOlwiXFx1MjAzOVwiLFwibHNjclwiOlwiXFx1RDgzNVxcdURDQzFcIixcIkxzY3JcIjpcIlxcdTIxMTJcIixcImxzaFwiOlwiXFx1MjFCMFwiLFwiTHNoXCI6XCJcXHUyMUIwXCIsXCJsc2ltXCI6XCJcXHUyMjcyXCIsXCJsc2ltZVwiOlwiXFx1MkE4RFwiLFwibHNpbWdcIjpcIlxcdTJBOEZcIixcImxzcWJcIjpcIltcIixcImxzcXVvXCI6XCJcXHUyMDE4XCIsXCJsc3F1b3JcIjpcIlxcdTIwMUFcIixcIkxzdHJva1wiOlwiXFx1MDE0MVwiLFwibHN0cm9rXCI6XCJcXHUwMTQyXCIsXCJsdGNjXCI6XCJcXHUyQUE2XCIsXCJsdGNpclwiOlwiXFx1MkE3OVwiLFwibHRcIjpcIjxcIixcIkxUXCI6XCI8XCIsXCJMdFwiOlwiXFx1MjI2QVwiLFwibHRkb3RcIjpcIlxcdTIyRDZcIixcImx0aHJlZVwiOlwiXFx1MjJDQlwiLFwibHRpbWVzXCI6XCJcXHUyMkM5XCIsXCJsdGxhcnJcIjpcIlxcdTI5NzZcIixcImx0cXVlc3RcIjpcIlxcdTJBN0JcIixcImx0cmlcIjpcIlxcdTI1QzNcIixcImx0cmllXCI6XCJcXHUyMkI0XCIsXCJsdHJpZlwiOlwiXFx1MjVDMlwiLFwibHRyUGFyXCI6XCJcXHUyOTk2XCIsXCJsdXJkc2hhclwiOlwiXFx1Mjk0QVwiLFwibHVydWhhclwiOlwiXFx1Mjk2NlwiLFwibHZlcnRuZXFxXCI6XCJcXHUyMjY4XFx1RkUwMFwiLFwibHZuRVwiOlwiXFx1MjI2OFxcdUZFMDBcIixcIm1hY3JcIjpcIlxcdTAwQUZcIixcIm1hbGVcIjpcIlxcdTI2NDJcIixcIm1hbHRcIjpcIlxcdTI3MjBcIixcIm1hbHRlc2VcIjpcIlxcdTI3MjBcIixcIk1hcFwiOlwiXFx1MjkwNVwiLFwibWFwXCI6XCJcXHUyMUE2XCIsXCJtYXBzdG9cIjpcIlxcdTIxQTZcIixcIm1hcHN0b2Rvd25cIjpcIlxcdTIxQTdcIixcIm1hcHN0b2xlZnRcIjpcIlxcdTIxQTRcIixcIm1hcHN0b3VwXCI6XCJcXHUyMUE1XCIsXCJtYXJrZXJcIjpcIlxcdTI1QUVcIixcIm1jb21tYVwiOlwiXFx1MkEyOVwiLFwiTWN5XCI6XCJcXHUwNDFDXCIsXCJtY3lcIjpcIlxcdTA0M0NcIixcIm1kYXNoXCI6XCJcXHUyMDE0XCIsXCJtRERvdFwiOlwiXFx1MjIzQVwiLFwibWVhc3VyZWRhbmdsZVwiOlwiXFx1MjIyMVwiLFwiTWVkaXVtU3BhY2VcIjpcIlxcdTIwNUZcIixcIk1lbGxpbnRyZlwiOlwiXFx1MjEzM1wiLFwiTWZyXCI6XCJcXHVEODM1XFx1REQxMFwiLFwibWZyXCI6XCJcXHVEODM1XFx1REQyQVwiLFwibWhvXCI6XCJcXHUyMTI3XCIsXCJtaWNyb1wiOlwiXFx1MDBCNVwiLFwibWlkYXN0XCI6XCIqXCIsXCJtaWRjaXJcIjpcIlxcdTJBRjBcIixcIm1pZFwiOlwiXFx1MjIyM1wiLFwibWlkZG90XCI6XCJcXHUwMEI3XCIsXCJtaW51c2JcIjpcIlxcdTIyOUZcIixcIm1pbnVzXCI6XCJcXHUyMjEyXCIsXCJtaW51c2RcIjpcIlxcdTIyMzhcIixcIm1pbnVzZHVcIjpcIlxcdTJBMkFcIixcIk1pbnVzUGx1c1wiOlwiXFx1MjIxM1wiLFwibWxjcFwiOlwiXFx1MkFEQlwiLFwibWxkclwiOlwiXFx1MjAyNlwiLFwibW5wbHVzXCI6XCJcXHUyMjEzXCIsXCJtb2RlbHNcIjpcIlxcdTIyQTdcIixcIk1vcGZcIjpcIlxcdUQ4MzVcXHVERDQ0XCIsXCJtb3BmXCI6XCJcXHVEODM1XFx1REQ1RVwiLFwibXBcIjpcIlxcdTIyMTNcIixcIm1zY3JcIjpcIlxcdUQ4MzVcXHVEQ0MyXCIsXCJNc2NyXCI6XCJcXHUyMTMzXCIsXCJtc3Rwb3NcIjpcIlxcdTIyM0VcIixcIk11XCI6XCJcXHUwMzlDXCIsXCJtdVwiOlwiXFx1MDNCQ1wiLFwibXVsdGltYXBcIjpcIlxcdTIyQjhcIixcIm11bWFwXCI6XCJcXHUyMkI4XCIsXCJuYWJsYVwiOlwiXFx1MjIwN1wiLFwiTmFjdXRlXCI6XCJcXHUwMTQzXCIsXCJuYWN1dGVcIjpcIlxcdTAxNDRcIixcIm5hbmdcIjpcIlxcdTIyMjBcXHUyMEQyXCIsXCJuYXBcIjpcIlxcdTIyNDlcIixcIm5hcEVcIjpcIlxcdTJBNzBcXHUwMzM4XCIsXCJuYXBpZFwiOlwiXFx1MjI0QlxcdTAzMzhcIixcIm5hcG9zXCI6XCJcXHUwMTQ5XCIsXCJuYXBwcm94XCI6XCJcXHUyMjQ5XCIsXCJuYXR1cmFsXCI6XCJcXHUyNjZFXCIsXCJuYXR1cmFsc1wiOlwiXFx1MjExNVwiLFwibmF0dXJcIjpcIlxcdTI2NkVcIixcIm5ic3BcIjpcIlxcdTAwQTBcIixcIm5idW1wXCI6XCJcXHUyMjRFXFx1MDMzOFwiLFwibmJ1bXBlXCI6XCJcXHUyMjRGXFx1MDMzOFwiLFwibmNhcFwiOlwiXFx1MkE0M1wiLFwiTmNhcm9uXCI6XCJcXHUwMTQ3XCIsXCJuY2Fyb25cIjpcIlxcdTAxNDhcIixcIk5jZWRpbFwiOlwiXFx1MDE0NVwiLFwibmNlZGlsXCI6XCJcXHUwMTQ2XCIsXCJuY29uZ1wiOlwiXFx1MjI0N1wiLFwibmNvbmdkb3RcIjpcIlxcdTJBNkRcXHUwMzM4XCIsXCJuY3VwXCI6XCJcXHUyQTQyXCIsXCJOY3lcIjpcIlxcdTA0MURcIixcIm5jeVwiOlwiXFx1MDQzRFwiLFwibmRhc2hcIjpcIlxcdTIwMTNcIixcIm5lYXJoa1wiOlwiXFx1MjkyNFwiLFwibmVhcnJcIjpcIlxcdTIxOTdcIixcIm5lQXJyXCI6XCJcXHUyMUQ3XCIsXCJuZWFycm93XCI6XCJcXHUyMTk3XCIsXCJuZVwiOlwiXFx1MjI2MFwiLFwibmVkb3RcIjpcIlxcdTIyNTBcXHUwMzM4XCIsXCJOZWdhdGl2ZU1lZGl1bVNwYWNlXCI6XCJcXHUyMDBCXCIsXCJOZWdhdGl2ZVRoaWNrU3BhY2VcIjpcIlxcdTIwMEJcIixcIk5lZ2F0aXZlVGhpblNwYWNlXCI6XCJcXHUyMDBCXCIsXCJOZWdhdGl2ZVZlcnlUaGluU3BhY2VcIjpcIlxcdTIwMEJcIixcIm5lcXVpdlwiOlwiXFx1MjI2MlwiLFwibmVzZWFyXCI6XCJcXHUyOTI4XCIsXCJuZXNpbVwiOlwiXFx1MjI0MlxcdTAzMzhcIixcIk5lc3RlZEdyZWF0ZXJHcmVhdGVyXCI6XCJcXHUyMjZCXCIsXCJOZXN0ZWRMZXNzTGVzc1wiOlwiXFx1MjI2QVwiLFwiTmV3TGluZVwiOlwiXFxuXCIsXCJuZXhpc3RcIjpcIlxcdTIyMDRcIixcIm5leGlzdHNcIjpcIlxcdTIyMDRcIixcIk5mclwiOlwiXFx1RDgzNVxcdUREMTFcIixcIm5mclwiOlwiXFx1RDgzNVxcdUREMkJcIixcIm5nRVwiOlwiXFx1MjI2N1xcdTAzMzhcIixcIm5nZVwiOlwiXFx1MjI3MVwiLFwibmdlcVwiOlwiXFx1MjI3MVwiLFwibmdlcXFcIjpcIlxcdTIyNjdcXHUwMzM4XCIsXCJuZ2Vxc2xhbnRcIjpcIlxcdTJBN0VcXHUwMzM4XCIsXCJuZ2VzXCI6XCJcXHUyQTdFXFx1MDMzOFwiLFwibkdnXCI6XCJcXHUyMkQ5XFx1MDMzOFwiLFwibmdzaW1cIjpcIlxcdTIyNzVcIixcIm5HdFwiOlwiXFx1MjI2QlxcdTIwRDJcIixcIm5ndFwiOlwiXFx1MjI2RlwiLFwibmd0clwiOlwiXFx1MjI2RlwiLFwibkd0dlwiOlwiXFx1MjI2QlxcdTAzMzhcIixcIm5oYXJyXCI6XCJcXHUyMUFFXCIsXCJuaEFyclwiOlwiXFx1MjFDRVwiLFwibmhwYXJcIjpcIlxcdTJBRjJcIixcIm5pXCI6XCJcXHUyMjBCXCIsXCJuaXNcIjpcIlxcdTIyRkNcIixcIm5pc2RcIjpcIlxcdTIyRkFcIixcIm5pdlwiOlwiXFx1MjIwQlwiLFwiTkpjeVwiOlwiXFx1MDQwQVwiLFwibmpjeVwiOlwiXFx1MDQ1QVwiLFwibmxhcnJcIjpcIlxcdTIxOUFcIixcIm5sQXJyXCI6XCJcXHUyMUNEXCIsXCJubGRyXCI6XCJcXHUyMDI1XCIsXCJubEVcIjpcIlxcdTIyNjZcXHUwMzM4XCIsXCJubGVcIjpcIlxcdTIyNzBcIixcIm5sZWZ0YXJyb3dcIjpcIlxcdTIxOUFcIixcIm5MZWZ0YXJyb3dcIjpcIlxcdTIxQ0RcIixcIm5sZWZ0cmlnaHRhcnJvd1wiOlwiXFx1MjFBRVwiLFwibkxlZnRyaWdodGFycm93XCI6XCJcXHUyMUNFXCIsXCJubGVxXCI6XCJcXHUyMjcwXCIsXCJubGVxcVwiOlwiXFx1MjI2NlxcdTAzMzhcIixcIm5sZXFzbGFudFwiOlwiXFx1MkE3RFxcdTAzMzhcIixcIm5sZXNcIjpcIlxcdTJBN0RcXHUwMzM4XCIsXCJubGVzc1wiOlwiXFx1MjI2RVwiLFwibkxsXCI6XCJcXHUyMkQ4XFx1MDMzOFwiLFwibmxzaW1cIjpcIlxcdTIyNzRcIixcIm5MdFwiOlwiXFx1MjI2QVxcdTIwRDJcIixcIm5sdFwiOlwiXFx1MjI2RVwiLFwibmx0cmlcIjpcIlxcdTIyRUFcIixcIm5sdHJpZVwiOlwiXFx1MjJFQ1wiLFwibkx0dlwiOlwiXFx1MjI2QVxcdTAzMzhcIixcIm5taWRcIjpcIlxcdTIyMjRcIixcIk5vQnJlYWtcIjpcIlxcdTIwNjBcIixcIk5vbkJyZWFraW5nU3BhY2VcIjpcIlxcdTAwQTBcIixcIm5vcGZcIjpcIlxcdUQ4MzVcXHVERDVGXCIsXCJOb3BmXCI6XCJcXHUyMTE1XCIsXCJOb3RcIjpcIlxcdTJBRUNcIixcIm5vdFwiOlwiXFx1MDBBQ1wiLFwiTm90Q29uZ3J1ZW50XCI6XCJcXHUyMjYyXCIsXCJOb3RDdXBDYXBcIjpcIlxcdTIyNkRcIixcIk5vdERvdWJsZVZlcnRpY2FsQmFyXCI6XCJcXHUyMjI2XCIsXCJOb3RFbGVtZW50XCI6XCJcXHUyMjA5XCIsXCJOb3RFcXVhbFwiOlwiXFx1MjI2MFwiLFwiTm90RXF1YWxUaWxkZVwiOlwiXFx1MjI0MlxcdTAzMzhcIixcIk5vdEV4aXN0c1wiOlwiXFx1MjIwNFwiLFwiTm90R3JlYXRlclwiOlwiXFx1MjI2RlwiLFwiTm90R3JlYXRlckVxdWFsXCI6XCJcXHUyMjcxXCIsXCJOb3RHcmVhdGVyRnVsbEVxdWFsXCI6XCJcXHUyMjY3XFx1MDMzOFwiLFwiTm90R3JlYXRlckdyZWF0ZXJcIjpcIlxcdTIyNkJcXHUwMzM4XCIsXCJOb3RHcmVhdGVyTGVzc1wiOlwiXFx1MjI3OVwiLFwiTm90R3JlYXRlclNsYW50RXF1YWxcIjpcIlxcdTJBN0VcXHUwMzM4XCIsXCJOb3RHcmVhdGVyVGlsZGVcIjpcIlxcdTIyNzVcIixcIk5vdEh1bXBEb3duSHVtcFwiOlwiXFx1MjI0RVxcdTAzMzhcIixcIk5vdEh1bXBFcXVhbFwiOlwiXFx1MjI0RlxcdTAzMzhcIixcIm5vdGluXCI6XCJcXHUyMjA5XCIsXCJub3RpbmRvdFwiOlwiXFx1MjJGNVxcdTAzMzhcIixcIm5vdGluRVwiOlwiXFx1MjJGOVxcdTAzMzhcIixcIm5vdGludmFcIjpcIlxcdTIyMDlcIixcIm5vdGludmJcIjpcIlxcdTIyRjdcIixcIm5vdGludmNcIjpcIlxcdTIyRjZcIixcIk5vdExlZnRUcmlhbmdsZUJhclwiOlwiXFx1MjlDRlxcdTAzMzhcIixcIk5vdExlZnRUcmlhbmdsZVwiOlwiXFx1MjJFQVwiLFwiTm90TGVmdFRyaWFuZ2xlRXF1YWxcIjpcIlxcdTIyRUNcIixcIk5vdExlc3NcIjpcIlxcdTIyNkVcIixcIk5vdExlc3NFcXVhbFwiOlwiXFx1MjI3MFwiLFwiTm90TGVzc0dyZWF0ZXJcIjpcIlxcdTIyNzhcIixcIk5vdExlc3NMZXNzXCI6XCJcXHUyMjZBXFx1MDMzOFwiLFwiTm90TGVzc1NsYW50RXF1YWxcIjpcIlxcdTJBN0RcXHUwMzM4XCIsXCJOb3RMZXNzVGlsZGVcIjpcIlxcdTIyNzRcIixcIk5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyXCI6XCJcXHUyQUEyXFx1MDMzOFwiLFwiTm90TmVzdGVkTGVzc0xlc3NcIjpcIlxcdTJBQTFcXHUwMzM4XCIsXCJub3RuaVwiOlwiXFx1MjIwQ1wiLFwibm90bml2YVwiOlwiXFx1MjIwQ1wiLFwibm90bml2YlwiOlwiXFx1MjJGRVwiLFwibm90bml2Y1wiOlwiXFx1MjJGRFwiLFwiTm90UHJlY2VkZXNcIjpcIlxcdTIyODBcIixcIk5vdFByZWNlZGVzRXF1YWxcIjpcIlxcdTJBQUZcXHUwMzM4XCIsXCJOb3RQcmVjZWRlc1NsYW50RXF1YWxcIjpcIlxcdTIyRTBcIixcIk5vdFJldmVyc2VFbGVtZW50XCI6XCJcXHUyMjBDXCIsXCJOb3RSaWdodFRyaWFuZ2xlQmFyXCI6XCJcXHUyOUQwXFx1MDMzOFwiLFwiTm90UmlnaHRUcmlhbmdsZVwiOlwiXFx1MjJFQlwiLFwiTm90UmlnaHRUcmlhbmdsZUVxdWFsXCI6XCJcXHUyMkVEXCIsXCJOb3RTcXVhcmVTdWJzZXRcIjpcIlxcdTIyOEZcXHUwMzM4XCIsXCJOb3RTcXVhcmVTdWJzZXRFcXVhbFwiOlwiXFx1MjJFMlwiLFwiTm90U3F1YXJlU3VwZXJzZXRcIjpcIlxcdTIyOTBcXHUwMzM4XCIsXCJOb3RTcXVhcmVTdXBlcnNldEVxdWFsXCI6XCJcXHUyMkUzXCIsXCJOb3RTdWJzZXRcIjpcIlxcdTIyODJcXHUyMEQyXCIsXCJOb3RTdWJzZXRFcXVhbFwiOlwiXFx1MjI4OFwiLFwiTm90U3VjY2VlZHNcIjpcIlxcdTIyODFcIixcIk5vdFN1Y2NlZWRzRXF1YWxcIjpcIlxcdTJBQjBcXHUwMzM4XCIsXCJOb3RTdWNjZWVkc1NsYW50RXF1YWxcIjpcIlxcdTIyRTFcIixcIk5vdFN1Y2NlZWRzVGlsZGVcIjpcIlxcdTIyN0ZcXHUwMzM4XCIsXCJOb3RTdXBlcnNldFwiOlwiXFx1MjI4M1xcdTIwRDJcIixcIk5vdFN1cGVyc2V0RXF1YWxcIjpcIlxcdTIyODlcIixcIk5vdFRpbGRlXCI6XCJcXHUyMjQxXCIsXCJOb3RUaWxkZUVxdWFsXCI6XCJcXHUyMjQ0XCIsXCJOb3RUaWxkZUZ1bGxFcXVhbFwiOlwiXFx1MjI0N1wiLFwiTm90VGlsZGVUaWxkZVwiOlwiXFx1MjI0OVwiLFwiTm90VmVydGljYWxCYXJcIjpcIlxcdTIyMjRcIixcIm5wYXJhbGxlbFwiOlwiXFx1MjIyNlwiLFwibnBhclwiOlwiXFx1MjIyNlwiLFwibnBhcnNsXCI6XCJcXHUyQUZEXFx1MjBFNVwiLFwibnBhcnRcIjpcIlxcdTIyMDJcXHUwMzM4XCIsXCJucG9saW50XCI6XCJcXHUyQTE0XCIsXCJucHJcIjpcIlxcdTIyODBcIixcIm5wcmN1ZVwiOlwiXFx1MjJFMFwiLFwibnByZWNcIjpcIlxcdTIyODBcIixcIm5wcmVjZXFcIjpcIlxcdTJBQUZcXHUwMzM4XCIsXCJucHJlXCI6XCJcXHUyQUFGXFx1MDMzOFwiLFwibnJhcnJjXCI6XCJcXHUyOTMzXFx1MDMzOFwiLFwibnJhcnJcIjpcIlxcdTIxOUJcIixcIm5yQXJyXCI6XCJcXHUyMUNGXCIsXCJucmFycndcIjpcIlxcdTIxOURcXHUwMzM4XCIsXCJucmlnaHRhcnJvd1wiOlwiXFx1MjE5QlwiLFwiblJpZ2h0YXJyb3dcIjpcIlxcdTIxQ0ZcIixcIm5ydHJpXCI6XCJcXHUyMkVCXCIsXCJucnRyaWVcIjpcIlxcdTIyRURcIixcIm5zY1wiOlwiXFx1MjI4MVwiLFwibnNjY3VlXCI6XCJcXHUyMkUxXCIsXCJuc2NlXCI6XCJcXHUyQUIwXFx1MDMzOFwiLFwiTnNjclwiOlwiXFx1RDgzNVxcdURDQTlcIixcIm5zY3JcIjpcIlxcdUQ4MzVcXHVEQ0MzXCIsXCJuc2hvcnRtaWRcIjpcIlxcdTIyMjRcIixcIm5zaG9ydHBhcmFsbGVsXCI6XCJcXHUyMjI2XCIsXCJuc2ltXCI6XCJcXHUyMjQxXCIsXCJuc2ltZVwiOlwiXFx1MjI0NFwiLFwibnNpbWVxXCI6XCJcXHUyMjQ0XCIsXCJuc21pZFwiOlwiXFx1MjIyNFwiLFwibnNwYXJcIjpcIlxcdTIyMjZcIixcIm5zcXN1YmVcIjpcIlxcdTIyRTJcIixcIm5zcXN1cGVcIjpcIlxcdTIyRTNcIixcIm5zdWJcIjpcIlxcdTIyODRcIixcIm5zdWJFXCI6XCJcXHUyQUM1XFx1MDMzOFwiLFwibnN1YmVcIjpcIlxcdTIyODhcIixcIm5zdWJzZXRcIjpcIlxcdTIyODJcXHUyMEQyXCIsXCJuc3Vic2V0ZXFcIjpcIlxcdTIyODhcIixcIm5zdWJzZXRlcXFcIjpcIlxcdTJBQzVcXHUwMzM4XCIsXCJuc3VjY1wiOlwiXFx1MjI4MVwiLFwibnN1Y2NlcVwiOlwiXFx1MkFCMFxcdTAzMzhcIixcIm5zdXBcIjpcIlxcdTIyODVcIixcIm5zdXBFXCI6XCJcXHUyQUM2XFx1MDMzOFwiLFwibnN1cGVcIjpcIlxcdTIyODlcIixcIm5zdXBzZXRcIjpcIlxcdTIyODNcXHUyMEQyXCIsXCJuc3Vwc2V0ZXFcIjpcIlxcdTIyODlcIixcIm5zdXBzZXRlcXFcIjpcIlxcdTJBQzZcXHUwMzM4XCIsXCJudGdsXCI6XCJcXHUyMjc5XCIsXCJOdGlsZGVcIjpcIlxcdTAwRDFcIixcIm50aWxkZVwiOlwiXFx1MDBGMVwiLFwibnRsZ1wiOlwiXFx1MjI3OFwiLFwibnRyaWFuZ2xlbGVmdFwiOlwiXFx1MjJFQVwiLFwibnRyaWFuZ2xlbGVmdGVxXCI6XCJcXHUyMkVDXCIsXCJudHJpYW5nbGVyaWdodFwiOlwiXFx1MjJFQlwiLFwibnRyaWFuZ2xlcmlnaHRlcVwiOlwiXFx1MjJFRFwiLFwiTnVcIjpcIlxcdTAzOURcIixcIm51XCI6XCJcXHUwM0JEXCIsXCJudW1cIjpcIiNcIixcIm51bWVyb1wiOlwiXFx1MjExNlwiLFwibnVtc3BcIjpcIlxcdTIwMDdcIixcIm52YXBcIjpcIlxcdTIyNERcXHUyMEQyXCIsXCJudmRhc2hcIjpcIlxcdTIyQUNcIixcIm52RGFzaFwiOlwiXFx1MjJBRFwiLFwiblZkYXNoXCI6XCJcXHUyMkFFXCIsXCJuVkRhc2hcIjpcIlxcdTIyQUZcIixcIm52Z2VcIjpcIlxcdTIyNjVcXHUyMEQyXCIsXCJudmd0XCI6XCI+XFx1MjBEMlwiLFwibnZIYXJyXCI6XCJcXHUyOTA0XCIsXCJudmluZmluXCI6XCJcXHUyOURFXCIsXCJudmxBcnJcIjpcIlxcdTI5MDJcIixcIm52bGVcIjpcIlxcdTIyNjRcXHUyMEQyXCIsXCJudmx0XCI6XCI8XFx1MjBEMlwiLFwibnZsdHJpZVwiOlwiXFx1MjJCNFxcdTIwRDJcIixcIm52ckFyclwiOlwiXFx1MjkwM1wiLFwibnZydHJpZVwiOlwiXFx1MjJCNVxcdTIwRDJcIixcIm52c2ltXCI6XCJcXHUyMjNDXFx1MjBEMlwiLFwibndhcmhrXCI6XCJcXHUyOTIzXCIsXCJud2FyclwiOlwiXFx1MjE5NlwiLFwibndBcnJcIjpcIlxcdTIxRDZcIixcIm53YXJyb3dcIjpcIlxcdTIxOTZcIixcIm53bmVhclwiOlwiXFx1MjkyN1wiLFwiT2FjdXRlXCI6XCJcXHUwMEQzXCIsXCJvYWN1dGVcIjpcIlxcdTAwRjNcIixcIm9hc3RcIjpcIlxcdTIyOUJcIixcIk9jaXJjXCI6XCJcXHUwMEQ0XCIsXCJvY2lyY1wiOlwiXFx1MDBGNFwiLFwib2NpclwiOlwiXFx1MjI5QVwiLFwiT2N5XCI6XCJcXHUwNDFFXCIsXCJvY3lcIjpcIlxcdTA0M0VcIixcIm9kYXNoXCI6XCJcXHUyMjlEXCIsXCJPZGJsYWNcIjpcIlxcdTAxNTBcIixcIm9kYmxhY1wiOlwiXFx1MDE1MVwiLFwib2RpdlwiOlwiXFx1MkEzOFwiLFwib2RvdFwiOlwiXFx1MjI5OVwiLFwib2Rzb2xkXCI6XCJcXHUyOUJDXCIsXCJPRWxpZ1wiOlwiXFx1MDE1MlwiLFwib2VsaWdcIjpcIlxcdTAxNTNcIixcIm9mY2lyXCI6XCJcXHUyOUJGXCIsXCJPZnJcIjpcIlxcdUQ4MzVcXHVERDEyXCIsXCJvZnJcIjpcIlxcdUQ4MzVcXHVERDJDXCIsXCJvZ29uXCI6XCJcXHUwMkRCXCIsXCJPZ3JhdmVcIjpcIlxcdTAwRDJcIixcIm9ncmF2ZVwiOlwiXFx1MDBGMlwiLFwib2d0XCI6XCJcXHUyOUMxXCIsXCJvaGJhclwiOlwiXFx1MjlCNVwiLFwib2htXCI6XCJcXHUwM0E5XCIsXCJvaW50XCI6XCJcXHUyMjJFXCIsXCJvbGFyclwiOlwiXFx1MjFCQVwiLFwib2xjaXJcIjpcIlxcdTI5QkVcIixcIm9sY3Jvc3NcIjpcIlxcdTI5QkJcIixcIm9saW5lXCI6XCJcXHUyMDNFXCIsXCJvbHRcIjpcIlxcdTI5QzBcIixcIk9tYWNyXCI6XCJcXHUwMTRDXCIsXCJvbWFjclwiOlwiXFx1MDE0RFwiLFwiT21lZ2FcIjpcIlxcdTAzQTlcIixcIm9tZWdhXCI6XCJcXHUwM0M5XCIsXCJPbWljcm9uXCI6XCJcXHUwMzlGXCIsXCJvbWljcm9uXCI6XCJcXHUwM0JGXCIsXCJvbWlkXCI6XCJcXHUyOUI2XCIsXCJvbWludXNcIjpcIlxcdTIyOTZcIixcIk9vcGZcIjpcIlxcdUQ4MzVcXHVERDQ2XCIsXCJvb3BmXCI6XCJcXHVEODM1XFx1REQ2MFwiLFwib3BhclwiOlwiXFx1MjlCN1wiLFwiT3BlbkN1cmx5RG91YmxlUXVvdGVcIjpcIlxcdTIwMUNcIixcIk9wZW5DdXJseVF1b3RlXCI6XCJcXHUyMDE4XCIsXCJvcGVycFwiOlwiXFx1MjlCOVwiLFwib3BsdXNcIjpcIlxcdTIyOTVcIixcIm9yYXJyXCI6XCJcXHUyMUJCXCIsXCJPclwiOlwiXFx1MkE1NFwiLFwib3JcIjpcIlxcdTIyMjhcIixcIm9yZFwiOlwiXFx1MkE1RFwiLFwib3JkZXJcIjpcIlxcdTIxMzRcIixcIm9yZGVyb2ZcIjpcIlxcdTIxMzRcIixcIm9yZGZcIjpcIlxcdTAwQUFcIixcIm9yZG1cIjpcIlxcdTAwQkFcIixcIm9yaWdvZlwiOlwiXFx1MjJCNlwiLFwib3JvclwiOlwiXFx1MkE1NlwiLFwib3JzbG9wZVwiOlwiXFx1MkE1N1wiLFwib3J2XCI6XCJcXHUyQTVCXCIsXCJvU1wiOlwiXFx1MjRDOFwiLFwiT3NjclwiOlwiXFx1RDgzNVxcdURDQUFcIixcIm9zY3JcIjpcIlxcdTIxMzRcIixcIk9zbGFzaFwiOlwiXFx1MDBEOFwiLFwib3NsYXNoXCI6XCJcXHUwMEY4XCIsXCJvc29sXCI6XCJcXHUyMjk4XCIsXCJPdGlsZGVcIjpcIlxcdTAwRDVcIixcIm90aWxkZVwiOlwiXFx1MDBGNVwiLFwib3RpbWVzYXNcIjpcIlxcdTJBMzZcIixcIk90aW1lc1wiOlwiXFx1MkEzN1wiLFwib3RpbWVzXCI6XCJcXHUyMjk3XCIsXCJPdW1sXCI6XCJcXHUwMEQ2XCIsXCJvdW1sXCI6XCJcXHUwMEY2XCIsXCJvdmJhclwiOlwiXFx1MjMzRFwiLFwiT3ZlckJhclwiOlwiXFx1MjAzRVwiLFwiT3ZlckJyYWNlXCI6XCJcXHUyM0RFXCIsXCJPdmVyQnJhY2tldFwiOlwiXFx1MjNCNFwiLFwiT3ZlclBhcmVudGhlc2lzXCI6XCJcXHUyM0RDXCIsXCJwYXJhXCI6XCJcXHUwMEI2XCIsXCJwYXJhbGxlbFwiOlwiXFx1MjIyNVwiLFwicGFyXCI6XCJcXHUyMjI1XCIsXCJwYXJzaW1cIjpcIlxcdTJBRjNcIixcInBhcnNsXCI6XCJcXHUyQUZEXCIsXCJwYXJ0XCI6XCJcXHUyMjAyXCIsXCJQYXJ0aWFsRFwiOlwiXFx1MjIwMlwiLFwiUGN5XCI6XCJcXHUwNDFGXCIsXCJwY3lcIjpcIlxcdTA0M0ZcIixcInBlcmNudFwiOlwiJVwiLFwicGVyaW9kXCI6XCIuXCIsXCJwZXJtaWxcIjpcIlxcdTIwMzBcIixcInBlcnBcIjpcIlxcdTIyQTVcIixcInBlcnRlbmtcIjpcIlxcdTIwMzFcIixcIlBmclwiOlwiXFx1RDgzNVxcdUREMTNcIixcInBmclwiOlwiXFx1RDgzNVxcdUREMkRcIixcIlBoaVwiOlwiXFx1MDNBNlwiLFwicGhpXCI6XCJcXHUwM0M2XCIsXCJwaGl2XCI6XCJcXHUwM0Q1XCIsXCJwaG1tYXRcIjpcIlxcdTIxMzNcIixcInBob25lXCI6XCJcXHUyNjBFXCIsXCJQaVwiOlwiXFx1MDNBMFwiLFwicGlcIjpcIlxcdTAzQzBcIixcInBpdGNoZm9ya1wiOlwiXFx1MjJENFwiLFwicGl2XCI6XCJcXHUwM0Q2XCIsXCJwbGFuY2tcIjpcIlxcdTIxMEZcIixcInBsYW5ja2hcIjpcIlxcdTIxMEVcIixcInBsYW5rdlwiOlwiXFx1MjEwRlwiLFwicGx1c2FjaXJcIjpcIlxcdTJBMjNcIixcInBsdXNiXCI6XCJcXHUyMjlFXCIsXCJwbHVzY2lyXCI6XCJcXHUyQTIyXCIsXCJwbHVzXCI6XCIrXCIsXCJwbHVzZG9cIjpcIlxcdTIyMTRcIixcInBsdXNkdVwiOlwiXFx1MkEyNVwiLFwicGx1c2VcIjpcIlxcdTJBNzJcIixcIlBsdXNNaW51c1wiOlwiXFx1MDBCMVwiLFwicGx1c21uXCI6XCJcXHUwMEIxXCIsXCJwbHVzc2ltXCI6XCJcXHUyQTI2XCIsXCJwbHVzdHdvXCI6XCJcXHUyQTI3XCIsXCJwbVwiOlwiXFx1MDBCMVwiLFwiUG9pbmNhcmVwbGFuZVwiOlwiXFx1MjEwQ1wiLFwicG9pbnRpbnRcIjpcIlxcdTJBMTVcIixcInBvcGZcIjpcIlxcdUQ4MzVcXHVERDYxXCIsXCJQb3BmXCI6XCJcXHUyMTE5XCIsXCJwb3VuZFwiOlwiXFx1MDBBM1wiLFwicHJhcFwiOlwiXFx1MkFCN1wiLFwiUHJcIjpcIlxcdTJBQkJcIixcInByXCI6XCJcXHUyMjdBXCIsXCJwcmN1ZVwiOlwiXFx1MjI3Q1wiLFwicHJlY2FwcHJveFwiOlwiXFx1MkFCN1wiLFwicHJlY1wiOlwiXFx1MjI3QVwiLFwicHJlY2N1cmx5ZXFcIjpcIlxcdTIyN0NcIixcIlByZWNlZGVzXCI6XCJcXHUyMjdBXCIsXCJQcmVjZWRlc0VxdWFsXCI6XCJcXHUyQUFGXCIsXCJQcmVjZWRlc1NsYW50RXF1YWxcIjpcIlxcdTIyN0NcIixcIlByZWNlZGVzVGlsZGVcIjpcIlxcdTIyN0VcIixcInByZWNlcVwiOlwiXFx1MkFBRlwiLFwicHJlY25hcHByb3hcIjpcIlxcdTJBQjlcIixcInByZWNuZXFxXCI6XCJcXHUyQUI1XCIsXCJwcmVjbnNpbVwiOlwiXFx1MjJFOFwiLFwicHJlXCI6XCJcXHUyQUFGXCIsXCJwckVcIjpcIlxcdTJBQjNcIixcInByZWNzaW1cIjpcIlxcdTIyN0VcIixcInByaW1lXCI6XCJcXHUyMDMyXCIsXCJQcmltZVwiOlwiXFx1MjAzM1wiLFwicHJpbWVzXCI6XCJcXHUyMTE5XCIsXCJwcm5hcFwiOlwiXFx1MkFCOVwiLFwicHJuRVwiOlwiXFx1MkFCNVwiLFwicHJuc2ltXCI6XCJcXHUyMkU4XCIsXCJwcm9kXCI6XCJcXHUyMjBGXCIsXCJQcm9kdWN0XCI6XCJcXHUyMjBGXCIsXCJwcm9mYWxhclwiOlwiXFx1MjMyRVwiLFwicHJvZmxpbmVcIjpcIlxcdTIzMTJcIixcInByb2ZzdXJmXCI6XCJcXHUyMzEzXCIsXCJwcm9wXCI6XCJcXHUyMjFEXCIsXCJQcm9wb3J0aW9uYWxcIjpcIlxcdTIyMURcIixcIlByb3BvcnRpb25cIjpcIlxcdTIyMzdcIixcInByb3B0b1wiOlwiXFx1MjIxRFwiLFwicHJzaW1cIjpcIlxcdTIyN0VcIixcInBydXJlbFwiOlwiXFx1MjJCMFwiLFwiUHNjclwiOlwiXFx1RDgzNVxcdURDQUJcIixcInBzY3JcIjpcIlxcdUQ4MzVcXHVEQ0M1XCIsXCJQc2lcIjpcIlxcdTAzQThcIixcInBzaVwiOlwiXFx1MDNDOFwiLFwicHVuY3NwXCI6XCJcXHUyMDA4XCIsXCJRZnJcIjpcIlxcdUQ4MzVcXHVERDE0XCIsXCJxZnJcIjpcIlxcdUQ4MzVcXHVERDJFXCIsXCJxaW50XCI6XCJcXHUyQTBDXCIsXCJxb3BmXCI6XCJcXHVEODM1XFx1REQ2MlwiLFwiUW9wZlwiOlwiXFx1MjExQVwiLFwicXByaW1lXCI6XCJcXHUyMDU3XCIsXCJRc2NyXCI6XCJcXHVEODM1XFx1RENBQ1wiLFwicXNjclwiOlwiXFx1RDgzNVxcdURDQzZcIixcInF1YXRlcm5pb25zXCI6XCJcXHUyMTBEXCIsXCJxdWF0aW50XCI6XCJcXHUyQTE2XCIsXCJxdWVzdFwiOlwiP1wiLFwicXVlc3RlcVwiOlwiXFx1MjI1RlwiLFwicXVvdFwiOlwiXFxcIlwiLFwiUVVPVFwiOlwiXFxcIlwiLFwickFhcnJcIjpcIlxcdTIxREJcIixcInJhY2VcIjpcIlxcdTIyM0RcXHUwMzMxXCIsXCJSYWN1dGVcIjpcIlxcdTAxNTRcIixcInJhY3V0ZVwiOlwiXFx1MDE1NVwiLFwicmFkaWNcIjpcIlxcdTIyMUFcIixcInJhZW1wdHl2XCI6XCJcXHUyOUIzXCIsXCJyYW5nXCI6XCJcXHUyN0U5XCIsXCJSYW5nXCI6XCJcXHUyN0VCXCIsXCJyYW5nZFwiOlwiXFx1Mjk5MlwiLFwicmFuZ2VcIjpcIlxcdTI5QTVcIixcInJhbmdsZVwiOlwiXFx1MjdFOVwiLFwicmFxdW9cIjpcIlxcdTAwQkJcIixcInJhcnJhcFwiOlwiXFx1Mjk3NVwiLFwicmFycmJcIjpcIlxcdTIxRTVcIixcInJhcnJiZnNcIjpcIlxcdTI5MjBcIixcInJhcnJjXCI6XCJcXHUyOTMzXCIsXCJyYXJyXCI6XCJcXHUyMTkyXCIsXCJSYXJyXCI6XCJcXHUyMUEwXCIsXCJyQXJyXCI6XCJcXHUyMUQyXCIsXCJyYXJyZnNcIjpcIlxcdTI5MUVcIixcInJhcnJoa1wiOlwiXFx1MjFBQVwiLFwicmFycmxwXCI6XCJcXHUyMUFDXCIsXCJyYXJycGxcIjpcIlxcdTI5NDVcIixcInJhcnJzaW1cIjpcIlxcdTI5NzRcIixcIlJhcnJ0bFwiOlwiXFx1MjkxNlwiLFwicmFycnRsXCI6XCJcXHUyMUEzXCIsXCJyYXJyd1wiOlwiXFx1MjE5RFwiLFwicmF0YWlsXCI6XCJcXHUyOTFBXCIsXCJyQXRhaWxcIjpcIlxcdTI5MUNcIixcInJhdGlvXCI6XCJcXHUyMjM2XCIsXCJyYXRpb25hbHNcIjpcIlxcdTIxMUFcIixcInJiYXJyXCI6XCJcXHUyOTBEXCIsXCJyQmFyclwiOlwiXFx1MjkwRlwiLFwiUkJhcnJcIjpcIlxcdTI5MTBcIixcInJiYnJrXCI6XCJcXHUyNzczXCIsXCJyYnJhY2VcIjpcIn1cIixcInJicmFja1wiOlwiXVwiLFwicmJya2VcIjpcIlxcdTI5OENcIixcInJicmtzbGRcIjpcIlxcdTI5OEVcIixcInJicmtzbHVcIjpcIlxcdTI5OTBcIixcIlJjYXJvblwiOlwiXFx1MDE1OFwiLFwicmNhcm9uXCI6XCJcXHUwMTU5XCIsXCJSY2VkaWxcIjpcIlxcdTAxNTZcIixcInJjZWRpbFwiOlwiXFx1MDE1N1wiLFwicmNlaWxcIjpcIlxcdTIzMDlcIixcInJjdWJcIjpcIn1cIixcIlJjeVwiOlwiXFx1MDQyMFwiLFwicmN5XCI6XCJcXHUwNDQwXCIsXCJyZGNhXCI6XCJcXHUyOTM3XCIsXCJyZGxkaGFyXCI6XCJcXHUyOTY5XCIsXCJyZHF1b1wiOlwiXFx1MjAxRFwiLFwicmRxdW9yXCI6XCJcXHUyMDFEXCIsXCJyZHNoXCI6XCJcXHUyMUIzXCIsXCJyZWFsXCI6XCJcXHUyMTFDXCIsXCJyZWFsaW5lXCI6XCJcXHUyMTFCXCIsXCJyZWFscGFydFwiOlwiXFx1MjExQ1wiLFwicmVhbHNcIjpcIlxcdTIxMURcIixcIlJlXCI6XCJcXHUyMTFDXCIsXCJyZWN0XCI6XCJcXHUyNUFEXCIsXCJyZWdcIjpcIlxcdTAwQUVcIixcIlJFR1wiOlwiXFx1MDBBRVwiLFwiUmV2ZXJzZUVsZW1lbnRcIjpcIlxcdTIyMEJcIixcIlJldmVyc2VFcXVpbGlicml1bVwiOlwiXFx1MjFDQlwiLFwiUmV2ZXJzZVVwRXF1aWxpYnJpdW1cIjpcIlxcdTI5NkZcIixcInJmaXNodFwiOlwiXFx1Mjk3RFwiLFwicmZsb29yXCI6XCJcXHUyMzBCXCIsXCJyZnJcIjpcIlxcdUQ4MzVcXHVERDJGXCIsXCJSZnJcIjpcIlxcdTIxMUNcIixcInJIYXJcIjpcIlxcdTI5NjRcIixcInJoYXJkXCI6XCJcXHUyMUMxXCIsXCJyaGFydVwiOlwiXFx1MjFDMFwiLFwicmhhcnVsXCI6XCJcXHUyOTZDXCIsXCJSaG9cIjpcIlxcdTAzQTFcIixcInJob1wiOlwiXFx1MDNDMVwiLFwicmhvdlwiOlwiXFx1MDNGMVwiLFwiUmlnaHRBbmdsZUJyYWNrZXRcIjpcIlxcdTI3RTlcIixcIlJpZ2h0QXJyb3dCYXJcIjpcIlxcdTIxRTVcIixcInJpZ2h0YXJyb3dcIjpcIlxcdTIxOTJcIixcIlJpZ2h0QXJyb3dcIjpcIlxcdTIxOTJcIixcIlJpZ2h0YXJyb3dcIjpcIlxcdTIxRDJcIixcIlJpZ2h0QXJyb3dMZWZ0QXJyb3dcIjpcIlxcdTIxQzRcIixcInJpZ2h0YXJyb3d0YWlsXCI6XCJcXHUyMUEzXCIsXCJSaWdodENlaWxpbmdcIjpcIlxcdTIzMDlcIixcIlJpZ2h0RG91YmxlQnJhY2tldFwiOlwiXFx1MjdFN1wiLFwiUmlnaHREb3duVGVlVmVjdG9yXCI6XCJcXHUyOTVEXCIsXCJSaWdodERvd25WZWN0b3JCYXJcIjpcIlxcdTI5NTVcIixcIlJpZ2h0RG93blZlY3RvclwiOlwiXFx1MjFDMlwiLFwiUmlnaHRGbG9vclwiOlwiXFx1MjMwQlwiLFwicmlnaHRoYXJwb29uZG93blwiOlwiXFx1MjFDMVwiLFwicmlnaHRoYXJwb29udXBcIjpcIlxcdTIxQzBcIixcInJpZ2h0bGVmdGFycm93c1wiOlwiXFx1MjFDNFwiLFwicmlnaHRsZWZ0aGFycG9vbnNcIjpcIlxcdTIxQ0NcIixcInJpZ2h0cmlnaHRhcnJvd3NcIjpcIlxcdTIxQzlcIixcInJpZ2h0c3F1aWdhcnJvd1wiOlwiXFx1MjE5RFwiLFwiUmlnaHRUZWVBcnJvd1wiOlwiXFx1MjFBNlwiLFwiUmlnaHRUZWVcIjpcIlxcdTIyQTJcIixcIlJpZ2h0VGVlVmVjdG9yXCI6XCJcXHUyOTVCXCIsXCJyaWdodHRocmVldGltZXNcIjpcIlxcdTIyQ0NcIixcIlJpZ2h0VHJpYW5nbGVCYXJcIjpcIlxcdTI5RDBcIixcIlJpZ2h0VHJpYW5nbGVcIjpcIlxcdTIyQjNcIixcIlJpZ2h0VHJpYW5nbGVFcXVhbFwiOlwiXFx1MjJCNVwiLFwiUmlnaHRVcERvd25WZWN0b3JcIjpcIlxcdTI5NEZcIixcIlJpZ2h0VXBUZWVWZWN0b3JcIjpcIlxcdTI5NUNcIixcIlJpZ2h0VXBWZWN0b3JCYXJcIjpcIlxcdTI5NTRcIixcIlJpZ2h0VXBWZWN0b3JcIjpcIlxcdTIxQkVcIixcIlJpZ2h0VmVjdG9yQmFyXCI6XCJcXHUyOTUzXCIsXCJSaWdodFZlY3RvclwiOlwiXFx1MjFDMFwiLFwicmluZ1wiOlwiXFx1MDJEQVwiLFwicmlzaW5nZG90c2VxXCI6XCJcXHUyMjUzXCIsXCJybGFyclwiOlwiXFx1MjFDNFwiLFwicmxoYXJcIjpcIlxcdTIxQ0NcIixcInJsbVwiOlwiXFx1MjAwRlwiLFwicm1vdXN0YWNoZVwiOlwiXFx1MjNCMVwiLFwicm1vdXN0XCI6XCJcXHUyM0IxXCIsXCJybm1pZFwiOlwiXFx1MkFFRVwiLFwicm9hbmdcIjpcIlxcdTI3RURcIixcInJvYXJyXCI6XCJcXHUyMUZFXCIsXCJyb2Jya1wiOlwiXFx1MjdFN1wiLFwicm9wYXJcIjpcIlxcdTI5ODZcIixcInJvcGZcIjpcIlxcdUQ4MzVcXHVERDYzXCIsXCJSb3BmXCI6XCJcXHUyMTFEXCIsXCJyb3BsdXNcIjpcIlxcdTJBMkVcIixcInJvdGltZXNcIjpcIlxcdTJBMzVcIixcIlJvdW5kSW1wbGllc1wiOlwiXFx1Mjk3MFwiLFwicnBhclwiOlwiKVwiLFwicnBhcmd0XCI6XCJcXHUyOTk0XCIsXCJycHBvbGludFwiOlwiXFx1MkExMlwiLFwicnJhcnJcIjpcIlxcdTIxQzlcIixcIlJyaWdodGFycm93XCI6XCJcXHUyMURCXCIsXCJyc2FxdW9cIjpcIlxcdTIwM0FcIixcInJzY3JcIjpcIlxcdUQ4MzVcXHVEQ0M3XCIsXCJSc2NyXCI6XCJcXHUyMTFCXCIsXCJyc2hcIjpcIlxcdTIxQjFcIixcIlJzaFwiOlwiXFx1MjFCMVwiLFwicnNxYlwiOlwiXVwiLFwicnNxdW9cIjpcIlxcdTIwMTlcIixcInJzcXVvclwiOlwiXFx1MjAxOVwiLFwicnRocmVlXCI6XCJcXHUyMkNDXCIsXCJydGltZXNcIjpcIlxcdTIyQ0FcIixcInJ0cmlcIjpcIlxcdTI1QjlcIixcInJ0cmllXCI6XCJcXHUyMkI1XCIsXCJydHJpZlwiOlwiXFx1MjVCOFwiLFwicnRyaWx0cmlcIjpcIlxcdTI5Q0VcIixcIlJ1bGVEZWxheWVkXCI6XCJcXHUyOUY0XCIsXCJydWx1aGFyXCI6XCJcXHUyOTY4XCIsXCJyeFwiOlwiXFx1MjExRVwiLFwiU2FjdXRlXCI6XCJcXHUwMTVBXCIsXCJzYWN1dGVcIjpcIlxcdTAxNUJcIixcInNicXVvXCI6XCJcXHUyMDFBXCIsXCJzY2FwXCI6XCJcXHUyQUI4XCIsXCJTY2Fyb25cIjpcIlxcdTAxNjBcIixcInNjYXJvblwiOlwiXFx1MDE2MVwiLFwiU2NcIjpcIlxcdTJBQkNcIixcInNjXCI6XCJcXHUyMjdCXCIsXCJzY2N1ZVwiOlwiXFx1MjI3RFwiLFwic2NlXCI6XCJcXHUyQUIwXCIsXCJzY0VcIjpcIlxcdTJBQjRcIixcIlNjZWRpbFwiOlwiXFx1MDE1RVwiLFwic2NlZGlsXCI6XCJcXHUwMTVGXCIsXCJTY2lyY1wiOlwiXFx1MDE1Q1wiLFwic2NpcmNcIjpcIlxcdTAxNURcIixcInNjbmFwXCI6XCJcXHUyQUJBXCIsXCJzY25FXCI6XCJcXHUyQUI2XCIsXCJzY25zaW1cIjpcIlxcdTIyRTlcIixcInNjcG9saW50XCI6XCJcXHUyQTEzXCIsXCJzY3NpbVwiOlwiXFx1MjI3RlwiLFwiU2N5XCI6XCJcXHUwNDIxXCIsXCJzY3lcIjpcIlxcdTA0NDFcIixcInNkb3RiXCI6XCJcXHUyMkExXCIsXCJzZG90XCI6XCJcXHUyMkM1XCIsXCJzZG90ZVwiOlwiXFx1MkE2NlwiLFwic2VhcmhrXCI6XCJcXHUyOTI1XCIsXCJzZWFyclwiOlwiXFx1MjE5OFwiLFwic2VBcnJcIjpcIlxcdTIxRDhcIixcInNlYXJyb3dcIjpcIlxcdTIxOThcIixcInNlY3RcIjpcIlxcdTAwQTdcIixcInNlbWlcIjpcIjtcIixcInNlc3dhclwiOlwiXFx1MjkyOVwiLFwic2V0bWludXNcIjpcIlxcdTIyMTZcIixcInNldG1uXCI6XCJcXHUyMjE2XCIsXCJzZXh0XCI6XCJcXHUyNzM2XCIsXCJTZnJcIjpcIlxcdUQ4MzVcXHVERDE2XCIsXCJzZnJcIjpcIlxcdUQ4MzVcXHVERDMwXCIsXCJzZnJvd25cIjpcIlxcdTIzMjJcIixcInNoYXJwXCI6XCJcXHUyNjZGXCIsXCJTSENIY3lcIjpcIlxcdTA0MjlcIixcInNoY2hjeVwiOlwiXFx1MDQ0OVwiLFwiU0hjeVwiOlwiXFx1MDQyOFwiLFwic2hjeVwiOlwiXFx1MDQ0OFwiLFwiU2hvcnREb3duQXJyb3dcIjpcIlxcdTIxOTNcIixcIlNob3J0TGVmdEFycm93XCI6XCJcXHUyMTkwXCIsXCJzaG9ydG1pZFwiOlwiXFx1MjIyM1wiLFwic2hvcnRwYXJhbGxlbFwiOlwiXFx1MjIyNVwiLFwiU2hvcnRSaWdodEFycm93XCI6XCJcXHUyMTkyXCIsXCJTaG9ydFVwQXJyb3dcIjpcIlxcdTIxOTFcIixcInNoeVwiOlwiXFx1MDBBRFwiLFwiU2lnbWFcIjpcIlxcdTAzQTNcIixcInNpZ21hXCI6XCJcXHUwM0MzXCIsXCJzaWdtYWZcIjpcIlxcdTAzQzJcIixcInNpZ21hdlwiOlwiXFx1MDNDMlwiLFwic2ltXCI6XCJcXHUyMjNDXCIsXCJzaW1kb3RcIjpcIlxcdTJBNkFcIixcInNpbWVcIjpcIlxcdTIyNDNcIixcInNpbWVxXCI6XCJcXHUyMjQzXCIsXCJzaW1nXCI6XCJcXHUyQTlFXCIsXCJzaW1nRVwiOlwiXFx1MkFBMFwiLFwic2ltbFwiOlwiXFx1MkE5RFwiLFwic2ltbEVcIjpcIlxcdTJBOUZcIixcInNpbW5lXCI6XCJcXHUyMjQ2XCIsXCJzaW1wbHVzXCI6XCJcXHUyQTI0XCIsXCJzaW1yYXJyXCI6XCJcXHUyOTcyXCIsXCJzbGFyclwiOlwiXFx1MjE5MFwiLFwiU21hbGxDaXJjbGVcIjpcIlxcdTIyMThcIixcInNtYWxsc2V0bWludXNcIjpcIlxcdTIyMTZcIixcInNtYXNocFwiOlwiXFx1MkEzM1wiLFwic21lcGFyc2xcIjpcIlxcdTI5RTRcIixcInNtaWRcIjpcIlxcdTIyMjNcIixcInNtaWxlXCI6XCJcXHUyMzIzXCIsXCJzbXRcIjpcIlxcdTJBQUFcIixcInNtdGVcIjpcIlxcdTJBQUNcIixcInNtdGVzXCI6XCJcXHUyQUFDXFx1RkUwMFwiLFwiU09GVGN5XCI6XCJcXHUwNDJDXCIsXCJzb2Z0Y3lcIjpcIlxcdTA0NENcIixcInNvbGJhclwiOlwiXFx1MjMzRlwiLFwic29sYlwiOlwiXFx1MjlDNFwiLFwic29sXCI6XCIvXCIsXCJTb3BmXCI6XCJcXHVEODM1XFx1REQ0QVwiLFwic29wZlwiOlwiXFx1RDgzNVxcdURENjRcIixcInNwYWRlc1wiOlwiXFx1MjY2MFwiLFwic3BhZGVzdWl0XCI6XCJcXHUyNjYwXCIsXCJzcGFyXCI6XCJcXHUyMjI1XCIsXCJzcWNhcFwiOlwiXFx1MjI5M1wiLFwic3FjYXBzXCI6XCJcXHUyMjkzXFx1RkUwMFwiLFwic3FjdXBcIjpcIlxcdTIyOTRcIixcInNxY3Vwc1wiOlwiXFx1MjI5NFxcdUZFMDBcIixcIlNxcnRcIjpcIlxcdTIyMUFcIixcInNxc3ViXCI6XCJcXHUyMjhGXCIsXCJzcXN1YmVcIjpcIlxcdTIyOTFcIixcInNxc3Vic2V0XCI6XCJcXHUyMjhGXCIsXCJzcXN1YnNldGVxXCI6XCJcXHUyMjkxXCIsXCJzcXN1cFwiOlwiXFx1MjI5MFwiLFwic3FzdXBlXCI6XCJcXHUyMjkyXCIsXCJzcXN1cHNldFwiOlwiXFx1MjI5MFwiLFwic3FzdXBzZXRlcVwiOlwiXFx1MjI5MlwiLFwic3F1YXJlXCI6XCJcXHUyNUExXCIsXCJTcXVhcmVcIjpcIlxcdTI1QTFcIixcIlNxdWFyZUludGVyc2VjdGlvblwiOlwiXFx1MjI5M1wiLFwiU3F1YXJlU3Vic2V0XCI6XCJcXHUyMjhGXCIsXCJTcXVhcmVTdWJzZXRFcXVhbFwiOlwiXFx1MjI5MVwiLFwiU3F1YXJlU3VwZXJzZXRcIjpcIlxcdTIyOTBcIixcIlNxdWFyZVN1cGVyc2V0RXF1YWxcIjpcIlxcdTIyOTJcIixcIlNxdWFyZVVuaW9uXCI6XCJcXHUyMjk0XCIsXCJzcXVhcmZcIjpcIlxcdTI1QUFcIixcInNxdVwiOlwiXFx1MjVBMVwiLFwic3F1ZlwiOlwiXFx1MjVBQVwiLFwic3JhcnJcIjpcIlxcdTIxOTJcIixcIlNzY3JcIjpcIlxcdUQ4MzVcXHVEQ0FFXCIsXCJzc2NyXCI6XCJcXHVEODM1XFx1RENDOFwiLFwic3NldG1uXCI6XCJcXHUyMjE2XCIsXCJzc21pbGVcIjpcIlxcdTIzMjNcIixcInNzdGFyZlwiOlwiXFx1MjJDNlwiLFwiU3RhclwiOlwiXFx1MjJDNlwiLFwic3RhclwiOlwiXFx1MjYwNlwiLFwic3RhcmZcIjpcIlxcdTI2MDVcIixcInN0cmFpZ2h0ZXBzaWxvblwiOlwiXFx1MDNGNVwiLFwic3RyYWlnaHRwaGlcIjpcIlxcdTAzRDVcIixcInN0cm5zXCI6XCJcXHUwMEFGXCIsXCJzdWJcIjpcIlxcdTIyODJcIixcIlN1YlwiOlwiXFx1MjJEMFwiLFwic3ViZG90XCI6XCJcXHUyQUJEXCIsXCJzdWJFXCI6XCJcXHUyQUM1XCIsXCJzdWJlXCI6XCJcXHUyMjg2XCIsXCJzdWJlZG90XCI6XCJcXHUyQUMzXCIsXCJzdWJtdWx0XCI6XCJcXHUyQUMxXCIsXCJzdWJuRVwiOlwiXFx1MkFDQlwiLFwic3VibmVcIjpcIlxcdTIyOEFcIixcInN1YnBsdXNcIjpcIlxcdTJBQkZcIixcInN1YnJhcnJcIjpcIlxcdTI5NzlcIixcInN1YnNldFwiOlwiXFx1MjI4MlwiLFwiU3Vic2V0XCI6XCJcXHUyMkQwXCIsXCJzdWJzZXRlcVwiOlwiXFx1MjI4NlwiLFwic3Vic2V0ZXFxXCI6XCJcXHUyQUM1XCIsXCJTdWJzZXRFcXVhbFwiOlwiXFx1MjI4NlwiLFwic3Vic2V0bmVxXCI6XCJcXHUyMjhBXCIsXCJzdWJzZXRuZXFxXCI6XCJcXHUyQUNCXCIsXCJzdWJzaW1cIjpcIlxcdTJBQzdcIixcInN1YnN1YlwiOlwiXFx1MkFENVwiLFwic3Vic3VwXCI6XCJcXHUyQUQzXCIsXCJzdWNjYXBwcm94XCI6XCJcXHUyQUI4XCIsXCJzdWNjXCI6XCJcXHUyMjdCXCIsXCJzdWNjY3VybHllcVwiOlwiXFx1MjI3RFwiLFwiU3VjY2VlZHNcIjpcIlxcdTIyN0JcIixcIlN1Y2NlZWRzRXF1YWxcIjpcIlxcdTJBQjBcIixcIlN1Y2NlZWRzU2xhbnRFcXVhbFwiOlwiXFx1MjI3RFwiLFwiU3VjY2VlZHNUaWxkZVwiOlwiXFx1MjI3RlwiLFwic3VjY2VxXCI6XCJcXHUyQUIwXCIsXCJzdWNjbmFwcHJveFwiOlwiXFx1MkFCQVwiLFwic3VjY25lcXFcIjpcIlxcdTJBQjZcIixcInN1Y2Nuc2ltXCI6XCJcXHUyMkU5XCIsXCJzdWNjc2ltXCI6XCJcXHUyMjdGXCIsXCJTdWNoVGhhdFwiOlwiXFx1MjIwQlwiLFwic3VtXCI6XCJcXHUyMjExXCIsXCJTdW1cIjpcIlxcdTIyMTFcIixcInN1bmdcIjpcIlxcdTI2NkFcIixcInN1cDFcIjpcIlxcdTAwQjlcIixcInN1cDJcIjpcIlxcdTAwQjJcIixcInN1cDNcIjpcIlxcdTAwQjNcIixcInN1cFwiOlwiXFx1MjI4M1wiLFwiU3VwXCI6XCJcXHUyMkQxXCIsXCJzdXBkb3RcIjpcIlxcdTJBQkVcIixcInN1cGRzdWJcIjpcIlxcdTJBRDhcIixcInN1cEVcIjpcIlxcdTJBQzZcIixcInN1cGVcIjpcIlxcdTIyODdcIixcInN1cGVkb3RcIjpcIlxcdTJBQzRcIixcIlN1cGVyc2V0XCI6XCJcXHUyMjgzXCIsXCJTdXBlcnNldEVxdWFsXCI6XCJcXHUyMjg3XCIsXCJzdXBoc29sXCI6XCJcXHUyN0M5XCIsXCJzdXBoc3ViXCI6XCJcXHUyQUQ3XCIsXCJzdXBsYXJyXCI6XCJcXHUyOTdCXCIsXCJzdXBtdWx0XCI6XCJcXHUyQUMyXCIsXCJzdXBuRVwiOlwiXFx1MkFDQ1wiLFwic3VwbmVcIjpcIlxcdTIyOEJcIixcInN1cHBsdXNcIjpcIlxcdTJBQzBcIixcInN1cHNldFwiOlwiXFx1MjI4M1wiLFwiU3Vwc2V0XCI6XCJcXHUyMkQxXCIsXCJzdXBzZXRlcVwiOlwiXFx1MjI4N1wiLFwic3Vwc2V0ZXFxXCI6XCJcXHUyQUM2XCIsXCJzdXBzZXRuZXFcIjpcIlxcdTIyOEJcIixcInN1cHNldG5lcXFcIjpcIlxcdTJBQ0NcIixcInN1cHNpbVwiOlwiXFx1MkFDOFwiLFwic3Vwc3ViXCI6XCJcXHUyQUQ0XCIsXCJzdXBzdXBcIjpcIlxcdTJBRDZcIixcInN3YXJoa1wiOlwiXFx1MjkyNlwiLFwic3dhcnJcIjpcIlxcdTIxOTlcIixcInN3QXJyXCI6XCJcXHUyMUQ5XCIsXCJzd2Fycm93XCI6XCJcXHUyMTk5XCIsXCJzd253YXJcIjpcIlxcdTI5MkFcIixcInN6bGlnXCI6XCJcXHUwMERGXCIsXCJUYWJcIjpcIlxcdFwiLFwidGFyZ2V0XCI6XCJcXHUyMzE2XCIsXCJUYXVcIjpcIlxcdTAzQTRcIixcInRhdVwiOlwiXFx1MDNDNFwiLFwidGJya1wiOlwiXFx1MjNCNFwiLFwiVGNhcm9uXCI6XCJcXHUwMTY0XCIsXCJ0Y2Fyb25cIjpcIlxcdTAxNjVcIixcIlRjZWRpbFwiOlwiXFx1MDE2MlwiLFwidGNlZGlsXCI6XCJcXHUwMTYzXCIsXCJUY3lcIjpcIlxcdTA0MjJcIixcInRjeVwiOlwiXFx1MDQ0MlwiLFwidGRvdFwiOlwiXFx1MjBEQlwiLFwidGVscmVjXCI6XCJcXHUyMzE1XCIsXCJUZnJcIjpcIlxcdUQ4MzVcXHVERDE3XCIsXCJ0ZnJcIjpcIlxcdUQ4MzVcXHVERDMxXCIsXCJ0aGVyZTRcIjpcIlxcdTIyMzRcIixcInRoZXJlZm9yZVwiOlwiXFx1MjIzNFwiLFwiVGhlcmVmb3JlXCI6XCJcXHUyMjM0XCIsXCJUaGV0YVwiOlwiXFx1MDM5OFwiLFwidGhldGFcIjpcIlxcdTAzQjhcIixcInRoZXRhc3ltXCI6XCJcXHUwM0QxXCIsXCJ0aGV0YXZcIjpcIlxcdTAzRDFcIixcInRoaWNrYXBwcm94XCI6XCJcXHUyMjQ4XCIsXCJ0aGlja3NpbVwiOlwiXFx1MjIzQ1wiLFwiVGhpY2tTcGFjZVwiOlwiXFx1MjA1RlxcdTIwMEFcIixcIlRoaW5TcGFjZVwiOlwiXFx1MjAwOVwiLFwidGhpbnNwXCI6XCJcXHUyMDA5XCIsXCJ0aGthcFwiOlwiXFx1MjI0OFwiLFwidGhrc2ltXCI6XCJcXHUyMjNDXCIsXCJUSE9STlwiOlwiXFx1MDBERVwiLFwidGhvcm5cIjpcIlxcdTAwRkVcIixcInRpbGRlXCI6XCJcXHUwMkRDXCIsXCJUaWxkZVwiOlwiXFx1MjIzQ1wiLFwiVGlsZGVFcXVhbFwiOlwiXFx1MjI0M1wiLFwiVGlsZGVGdWxsRXF1YWxcIjpcIlxcdTIyNDVcIixcIlRpbGRlVGlsZGVcIjpcIlxcdTIyNDhcIixcInRpbWVzYmFyXCI6XCJcXHUyQTMxXCIsXCJ0aW1lc2JcIjpcIlxcdTIyQTBcIixcInRpbWVzXCI6XCJcXHUwMEQ3XCIsXCJ0aW1lc2RcIjpcIlxcdTJBMzBcIixcInRpbnRcIjpcIlxcdTIyMkRcIixcInRvZWFcIjpcIlxcdTI5MjhcIixcInRvcGJvdFwiOlwiXFx1MjMzNlwiLFwidG9wY2lyXCI6XCJcXHUyQUYxXCIsXCJ0b3BcIjpcIlxcdTIyQTRcIixcIlRvcGZcIjpcIlxcdUQ4MzVcXHVERDRCXCIsXCJ0b3BmXCI6XCJcXHVEODM1XFx1REQ2NVwiLFwidG9wZm9ya1wiOlwiXFx1MkFEQVwiLFwidG9zYVwiOlwiXFx1MjkyOVwiLFwidHByaW1lXCI6XCJcXHUyMDM0XCIsXCJ0cmFkZVwiOlwiXFx1MjEyMlwiLFwiVFJBREVcIjpcIlxcdTIxMjJcIixcInRyaWFuZ2xlXCI6XCJcXHUyNUI1XCIsXCJ0cmlhbmdsZWRvd25cIjpcIlxcdTI1QkZcIixcInRyaWFuZ2xlbGVmdFwiOlwiXFx1MjVDM1wiLFwidHJpYW5nbGVsZWZ0ZXFcIjpcIlxcdTIyQjRcIixcInRyaWFuZ2xlcVwiOlwiXFx1MjI1Q1wiLFwidHJpYW5nbGVyaWdodFwiOlwiXFx1MjVCOVwiLFwidHJpYW5nbGVyaWdodGVxXCI6XCJcXHUyMkI1XCIsXCJ0cmlkb3RcIjpcIlxcdTI1RUNcIixcInRyaWVcIjpcIlxcdTIyNUNcIixcInRyaW1pbnVzXCI6XCJcXHUyQTNBXCIsXCJUcmlwbGVEb3RcIjpcIlxcdTIwREJcIixcInRyaXBsdXNcIjpcIlxcdTJBMzlcIixcInRyaXNiXCI6XCJcXHUyOUNEXCIsXCJ0cml0aW1lXCI6XCJcXHUyQTNCXCIsXCJ0cnBleml1bVwiOlwiXFx1MjNFMlwiLFwiVHNjclwiOlwiXFx1RDgzNVxcdURDQUZcIixcInRzY3JcIjpcIlxcdUQ4MzVcXHVEQ0M5XCIsXCJUU2N5XCI6XCJcXHUwNDI2XCIsXCJ0c2N5XCI6XCJcXHUwNDQ2XCIsXCJUU0hjeVwiOlwiXFx1MDQwQlwiLFwidHNoY3lcIjpcIlxcdTA0NUJcIixcIlRzdHJva1wiOlwiXFx1MDE2NlwiLFwidHN0cm9rXCI6XCJcXHUwMTY3XCIsXCJ0d2l4dFwiOlwiXFx1MjI2Q1wiLFwidHdvaGVhZGxlZnRhcnJvd1wiOlwiXFx1MjE5RVwiLFwidHdvaGVhZHJpZ2h0YXJyb3dcIjpcIlxcdTIxQTBcIixcIlVhY3V0ZVwiOlwiXFx1MDBEQVwiLFwidWFjdXRlXCI6XCJcXHUwMEZBXCIsXCJ1YXJyXCI6XCJcXHUyMTkxXCIsXCJVYXJyXCI6XCJcXHUyMTlGXCIsXCJ1QXJyXCI6XCJcXHUyMUQxXCIsXCJVYXJyb2NpclwiOlwiXFx1Mjk0OVwiLFwiVWJyY3lcIjpcIlxcdTA0MEVcIixcInVicmN5XCI6XCJcXHUwNDVFXCIsXCJVYnJldmVcIjpcIlxcdTAxNkNcIixcInVicmV2ZVwiOlwiXFx1MDE2RFwiLFwiVWNpcmNcIjpcIlxcdTAwREJcIixcInVjaXJjXCI6XCJcXHUwMEZCXCIsXCJVY3lcIjpcIlxcdTA0MjNcIixcInVjeVwiOlwiXFx1MDQ0M1wiLFwidWRhcnJcIjpcIlxcdTIxQzVcIixcIlVkYmxhY1wiOlwiXFx1MDE3MFwiLFwidWRibGFjXCI6XCJcXHUwMTcxXCIsXCJ1ZGhhclwiOlwiXFx1Mjk2RVwiLFwidWZpc2h0XCI6XCJcXHUyOTdFXCIsXCJVZnJcIjpcIlxcdUQ4MzVcXHVERDE4XCIsXCJ1ZnJcIjpcIlxcdUQ4MzVcXHVERDMyXCIsXCJVZ3JhdmVcIjpcIlxcdTAwRDlcIixcInVncmF2ZVwiOlwiXFx1MDBGOVwiLFwidUhhclwiOlwiXFx1Mjk2M1wiLFwidWhhcmxcIjpcIlxcdTIxQkZcIixcInVoYXJyXCI6XCJcXHUyMUJFXCIsXCJ1aGJsa1wiOlwiXFx1MjU4MFwiLFwidWxjb3JuXCI6XCJcXHUyMzFDXCIsXCJ1bGNvcm5lclwiOlwiXFx1MjMxQ1wiLFwidWxjcm9wXCI6XCJcXHUyMzBGXCIsXCJ1bHRyaVwiOlwiXFx1MjVGOFwiLFwiVW1hY3JcIjpcIlxcdTAxNkFcIixcInVtYWNyXCI6XCJcXHUwMTZCXCIsXCJ1bWxcIjpcIlxcdTAwQThcIixcIlVuZGVyQmFyXCI6XCJfXCIsXCJVbmRlckJyYWNlXCI6XCJcXHUyM0RGXCIsXCJVbmRlckJyYWNrZXRcIjpcIlxcdTIzQjVcIixcIlVuZGVyUGFyZW50aGVzaXNcIjpcIlxcdTIzRERcIixcIlVuaW9uXCI6XCJcXHUyMkMzXCIsXCJVbmlvblBsdXNcIjpcIlxcdTIyOEVcIixcIlVvZ29uXCI6XCJcXHUwMTcyXCIsXCJ1b2dvblwiOlwiXFx1MDE3M1wiLFwiVW9wZlwiOlwiXFx1RDgzNVxcdURENENcIixcInVvcGZcIjpcIlxcdUQ4MzVcXHVERDY2XCIsXCJVcEFycm93QmFyXCI6XCJcXHUyOTEyXCIsXCJ1cGFycm93XCI6XCJcXHUyMTkxXCIsXCJVcEFycm93XCI6XCJcXHUyMTkxXCIsXCJVcGFycm93XCI6XCJcXHUyMUQxXCIsXCJVcEFycm93RG93bkFycm93XCI6XCJcXHUyMUM1XCIsXCJ1cGRvd25hcnJvd1wiOlwiXFx1MjE5NVwiLFwiVXBEb3duQXJyb3dcIjpcIlxcdTIxOTVcIixcIlVwZG93bmFycm93XCI6XCJcXHUyMUQ1XCIsXCJVcEVxdWlsaWJyaXVtXCI6XCJcXHUyOTZFXCIsXCJ1cGhhcnBvb25sZWZ0XCI6XCJcXHUyMUJGXCIsXCJ1cGhhcnBvb25yaWdodFwiOlwiXFx1MjFCRVwiLFwidXBsdXNcIjpcIlxcdTIyOEVcIixcIlVwcGVyTGVmdEFycm93XCI6XCJcXHUyMTk2XCIsXCJVcHBlclJpZ2h0QXJyb3dcIjpcIlxcdTIxOTdcIixcInVwc2lcIjpcIlxcdTAzQzVcIixcIlVwc2lcIjpcIlxcdTAzRDJcIixcInVwc2loXCI6XCJcXHUwM0QyXCIsXCJVcHNpbG9uXCI6XCJcXHUwM0E1XCIsXCJ1cHNpbG9uXCI6XCJcXHUwM0M1XCIsXCJVcFRlZUFycm93XCI6XCJcXHUyMUE1XCIsXCJVcFRlZVwiOlwiXFx1MjJBNVwiLFwidXB1cGFycm93c1wiOlwiXFx1MjFDOFwiLFwidXJjb3JuXCI6XCJcXHUyMzFEXCIsXCJ1cmNvcm5lclwiOlwiXFx1MjMxRFwiLFwidXJjcm9wXCI6XCJcXHUyMzBFXCIsXCJVcmluZ1wiOlwiXFx1MDE2RVwiLFwidXJpbmdcIjpcIlxcdTAxNkZcIixcInVydHJpXCI6XCJcXHUyNUY5XCIsXCJVc2NyXCI6XCJcXHVEODM1XFx1RENCMFwiLFwidXNjclwiOlwiXFx1RDgzNVxcdURDQ0FcIixcInV0ZG90XCI6XCJcXHUyMkYwXCIsXCJVdGlsZGVcIjpcIlxcdTAxNjhcIixcInV0aWxkZVwiOlwiXFx1MDE2OVwiLFwidXRyaVwiOlwiXFx1MjVCNVwiLFwidXRyaWZcIjpcIlxcdTI1QjRcIixcInV1YXJyXCI6XCJcXHUyMUM4XCIsXCJVdW1sXCI6XCJcXHUwMERDXCIsXCJ1dW1sXCI6XCJcXHUwMEZDXCIsXCJ1d2FuZ2xlXCI6XCJcXHUyOUE3XCIsXCJ2YW5ncnRcIjpcIlxcdTI5OUNcIixcInZhcmVwc2lsb25cIjpcIlxcdTAzRjVcIixcInZhcmthcHBhXCI6XCJcXHUwM0YwXCIsXCJ2YXJub3RoaW5nXCI6XCJcXHUyMjA1XCIsXCJ2YXJwaGlcIjpcIlxcdTAzRDVcIixcInZhcnBpXCI6XCJcXHUwM0Q2XCIsXCJ2YXJwcm9wdG9cIjpcIlxcdTIyMURcIixcInZhcnJcIjpcIlxcdTIxOTVcIixcInZBcnJcIjpcIlxcdTIxRDVcIixcInZhcnJob1wiOlwiXFx1MDNGMVwiLFwidmFyc2lnbWFcIjpcIlxcdTAzQzJcIixcInZhcnN1YnNldG5lcVwiOlwiXFx1MjI4QVxcdUZFMDBcIixcInZhcnN1YnNldG5lcXFcIjpcIlxcdTJBQ0JcXHVGRTAwXCIsXCJ2YXJzdXBzZXRuZXFcIjpcIlxcdTIyOEJcXHVGRTAwXCIsXCJ2YXJzdXBzZXRuZXFxXCI6XCJcXHUyQUNDXFx1RkUwMFwiLFwidmFydGhldGFcIjpcIlxcdTAzRDFcIixcInZhcnRyaWFuZ2xlbGVmdFwiOlwiXFx1MjJCMlwiLFwidmFydHJpYW5nbGVyaWdodFwiOlwiXFx1MjJCM1wiLFwidkJhclwiOlwiXFx1MkFFOFwiLFwiVmJhclwiOlwiXFx1MkFFQlwiLFwidkJhcnZcIjpcIlxcdTJBRTlcIixcIlZjeVwiOlwiXFx1MDQxMlwiLFwidmN5XCI6XCJcXHUwNDMyXCIsXCJ2ZGFzaFwiOlwiXFx1MjJBMlwiLFwidkRhc2hcIjpcIlxcdTIyQThcIixcIlZkYXNoXCI6XCJcXHUyMkE5XCIsXCJWRGFzaFwiOlwiXFx1MjJBQlwiLFwiVmRhc2hsXCI6XCJcXHUyQUU2XCIsXCJ2ZWViYXJcIjpcIlxcdTIyQkJcIixcInZlZVwiOlwiXFx1MjIyOFwiLFwiVmVlXCI6XCJcXHUyMkMxXCIsXCJ2ZWVlcVwiOlwiXFx1MjI1QVwiLFwidmVsbGlwXCI6XCJcXHUyMkVFXCIsXCJ2ZXJiYXJcIjpcInxcIixcIlZlcmJhclwiOlwiXFx1MjAxNlwiLFwidmVydFwiOlwifFwiLFwiVmVydFwiOlwiXFx1MjAxNlwiLFwiVmVydGljYWxCYXJcIjpcIlxcdTIyMjNcIixcIlZlcnRpY2FsTGluZVwiOlwifFwiLFwiVmVydGljYWxTZXBhcmF0b3JcIjpcIlxcdTI3NThcIixcIlZlcnRpY2FsVGlsZGVcIjpcIlxcdTIyNDBcIixcIlZlcnlUaGluU3BhY2VcIjpcIlxcdTIwMEFcIixcIlZmclwiOlwiXFx1RDgzNVxcdUREMTlcIixcInZmclwiOlwiXFx1RDgzNVxcdUREMzNcIixcInZsdHJpXCI6XCJcXHUyMkIyXCIsXCJ2bnN1YlwiOlwiXFx1MjI4MlxcdTIwRDJcIixcInZuc3VwXCI6XCJcXHUyMjgzXFx1MjBEMlwiLFwiVm9wZlwiOlwiXFx1RDgzNVxcdURENERcIixcInZvcGZcIjpcIlxcdUQ4MzVcXHVERDY3XCIsXCJ2cHJvcFwiOlwiXFx1MjIxRFwiLFwidnJ0cmlcIjpcIlxcdTIyQjNcIixcIlZzY3JcIjpcIlxcdUQ4MzVcXHVEQ0IxXCIsXCJ2c2NyXCI6XCJcXHVEODM1XFx1RENDQlwiLFwidnN1Ym5FXCI6XCJcXHUyQUNCXFx1RkUwMFwiLFwidnN1Ym5lXCI6XCJcXHUyMjhBXFx1RkUwMFwiLFwidnN1cG5FXCI6XCJcXHUyQUNDXFx1RkUwMFwiLFwidnN1cG5lXCI6XCJcXHUyMjhCXFx1RkUwMFwiLFwiVnZkYXNoXCI6XCJcXHUyMkFBXCIsXCJ2emlnemFnXCI6XCJcXHUyOTlBXCIsXCJXY2lyY1wiOlwiXFx1MDE3NFwiLFwid2NpcmNcIjpcIlxcdTAxNzVcIixcIndlZGJhclwiOlwiXFx1MkE1RlwiLFwid2VkZ2VcIjpcIlxcdTIyMjdcIixcIldlZGdlXCI6XCJcXHUyMkMwXCIsXCJ3ZWRnZXFcIjpcIlxcdTIyNTlcIixcIndlaWVycFwiOlwiXFx1MjExOFwiLFwiV2ZyXCI6XCJcXHVEODM1XFx1REQxQVwiLFwid2ZyXCI6XCJcXHVEODM1XFx1REQzNFwiLFwiV29wZlwiOlwiXFx1RDgzNVxcdURENEVcIixcIndvcGZcIjpcIlxcdUQ4MzVcXHVERDY4XCIsXCJ3cFwiOlwiXFx1MjExOFwiLFwid3JcIjpcIlxcdTIyNDBcIixcIndyZWF0aFwiOlwiXFx1MjI0MFwiLFwiV3NjclwiOlwiXFx1RDgzNVxcdURDQjJcIixcIndzY3JcIjpcIlxcdUQ4MzVcXHVEQ0NDXCIsXCJ4Y2FwXCI6XCJcXHUyMkMyXCIsXCJ4Y2lyY1wiOlwiXFx1MjVFRlwiLFwieGN1cFwiOlwiXFx1MjJDM1wiLFwieGR0cmlcIjpcIlxcdTI1QkRcIixcIlhmclwiOlwiXFx1RDgzNVxcdUREMUJcIixcInhmclwiOlwiXFx1RDgzNVxcdUREMzVcIixcInhoYXJyXCI6XCJcXHUyN0Y3XCIsXCJ4aEFyclwiOlwiXFx1MjdGQVwiLFwiWGlcIjpcIlxcdTAzOUVcIixcInhpXCI6XCJcXHUwM0JFXCIsXCJ4bGFyclwiOlwiXFx1MjdGNVwiLFwieGxBcnJcIjpcIlxcdTI3RjhcIixcInhtYXBcIjpcIlxcdTI3RkNcIixcInhuaXNcIjpcIlxcdTIyRkJcIixcInhvZG90XCI6XCJcXHUyQTAwXCIsXCJYb3BmXCI6XCJcXHVEODM1XFx1REQ0RlwiLFwieG9wZlwiOlwiXFx1RDgzNVxcdURENjlcIixcInhvcGx1c1wiOlwiXFx1MkEwMVwiLFwieG90aW1lXCI6XCJcXHUyQTAyXCIsXCJ4cmFyclwiOlwiXFx1MjdGNlwiLFwieHJBcnJcIjpcIlxcdTI3RjlcIixcIlhzY3JcIjpcIlxcdUQ4MzVcXHVEQ0IzXCIsXCJ4c2NyXCI6XCJcXHVEODM1XFx1RENDRFwiLFwieHNxY3VwXCI6XCJcXHUyQTA2XCIsXCJ4dXBsdXNcIjpcIlxcdTJBMDRcIixcInh1dHJpXCI6XCJcXHUyNUIzXCIsXCJ4dmVlXCI6XCJcXHUyMkMxXCIsXCJ4d2VkZ2VcIjpcIlxcdTIyQzBcIixcIllhY3V0ZVwiOlwiXFx1MDBERFwiLFwieWFjdXRlXCI6XCJcXHUwMEZEXCIsXCJZQWN5XCI6XCJcXHUwNDJGXCIsXCJ5YWN5XCI6XCJcXHUwNDRGXCIsXCJZY2lyY1wiOlwiXFx1MDE3NlwiLFwieWNpcmNcIjpcIlxcdTAxNzdcIixcIlljeVwiOlwiXFx1MDQyQlwiLFwieWN5XCI6XCJcXHUwNDRCXCIsXCJ5ZW5cIjpcIlxcdTAwQTVcIixcIllmclwiOlwiXFx1RDgzNVxcdUREMUNcIixcInlmclwiOlwiXFx1RDgzNVxcdUREMzZcIixcIllJY3lcIjpcIlxcdTA0MDdcIixcInlpY3lcIjpcIlxcdTA0NTdcIixcIllvcGZcIjpcIlxcdUQ4MzVcXHVERDUwXCIsXCJ5b3BmXCI6XCJcXHVEODM1XFx1REQ2QVwiLFwiWXNjclwiOlwiXFx1RDgzNVxcdURDQjRcIixcInlzY3JcIjpcIlxcdUQ4MzVcXHVEQ0NFXCIsXCJZVWN5XCI6XCJcXHUwNDJFXCIsXCJ5dWN5XCI6XCJcXHUwNDRFXCIsXCJ5dW1sXCI6XCJcXHUwMEZGXCIsXCJZdW1sXCI6XCJcXHUwMTc4XCIsXCJaYWN1dGVcIjpcIlxcdTAxNzlcIixcInphY3V0ZVwiOlwiXFx1MDE3QVwiLFwiWmNhcm9uXCI6XCJcXHUwMTdEXCIsXCJ6Y2Fyb25cIjpcIlxcdTAxN0VcIixcIlpjeVwiOlwiXFx1MDQxN1wiLFwiemN5XCI6XCJcXHUwNDM3XCIsXCJaZG90XCI6XCJcXHUwMTdCXCIsXCJ6ZG90XCI6XCJcXHUwMTdDXCIsXCJ6ZWV0cmZcIjpcIlxcdTIxMjhcIixcIlplcm9XaWR0aFNwYWNlXCI6XCJcXHUyMDBCXCIsXCJaZXRhXCI6XCJcXHUwMzk2XCIsXCJ6ZXRhXCI6XCJcXHUwM0I2XCIsXCJ6ZnJcIjpcIlxcdUQ4MzVcXHVERDM3XCIsXCJaZnJcIjpcIlxcdTIxMjhcIixcIlpIY3lcIjpcIlxcdTA0MTZcIixcInpoY3lcIjpcIlxcdTA0MzZcIixcInppZ3JhcnJcIjpcIlxcdTIxRERcIixcInpvcGZcIjpcIlxcdUQ4MzVcXHVERDZCXCIsXCJab3BmXCI6XCJcXHUyMTI0XCIsXCJac2NyXCI6XCJcXHVEODM1XFx1RENCNVwiLFwienNjclwiOlwiXFx1RDgzNVxcdURDQ0ZcIixcInp3alwiOlwiXFx1MjAwRFwiLFwiendualwiOlwiXFx1MjAwQ1wifVxyXG59LHt9XSw1MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLyBIZWxwZXJzXHJcblxyXG4vLyBNZXJnZSBvYmplY3RzXHJcbi8vXHJcbmZ1bmN0aW9uIGFzc2lnbihvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xyXG4gIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgIGlmICghc291cmNlKSB7IHJldHVybjsgfVxyXG5cclxuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgIG9ialtrZXldID0gc291cmNlW2tleV07XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuZnVuY3Rpb24gX2NsYXNzKG9iaikgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7IH1cclxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7IH1cclxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7IH1cclxuZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7IH1cclxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nOyB9XHJcblxyXG5cclxuZnVuY3Rpb24gZXNjYXBlUkUgKHN0cikgeyByZXR1cm4gc3RyLnJlcGxhY2UoL1suPyorXiRbXFxdXFxcXCgpe318LV0vZywgJ1xcXFwkJicpOyB9XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuXHJcbnZhciBkZWZhdWx0U2NoZW1hcyA9IHtcclxuICAnaHR0cDonOiB7XHJcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHRleHQsIHBvcywgc2VsZikge1xyXG4gICAgICB2YXIgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcclxuXHJcbiAgICAgIGlmICghc2VsZi5yZS5odHRwKSB7XHJcbiAgICAgICAgLy8gY29tcGlsZSBsYXppbHksIGJlY2F1c2UgXCJob3N0XCItY29udGFpbmluZyB2YXJpYWJsZXMgY2FuIGNoYW5nZSBvbiB0bGRzIHVwZGF0ZS5cclxuICAgICAgICBzZWxmLnJlLmh0dHAgPSAgbmV3IFJlZ0V4cChcclxuICAgICAgICAgICdeXFxcXC9cXFxcLycgKyBzZWxmLnJlLnNyY19hdXRoICsgc2VsZi5yZS5zcmNfaG9zdF9wb3J0X3N0cmljdCArIHNlbGYucmUuc3JjX3BhdGgsICdpJ1xyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNlbGYucmUuaHR0cC50ZXN0KHRhaWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2goc2VsZi5yZS5odHRwKVswXS5sZW5ndGg7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgfSxcclxuICAnaHR0cHM6JzogICdodHRwOicsXHJcbiAgJ2Z0cDonOiAgICAnaHR0cDonLFxyXG4gICcvLyc6ICAgICAge1xyXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh0ZXh0LCBwb3MsIHNlbGYpIHtcclxuICAgICAgdmFyIHRhaWwgPSB0ZXh0LnNsaWNlKHBvcyk7XHJcblxyXG4gICAgICBpZiAoIXNlbGYucmUubm9faHR0cCkge1xyXG4gICAgICAvLyBjb21waWxlIGxhemlseSwgYmVjYXlzZSBcImhvc3RcIi1jb250YWluaW5nIHZhcmlhYmxlcyBjYW4gY2hhbmdlIG9uIHRsZHMgdXBkYXRlLlxyXG4gICAgICAgIHNlbGYucmUubm9faHR0cCA9ICBuZXcgUmVnRXhwKFxyXG4gICAgICAgICAgJ14nICsgc2VsZi5yZS5zcmNfYXV0aCArIHNlbGYucmUuc3JjX2hvc3RfcG9ydF9zdHJpY3QgKyBzZWxmLnJlLnNyY19wYXRoLCAnaSdcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2VsZi5yZS5ub19odHRwLnRlc3QodGFpbCkpIHtcclxuICAgICAgICAvLyBzaG91bGQgbm90IGJlIGA6Ly9gLCB0aGF0IHByb3RlY3RzIGZyb20gZXJyb3JzIGluIHByb3RvY29sIG5hbWVcclxuICAgICAgICBpZiAocG9zID49IDMgJiYgdGV4dFtwb3MgLSAzXSA9PT0gJzonKSB7IHJldHVybiAwOyB9XHJcbiAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2goc2VsZi5yZS5ub19odHRwKVswXS5sZW5ndGg7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgfSxcclxuICAnbWFpbHRvOic6IHtcclxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodGV4dCwgcG9zLCBzZWxmKSB7XHJcbiAgICAgIHZhciB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xyXG5cclxuICAgICAgaWYgKCFzZWxmLnJlLm1haWx0bykge1xyXG4gICAgICAgIHNlbGYucmUubWFpbHRvID0gIG5ldyBSZWdFeHAoXHJcbiAgICAgICAgICAnXicgKyBzZWxmLnJlLnNyY19lbWFpbF9uYW1lICsgJ0AnICsgc2VsZi5yZS5zcmNfaG9zdF9zdHJpY3QsICdpJ1xyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNlbGYucmUubWFpbHRvLnRlc3QodGFpbCkpIHtcclxuICAgICAgICByZXR1cm4gdGFpbC5tYXRjaChzZWxmLnJlLm1haWx0bylbMF0ubGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8vIERPTidUIHRyeSB0byBtYWtlIFBScyB3aXRoIGNoYW5nZXMuIEV4dGVuZCBUTERzIHdpdGggTGlua2lmeUl0LnRsZHMoKSBpbnN0ZWFkXHJcbnZhciB0bGRzX2RlZmF1bHQgPSAnYml6fGNvbXxlZHV8Z292fG5ldHxvcmd8cHJvfHdlYnx4eHh8YWVyb3xhc2lhfGNvb3B8aW5mb3xtdXNldW18bmFtZXxzaG9wfNGA0YQnLnNwbGl0KCd8Jyk7XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuZnVuY3Rpb24gcmVzZXRTY2FuQ2FjaGUoc2VsZikge1xyXG4gIHNlbGYuX19pbmRleF9fID0gLTE7XHJcbiAgc2VsZi5fX3RleHRfY2FjaGVfXyAgID0gJyc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRvcihyZSkge1xyXG4gIHJldHVybiBmdW5jdGlvbiAodGV4dCwgcG9zKSB7XHJcbiAgICB2YXIgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcclxuXHJcbiAgICBpZiAocmUudGVzdCh0YWlsKSkge1xyXG4gICAgICByZXR1cm4gdGFpbC5tYXRjaChyZSlbMF0ubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTm9ybWFsaXplcigpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKG1hdGNoLCBzZWxmKSB7XHJcbiAgICBzZWxmLm5vcm1hbGl6ZShtYXRjaCk7XHJcbiAgfTtcclxufVxyXG5cclxuLy8gU2NoZW1hcyBjb21waWxlci4gQnVpbGQgcmVnZXhwcy5cclxuLy9cclxuZnVuY3Rpb24gY29tcGlsZShzZWxmKSB7XHJcblxyXG4gIC8vIExvYWQgJiBjbG9uZSBSRSBwYXR0ZXJucy5cclxuICB2YXIgcmUgPSBzZWxmLnJlID0gYXNzaWduKHt9LCByZXF1aXJlKCcuL2xpYi9yZScpKTtcclxuXHJcbiAgLy8gRGVmaW5lIGR5bmFtaWMgcGF0dGVybnNcclxuICB2YXIgdGxkcyA9IHNlbGYuX190bGRzX18uc2xpY2UoKTtcclxuXHJcbiAgaWYgKCFzZWxmLl9fdGxkc19yZXBsYWNlZF9fKSB7XHJcbiAgICB0bGRzLnB1c2goJ1thLXpdezJ9Jyk7XHJcbiAgfVxyXG4gIHRsZHMucHVzaChyZS5zcmNfeG4pO1xyXG5cclxuICByZS5zcmNfdGxkcyA9IHRsZHMuam9pbignfCcpO1xyXG5cclxuICBmdW5jdGlvbiB1bnRwbCh0cGwpIHsgcmV0dXJuIHRwbC5yZXBsYWNlKCclVExEUyUnLCByZS5zcmNfdGxkcyk7IH1cclxuXHJcbiAgcmUuZW1haWxfZnV6enkgICAgICA9IFJlZ0V4cCh1bnRwbChyZS50cGxfZW1haWxfZnV6enkpLCAnaScpO1xyXG4gIHJlLmxpbmtfZnV6enkgICAgICAgPSBSZWdFeHAodW50cGwocmUudHBsX2xpbmtfZnV6enkpLCAnaScpO1xyXG4gIHJlLmhvc3RfZnV6enlfdGVzdCAgPSBSZWdFeHAodW50cGwocmUudHBsX2hvc3RfZnV6enlfdGVzdCksICdpJyk7XHJcblxyXG4gIC8vXHJcbiAgLy8gQ29tcGlsZSBlYWNoIHNjaGVtYVxyXG4gIC8vXHJcblxyXG4gIHZhciBhbGlhc2VzID0gW107XHJcblxyXG4gIHNlbGYuX19jb21waWxlZF9fID0ge307IC8vIFJlc2V0IGNvbXBpbGVkIGRhdGFcclxuXHJcbiAgZnVuY3Rpb24gc2NoZW1hRXJyb3IobmFtZSwgdmFsKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJyhMaW5raWZ5SXQpIEludmFsaWQgc2NoZW1hIFwiJyArIG5hbWUgKyAnXCI6ICcgKyB2YWwpO1xyXG4gIH1cclxuXHJcbiAgT2JqZWN0LmtleXMoc2VsZi5fX3NjaGVtYXNfXykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgdmFyIHZhbCA9IHNlbGYuX19zY2hlbWFzX19bbmFtZV07XHJcblxyXG4gICAgLy8gc2tpcCBkaXNhYmxlZCBtZXRob2RzXHJcbiAgICBpZiAodmFsID09PSBudWxsKSB7IHJldHVybjsgfVxyXG5cclxuICAgIHZhciBjb21waWxlZCA9IHsgdmFsaWRhdGU6IG51bGwsIGxpbms6IG51bGwgfTtcclxuXHJcbiAgICBzZWxmLl9fY29tcGlsZWRfX1tuYW1lXSA9IGNvbXBpbGVkO1xyXG5cclxuICAgIGlmIChpc09iamVjdCh2YWwpKSB7XHJcbiAgICAgIGlmIChpc1JlZ0V4cCh2YWwudmFsaWRhdGUpKSB7XHJcbiAgICAgICAgY29tcGlsZWQudmFsaWRhdGUgPSBjcmVhdGVWYWxpZGF0b3IodmFsLnZhbGlkYXRlKTtcclxuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHZhbC52YWxpZGF0ZSkpIHtcclxuICAgICAgICBjb21waWxlZC52YWxpZGF0ZSA9IHZhbC52YWxpZGF0ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzY2hlbWFFcnJvcihuYW1lLCB2YWwpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNGdW5jdGlvbih2YWwubm9ybWFsaXplKSkge1xyXG4gICAgICAgIGNvbXBpbGVkLm5vcm1hbGl6ZSA9IHZhbC5ub3JtYWxpemU7XHJcbiAgICAgIH0gZWxzZSBpZiAoIXZhbC5ub3JtYWxpemUpIHtcclxuICAgICAgICBjb21waWxlZC5ub3JtYWxpemUgPSBjcmVhdGVOb3JtYWxpemVyKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2NoZW1hRXJyb3IobmFtZSwgdmFsKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc1N0cmluZyh2YWwpKSB7XHJcbiAgICAgIGFsaWFzZXMucHVzaChuYW1lKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHNjaGVtYUVycm9yKG5hbWUsIHZhbCk7XHJcbiAgfSk7XHJcblxyXG4gIC8vXHJcbiAgLy8gQ29tcGlsZSBwb3N0cG9uZWQgYWxpYXNlc1xyXG4gIC8vXHJcblxyXG4gIGFsaWFzZXMuZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcclxuICAgIGlmICghc2VsZi5fX2NvbXBpbGVkX19bc2VsZi5fX3NjaGVtYXNfX1thbGlhc11dKSB7XHJcbiAgICAgIC8vIFNpbGVudGx5IGZhaWwgb24gbWlzc2VkIHNjaGVtYXMgdG8gYXZvaWQgZXJyb25zIG9uIGRpc2FibGUuXHJcbiAgICAgIC8vIHNjaGVtYUVycm9yKGFsaWFzLCBzZWxmLl9fc2NoZW1hc19fW2FsaWFzXSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBzZWxmLl9fY29tcGlsZWRfX1thbGlhc10udmFsaWRhdGUgPVxyXG4gICAgICBzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0udmFsaWRhdGU7XHJcbiAgICBzZWxmLl9fY29tcGlsZWRfX1thbGlhc10ubm9ybWFsaXplID1cclxuICAgICAgc2VsZi5fX2NvbXBpbGVkX19bc2VsZi5fX3NjaGVtYXNfX1thbGlhc11dLm5vcm1hbGl6ZTtcclxuICB9KTtcclxuXHJcbiAgLy9cclxuICAvLyBGYWtlIHJlY29yZCBmb3IgZ3Vlc3NlZCBsaW5rc1xyXG4gIC8vXHJcbiAgc2VsZi5fX2NvbXBpbGVkX19bJyddID0geyB2YWxpZGF0ZTogbnVsbCwgbm9ybWFsaXplOiBjcmVhdGVOb3JtYWxpemVyKCkgfTtcclxuXHJcbiAgLy9cclxuICAvLyBCdWlsZCBzY2hlbWEgY29uZGl0aW9uXHJcbiAgLy9cclxuICB2YXIgc2xpc3QgPSBPYmplY3Qua2V5cyhzZWxmLl9fY29tcGlsZWRfXylcclxuICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgZGlzYWJsZWQgJiBmYWtlIHNjaGVtYXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUubGVuZ3RoID4gMCAmJiBzZWxmLl9fY29tcGlsZWRfX1tuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAubWFwKGVzY2FwZVJFKVxyXG4gICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ3wnKTtcclxuICAvLyAoPyFfKSBjYXVzZSAxLjV4IHNsb3dkb3duXHJcbiAgc2VsZi5yZS5zY2hlbWFfdGVzdCAgID0gUmVnRXhwKCcoXnwoPyFfKSg/Oj58JyArIHJlLnNyY19aUENjICsgJykpKCcgKyBzbGlzdCArICcpJywgJ2knKTtcclxuICBzZWxmLnJlLnNjaGVtYV9zZWFyY2ggPSBSZWdFeHAoJyhefCg/IV8pKD86PnwnICsgcmUuc3JjX1pQQ2MgKyAnKSkoJyArIHNsaXN0ICsgJyknLCAnaWcnKTtcclxuXHJcbiAgc2VsZi5yZS5wcmV0ZXN0ICAgICAgID0gUmVnRXhwKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJygnICsgc2VsZi5yZS5zY2hlbWFfdGVzdC5zb3VyY2UgKyAnKXwnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNlbGYucmUuaG9zdF9mdXp6eV90ZXN0LnNvdXJjZSArICcpfCcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0AnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2knKTtcclxuXHJcbiAgLy9cclxuICAvLyBDbGVhbnVwXHJcbiAgLy9cclxuXHJcbiAgcmVzZXRTY2FuQ2FjaGUoc2VsZik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjbGFzcyBNYXRjaFxyXG4gKlxyXG4gKiBNYXRjaCByZXN1bHQuIFNpbmdsZSBlbGVtZW50IG9mIGFycmF5LCByZXR1cm5lZCBieSBbW0xpbmtpZnlJdCNtYXRjaF1dXHJcbiAqKi9cclxuZnVuY3Rpb24gTWF0Y2goc2VsZiwgc2hpZnQpIHtcclxuICB2YXIgc3RhcnQgPSBzZWxmLl9faW5kZXhfXyxcclxuICAgICAgZW5kICAgPSBzZWxmLl9fbGFzdF9pbmRleF9fLFxyXG4gICAgICB0ZXh0ICA9IHNlbGYuX190ZXh0X2NhY2hlX18uc2xpY2Uoc3RhcnQsIGVuZCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIE1hdGNoI3NjaGVtYSAtPiBTdHJpbmdcclxuICAgKlxyXG4gICAqIFByZWZpeCAocHJvdG9jb2wpIGZvciBtYXRjaGVkIHN0cmluZy5cclxuICAgKiovXHJcbiAgdGhpcy5zY2hlbWEgICAgPSBzZWxmLl9fc2NoZW1hX18udG9Mb3dlckNhc2UoKTtcclxuICAvKipcclxuICAgKiBNYXRjaCNpbmRleCAtPiBOdW1iZXJcclxuICAgKlxyXG4gICAqIEZpcnN0IHBvc2l0aW9uIG9mIG1hdGNoZWQgc3RyaW5nLlxyXG4gICAqKi9cclxuICB0aGlzLmluZGV4ICAgICA9IHN0YXJ0ICsgc2hpZnQ7XHJcbiAgLyoqXHJcbiAgICogTWF0Y2gjbGFzdEluZGV4IC0+IE51bWJlclxyXG4gICAqXHJcbiAgICogTmV4dCBwb3NpdGlvbiBhZnRlciBtYXRjaGVkIHN0cmluZy5cclxuICAgKiovXHJcbiAgdGhpcy5sYXN0SW5kZXggPSBlbmQgKyBzaGlmdDtcclxuICAvKipcclxuICAgKiBNYXRjaCNyYXcgLT4gU3RyaW5nXHJcbiAgICpcclxuICAgKiBNYXRjaGVkIHN0cmluZy5cclxuICAgKiovXHJcbiAgdGhpcy5yYXcgICAgICAgPSB0ZXh0O1xyXG4gIC8qKlxyXG4gICAqIE1hdGNoI3RleHQgLT4gU3RyaW5nXHJcbiAgICpcclxuICAgKiBOb3RtYWxpemVkIHRleHQgb2YgbWF0Y2hlZCBzdHJpbmcuXHJcbiAgICoqL1xyXG4gIHRoaXMudGV4dCAgICAgID0gdGV4dDtcclxuICAvKipcclxuICAgKiBNYXRjaCN1cmwgLT4gU3RyaW5nXHJcbiAgICpcclxuICAgKiBOb3JtYWxpemVkIHVybCBvZiBtYXRjaGVkIHN0cmluZy5cclxuICAgKiovXHJcbiAgdGhpcy51cmwgICAgICAgPSB0ZXh0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVNYXRjaChzZWxmLCBzaGlmdCkge1xyXG4gIHZhciBtYXRjaCA9IG5ldyBNYXRjaChzZWxmLCBzaGlmdCk7XHJcblxyXG4gIHNlbGYuX19jb21waWxlZF9fW21hdGNoLnNjaGVtYV0ubm9ybWFsaXplKG1hdGNoLCBzZWxmKTtcclxuXHJcbiAgcmV0dXJuIG1hdGNoO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIGNsYXNzIExpbmtpZnlJdFxyXG4gKiovXHJcblxyXG4vKipcclxuICogbmV3IExpbmtpZnlJdChzY2hlbWFzKVxyXG4gKiAtIHNjaGVtYXMgKE9iamVjdCk6IE9wdGlvbmFsLiBBZGRpdGlvbmFsIHNjaGVtYXMgdG8gdmFsaWRhdGUgKHByZWZpeC92YWxpZGF0b3IpXHJcbiAqXHJcbiAqIENyZWF0ZXMgbmV3IGxpbmtpZmllciBpbnN0YW5jZSB3aXRoIG9wdGlvbmFsIGFkZGl0aW9uYWwgc2NoZW1hcy5cclxuICogQ2FuIGJlIGNhbGxlZCB3aXRob3V0IGBuZXdgIGtleXdvcmQgZm9yIGNvbnZlbmllbmNlLlxyXG4gKlxyXG4gKiBCeSBkZWZhdWx0IHVuZGVyc3RhbmRzOlxyXG4gKlxyXG4gKiAtIGBodHRwKHMpOi8vLi4uYCAsIGBmdHA6Ly8uLi5gLCBgbWFpbHRvOi4uLmAgJiBgLy8uLi5gIGxpbmtzXHJcbiAqIC0gXCJmdXp6eVwiIGxpbmtzIGFuZCBlbWFpbHMgKGV4YW1wbGUuY29tLCBmb29AYmFyLmNvbSkuXHJcbiAqXHJcbiAqIGBzY2hlbWFzYCBpcyBhbiBvYmplY3QsIHdoZXJlIGVhY2gga2V5L3ZhbHVlIGRlc2NyaWJlcyBwcm90b2NvbC9ydWxlOlxyXG4gKlxyXG4gKiAtIF9fa2V5X18gLSBsaW5rIHByZWZpeCAodXN1YWxseSwgcHJvdG9jb2wgbmFtZSB3aXRoIGA6YCBhdCB0aGUgZW5kLCBgc2t5cGU6YFxyXG4gKiAgIGZvciBleGFtcGxlKS4gYGxpbmtpZnktaXRgIG1ha2VzIHNodXJlIHRoYXQgcHJlZml4IGlzIG5vdCBwcmVjZWVkZWQgd2l0aFxyXG4gKiAgIGFscGhhbnVtZXJpYyBjaGFyIGFuZCBzeW1ib2xzLiBPbmx5IHdoaXRlc3BhY2VzIGFuZCBwdW5jdHVhdGlvbiBhbGxvd2VkLlxyXG4gKiAtIF9fdmFsdWVfXyAtIHJ1bGUgdG8gY2hlY2sgdGFpbCBhZnRlciBsaW5rIHByZWZpeFxyXG4gKiAgIC0gX1N0cmluZ18gLSBqdXN0IGFsaWFzIHRvIGV4aXN0aW5nIHJ1bGVcclxuICogICAtIF9PYmplY3RfXHJcbiAqICAgICAtIF92YWxpZGF0ZV8gLSB2YWxpZGF0b3IgZnVuY3Rpb24gKHNob3VsZCByZXR1cm4gbWF0Y2hlZCBsZW5ndGggb24gc3VjY2VzcyksXHJcbiAqICAgICAgIG9yIGBSZWdFeHBgLlxyXG4gKiAgICAgLSBfbm9ybWFsaXplXyAtIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIG5vcm1hbGl6ZSB0ZXh0ICYgdXJsIG9mIG1hdGNoZWQgcmVzdWx0XHJcbiAqICAgICAgIChmb3IgZXhhbXBsZSwgZm9yIEB0d2l0dGVyIG1lbnRpb25zKS5cclxuICoqL1xyXG5mdW5jdGlvbiBMaW5raWZ5SXQoc2NoZW1hcykge1xyXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMaW5raWZ5SXQpKSB7XHJcbiAgICByZXR1cm4gbmV3IExpbmtpZnlJdChzY2hlbWFzKTtcclxuICB9XHJcblxyXG4gIC8vIENhY2hlIGxhc3QgdGVzdGVkIHJlc3VsdC4gVXNlZCB0byBza2lwIHJlcGVhdGluZyBzdGVwcyBvbiBuZXh0IGBtYXRjaGAgY2FsbC5cclxuICB0aGlzLl9faW5kZXhfXyAgICAgICAgICA9IC0xO1xyXG4gIHRoaXMuX19sYXN0X2luZGV4X18gICAgID0gLTE7IC8vIE5leHQgc2NhbiBwb3NpdGlvblxyXG4gIHRoaXMuX19zY2hlbWFfXyAgICAgICAgID0gJyc7XHJcbiAgdGhpcy5fX3RleHRfY2FjaGVfXyAgICAgPSAnJztcclxuXHJcbiAgdGhpcy5fX3NjaGVtYXNfXyAgICAgICAgPSBhc3NpZ24oe30sIGRlZmF1bHRTY2hlbWFzLCBzY2hlbWFzKTtcclxuICB0aGlzLl9fY29tcGlsZWRfXyAgICAgICA9IHt9O1xyXG5cclxuICB0aGlzLl9fdGxkc19fICAgICAgICAgICA9IHRsZHNfZGVmYXVsdDtcclxuICB0aGlzLl9fdGxkc19yZXBsYWNlZF9fICA9IGZhbHNlO1xyXG5cclxuICB0aGlzLnJlID0ge307XHJcblxyXG4gIGNvbXBpbGUodGhpcyk7XHJcbn1cclxuXHJcblxyXG4vKiogY2hhaW5hYmxlXHJcbiAqIExpbmtpZnlJdCNhZGQoc2NoZW1hLCBkZWZpbml0aW9uKVxyXG4gKiAtIHNjaGVtYSAoU3RyaW5nKTogcnVsZSBuYW1lIChmaXhlZCBwYXR0ZXJuIHByZWZpeClcclxuICogLSBkZWZpbml0aW9uIChTdHJpbmd8UmVnRXhwfE9iamVjdCk6IHNjaGVtYSBkZWZpbml0aW9uXHJcbiAqXHJcbiAqIEFkZCBuZXcgcnVsZSBkZWZpbml0aW9uLiBTZWUgY29uc3RydWN0b3IgZGVzY3JpcHRpb24gZm9yIGRldGFpbHMuXHJcbiAqKi9cclxuTGlua2lmeUl0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoc2NoZW1hLCBkZWZpbml0aW9uKSB7XHJcbiAgdGhpcy5fX3NjaGVtYXNfX1tzY2hlbWFdID0gZGVmaW5pdGlvbjtcclxuICBjb21waWxlKHRoaXMpO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBMaW5raWZ5SXQjdGVzdCh0ZXh0KSAtPiBCb29sZWFuXHJcbiAqXHJcbiAqIFNlYXJjaGVzIGxpbmtpZmlhYmxlIHBhdHRlcm4gYW5kIHJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3Mgb3IgYGZhbHNlYCBvbiBmYWlsLlxyXG4gKiovXHJcbkxpbmtpZnlJdC5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uIHRlc3QodGV4dCkge1xyXG4gIC8vIFJlc2V0IHNjYW4gY2FjaGVcclxuICB0aGlzLl9fdGV4dF9jYWNoZV9fID0gdGV4dDtcclxuICB0aGlzLl9faW5kZXhfXyAgICAgID0gLTE7XHJcblxyXG4gIGlmICghdGV4dC5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIHZhciBtLCBtbCwgbWUsIGxlbiwgc2hpZnQsIG5leHQsIHJlLCB0bGRfcG9zLCBhdF9wb3M7XHJcblxyXG4gIC8vIHRyeSB0byBzY2FuIGZvciBsaW5rIHdpdGggc2NoZW1hIC0gdGhhdCdzIHRoZSBtb3N0IHNpbXBsZSBydWxlXHJcbiAgaWYgKHRoaXMucmUuc2NoZW1hX3Rlc3QudGVzdCh0ZXh0KSkge1xyXG4gICAgcmUgPSB0aGlzLnJlLnNjaGVtYV9zZWFyY2g7XHJcbiAgICByZS5sYXN0SW5kZXggPSAwO1xyXG4gICAgd2hpbGUgKChtID0gcmUuZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcclxuICAgICAgbGVuID0gdGhpcy50ZXN0U2NoZW1hQXQodGV4dCwgbVsyXSwgcmUubGFzdEluZGV4KTtcclxuICAgICAgaWYgKGxlbikge1xyXG4gICAgICAgIHRoaXMuX19zY2hlbWFfXyAgICAgPSBtWzJdO1xyXG4gICAgICAgIHRoaXMuX19pbmRleF9fICAgICAgPSBtLmluZGV4ICsgbVsxXS5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5fX2xhc3RfaW5kZXhfXyA9IG0uaW5kZXggKyBtWzBdLmxlbmd0aCArIGxlbjtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHRoaXMuX19jb21waWxlZF9fWydodHRwOiddKSB7XHJcbiAgICAvLyBndWVzcyBzY2hlbWFsZXNzIGxpbmtzXHJcbiAgICB0bGRfcG9zID0gdGV4dC5zZWFyY2godGhpcy5yZS5ob3N0X2Z1enp5X3Rlc3QpO1xyXG4gICAgaWYgKHRsZF9wb3MgPj0gMCkge1xyXG4gICAgICAvLyBpZiB0bGQgaXMgbG9jYXRlZCBhZnRlciBmb3VuZCBsaW5rIC0gbm8gbmVlZCB0byBjaGVjayBmdXp6eSBwYXR0ZXJuXHJcbiAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgdGxkX3BvcyA8IHRoaXMuX19pbmRleF9fKSB7XHJcbiAgICAgICAgaWYgKChtbCA9IHRleHQubWF0Y2godGhpcy5yZS5saW5rX2Z1enp5KSkgIT09IG51bGwpIHtcclxuXHJcbiAgICAgICAgICBzaGlmdCA9IG1sLmluZGV4ICsgbWxbMV0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgc2hpZnQgPCB0aGlzLl9faW5kZXhfXykge1xyXG4gICAgICAgICAgICB0aGlzLl9fc2NoZW1hX18gICAgID0gJyc7XHJcbiAgICAgICAgICAgIHRoaXMuX19pbmRleF9fICAgICAgPSBzaGlmdDtcclxuICAgICAgICAgICAgdGhpcy5fX2xhc3RfaW5kZXhfXyA9IG1sLmluZGV4ICsgbWxbMF0ubGVuZ3RoO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHRoaXMuX19jb21waWxlZF9fWydtYWlsdG86J10pIHtcclxuICAgIC8vIGd1ZXNzIHNjaGVtYWxlc3MgZW1haWxzXHJcbiAgICBhdF9wb3MgPSB0ZXh0LmluZGV4T2YoJ0AnKTtcclxuICAgIGlmIChhdF9wb3MgPj0gMCkge1xyXG4gICAgICAvLyBXZSBjYW4ndCBza2lwIHRoaXMgY2hlY2ssIGJlY2F1c2UgdGhpcyBjYXNlcyBhcmUgcG9zc2libGU6XHJcbiAgICAgIC8vIDE5Mi4xNjguMS4xQGdtYWlsLmNvbSwgbXkuaW5AZXhhbXBsZS5jb21cclxuICAgICAgaWYgKChtZSA9IHRleHQubWF0Y2godGhpcy5yZS5lbWFpbF9mdXp6eSkpICE9PSBudWxsKSB7XHJcblxyXG4gICAgICAgIHNoaWZ0ID0gbWUuaW5kZXggKyBtZVsxXS5sZW5ndGg7XHJcbiAgICAgICAgbmV4dCAgPSBtZS5pbmRleCArIG1lWzBdLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX19pbmRleF9fIDwgMCB8fCBzaGlmdCA8IHRoaXMuX19pbmRleF9fIHx8XHJcbiAgICAgICAgICAgIChzaGlmdCA9PT0gdGhpcy5fX2luZGV4X18gJiYgbmV4dCA+IHRoaXMuX19sYXN0X2luZGV4X18pKSB7XHJcbiAgICAgICAgICB0aGlzLl9fc2NoZW1hX18gICAgID0gJ21haWx0bzonO1xyXG4gICAgICAgICAgdGhpcy5fX2luZGV4X18gICAgICA9IHNoaWZ0O1xyXG4gICAgICAgICAgdGhpcy5fX2xhc3RfaW5kZXhfXyA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcy5fX2luZGV4X18gPj0gMDtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogTGlua2lmeUl0I3ByZXRlc3QodGV4dCkgLT4gQm9vbGVhblxyXG4gKlxyXG4gKiBWZXJ5IHF1aWNrIGNoZWNrLCB0aGF0IGNhbiBnaXZlIGZhbHNlIHBvc2l0aXZlcy4gUmV0dXJucyB0cnVlIGlmIGxpbmsgTUFZIEJFXHJcbiAqIGNhbiBleGlzdHMuIENhbiBiZSB1c2VkIGZvciBzcGVlZCBvcHRpbWl6YXRpb24sIHdoZW4geW91IG5lZWQgdG8gY2hlY2sgdGhhdFxyXG4gKiBsaW5rIE5PVCBleGlzdHMuXHJcbiAqKi9cclxuTGlua2lmeUl0LnByb3RvdHlwZS5wcmV0ZXN0ID0gZnVuY3Rpb24gcHJldGVzdCh0ZXh0KSB7XHJcbiAgcmV0dXJuIHRoaXMucmUucHJldGVzdC50ZXN0KHRleHQpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBMaW5raWZ5SXQjdGVzdFNjaGVtYUF0KHRleHQsIG5hbWUsIHBvc2l0aW9uKSAtPiBOdW1iZXJcclxuICogLSB0ZXh0IChTdHJpbmcpOiB0ZXh0IHRvIHNjYW5cclxuICogLSBuYW1lIChTdHJpbmcpOiBydWxlIChzY2hlbWEpIG5hbWVcclxuICogLSBwb3NpdGlvbiAoTnVtYmVyKTogdGV4dCBvZmZzZXQgdG8gY2hlY2sgZnJvbVxyXG4gKlxyXG4gKiBTaW1pbGFyIHRvIFtbTGlua2lmeUl0I3Rlc3RdXSBidXQgY2hlY2tzIG9ubHkgc3BlY2lmaWMgcHJvdG9jb2wgdGFpbCBleGFjdGx5XHJcbiAqIGF0IGdpdmVuIHBvc2l0aW9uLiBSZXR1cm5zIGxlbmd0aCBvZiBmb3VuZCBwYXR0ZXJuICgwIG9uIGZhaWwpLlxyXG4gKiovXHJcbkxpbmtpZnlJdC5wcm90b3R5cGUudGVzdFNjaGVtYUF0ID0gZnVuY3Rpb24gdGVzdFNjaGVtYUF0KHRleHQsIHNjaGVtYSwgcG9zKSB7XHJcbiAgLy8gSWYgbm90IHN1cHBvcnRlZCBzY2hlbWEgY2hlY2sgcmVxdWVzdGVkIC0gdGVybWluYXRlXHJcbiAgaWYgKCF0aGlzLl9fY29tcGlsZWRfX1tzY2hlbWEudG9Mb3dlckNhc2UoKV0pIHtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuICByZXR1cm4gdGhpcy5fX2NvbXBpbGVkX19bc2NoZW1hLnRvTG93ZXJDYXNlKCldLnZhbGlkYXRlKHRleHQsIHBvcywgdGhpcyk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIExpbmtpZnlJdCNtYXRjaCh0ZXh0KSAtPiBBcnJheXxudWxsXHJcbiAqXHJcbiAqIFJldHVybnMgYXJyYXkgb2YgZm91bmQgbGluayBkZXNjcmlwdGlvbnMgb3IgYG51bGxgIG9uIGZhaWwuIFdlIHN0cm9uZ2x5XHJcbiAqIHRvIHVzZSBbW0xpbmtpZnlJdCN0ZXN0XV0gZmlyc3QsIGZvciBiZXN0IHNwZWVkLlxyXG4gKlxyXG4gKiAjIyMjIyBSZXN1bHQgbWF0Y2ggZGVzY3JpcHRpb25cclxuICpcclxuICogLSBfX3NjaGVtYV9fIC0gbGluayBzY2hlbWEsIGNhbiBiZSBlbXB0eSBmb3IgZnV6enkgbGlua3MsIG9yIGAvL2AgZm9yXHJcbiAqICAgcHJvdG9jb2wtbmV1dHJhbCAgbGlua3MuXHJcbiAqIC0gX19pbmRleF9fIC0gb2Zmc2V0IG9mIG1hdGNoZWQgdGV4dFxyXG4gKiAtIF9fbGFzdEluZGV4X18gLSBpbmRleCBvZiBuZXh0IGNoYXIgYWZ0ZXIgbWF0aGNoIGVuZFxyXG4gKiAtIF9fcmF3X18gLSBtYXRjaGVkIHRleHRcclxuICogLSBfX3RleHRfXyAtIG5vcm1hbGl6ZWQgdGV4dFxyXG4gKiAtIF9fdXJsX18gLSBsaW5rLCBnZW5lcmF0ZWQgZnJvbSBtYXRjaGVkIHRleHRcclxuICoqL1xyXG5MaW5raWZ5SXQucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gbWF0Y2godGV4dCkge1xyXG4gIHZhciBzaGlmdCA9IDAsIHJlc3VsdCA9IFtdO1xyXG5cclxuICAvLyBUcnkgdG8gdGFrZSBwcmV2aW91cyBlbGVtZW50IGZyb20gY2FjaGUsIGlmIC50ZXN0KCkgY2FsbGVkIGJlZm9yZVxyXG4gIGlmICh0aGlzLl9faW5kZXhfXyA+PSAwICYmIHRoaXMuX190ZXh0X2NhY2hlX18gPT09IHRleHQpIHtcclxuICAgIHJlc3VsdC5wdXNoKGNyZWF0ZU1hdGNoKHRoaXMsIHNoaWZ0KSk7XHJcbiAgICBzaGlmdCA9IHRoaXMuX19sYXN0X2luZGV4X187XHJcbiAgfVxyXG5cclxuICAvLyBDdXQgaGVhZCBpZiBjYWNoZSB3YXMgdXNlZFxyXG4gIHZhciB0YWlsID0gc2hpZnQgPyB0ZXh0LnNsaWNlKHNoaWZ0KSA6IHRleHQ7XHJcblxyXG4gIC8vIFNjYW4gc3RyaW5nIHVudGlsIGVuZCByZWFjaGVkXHJcbiAgd2hpbGUgKHRoaXMudGVzdCh0YWlsKSkge1xyXG4gICAgcmVzdWx0LnB1c2goY3JlYXRlTWF0Y2godGhpcywgc2hpZnQpKTtcclxuXHJcbiAgICB0YWlsID0gdGFpbC5zbGljZSh0aGlzLl9fbGFzdF9pbmRleF9fKTtcclxuICAgIHNoaWZ0ICs9IHRoaXMuX19sYXN0X2luZGV4X187XHJcbiAgfVxyXG5cclxuICBpZiAocmVzdWx0Lmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuXHJcbi8qKiBjaGFpbmFibGVcclxuICogTGlua2lmeUl0I3RsZHMobGlzdCBbLCBrZWVwT2xkXSkgLT4gdGhpc1xyXG4gKiAtIGxpc3QgKEFycmF5KTogbGlzdCBvZiB0bGRzXHJcbiAqIC0ga2VlcE9sZCAoQm9vbGVhbik6IG1lcmdlIHdpdGggY3VycmVudCBsaXN0IGlmIGB0cnVlYCAoYGZhbHNlYCBieSBkZWZhdWx0KVxyXG4gKlxyXG4gKiBMb2FkIChvciBtZXJnZSkgbmV3IHRsZHMgbGlzdC4gVGhvc2UgYXJlIHVzZXIgZm9yIGZ1enp5IGxpbmtzICh3aXRob3V0IHByZWZpeClcclxuICogdG8gYXZvaWQgZmFsc2UgcG9zaXRpdmVzLiBCeSBkZWZhdWx0IHRoaXMgYWxnb3J5dGhtIHVzZWQ6XHJcbiAqXHJcbiAqIC0gaG9zdG5hbWUgd2l0aCBhbnkgMi1sZXR0ZXIgcm9vdCB6b25lcyBhcmUgb2suXHJcbiAqIC0gYml6fGNvbXxlZHV8Z292fG5ldHxvcmd8cHJvfHdlYnx4eHh8YWVyb3xhc2lhfGNvb3B8aW5mb3xtdXNldW18bmFtZXxzaG9wfNGA0YRcclxuICogICBhcmUgb2suXHJcbiAqIC0gZW5jb2RlZCAoYHhuLS0uLi5gKSByb290IHpvbmVzIGFyZSBvay5cclxuICpcclxuICogSWYgbGlzdCBpcyByZXBsYWNlZCwgdGhlbiBleGFjdCBtYXRjaCBmb3IgMi1jaGFycyByb290IHpvbmVzIHdpbGwgYmUgY2hlY2tlZC5cclxuICoqL1xyXG5MaW5raWZ5SXQucHJvdG90eXBlLnRsZHMgPSBmdW5jdGlvbiB0bGRzKGxpc3QsIGtlZXBPbGQpIHtcclxuICBsaXN0ID0gQXJyYXkuaXNBcnJheShsaXN0KSA/IGxpc3QgOiBbIGxpc3QgXTtcclxuXHJcbiAgaWYgKCFrZWVwT2xkKSB7XHJcbiAgICB0aGlzLl9fdGxkc19fID0gbGlzdC5zbGljZSgpO1xyXG4gICAgdGhpcy5fX3RsZHNfcmVwbGFjZWRfXyA9IHRydWU7XHJcbiAgICBjb21waWxlKHRoaXMpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICB0aGlzLl9fdGxkc19fID0gdGhpcy5fX3RsZHNfXy5jb25jYXQobGlzdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oZWwsIGlkeCwgYXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbCAhPT0gYXJyW2lkeCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXZlcnNlKCk7XHJcblxyXG4gIGNvbXBpbGUodGhpcyk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogTGlua2lmeUl0I25vcm1hbGl6ZShtYXRjaClcclxuICpcclxuICogRGVmYXVsdCBub3JtYWxpemVyIChpZiBzY2hlbWEgZG9lcyBub3QgZGVmaW5lIGl0J3Mgb3duKS5cclxuICoqL1xyXG5MaW5raWZ5SXQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShtYXRjaCkge1xyXG5cclxuICAvLyBEbyBtaW5pbWFsIHBvc3NpYmxlIGNoYW5nZXMgYnkgZGVmYXVsdC4gTmVlZCB0byBjb2xsZWN0IGZlZWRiYWNrIHByaW9yXHJcbiAgLy8gdG8gbW92ZSBmb3J3YXJkIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9saW5raWZ5LWl0L2lzc3Vlcy8xXHJcblxyXG4gIGlmICghbWF0Y2guc2NoZW1hKSB7IG1hdGNoLnVybCA9ICdodHRwOi8vJyArIG1hdGNoLnVybDsgfVxyXG5cclxuICBpZiAobWF0Y2guc2NoZW1hID09PSAnbWFpbHRvOicgJiYgIS9ebWFpbHRvOi9pLnRlc3QobWF0Y2gudXJsKSkge1xyXG4gICAgbWF0Y2gudXJsID0gJ21haWx0bzonICsgbWF0Y2gudXJsO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpbmtpZnlJdDtcclxuXHJcbn0se1wiLi9saWIvcmVcIjo1NH1dLDU0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gVXNlIGRpcmVjdCBleHRyYWN0IGluc3RlYWQgb2YgYHJlZ2VuZXJhdGVgIHRvIHJlZHVzZSBicm93c2VyaWZpZWQgc2l6ZVxyXG52YXIgc3JjX0FueSA9IGV4cG9ydHMuc3JjX0FueSA9IHJlcXVpcmUoJ3VjLm1pY3JvL3Byb3BlcnRpZXMvQW55L3JlZ2V4Jykuc291cmNlO1xyXG52YXIgc3JjX0NjICA9IGV4cG9ydHMuc3JjX0NjID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9DYy9yZWdleCcpLnNvdXJjZTtcclxudmFyIHNyY19aICAgPSBleHBvcnRzLnNyY19aICA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvWi9yZWdleCcpLnNvdXJjZTtcclxudmFyIHNyY19QICAgPSBleHBvcnRzLnNyY19QICA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvUC9yZWdleCcpLnNvdXJjZTtcclxuXHJcbi8vIFxccHtcXFpcXFBcXENjXFxDRn0gKHdoaXRlIHNwYWNlcyArIGNvbnRyb2wgKyBmb3JtYXQgKyBwdW5jdHVhdGlvbilcclxudmFyIHNyY19aUENjID0gZXhwb3J0cy5zcmNfWlBDYyA9IFsgc3JjX1osIHNyY19QLCBzcmNfQ2MgXS5qb2luKCd8Jyk7XHJcblxyXG4vLyBcXHB7XFxaXFxDY30gKHdoaXRlIHNwYWNlcyArIGNvbnRyb2wpXHJcbnZhciBzcmNfWkNjID0gZXhwb3J0cy5zcmNfWkNjID0gWyBzcmNfWiwgc3JjX0NjIF0uam9pbignfCcpO1xyXG5cclxuLy8gQWxsIHBvc3NpYmxlIHdvcmQgY2hhcmFjdGVycyAoZXZlcnl0aGluZyB3aXRob3V0IHB1bmN0dWF0aW9uLCBzcGFjZXMgJiBjb250cm9scylcclxuLy8gRGVmaW5lZCB2aWEgcHVuY3R1YXRpb24gJiBzcGFjZXMgdG8gc2F2ZSBzcGFjZVxyXG4vLyBTaG91bGQgYmUgc29tZXRoaW5nIGxpa2UgXFxwe1xcTFxcTlxcU1xcTX0gKFxcdyBidXQgd2l0aG91dCBgX2ApXHJcbnZhciBzcmNfcHNldWRvX2xldHRlciAgICAgICA9ICcoPzooPyEnICsgc3JjX1pQQ2MgKyAnKScgKyBzcmNfQW55ICsgJyknO1xyXG4vLyBUaGUgc2FtZSBhcyBhYm90aGUgYnV0IHdpdGhvdXQgWzAtOV1cclxudmFyIHNyY19wc2V1ZG9fbGV0dGVyX25vbl9kID0gJyg/Oig/IVswLTldfCcgKyBzcmNfWlBDYyArICcpJyArIHNyY19BbnkgKyAnKSc7XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxudmFyIHNyY19pcDQgPSBleHBvcnRzLnNyY19pcDQgPVxyXG5cclxuICAnKD86KDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXFxcLil7M30oMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KSc7XHJcblxyXG5leHBvcnRzLnNyY19hdXRoICAgID0gJyg/Oig/Oig/IScgKyBzcmNfWkNjICsgJykuKStAKT8nO1xyXG5cclxudmFyIHNyY19wb3J0ID0gZXhwb3J0cy5zcmNfcG9ydCA9XHJcblxyXG4gICcoPzo6KD86Nig/OlswLTRdXFxcXGR7M318NSg/OlswLTRdXFxcXGR7Mn18NSg/OlswLTJdXFxcXGR8M1swLTVdKSkpfFsxLTVdP1xcXFxkezEsNH0pKT8nO1xyXG5cclxudmFyIHNyY19ob3N0X3Rlcm1pbmF0b3IgPSBleHBvcnRzLnNyY19ob3N0X3Rlcm1pbmF0b3IgPVxyXG5cclxuICAnKD89JHwnICsgc3JjX1pQQ2MgKyAnKSg/IS18X3w6XFxcXGR8XFxcXC4tfFxcXFwuKD8hJHwnICsgc3JjX1pQQ2MgKyAnKSknO1xyXG5cclxudmFyIHNyY19wYXRoID0gZXhwb3J0cy5zcmNfcGF0aCA9XHJcblxyXG4gICcoPzonICtcclxuICAgICdbLz8jXScgK1xyXG4gICAgICAnKD86JyArXHJcbiAgICAgICAgJyg/IScgKyBzcmNfWkNjICsgJ3xbKClbXFxcXF17fS4sXCJcXCc/IVxcXFwtXSkufCcgK1xyXG4gICAgICAgICdcXFxcWyg/Oig/IScgKyBzcmNfWkNjICsgJ3xcXFxcXSkuKSpcXFxcXXwnICtcclxuICAgICAgICAnXFxcXCgoPzooPyEnICsgc3JjX1pDYyArICd8WyldKS4pKlxcXFwpfCcgK1xyXG4gICAgICAgICdcXFxceyg/Oig/IScgKyBzcmNfWkNjICsgJ3xbfV0pLikqXFxcXH18JyArXHJcbiAgICAgICAgJ1xcXFxcIig/Oig/IScgKyBzcmNfWkNjICsgJ3xbXCJdKS4pK1xcXFxcInwnICtcclxuICAgICAgICBcIlxcXFwnKD86KD8hXCIgKyBzcmNfWkNjICsgXCJ8WyddKS4pK1xcXFwnfFwiICtcclxuICAgICAgICBcIlxcXFwnKD89XCIgKyBzcmNfcHNldWRvX2xldHRlciArICcpLnwnICsgIC8vIGFsbG93IGBJJ21fa2luZ2AgaWYgbm8gcGFpciBmb3VuZFxyXG4gICAgICAgICdcXFxcLnsyLDN9W2EtekEtWjAtOSVdfCcgKyAvLyBnaXRodWIgaGFzIC4uLiBpbiBjb21taXQgcmFuZ2UgbGlua3MuIFJlc3RyaWN0IHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbmdsaXNoICYgcGVyY2VudC1lbmNvZGVkIG9ubHksIHVudGlsIG1vcmUgZXhhbXBsZXMgZm91bmQuXHJcbiAgICAgICAgJ1xcXFwuKD8hJyArIHNyY19aQ2MgKyAnfFsuXSkufCcgK1xyXG4gICAgICAgICdcXFxcLSg/IScgKyBzcmNfWkNjICsgJ3wtLSg/OlteLV18JCkpKD86Wy1dK3wuKXwnICsgIC8vIGAtLS1gID0+IGxvbmcgZGFzaCwgdGVybWluYXRlXHJcbiAgICAgICAgJ1xcXFwsKD8hJyArIHNyY19aQ2MgKyAnKS58JyArICAgICAgLy8gYWxsb3cgYCwsLGAgaW4gcGF0aHNcclxuICAgICAgICAnXFxcXCEoPyEnICsgc3JjX1pDYyArICd8WyFdKS58JyArXHJcbiAgICAgICAgJ1xcXFw/KD8hJyArIHNyY19aQ2MgKyAnfFs/XSkuJyArXHJcbiAgICAgICcpKycgK1xyXG4gICAgJ3xcXFxcLycgK1xyXG4gICcpPyc7XHJcblxyXG52YXIgc3JjX2VtYWlsX25hbWUgPSBleHBvcnRzLnNyY19lbWFpbF9uYW1lID1cclxuXHJcbiAgJ1tcXFxcLTs6Jj1cXFxcK1xcXFwkLFxcXFxcIlxcXFwuYS16QS1aMC05X10rJztcclxuXHJcbnZhciBzcmNfeG4gPSBleHBvcnRzLnNyY194biA9XHJcblxyXG4gICd4bi0tW2EtejAtOVxcXFwtXXsxLDU5fSc7XHJcblxyXG4vLyBNb3JlIHRvIHJlYWQgYWJvdXQgZG9tYWluIG5hbWVzXHJcbi8vIGh0dHA6Ly9zZXJ2ZXJmYXVsdC5jb20vcXVlc3Rpb25zLzYzODI2MC9cclxuXHJcbnZhciBzcmNfZG9tYWluX3Jvb3QgPSBleHBvcnRzLnNyY19kb21haW5fcm9vdCA9XHJcblxyXG4gIC8vIENhbid0IGhhdmUgZGlnaXRzIGFuZCBkYXNoZXNcclxuICAnKD86JyArXHJcbiAgICBzcmNfeG4gK1xyXG4gICAgJ3wnICtcclxuICAgIHNyY19wc2V1ZG9fbGV0dGVyX25vbl9kICsgJ3sxLDYzfScgK1xyXG4gICcpJztcclxuXHJcbnZhciBzcmNfZG9tYWluID0gZXhwb3J0cy5zcmNfZG9tYWluID1cclxuXHJcbiAgJyg/OicgK1xyXG4gICAgc3JjX3huICtcclxuICAgICd8JyArXHJcbiAgICAnKD86JyArIHNyY19wc2V1ZG9fbGV0dGVyICsgJyknICtcclxuICAgICd8JyArXHJcbiAgICAvLyBkb24ndCBhbGxvdyBgLS1gIGluIGRvbWFpbiBuYW1lcywgYmVjYXVzZTpcclxuICAgIC8vIC0gdGhhdCBjYW4gY29uZmxpY3Qgd2l0aCBtYXJrZG93biAmbWRhc2g7IC8gJm5kYXNoO1xyXG4gICAgLy8gLSBub2JvZHkgdXNlIHRob3NlIGFueXdheVxyXG4gICAgJyg/OicgKyBzcmNfcHNldWRvX2xldHRlciArICcoPzotKD8hLSl8JyArIHNyY19wc2V1ZG9fbGV0dGVyICsgJyl7MCw2MX0nICsgc3JjX3BzZXVkb19sZXR0ZXIgKyAnKScgK1xyXG4gICcpJztcclxuXHJcbnZhciBzcmNfaG9zdCA9IGV4cG9ydHMuc3JjX2hvc3QgPVxyXG5cclxuICAnKD86JyArXHJcbiAgICBzcmNfaXA0ICtcclxuICAnfCcgK1xyXG4gICAgJyg/Oig/Oig/OicgKyBzcmNfZG9tYWluICsgJylcXFxcLikqJyArIHNyY19kb21haW5fcm9vdCArICcpJyArXHJcbiAgJyknO1xyXG5cclxudmFyIHRwbF9ob3N0X2Z1enp5ID0gZXhwb3J0cy50cGxfaG9zdF9mdXp6eSA9XHJcblxyXG4gICcoPzonICtcclxuICAgIHNyY19pcDQgK1xyXG4gICd8JyArXHJcbiAgICAnKD86KD86KD86JyArIHNyY19kb21haW4gKyAnKVxcXFwuKSsoPzolVExEUyUpKScgK1xyXG4gICcpJztcclxuXHJcbmV4cG9ydHMuc3JjX2hvc3Rfc3RyaWN0ID1cclxuXHJcbiAgc3JjX2hvc3QgKyBzcmNfaG9zdF90ZXJtaW5hdG9yO1xyXG5cclxudmFyIHRwbF9ob3N0X2Z1enp5X3N0cmljdCA9IGV4cG9ydHMudHBsX2hvc3RfZnV6enlfc3RyaWN0ID1cclxuXHJcbiAgdHBsX2hvc3RfZnV6enkgKyBzcmNfaG9zdF90ZXJtaW5hdG9yO1xyXG5cclxuZXhwb3J0cy5zcmNfaG9zdF9wb3J0X3N0cmljdCA9XHJcblxyXG4gIHNyY19ob3N0ICsgc3JjX3BvcnQgKyBzcmNfaG9zdF90ZXJtaW5hdG9yO1xyXG5cclxudmFyIHRwbF9ob3N0X3BvcnRfZnV6enlfc3RyaWN0ID0gZXhwb3J0cy50cGxfaG9zdF9wb3J0X2Z1enp5X3N0cmljdCA9XHJcblxyXG4gIHRwbF9ob3N0X2Z1enp5ICsgc3JjX3BvcnQgKyBzcmNfaG9zdF90ZXJtaW5hdG9yO1xyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gTWFpbiBydWxlc1xyXG5cclxuLy8gUnVkZSB0ZXN0IGZ1enp5IGxpbmtzIGJ5IGhvc3QsIGZvciBxdWljayBkZW55XHJcbmV4cG9ydHMudHBsX2hvc3RfZnV6enlfdGVzdCA9XHJcblxyXG4gICdsb2NhbGhvc3R8XFxcXC5cXFxcZHsxLDN9XFxcXC58KD86XFxcXC4oPzolVExEUyUpKD86JyArIHNyY19aUENjICsgJ3wkKSknO1xyXG5cclxuZXhwb3J0cy50cGxfZW1haWxfZnV6enkgPVxyXG5cclxuICAgICcoXnw+fCcgKyBzcmNfWkNjICsgJykoJyArIHNyY19lbWFpbF9uYW1lICsgJ0AnICsgdHBsX2hvc3RfZnV6enlfc3RyaWN0ICsgJyknO1xyXG5cclxuZXhwb3J0cy50cGxfbGlua19mdXp6eSA9XHJcbiAgICAvLyBGdXp6eSBsaW5rIGNhbid0IGJlIHByZXBlbmRlZCB3aXRoIC46L1xcLSBhbmQgbm9uIHB1bmN0dWF0aW9uLlxyXG4gICAgLy8gYnV0IGNhbiBzdGFydCB3aXRoID4gKG1hcmtkb3duIGJsb2NrcXVvdGUpXHJcbiAgICAnKF58KD8hWy46L1xcXFwtX0BdKSg/OlskKzw9Pl5gfF18JyArIHNyY19aUENjICsgJykpJyArXHJcbiAgICAnKCg/IVskKzw9Pl5gfF0pJyArIHRwbF9ob3N0X3BvcnRfZnV6enlfc3RyaWN0ICsgc3JjX3BhdGggKyAnKSc7XHJcblxyXG59LHtcInVjLm1pY3JvL2NhdGVnb3JpZXMvQ2MvcmVnZXhcIjo2MCxcInVjLm1pY3JvL2NhdGVnb3JpZXMvUC9yZWdleFwiOjYyLFwidWMubWljcm8vY2F0ZWdvcmllcy9aL3JlZ2V4XCI6NjMsXCJ1Yy5taWNyby9wcm9wZXJ0aWVzL0FueS9yZWdleFwiOjY1fV0sNTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cclxuXHJcbnZhciBkZWNvZGVDYWNoZSA9IHt9O1xyXG5cclxuZnVuY3Rpb24gZ2V0RGVjb2RlQ2FjaGUoZXhjbHVkZSkge1xyXG4gIHZhciBpLCBjaCwgY2FjaGUgPSBkZWNvZGVDYWNoZVtleGNsdWRlXTtcclxuICBpZiAoY2FjaGUpIHsgcmV0dXJuIGNhY2hlOyB9XHJcblxyXG4gIGNhY2hlID0gZGVjb2RlQ2FjaGVbZXhjbHVkZV0gPSBbXTtcclxuXHJcbiAgZm9yIChpID0gMDsgaSA8IDEyODsgaSsrKSB7XHJcbiAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XHJcbiAgICBjYWNoZS5wdXNoKGNoKTtcclxuICB9XHJcblxyXG4gIGZvciAoaSA9IDA7IGkgPCBleGNsdWRlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjaCA9IGV4Y2x1ZGUuY2hhckNvZGVBdChpKTtcclxuICAgIGNhY2hlW2NoXSA9ICclJyArICgnMCcgKyBjaC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNhY2hlO1xyXG59XHJcblxyXG5cclxuLy8gRGVjb2RlIHBlcmNlbnQtZW5jb2RlZCBzdHJpbmcuXHJcbi8vXHJcbmZ1bmN0aW9uIGRlY29kZShzdHJpbmcsIGV4Y2x1ZGUpIHtcclxuICB2YXIgY2FjaGU7XHJcblxyXG4gIGlmICh0eXBlb2YgZXhjbHVkZSAhPT0gJ3N0cmluZycpIHtcclxuICAgIGV4Y2x1ZGUgPSBkZWNvZGUuZGVmYXVsdENoYXJzO1xyXG4gIH1cclxuXHJcbiAgY2FjaGUgPSBnZXREZWNvZGVDYWNoZShleGNsdWRlKTtcclxuXHJcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8oJVthLWYwLTldezJ9KSsvZ2ksIGZ1bmN0aW9uKHNlcSkge1xyXG4gICAgdmFyIGksIGwsIGIxLCBiMiwgYjMsIGI0LCBjaGFyLFxyXG4gICAgICAgIHJlc3VsdCA9ICcnO1xyXG5cclxuICAgIGZvciAoaSA9IDAsIGwgPSBzZXEubGVuZ3RoOyBpIDwgbDsgaSArPSAzKSB7XHJcbiAgICAgIGIxID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyAxLCBpICsgMyksIDE2KTtcclxuXHJcbiAgICAgIGlmIChiMSA8IDB4ODApIHtcclxuICAgICAgICByZXN1bHQgKz0gY2FjaGVbYjFdO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoKGIxICYgMHhFMCkgPT09IDB4QzAgJiYgKGkgKyAzIDwgbCkpIHtcclxuICAgICAgICAvLyAxMTB4eHh4eCAxMHh4eHh4eFxyXG4gICAgICAgIGIyID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA0LCBpICsgNiksIDE2KTtcclxuXHJcbiAgICAgICAgaWYgKChiMiAmIDB4QzApID09PSAweDgwKSB7XHJcbiAgICAgICAgICBjaGFyID0gKChiMSA8PCA2KSAmIDB4N0MwKSB8IChiMiAmIDB4M0YpO1xyXG5cclxuICAgICAgICAgIGlmIChjaGFyIDwgMHg4MCkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcdWZmZmRcXHVmZmZkJztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXIpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGkgKz0gMztcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKChiMSAmIDB4RjApID09PSAweEUwICYmIChpICsgNiA8IGwpKSB7XHJcbiAgICAgICAgLy8gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHhcclxuICAgICAgICBiMiA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNCwgaSArIDYpLCAxNik7XHJcbiAgICAgICAgYjMgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDcsIGkgKyA5KSwgMTYpO1xyXG5cclxuICAgICAgICBpZiAoKGIyICYgMHhDMCkgPT09IDB4ODAgJiYgKGIzICYgMHhDMCkgPT09IDB4ODApIHtcclxuICAgICAgICAgIGNoYXIgPSAoKGIxIDw8IDEyKSAmIDB4RjAwMCkgfCAoKGIyIDw8IDYpICYgMHhGQzApIHwgKGIzICYgMHgzRik7XHJcblxyXG4gICAgICAgICAgaWYgKGNoYXIgPCAweDgwMCB8fCAoY2hhciA+PSAweEQ4MDAgJiYgY2hhciA8PSAweERGRkYpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFx1ZmZmZFxcdWZmZmRcXHVmZmZkJztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXIpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGkgKz0gNjtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKChiMSAmIDB4RjgpID09PSAweEYwICYmIChpICsgOSA8IGwpKSB7XHJcbiAgICAgICAgLy8gMTExMTEweHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcclxuICAgICAgICBiMiA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNCwgaSArIDYpLCAxNik7XHJcbiAgICAgICAgYjMgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDcsIGkgKyA5KSwgMTYpO1xyXG4gICAgICAgIGI0ID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyAxMCwgaSArIDEyKSwgMTYpO1xyXG5cclxuICAgICAgICBpZiAoKGIyICYgMHhDMCkgPT09IDB4ODAgJiYgKGIzICYgMHhDMCkgPT09IDB4ODAgJiYgKGI0ICYgMHhDMCkgPT09IDB4ODApIHtcclxuICAgICAgICAgIGNoYXIgPSAoKGIxIDw8IDE4KSAmIDB4MUMwMDAwKSB8ICgoYjIgPDwgMTIpICYgMHgzRjAwMCkgfCAoKGIzIDw8IDYpICYgMHhGQzApIHwgKGI0ICYgMHgzRik7XHJcblxyXG4gICAgICAgICAgaWYgKGNoYXIgPCAweDEwMDAwIHx8IGNoYXIgPiAweDEwRkZGRikge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcdWZmZmRcXHVmZmZkXFx1ZmZmZFxcdWZmZmQnO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2hhciAtPSAweDEwMDAwO1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MDAgKyAoY2hhciA+PiAxMCksIDB4REMwMCArIChjaGFyICYgMHgzRkYpKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpICs9IDk7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlc3VsdCArPSAnXFx1ZmZmZCc7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9KTtcclxufVxyXG5cclxuXHJcbmRlY29kZS5kZWZhdWx0Q2hhcnMgICA9ICc7Lz86QCY9KyQsIyc7XHJcbmRlY29kZS5jb21wb25lbnRDaGFycyA9ICcnO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZGVjb2RlO1xyXG5cclxufSx7fV0sNTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBlbmNvZGVDYWNoZSA9IHt9O1xyXG5cclxuXHJcbi8vIENyZWF0ZSBhIGxvb2t1cCBhcnJheSB3aGVyZSBhbnl0aGluZyBidXQgY2hhcmFjdGVycyBpbiBgY2hhcnNgIHN0cmluZ1xyXG4vLyBhbmQgYWxwaGFudW1lcmljIGNoYXJzIGlzIHBlcmNlbnQtZW5jb2RlZC5cclxuLy9cclxuZnVuY3Rpb24gZ2V0RW5jb2RlQ2FjaGUoZXhjbHVkZSkge1xyXG4gIHZhciBpLCBjaCwgY2FjaGUgPSBlbmNvZGVDYWNoZVtleGNsdWRlXTtcclxuICBpZiAoY2FjaGUpIHsgcmV0dXJuIGNhY2hlOyB9XHJcblxyXG4gIGNhY2hlID0gZW5jb2RlQ2FjaGVbZXhjbHVkZV0gPSBbXTtcclxuXHJcbiAgZm9yIChpID0gMDsgaSA8IDEyODsgaSsrKSB7XHJcbiAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XHJcblxyXG4gICAgaWYgKC9eWzAtOWEtel0kL2kudGVzdChjaCkpIHtcclxuICAgICAgLy8gYWx3YXlzIGFsbG93IHVuZW5jb2RlZCBhbHBoYW51bWVyaWMgY2hhcmFjdGVyc1xyXG4gICAgICBjYWNoZS5wdXNoKGNoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNhY2hlLnB1c2goJyUnICsgKCcwJyArIGkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmb3IgKGkgPSAwOyBpIDwgZXhjbHVkZS5sZW5ndGg7IGkrKykge1xyXG4gICAgY2FjaGVbZXhjbHVkZS5jaGFyQ29kZUF0KGkpXSA9IGV4Y2x1ZGVbaV07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY2FjaGU7XHJcbn1cclxuXHJcblxyXG4vLyBFbmNvZGUgdW5zYWZlIGNoYXJhY3RlcnMgd2l0aCBwZXJjZW50LWVuY29kaW5nLCBza2lwcGluZyBhbHJlYWR5XHJcbi8vIGVuY29kZWQgc2VxdWVuY2VzLlxyXG4vL1xyXG4vLyAgLSBzdHJpbmcgICAgICAgLSBzdHJpbmcgdG8gZW5jb2RlXHJcbi8vICAtIGV4Y2x1ZGUgICAgICAtIGxpc3Qgb2YgY2hhcmFjdGVycyB0byBpZ25vcmUgKGluIGFkZGl0aW9uIHRvIGEtekEtWjAtOSlcclxuLy8gIC0ga2VlcEVzY2FwZWQgIC0gZG9uJ3QgZW5jb2RlICclJyBpbiBhIGNvcnJlY3QgZXNjYXBlIHNlcXVlbmNlIChkZWZhdWx0OiB0cnVlKVxyXG4vL1xyXG5mdW5jdGlvbiBlbmNvZGUoc3RyaW5nLCBleGNsdWRlLCBrZWVwRXNjYXBlZCkge1xyXG4gIHZhciBpLCBsLCBjb2RlLCBuZXh0Q29kZSwgY2FjaGUsXHJcbiAgICAgIHJlc3VsdCA9ICcnO1xyXG5cclxuICBpZiAodHlwZW9mIGV4Y2x1ZGUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAvLyBlbmNvZGUoc3RyaW5nLCBrZWVwRXNjYXBlZClcclxuICAgIGtlZXBFc2NhcGVkICA9IGV4Y2x1ZGU7XHJcbiAgICBleGNsdWRlID0gZW5jb2RlLmRlZmF1bHRDaGFycztcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2Yga2VlcEVzY2FwZWQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBrZWVwRXNjYXBlZCA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBjYWNoZSA9IGdldEVuY29kZUNhY2hlKGV4Y2x1ZGUpO1xyXG5cclxuICBmb3IgKGkgPSAwLCBsID0gc3RyaW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG5cclxuICAgIGlmIChrZWVwRXNjYXBlZCAmJiBjb2RlID09PSAweDI1IC8qICUgKi8gJiYgaSArIDIgPCBsKSB7XHJcbiAgICAgIGlmICgvXlswLTlhLWZdezJ9JC9pLnRlc3Qoc3RyaW5nLnNsaWNlKGkgKyAxLCBpICsgMykpKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IHN0cmluZy5zbGljZShpLCBpICsgMyk7XHJcbiAgICAgICAgaSArPSAyO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvZGUgPCAxMjgpIHtcclxuICAgICAgcmVzdWx0ICs9IGNhY2hlW2NvZGVdO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY29kZSA+PSAweEQ4MDAgJiYgY29kZSA8PSAweERGRkYpIHtcclxuICAgICAgaWYgKGNvZGUgPj0gMHhEODAwICYmIGNvZGUgPD0gMHhEQkZGICYmIGkgKyAxIDwgbCkge1xyXG4gICAgICAgIG5leHRDb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpO1xyXG4gICAgICAgIGlmIChuZXh0Q29kZSA+PSAweERDMDAgJiYgbmV4dENvZGUgPD0gMHhERkZGKSB7XHJcbiAgICAgICAgICByZXN1bHQgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ1tpXSArIHN0cmluZ1tpICsgMV0pO1xyXG4gICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJlc3VsdCArPSAnJUVGJUJGJUJEJztcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmVzdWx0ICs9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdbaV0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZW5jb2RlLmRlZmF1bHRDaGFycyAgID0gXCI7Lz86QCY9KyQsLV8uIX4qJygpI1wiO1xyXG5lbmNvZGUuY29tcG9uZW50Q2hhcnMgPSBcIi1fLiF+KicoKVwiO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZW5jb2RlO1xyXG5cclxufSx7fV0sNTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9ybWF0KHVybCkge1xyXG4gIHZhciByZXN1bHQgPSAnJztcclxuXHJcbiAgcmVzdWx0ICs9IHVybC5wcm90b2NvbCB8fCAnJztcclxuICByZXN1bHQgKz0gdXJsLnNsYXNoZXMgPyAnLy8nIDogJyc7XHJcbiAgcmVzdWx0ICs9IHVybC5hdXRoID8gdXJsLmF1dGggKyAnQCcgOiAnJztcclxuXHJcbiAgaWYgKHVybC5ob3N0bmFtZSAmJiB1cmwuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMSkge1xyXG4gICAgLy8gaXB2NiBhZGRyZXNzXHJcbiAgICByZXN1bHQgKz0gJ1snICsgdXJsLmhvc3RuYW1lICsgJ10nO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXN1bHQgKz0gdXJsLmhvc3RuYW1lIHx8ICcnO1xyXG4gIH1cclxuXHJcbiAgcmVzdWx0ICs9IHVybC5wb3J0ID8gJzonICsgdXJsLnBvcnQgOiAnJztcclxuICByZXN1bHQgKz0gdXJsLnBhdGhuYW1lIHx8ICcnO1xyXG4gIHJlc3VsdCArPSB1cmwuc2VhcmNoIHx8ICcnO1xyXG4gIHJlc3VsdCArPSB1cmwuaGFzaCB8fCAnJztcclxuXHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbn0se31dLDU4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzLmVuY29kZSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XHJcbm1vZHVsZS5leHBvcnRzLmRlY29kZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XHJcbm1vZHVsZS5leHBvcnRzLmZvcm1hdCA9IHJlcXVpcmUoJy4vZm9ybWF0Jyk7XHJcbm1vZHVsZS5leHBvcnRzLnBhcnNlICA9IHJlcXVpcmUoJy4vcGFyc2UnKTtcclxuXHJcbn0se1wiLi9kZWNvZGVcIjo1NSxcIi4vZW5jb2RlXCI6NTYsXCIuL2Zvcm1hdFwiOjU3LFwiLi9wYXJzZVwiOjU5fV0sNTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cclxuLy9cclxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcclxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XHJcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxyXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuLy9cclxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcclxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbi8vXHJcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcclxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXHJcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxyXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcclxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxyXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy9cclxuLy8gQ2hhbmdlcyBmcm9tIGpveWVudC9ub2RlOlxyXG4vL1xyXG4vLyAxLiBObyBsZWFkaW5nIHNsYXNoIGluIHBhdGhzLFxyXG4vLyAgICBlLmcuIGluIGB1cmwucGFyc2UoJ2h0dHA6Ly9mb28/YmFyJylgIHBhdGhuYW1lIGlzIGBgLCBub3QgYC9gXHJcbi8vXHJcbi8vIDIuIEJhY2tzbGFzaGVzIGFyZSBub3QgcmVwbGFjZWQgd2l0aCBzbGFzaGVzLFxyXG4vLyAgICBzbyBgaHR0cDpcXFxcZXhhbXBsZS5vcmdcXGAgaXMgdHJlYXRlZCBsaWtlIGEgcmVsYXRpdmUgcGF0aFxyXG4vL1xyXG4vLyAzLiBUcmFpbGluZyBjb2xvbiBpcyB0cmVhdGVkIGxpa2UgYSBwYXJ0IG9mIHRoZSBwYXRoLFxyXG4vLyAgICBpLmUuIGluIGBodHRwOi8vZXhhbXBsZS5vcmc6Zm9vYCBwYXRobmFtZSBpcyBgOmZvb2BcclxuLy9cclxuLy8gNC4gTm90aGluZyBpcyBVUkwtZW5jb2RlZCBpbiB0aGUgcmVzdWx0aW5nIG9iamVjdCxcclxuLy8gICAgKGluIGpveWVudC9ub2RlIHNvbWUgY2hhcnMgaW4gYXV0aCBhbmQgcGF0aHMgYXJlIGVuY29kZWQpXHJcbi8vXHJcbi8vIDUuIGB1cmwucGFyc2UoKWAgZG9lcyBub3QgaGF2ZSBgcGFyc2VRdWVyeVN0cmluZ2AgYXJndW1lbnRcclxuLy9cclxuLy8gNi4gUmVtb3ZlZCBleHRyYW5lb3VzIHJlc3VsdCBwcm9wZXJ0aWVzOiBgaG9zdGAsIGBwYXRoYCwgYHF1ZXJ5YCwgZXRjLixcclxuLy8gICAgd2hpY2ggY2FuIGJlIGNvbnN0cnVjdGVkIHVzaW5nIG90aGVyIHBhcnRzIG9mIHRoZSB1cmwuXHJcbi8vXHJcblxyXG5cclxuZnVuY3Rpb24gVXJsKCkge1xyXG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xyXG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XHJcbiAgdGhpcy5hdXRoID0gbnVsbDtcclxuICB0aGlzLnBvcnQgPSBudWxsO1xyXG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xyXG4gIHRoaXMuaGFzaCA9IG51bGw7XHJcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xyXG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xyXG59XHJcblxyXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcclxuXHJcbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXHJcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxyXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcclxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcclxuXHJcbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXHJcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXHJcblxyXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cclxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXHJcbiAgICBkZWxpbXMgPSBbICc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0JyBdLFxyXG5cclxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXHJcbiAgICB1bndpc2UgPSBbICd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCcgXS5jb25jYXQoZGVsaW1zKSxcclxuXHJcbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXHJcbiAgICBhdXRvRXNjYXBlID0gWyAnXFwnJyBdLmNvbmNhdCh1bndpc2UpLFxyXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cclxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcclxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxyXG4gICAgLy8gdGhlbS5cclxuICAgIG5vbkhvc3RDaGFycyA9IFsgJyUnLCAnLycsICc/JywgJzsnLCAnIycgXS5jb25jYXQoYXV0b0VzY2FwZSksXHJcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbICcvJywgJz8nLCAnIycgXSxcclxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxyXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcclxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxyXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXHJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zY3JpcHQtdXJsICovXHJcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXHJcbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xyXG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXHJcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcclxuICAgIH0sXHJcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cclxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcclxuICAgICAgJ2h0dHAnOiB0cnVlLFxyXG4gICAgICAnaHR0cHMnOiB0cnVlLFxyXG4gICAgICAnZnRwJzogdHJ1ZSxcclxuICAgICAgJ2dvcGhlcic6IHRydWUsXHJcbiAgICAgICdmaWxlJzogdHJ1ZSxcclxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcclxuICAgICAgJ2h0dHBzOic6IHRydWUsXHJcbiAgICAgICdmdHA6JzogdHJ1ZSxcclxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxyXG4gICAgICAnZmlsZTonOiB0cnVlXHJcbiAgICB9O1xyXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1zY3JpcHQtdXJsICovXHJcblxyXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XHJcbiAgaWYgKHVybCAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHsgcmV0dXJuIHVybDsgfVxyXG5cclxuICB2YXIgdSA9IG5ldyBVcmwoKTtcclxuICB1LnBhcnNlKHVybCwgc2xhc2hlc0Rlbm90ZUhvc3QpO1xyXG4gIHJldHVybiB1O1xyXG59XHJcblxyXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBzbGFzaGVzRGVub3RlSG9zdCkge1xyXG4gIHZhciBpLCBsLCBsb3dlclByb3RvLCBoZWMsIHNsYXNoZXMsXHJcbiAgICAgIHJlc3QgPSB1cmw7XHJcblxyXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXHJcbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxyXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcclxuXHJcbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcclxuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXHJcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XHJcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xyXG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcclxuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcclxuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcclxuICBpZiAocHJvdG8pIHtcclxuICAgIHByb3RvID0gcHJvdG9bMF07XHJcbiAgICBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcclxuICAgIHRoaXMucHJvdG9jb2wgPSBwcm90bztcclxuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xyXG4gIH1cclxuXHJcbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcclxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXHJcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xyXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxyXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xyXG4gICAgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xyXG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcclxuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xyXG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxyXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xyXG5cclxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cclxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXHJcbiAgICAvL1xyXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxyXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXHJcbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXHJcbiAgICAvL1xyXG4gICAgLy8gZXg6XHJcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xyXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xyXG5cclxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cclxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXHJcblxyXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xyXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XHJcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSkge1xyXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcclxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxyXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcclxuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xyXG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxyXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXHJcbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXHJcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cclxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXHJcbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xyXG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xyXG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcclxuICAgICAgdGhpcy5hdXRoID0gYXV0aDtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXHJcbiAgICBob3N0RW5kID0gLTE7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xyXG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpIHtcclxuICAgICAgICBob3N0RW5kID0gaGVjO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXHJcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcclxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChyZXN0W2hvc3RFbmQgLSAxXSA9PT0gJzonKSB7IGhvc3RFbmQtLTsgfVxyXG4gICAgdmFyIGhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xyXG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XHJcblxyXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cclxuICAgIHRoaXMucGFyc2VIb3N0KGhvc3QpO1xyXG5cclxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXHJcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxyXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XHJcblxyXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cclxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxyXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxyXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xyXG5cclxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxyXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcclxuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xyXG4gICAgICBmb3IgKGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xyXG4gICAgICAgIGlmICghcGFydCkgeyBjb250aW51ZTsgfVxyXG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xyXG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcclxuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcclxuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xyXG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcclxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXHJcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XHJcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcclxuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XHJcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcclxuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xyXG4gICAgICAgICAgICBpZiAoYml0KSB7XHJcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XHJcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgcmVzdCA9IG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XHJcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcclxuICAgIH1cclxuXHJcbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXHJcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxyXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xyXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXHJcbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcclxuICBpZiAoaGFzaCAhPT0gLTEpIHtcclxuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cclxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xyXG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XHJcbiAgfVxyXG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xyXG4gIGlmIChxbSAhPT0gLTEpIHtcclxuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xyXG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xyXG4gIH1cclxuICBpZiAocmVzdCkgeyB0aGlzLnBhdGhuYW1lID0gcmVzdDsgfVxyXG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcclxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xyXG4gICAgdGhpcy5wYXRobmFtZSA9ICcnO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKGhvc3QpIHtcclxuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XHJcbiAgaWYgKHBvcnQpIHtcclxuICAgIHBvcnQgPSBwb3J0WzBdO1xyXG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xyXG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcclxuICAgIH1cclxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcclxuICB9XHJcbiAgaWYgKGhvc3QpIHsgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7IH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gdXJsUGFyc2U7XHJcblxyXG59LHt9XSw2MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzPS9bXFwwLVxceDFGXFx4N0YtXFx4OUZdL1xyXG59LHt9XSw2MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzPS9bXFx4QURcXHUwNjAwLVxcdTA2MDVcXHUwNjFDXFx1MDZERFxcdTA3MEZcXHUxODBFXFx1MjAwQi1cXHUyMDBGXFx1MjAyQS1cXHUyMDJFXFx1MjA2MC1cXHUyMDY0XFx1MjA2Ni1cXHUyMDZGXFx1RkVGRlxcdUZGRjktXFx1RkZGQl18XFx1RDgwNFxcdURDQkR8XFx1RDgyRltcXHVEQ0EwLVxcdURDQTNdfFxcdUQ4MzRbXFx1REQ3My1cXHVERDdBXXxcXHVEQjQwW1xcdURDMDFcXHVEQzIwLVxcdURDN0ZdL1xyXG59LHt9XSw2MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzPS9bIS0jJS1cXCosLS86O1xcP0BcXFstXFxdX1xce1xcfVxceEExXFx4QTdcXHhBQlxceEI2XFx4QjdcXHhCQlxceEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDU4QVxcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTBBRjBcXHUwREY0XFx1MEU0RlxcdTBFNUFcXHUwRTVCXFx1MEYwNC1cXHUwRjEyXFx1MEYxNFxcdTBGM0EtXFx1MEYzRFxcdTBGODVcXHUwRkQwLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQVxcdTEwNEEtXFx1MTA0RlxcdTEwRkJcXHUxMzYwLVxcdTEzNjhcXHUxNDAwXFx1MTY2RFxcdTE2NkVcXHUxNjlCXFx1MTY5Q1xcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCRkMtXFx1MUJGRlxcdTFDM0ItXFx1MUMzRlxcdTFDN0VcXHUxQzdGXFx1MUNDMC1cXHUxQ0M3XFx1MUNEM1xcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA0M1xcdTIwNDUtXFx1MjA1MVxcdTIwNTMtXFx1MjA1RVxcdTIwN0RcXHUyMDdFXFx1MjA4RFxcdTIwOEVcXHUyMzA4LVxcdTIzMEJcXHUyMzI5XFx1MjMyQVxcdTI3NjgtXFx1Mjc3NVxcdTI3QzVcXHUyN0M2XFx1MjdFNi1cXHUyN0VGXFx1Mjk4My1cXHUyOTk4XFx1MjlEOC1cXHUyOURCXFx1MjlGQ1xcdTI5RkRcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwLVxcdTJFMkVcXHUyRTMwLVxcdTJFNDJcXHUzMDAxLVxcdTMwMDNcXHUzMDA4LVxcdTMwMTFcXHUzMDE0LVxcdTMwMUZcXHUzMDMwXFx1MzAzRFxcdTMwQTBcXHUzMEZCXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjczXFx1QTY3RVxcdUE2RjItXFx1QTZGN1xcdUE4NzQtXFx1QTg3N1xcdUE4Q0VcXHVBOENGXFx1QThGOC1cXHVBOEZBXFx1QTkyRVxcdUE5MkZcXHVBOTVGXFx1QTlDMS1cXHVBOUNEXFx1QTlERVxcdUE5REZcXHVBQTVDLVxcdUFBNUZcXHVBQURFXFx1QUFERlxcdUFBRjBcXHVBQUYxXFx1QUJFQlxcdUZEM0VcXHVGRDNGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTYxXFx1RkU2M1xcdUZFNjhcXHVGRTZBXFx1RkU2QlxcdUZGMDEtXFx1RkYwM1xcdUZGMDUtXFx1RkYwQVxcdUZGMEMtXFx1RkYwRlxcdUZGMUFcXHVGRjFCXFx1RkYxRlxcdUZGMjBcXHVGRjNCLVxcdUZGM0RcXHVGRjNGXFx1RkY1QlxcdUZGNURcXHVGRjVGLVxcdUZGNjVdfFxcdUQ4MDBbXFx1REQwMC1cXHVERDAyXFx1REY5RlxcdURGRDBdfFxcdUQ4MDFcXHVERDZGfFxcdUQ4MDJbXFx1REM1N1xcdUREMUZcXHVERDNGXFx1REU1MC1cXHVERTU4XFx1REU3RlxcdURFRjAtXFx1REVGNlxcdURGMzktXFx1REYzRlxcdURGOTktXFx1REY5Q118XFx1RDgwNFtcXHVEQzQ3LVxcdURDNERcXHVEQ0JCXFx1RENCQ1xcdURDQkUtXFx1RENDMVxcdURENDAtXFx1REQ0M1xcdURENzRcXHVERDc1XFx1RERDNS1cXHVEREM4XFx1RERDRFxcdURFMzgtXFx1REUzRF18XFx1RDgwNVtcXHVEQ0M2XFx1RERDMS1cXHVEREM5XFx1REU0MS1cXHVERTQzXXxcXHVEODA5W1xcdURDNzAtXFx1REM3NF18XFx1RDgxQVtcXHVERTZFXFx1REU2RlxcdURFRjVcXHVERjM3LVxcdURGM0JcXHVERjQ0XXxcXHVEODJGXFx1REM5Ri9cclxufSx7fV0sNjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG5tb2R1bGUuZXhwb3J0cz0vWyBcXHhBMFxcdTE2ODBcXHUyMDAwLVxcdTIwMEFcXHUyMDI4XFx1MjAyOVxcdTIwMkZcXHUyMDVGXFx1MzAwMF0vXHJcbn0se31dLDY0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuXHJcbm1vZHVsZS5leHBvcnRzLkFueSA9IHJlcXVpcmUoJy4vcHJvcGVydGllcy9BbnkvcmVnZXgnKTtcclxubW9kdWxlLmV4cG9ydHMuQ2MgID0gcmVxdWlyZSgnLi9jYXRlZ29yaWVzL0NjL3JlZ2V4Jyk7XHJcbm1vZHVsZS5leHBvcnRzLkNmICA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllcy9DZi9yZWdleCcpO1xyXG5tb2R1bGUuZXhwb3J0cy5QICAgPSByZXF1aXJlKCcuL2NhdGVnb3JpZXMvUC9yZWdleCcpO1xyXG5tb2R1bGUuZXhwb3J0cy5aICAgPSByZXF1aXJlKCcuL2NhdGVnb3JpZXMvWi9yZWdleCcpO1xyXG5cclxufSx7XCIuL2NhdGVnb3JpZXMvQ2MvcmVnZXhcIjo2MCxcIi4vY2F0ZWdvcmllcy9DZi9yZWdleFwiOjYxLFwiLi9jYXRlZ29yaWVzL1AvcmVnZXhcIjo2MixcIi4vY2F0ZWdvcmllcy9aL3JlZ2V4XCI6NjMsXCIuL3Byb3BlcnRpZXMvQW55L3JlZ2V4XCI6NjV9XSw2NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbm1vZHVsZS5leHBvcnRzPS9bXFwwLVxcdUQ3RkZcXHVEQzAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0vXHJcbn0se31dLDY2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvJyk7XHJcblxyXG59LHtcIi4vbGliL1wiOjEwfV19LHt9LFs2Nl0pKDY2KVxyXG59KTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/markdown-it.js\n");

/***/ }),

/***/ "./lib/rawdeflate.js":
/*!***************************!*\
  !*** ./lib/rawdeflate.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\r\n * $Id: rawdeflate.js,v 0.3 2009/03/01 19:05:05 dankogai Exp dankogai $\r\n *\r\n * Original:\r\n *   http://www.onicos.com/staff/iz/amuse/javascript/expert/deflate.txt\r\n */\r\n\r\n(function(){\r\n\r\n/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\r\n * Version: 1.0.1\r\n * LastModified: Dec 25 1999\r\n */\r\n\r\n/* Interface:\r\n * data = zip_deflate(src);\r\n */\r\n\r\n/* constant parameters */\r\nvar zip_WSIZE = 32768;\t\t// Sliding Window size\r\nvar zip_STORED_BLOCK = 0;\r\nvar zip_STATIC_TREES = 1;\r\nvar zip_DYN_TREES    = 2;\r\n\r\n/* for deflate */\r\nvar zip_DEFAULT_LEVEL = 6;\r\nvar zip_FULL_SEARCH = true;\r\nvar zip_INBUFSIZ = 32768;\t// Input buffer size\r\nvar zip_INBUF_EXTRA = 64;\t// Extra buffer\r\nvar zip_OUTBUFSIZ = 1024 * 8;\r\nvar zip_window_size = 2 * zip_WSIZE;\r\nvar zip_MIN_MATCH = 3;\r\nvar zip_MAX_MATCH = 258;\r\nvar zip_BITS = 16;\r\n// for SMALL_MEM\r\nvar zip_LIT_BUFSIZE = 0x2000;\r\nvar zip_HASH_BITS = 13;\r\n// for MEDIUM_MEM\r\n// var zip_LIT_BUFSIZE = 0x4000;\r\n// var zip_HASH_BITS = 14;\r\n// for BIG_MEM\r\n// var zip_LIT_BUFSIZE = 0x8000;\r\n// var zip_HASH_BITS = 15;\r\nif(zip_LIT_BUFSIZE > zip_INBUFSIZ)\r\n    alert(\"error: zip_INBUFSIZ is too small\");\r\nif((zip_WSIZE<<1) > (1<<zip_BITS))\r\n    alert(\"error: zip_WSIZE is too large\");\r\nif(zip_HASH_BITS > zip_BITS-1)\r\n    alert(\"error: zip_HASH_BITS is too large\");\r\nif(zip_HASH_BITS < 8 || zip_MAX_MATCH != 258)\r\n    alert(\"error: Code too clever\");\r\nvar zip_DIST_BUFSIZE = zip_LIT_BUFSIZE;\r\nvar zip_HASH_SIZE = 1 << zip_HASH_BITS;\r\nvar zip_HASH_MASK = zip_HASH_SIZE - 1;\r\nvar zip_WMASK = zip_WSIZE - 1;\r\nvar zip_NIL = 0; // Tail of hash chains\r\nvar zip_TOO_FAR = 4096;\r\nvar zip_MIN_LOOKAHEAD = zip_MAX_MATCH + zip_MIN_MATCH + 1;\r\nvar zip_MAX_DIST = zip_WSIZE - zip_MIN_LOOKAHEAD;\r\nvar zip_SMALLEST = 1;\r\nvar zip_MAX_BITS = 15;\r\nvar zip_MAX_BL_BITS = 7;\r\nvar zip_LENGTH_CODES = 29;\r\nvar zip_LITERALS =256;\r\nvar zip_END_BLOCK = 256;\r\nvar zip_L_CODES = zip_LITERALS + 1 + zip_LENGTH_CODES;\r\nvar zip_D_CODES = 30;\r\nvar zip_BL_CODES = 19;\r\nvar zip_REP_3_6 = 16;\r\nvar zip_REPZ_3_10 = 17;\r\nvar zip_REPZ_11_138 = 18;\r\nvar zip_HEAP_SIZE = 2 * zip_L_CODES + 1;\r\nvar zip_H_SHIFT = parseInt((zip_HASH_BITS + zip_MIN_MATCH - 1) /\r\n\t\t\t   zip_MIN_MATCH);\r\n\r\n/* variables */\r\nvar zip_free_queue;\r\nvar zip_qhead, zip_qtail;\r\nvar zip_initflag;\r\nvar zip_outbuf = null;\r\nvar zip_outcnt, zip_outoff;\r\nvar zip_complete;\r\nvar zip_window;\r\nvar zip_d_buf;\r\nvar zip_l_buf;\r\nvar zip_prev;\r\nvar zip_bi_buf;\r\nvar zip_bi_valid;\r\nvar zip_block_start;\r\nvar zip_ins_h;\r\nvar zip_hash_head;\r\nvar zip_prev_match;\r\nvar zip_match_available;\r\nvar zip_match_length;\r\nvar zip_prev_length;\r\nvar zip_strstart;\r\nvar zip_match_start;\r\nvar zip_eofile;\r\nvar zip_lookahead;\r\nvar zip_max_chain_length;\r\nvar zip_max_lazy_match;\r\nvar zip_compr_level;\r\nvar zip_good_match;\r\nvar zip_nice_match;\r\nvar zip_dyn_ltree;\r\nvar zip_dyn_dtree;\r\nvar zip_static_ltree;\r\nvar zip_static_dtree;\r\nvar zip_bl_tree;\r\nvar zip_l_desc;\r\nvar zip_d_desc;\r\nvar zip_bl_desc;\r\nvar zip_bl_count;\r\nvar zip_heap;\r\nvar zip_heap_len;\r\nvar zip_heap_max;\r\nvar zip_depth;\r\nvar zip_length_code;\r\nvar zip_dist_code;\r\nvar zip_base_length;\r\nvar zip_base_dist;\r\nvar zip_flag_buf;\r\nvar zip_last_lit;\r\nvar zip_last_dist;\r\nvar zip_last_flags;\r\nvar zip_flags;\r\nvar zip_flag_bit;\r\nvar zip_opt_len;\r\nvar zip_static_len;\r\nvar zip_deflate_data;\r\nvar zip_deflate_pos;\r\n\r\n/* objects (deflate) */\r\n\r\nvar zip_DeflateCT = function() {\r\n    this.fc = 0; // frequency count or bit string\r\n    this.dl = 0; // father node in Huffman tree or length of bit string\r\n}\r\n\r\nvar zip_DeflateTreeDesc = function() {\r\n    this.dyn_tree = null;\t// the dynamic tree\r\n    this.static_tree = null;\t// corresponding static tree or NULL\r\n    this.extra_bits = null;\t// extra bits for each code or NULL\r\n    this.extra_base = 0;\t// base index for extra_bits\r\n    this.elems = 0;\t\t// max number of elements in the tree\r\n    this.max_length = 0;\t// max bit length for the codes\r\n    this.max_code = 0;\t\t// largest code with non zero frequency\r\n}\r\n\r\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\r\n * the desired pack level (0..9). The values given below have been tuned to\r\n * exclude worst case performance for pathological files. Better values may be\r\n * found for specific files.\r\n */\r\nvar zip_DeflateConfiguration = function(a, b, c, d) {\r\n    this.good_length = a; // reduce lazy search above this match length\r\n    this.max_lazy = b;    // do not perform lazy search above this match length\r\n    this.nice_length = c; // quit search above this match length\r\n    this.max_chain = d;\r\n}\r\n\r\nvar zip_DeflateBuffer = function() {\r\n    this.next = null;\r\n    this.len = 0;\r\n    this.ptr = new Array(zip_OUTBUFSIZ);\r\n    this.off = 0;\r\n}\r\n\r\n/* constant tables */\r\nvar zip_extra_lbits = new Array(\r\n    0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0);\r\nvar zip_extra_dbits = new Array(\r\n    0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13);\r\nvar zip_extra_blbits = new Array(\r\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7);\r\nvar zip_bl_order = new Array(\r\n    16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15);\r\nvar zip_configuration_table = new Array(\r\n\tnew zip_DeflateConfiguration(0,    0,   0,    0),\r\n\tnew zip_DeflateConfiguration(4,    4,   8,    4),\r\n\tnew zip_DeflateConfiguration(4,    5,  16,    8),\r\n\tnew zip_DeflateConfiguration(4,    6,  32,   32),\r\n\tnew zip_DeflateConfiguration(4,    4,  16,   16),\r\n\tnew zip_DeflateConfiguration(8,   16,  32,   32),\r\n\tnew zip_DeflateConfiguration(8,   16, 128,  128),\r\n\tnew zip_DeflateConfiguration(8,   32, 128,  256),\r\n\tnew zip_DeflateConfiguration(32, 128, 258, 1024),\r\n\tnew zip_DeflateConfiguration(32, 258, 258, 4096));\r\n\r\n\r\n/* routines (deflate) */\r\n\r\nvar zip_deflate_start = function(level) {\r\n    var i;\r\n\r\n    if(!level)\r\n\tlevel = zip_DEFAULT_LEVEL;\r\n    else if(level < 1)\r\n\tlevel = 1;\r\n    else if(level > 9)\r\n\tlevel = 9;\r\n\r\n    zip_compr_level = level;\r\n    zip_initflag = false;\r\n    zip_eofile = false;\r\n    if(zip_outbuf != null)\r\n\treturn;\r\n\r\n    zip_free_queue = zip_qhead = zip_qtail = null;\r\n    zip_outbuf = new Array(zip_OUTBUFSIZ);\r\n    zip_window = new Array(zip_window_size);\r\n    zip_d_buf = new Array(zip_DIST_BUFSIZE);\r\n    zip_l_buf = new Array(zip_INBUFSIZ + zip_INBUF_EXTRA);\r\n    zip_prev = new Array(1 << zip_BITS);\r\n    zip_dyn_ltree = new Array(zip_HEAP_SIZE);\r\n    for(i = 0; i < zip_HEAP_SIZE; i++)\r\n\tzip_dyn_ltree[i] = new zip_DeflateCT();\r\n    zip_dyn_dtree = new Array(2*zip_D_CODES+1);\r\n    for(i = 0; i < 2*zip_D_CODES+1; i++)\r\n\tzip_dyn_dtree[i] = new zip_DeflateCT();\r\n    zip_static_ltree = new Array(zip_L_CODES+2);\r\n    for(i = 0; i < zip_L_CODES+2; i++)\r\n\tzip_static_ltree[i] = new zip_DeflateCT();\r\n    zip_static_dtree = new Array(zip_D_CODES);\r\n    for(i = 0; i < zip_D_CODES; i++)\r\n\tzip_static_dtree[i] = new zip_DeflateCT();\r\n    zip_bl_tree = new Array(2*zip_BL_CODES+1);\r\n    for(i = 0; i < 2*zip_BL_CODES+1; i++)\r\n\tzip_bl_tree[i] = new zip_DeflateCT();\r\n    zip_l_desc = new zip_DeflateTreeDesc();\r\n    zip_d_desc = new zip_DeflateTreeDesc();\r\n    zip_bl_desc = new zip_DeflateTreeDesc();\r\n    zip_bl_count = new Array(zip_MAX_BITS+1);\r\n    zip_heap = new Array(2*zip_L_CODES+1);\r\n    zip_depth = new Array(2*zip_L_CODES+1);\r\n    zip_length_code = new Array(zip_MAX_MATCH-zip_MIN_MATCH+1);\r\n    zip_dist_code = new Array(512);\r\n    zip_base_length = new Array(zip_LENGTH_CODES);\r\n    zip_base_dist = new Array(zip_D_CODES);\r\n    zip_flag_buf = new Array(parseInt(zip_LIT_BUFSIZE / 8));\r\n}\r\n\r\nvar zip_deflate_end = function() {\r\n    zip_free_queue = zip_qhead = zip_qtail = null;\r\n    zip_outbuf = null;\r\n    zip_window = null;\r\n    zip_d_buf = null;\r\n    zip_l_buf = null;\r\n    zip_prev = null;\r\n    zip_dyn_ltree = null;\r\n    zip_dyn_dtree = null;\r\n    zip_static_ltree = null;\r\n    zip_static_dtree = null;\r\n    zip_bl_tree = null;\r\n    zip_l_desc = null;\r\n    zip_d_desc = null;\r\n    zip_bl_desc = null;\r\n    zip_bl_count = null;\r\n    zip_heap = null;\r\n    zip_depth = null;\r\n    zip_length_code = null;\r\n    zip_dist_code = null;\r\n    zip_base_length = null;\r\n    zip_base_dist = null;\r\n    zip_flag_buf = null;\r\n}\r\n\r\nvar zip_reuse_queue = function(p) {\r\n    p.next = zip_free_queue;\r\n    zip_free_queue = p;\r\n}\r\n\r\nvar zip_new_queue = function() {\r\n    var p;\r\n\r\n    if(zip_free_queue != null)\r\n    {\r\n\tp = zip_free_queue;\r\n\tzip_free_queue = zip_free_queue.next;\r\n    }\r\n    else\r\n\tp = new zip_DeflateBuffer();\r\n    p.next = null;\r\n    p.len = p.off = 0;\r\n\r\n    return p;\r\n}\r\n\r\nvar zip_head1 = function(i) {\r\n    return zip_prev[zip_WSIZE + i];\r\n}\r\n\r\nvar zip_head2 = function(i, val) {\r\n    return zip_prev[zip_WSIZE + i] = val;\r\n}\r\n\r\n/* put_byte is used for the compressed output, put_ubyte for the\r\n * uncompressed output. However unlzw() uses window for its\r\n * suffix table instead of its output buffer, so it does not use put_ubyte\r\n * (to be cleaned up).\r\n */\r\nvar zip_put_byte = function(c) {\r\n    zip_outbuf[zip_outoff + zip_outcnt++] = c;\r\n    if(zip_outoff + zip_outcnt == zip_OUTBUFSIZ)\r\n\tzip_qoutbuf();\r\n}\r\n\r\n/* Output a 16 bit value, lsb first */\r\nvar zip_put_short = function(w) {\r\n    w &= 0xffff;\r\n    if(zip_outoff + zip_outcnt < zip_OUTBUFSIZ - 2) {\r\n\tzip_outbuf[zip_outoff + zip_outcnt++] = (w & 0xff);\r\n\tzip_outbuf[zip_outoff + zip_outcnt++] = (w >>> 8);\r\n    } else {\r\n\tzip_put_byte(w & 0xff);\r\n\tzip_put_byte(w >>> 8);\r\n    }\r\n}\r\n\r\n/* ==========================================================================\r\n * Insert string s in the dictionary and set match_head to the previous head\r\n * of the hash chain (the most recent string with same hash key). Return\r\n * the previous length of the hash chain.\r\n * IN  assertion: all calls to to INSERT_STRING are made with consecutive\r\n *    input characters and the first MIN_MATCH bytes of s are valid\r\n *    (except for the last MIN_MATCH-1 bytes of the input file).\r\n */\r\nvar zip_INSERT_STRING = function() {\r\n    zip_ins_h = ((zip_ins_h << zip_H_SHIFT)\r\n\t\t ^ (zip_window[zip_strstart + zip_MIN_MATCH - 1] & 0xff))\r\n\t& zip_HASH_MASK;\r\n    zip_hash_head = zip_head1(zip_ins_h);\r\n    zip_prev[zip_strstart & zip_WMASK] = zip_hash_head;\r\n    zip_head2(zip_ins_h, zip_strstart);\r\n}\r\n\r\n/* Send a code of the given tree. c and tree must not have side effects */\r\nvar zip_SEND_CODE = function(c, tree) {\r\n    zip_send_bits(tree[c].fc, tree[c].dl);\r\n}\r\n\r\n/* Mapping from a distance to a distance code. dist is the distance - 1 and\r\n * must not have side effects. dist_code[256] and dist_code[257] are never\r\n * used.\r\n */\r\nvar zip_D_CODE = function(dist) {\r\n    return (dist < 256 ? zip_dist_code[dist]\r\n\t    : zip_dist_code[256 + (dist>>7)]) & 0xff;\r\n}\r\n\r\n/* ==========================================================================\r\n * Compares to subtrees, using the tree depth as tie breaker when\r\n * the subtrees have equal frequency. This minimizes the worst case length.\r\n */\r\nvar zip_SMALLER = function(tree, n, m) {\r\n    return tree[n].fc < tree[m].fc ||\r\n      (tree[n].fc == tree[m].fc && zip_depth[n] <= zip_depth[m]);\r\n}\r\n\r\n/* ==========================================================================\r\n * read string data\r\n */\r\nvar zip_read_buff = function(buff, offset, n) {\r\n    var i;\r\n    for(i = 0; i < n && zip_deflate_pos < zip_deflate_data.length; i++)\r\n\tbuff[offset + i] =\r\n\t    zip_deflate_data.charCodeAt(zip_deflate_pos++) & 0xff;\r\n    return i;\r\n}\r\n\r\n/* ==========================================================================\r\n * Initialize the \"longest match\" routines for a new file\r\n */\r\nvar zip_lm_init = function() {\r\n    var j;\r\n\r\n    /* Initialize the hash table. */\r\n    for(j = 0; j < zip_HASH_SIZE; j++)\r\n//\tzip_head2(j, zip_NIL);\r\n\tzip_prev[zip_WSIZE + j] = 0;\r\n    /* prev will be initialized on the fly */\r\n\r\n    /* Set the default configuration parameters:\r\n     */\r\n    zip_max_lazy_match = zip_configuration_table[zip_compr_level].max_lazy;\r\n    zip_good_match     = zip_configuration_table[zip_compr_level].good_length;\r\n    if(!zip_FULL_SEARCH)\r\n\tzip_nice_match = zip_configuration_table[zip_compr_level].nice_length;\r\n    zip_max_chain_length = zip_configuration_table[zip_compr_level].max_chain;\r\n\r\n    zip_strstart = 0;\r\n    zip_block_start = 0;\r\n\r\n    zip_lookahead = zip_read_buff(zip_window, 0, 2 * zip_WSIZE);\r\n    if(zip_lookahead <= 0) {\r\n\tzip_eofile = true;\r\n\tzip_lookahead = 0;\r\n\treturn;\r\n    }\r\n    zip_eofile = false;\r\n    /* Make sure that we always have enough lookahead. This is important\r\n     * if input comes from a device such as a tty.\r\n     */\r\n    while(zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)\r\n\tzip_fill_window();\r\n\r\n    /* If lookahead < MIN_MATCH, ins_h is garbage, but this is\r\n     * not important since only literal bytes will be emitted.\r\n     */\r\n    zip_ins_h = 0;\r\n    for(j = 0; j < zip_MIN_MATCH - 1; j++) {\r\n//      UPDATE_HASH(ins_h, window[j]);\r\n\tzip_ins_h = ((zip_ins_h << zip_H_SHIFT) ^ (zip_window[j] & 0xff)) & zip_HASH_MASK;\r\n    }\r\n}\r\n\r\n/* ==========================================================================\r\n * Set match_start to the longest match starting at the given string and\r\n * return its length. Matches shorter or equal to prev_length are discarded,\r\n * in which case the result is equal to prev_length and match_start is\r\n * garbage.\r\n * IN assertions: cur_match is the head of the hash chain for the current\r\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\r\n */\r\nvar zip_longest_match = function(cur_match) {\r\n    var chain_length = zip_max_chain_length; // max hash chain length\r\n    var scanp = zip_strstart; // current string\r\n    var matchp;\t\t// matched string\r\n    var len;\t\t// length of current match\r\n    var best_len = zip_prev_length;\t// best match length so far\r\n\r\n    /* Stop when cur_match becomes <= limit. To simplify the code,\r\n     * we prevent matches with the string of window index 0.\r\n     */\r\n    var limit = (zip_strstart > zip_MAX_DIST ? zip_strstart - zip_MAX_DIST : zip_NIL);\r\n\r\n    var strendp = zip_strstart + zip_MAX_MATCH;\r\n    var scan_end1 = zip_window[scanp + best_len - 1];\r\n    var scan_end  = zip_window[scanp + best_len];\r\n\r\n    /* Do not waste too much time if we already have a good match: */\r\n    if(zip_prev_length >= zip_good_match)\r\n\tchain_length >>= 2;\r\n\r\n//  Assert(encoder->strstart <= window_size-MIN_LOOKAHEAD, \"insufficient lookahead\");\r\n\r\n    do {\r\n//    Assert(cur_match < encoder->strstart, \"no future\");\r\n\tmatchp = cur_match;\r\n\r\n\t/* Skip to next match if the match length cannot increase\r\n\t    * or if the match length is less than 2:\r\n\t*/\r\n\tif(zip_window[matchp + best_len]\t!= scan_end  ||\r\n\t   zip_window[matchp + best_len - 1]\t!= scan_end1 ||\r\n\t   zip_window[matchp]\t\t\t!= zip_window[scanp] ||\r\n\t   zip_window[++matchp]\t\t\t!= zip_window[scanp + 1]) {\r\n\t    continue;\r\n\t}\r\n\r\n\t/* The check at best_len-1 can be removed because it will be made\r\n         * again later. (This heuristic is not always a win.)\r\n         * It is not necessary to compare scan[2] and match[2] since they\r\n         * are always equal when the other bytes match, given that\r\n         * the hash keys are equal and that HASH_BITS >= 8.\r\n         */\r\n\tscanp += 2;\r\n\tmatchp++;\r\n\r\n\t/* We check for insufficient lookahead only every 8th comparison;\r\n         * the 256th check will be made at strstart+258.\r\n         */\r\n\tdo {\r\n\t} while(zip_window[++scanp] == zip_window[++matchp] &&\r\n\t\tzip_window[++scanp] == zip_window[++matchp] &&\r\n\t\tzip_window[++scanp] == zip_window[++matchp] &&\r\n\t\tzip_window[++scanp] == zip_window[++matchp] &&\r\n\t\tzip_window[++scanp] == zip_window[++matchp] &&\r\n\t\tzip_window[++scanp] == zip_window[++matchp] &&\r\n\t\tzip_window[++scanp] == zip_window[++matchp] &&\r\n\t\tzip_window[++scanp] == zip_window[++matchp] &&\r\n\t\tscanp < strendp);\r\n\r\n      len = zip_MAX_MATCH - (strendp - scanp);\r\n      scanp = strendp - zip_MAX_MATCH;\r\n\r\n      if(len > best_len) {\r\n\t  zip_match_start = cur_match;\r\n\t  best_len = len;\r\n\t  if(zip_FULL_SEARCH) {\r\n\t      if(len >= zip_MAX_MATCH) break;\r\n\t  } else {\r\n\t      if(len >= zip_nice_match) break;\r\n\t  }\r\n\r\n\t  scan_end1  = zip_window[scanp + best_len-1];\r\n\t  scan_end   = zip_window[scanp + best_len];\r\n      }\r\n    } while((cur_match = zip_prev[cur_match & zip_WMASK]) > limit\r\n\t    && --chain_length != 0);\r\n\r\n    return best_len;\r\n}\r\n\r\n/* ==========================================================================\r\n * Fill the window when the lookahead becomes insufficient.\r\n * Updates strstart and lookahead, and sets eofile if end of input file.\r\n * IN assertion: lookahead < MIN_LOOKAHEAD && strstart + lookahead > 0\r\n * OUT assertions: at least one byte has been read, or eofile is set;\r\n *    file reads are performed for at least two bytes (required for the\r\n *    translate_eol option).\r\n */\r\nvar zip_fill_window = function() {\r\n    var n, m;\r\n\r\n    // Amount of free space at the end of the window.\r\n    var more = zip_window_size - zip_lookahead - zip_strstart;\r\n\r\n    /* If the window is almost full and there is insufficient lookahead,\r\n     * move the upper half to the lower one to make room in the upper half.\r\n     */\r\n    if(more == -1) {\r\n\t/* Very unlikely, but possible on 16 bit machine if strstart == 0\r\n         * and lookahead == 1 (input done one byte at time)\r\n         */\r\n\tmore--;\r\n    } else if(zip_strstart >= zip_WSIZE + zip_MAX_DIST) {\r\n\t/* By the IN assertion, the window is not empty so we can't confuse\r\n         * more == 0 with more == 64K on a 16 bit machine.\r\n         */\r\n//\tAssert(window_size == (ulg)2*WSIZE, \"no sliding with BIG_MEM\");\r\n\r\n//\tSystem.arraycopy(window, WSIZE, window, 0, WSIZE);\r\n\tfor(n = 0; n < zip_WSIZE; n++)\r\n\t    zip_window[n] = zip_window[n + zip_WSIZE];\r\n      \r\n\tzip_match_start -= zip_WSIZE;\r\n\tzip_strstart    -= zip_WSIZE; /* we now have strstart >= MAX_DIST: */\r\n\tzip_block_start -= zip_WSIZE;\r\n\r\n\tfor(n = 0; n < zip_HASH_SIZE; n++) {\r\n\t    m = zip_head1(n);\r\n\t    zip_head2(n, m >= zip_WSIZE ? m - zip_WSIZE : zip_NIL);\r\n\t}\r\n\tfor(n = 0; n < zip_WSIZE; n++) {\r\n\t    /* If n is not on any hash chain, prev[n] is garbage but\r\n\t     * its value will never be used.\r\n\t     */\r\n\t    m = zip_prev[n];\r\n\t    zip_prev[n] = (m >= zip_WSIZE ? m - zip_WSIZE : zip_NIL);\r\n\t}\r\n\tmore += zip_WSIZE;\r\n    }\r\n    // At this point, more >= 2\r\n    if(!zip_eofile) {\r\n\tn = zip_read_buff(zip_window, zip_strstart + zip_lookahead, more);\r\n\tif(n <= 0)\r\n\t    zip_eofile = true;\r\n\telse\r\n\t    zip_lookahead += n;\r\n    }\r\n}\r\n\r\n/* ==========================================================================\r\n * Processes a new input file and return its compressed length. This\r\n * function does not perform lazy evaluationof matches and inserts\r\n * new strings in the dictionary only for unmatched strings or for short\r\n * matches. It is used only for the fast compression options.\r\n */\r\nvar zip_deflate_fast = function() {\r\n    while(zip_lookahead != 0 && zip_qhead == null) {\r\n\tvar flush; // set if current block must be flushed\r\n\r\n\t/* Insert the string window[strstart .. strstart+2] in the\r\n\t * dictionary, and set hash_head to the head of the hash chain:\r\n\t */\r\n\tzip_INSERT_STRING();\r\n\r\n\t/* Find the longest match, discarding those <= prev_length.\r\n\t * At this point we have always match_length < MIN_MATCH\r\n\t */\r\n\tif(zip_hash_head != zip_NIL &&\r\n\t   zip_strstart - zip_hash_head <= zip_MAX_DIST) {\r\n\t    /* To simplify the code, we prevent matches with the string\r\n\t     * of window index 0 (in particular we have to avoid a match\r\n\t     * of the string with itself at the start of the input file).\r\n\t     */\r\n\t    zip_match_length = zip_longest_match(zip_hash_head);\r\n\t    /* longest_match() sets match_start */\r\n\t    if(zip_match_length > zip_lookahead)\r\n\t\tzip_match_length = zip_lookahead;\r\n\t}\r\n\tif(zip_match_length >= zip_MIN_MATCH) {\r\n//\t    check_match(strstart, match_start, match_length);\r\n\r\n\t    flush = zip_ct_tally(zip_strstart - zip_match_start,\r\n\t\t\t\t zip_match_length - zip_MIN_MATCH);\r\n\t    zip_lookahead -= zip_match_length;\r\n\r\n\t    /* Insert new strings in the hash table only if the match length\r\n\t     * is not too large. This saves time but degrades compression.\r\n\t     */\r\n\t    if(zip_match_length <= zip_max_lazy_match) {\r\n\t\tzip_match_length--; // string at strstart already in hash table\r\n\t\tdo {\r\n\t\t    zip_strstart++;\r\n\t\t    zip_INSERT_STRING();\r\n\t\t    /* strstart never exceeds WSIZE-MAX_MATCH, so there are\r\n\t\t     * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH\r\n\t\t     * these bytes are garbage, but it does not matter since\r\n\t\t     * the next lookahead bytes will be emitted as literals.\r\n\t\t     */\r\n\t\t} while(--zip_match_length != 0);\r\n\t\tzip_strstart++;\r\n\t    } else {\r\n\t\tzip_strstart += zip_match_length;\r\n\t\tzip_match_length = 0;\r\n\t\tzip_ins_h = zip_window[zip_strstart] & 0xff;\r\n//\t\tUPDATE_HASH(ins_h, window[strstart + 1]);\r\n\t\tzip_ins_h = ((zip_ins_h<<zip_H_SHIFT) ^ (zip_window[zip_strstart + 1] & 0xff)) & zip_HASH_MASK;\r\n\r\n//#if MIN_MATCH != 3\r\n//\t\tCall UPDATE_HASH() MIN_MATCH-3 more times\r\n//#endif\r\n\r\n\t    }\r\n\t} else {\r\n\t    /* No match, output a literal byte */\r\n\t    flush = zip_ct_tally(0, zip_window[zip_strstart] & 0xff);\r\n\t    zip_lookahead--;\r\n\t    zip_strstart++;\r\n\t}\r\n\tif(flush) {\r\n\t    zip_flush_block(0);\r\n\t    zip_block_start = zip_strstart;\r\n\t}\r\n\r\n\t/* Make sure that we always have enough lookahead, except\r\n\t * at the end of the input file. We need MAX_MATCH bytes\r\n\t * for the next match, plus MIN_MATCH bytes to insert the\r\n\t * string following the next match.\r\n\t */\r\n\twhile(zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)\r\n\t    zip_fill_window();\r\n    }\r\n}\r\n\r\nvar zip_deflate_better = function() {\r\n    /* Process the input block. */\r\n    while(zip_lookahead != 0 && zip_qhead == null) {\r\n\t/* Insert the string window[strstart .. strstart+2] in the\r\n\t * dictionary, and set hash_head to the head of the hash chain:\r\n\t */\r\n\tzip_INSERT_STRING();\r\n\r\n\t/* Find the longest match, discarding those <= prev_length.\r\n\t */\r\n\tzip_prev_length = zip_match_length;\r\n\tzip_prev_match = zip_match_start;\r\n\tzip_match_length = zip_MIN_MATCH - 1;\r\n\r\n\tif(zip_hash_head != zip_NIL &&\r\n\t   zip_prev_length < zip_max_lazy_match &&\r\n\t   zip_strstart - zip_hash_head <= zip_MAX_DIST) {\r\n\t    /* To simplify the code, we prevent matches with the string\r\n\t     * of window index 0 (in particular we have to avoid a match\r\n\t     * of the string with itself at the start of the input file).\r\n\t     */\r\n\t    zip_match_length = zip_longest_match(zip_hash_head);\r\n\t    /* longest_match() sets match_start */\r\n\t    if(zip_match_length > zip_lookahead)\r\n\t\tzip_match_length = zip_lookahead;\r\n\r\n\t    /* Ignore a length 3 match if it is too distant: */\r\n\t    if(zip_match_length == zip_MIN_MATCH &&\r\n\t       zip_strstart - zip_match_start > zip_TOO_FAR) {\r\n\t\t/* If prev_match is also MIN_MATCH, match_start is garbage\r\n\t\t * but we will ignore the current match anyway.\r\n\t\t */\r\n\t\tzip_match_length--;\r\n\t    }\r\n\t}\r\n\t/* If there was a match at the previous step and the current\r\n\t * match is not better, output the previous match:\r\n\t */\r\n\tif(zip_prev_length >= zip_MIN_MATCH &&\r\n\t   zip_match_length <= zip_prev_length) {\r\n\t    var flush; // set if current block must be flushed\r\n\r\n//\t    check_match(strstart - 1, prev_match, prev_length);\r\n\t    flush = zip_ct_tally(zip_strstart - 1 - zip_prev_match,\r\n\t\t\t\t zip_prev_length - zip_MIN_MATCH);\r\n\r\n\t    /* Insert in hash table all strings up to the end of the match.\r\n\t     * strstart-1 and strstart are already inserted.\r\n\t     */\r\n\t    zip_lookahead -= zip_prev_length - 1;\r\n\t    zip_prev_length -= 2;\r\n\t    do {\r\n\t\tzip_strstart++;\r\n\t\tzip_INSERT_STRING();\r\n\t\t/* strstart never exceeds WSIZE-MAX_MATCH, so there are\r\n\t\t * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH\r\n\t\t * these bytes are garbage, but it does not matter since the\r\n\t\t * next lookahead bytes will always be emitted as literals.\r\n\t\t */\r\n\t    } while(--zip_prev_length != 0);\r\n\t    zip_match_available = 0;\r\n\t    zip_match_length = zip_MIN_MATCH - 1;\r\n\t    zip_strstart++;\r\n\t    if(flush) {\r\n\t\tzip_flush_block(0);\r\n\t\tzip_block_start = zip_strstart;\r\n\t    }\r\n\t} else if(zip_match_available != 0) {\r\n\t    /* If there was no match at the previous position, output a\r\n\t     * single literal. If there was a match but the current match\r\n\t     * is longer, truncate the previous match to a single literal.\r\n\t     */\r\n\t    if(zip_ct_tally(0, zip_window[zip_strstart - 1] & 0xff)) {\r\n\t\tzip_flush_block(0);\r\n\t\tzip_block_start = zip_strstart;\r\n\t    }\r\n\t    zip_strstart++;\r\n\t    zip_lookahead--;\r\n\t} else {\r\n\t    /* There is no previous match to compare with, wait for\r\n\t     * the next step to decide.\r\n\t     */\r\n\t    zip_match_available = 1;\r\n\t    zip_strstart++;\r\n\t    zip_lookahead--;\r\n\t}\r\n\r\n\t/* Make sure that we always have enough lookahead, except\r\n\t * at the end of the input file. We need MAX_MATCH bytes\r\n\t * for the next match, plus MIN_MATCH bytes to insert the\r\n\t * string following the next match.\r\n\t */\r\n\twhile(zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)\r\n\t    zip_fill_window();\r\n    }\r\n}\r\n\r\nvar zip_init_deflate = function() {\r\n    if(zip_eofile)\r\n\treturn;\r\n    zip_bi_buf = 0;\r\n    zip_bi_valid = 0;\r\n    zip_ct_init();\r\n    zip_lm_init();\r\n\r\n    zip_qhead = null;\r\n    zip_outcnt = 0;\r\n    zip_outoff = 0;\r\n\r\n    if(zip_compr_level <= 3)\r\n    {\r\n\tzip_prev_length = zip_MIN_MATCH - 1;\r\n\tzip_match_length = 0;\r\n    }\r\n    else\r\n    {\r\n\tzip_match_length = zip_MIN_MATCH - 1;\r\n\tzip_match_available = 0;\r\n    }\r\n\r\n    zip_complete = false;\r\n}\r\n\r\n/* ==========================================================================\r\n * Same as above, but achieves better compression. We use a lazy\r\n * evaluation for matches: a match is finally adopted only if there is\r\n * no better match at the next window position.\r\n */\r\nvar zip_deflate_internal = function(buff, off, buff_size) {\r\n    var n;\r\n\r\n    if(!zip_initflag)\r\n    {\r\n\tzip_init_deflate();\r\n\tzip_initflag = true;\r\n\tif(zip_lookahead == 0) { // empty\r\n\t    zip_complete = true;\r\n\t    return 0;\r\n\t}\r\n    }\r\n\r\n    if((n = zip_qcopy(buff, off, buff_size)) == buff_size)\r\n\treturn buff_size;\r\n\r\n    if(zip_complete)\r\n\treturn n;\r\n\r\n    if(zip_compr_level <= 3) // optimized for speed\r\n\tzip_deflate_fast();\r\n    else\r\n\tzip_deflate_better();\r\n    if(zip_lookahead == 0) {\r\n\tif(zip_match_available != 0)\r\n\t    zip_ct_tally(0, zip_window[zip_strstart - 1] & 0xff);\r\n\tzip_flush_block(1);\r\n\tzip_complete = true;\r\n    }\r\n    return n + zip_qcopy(buff, n + off, buff_size - n);\r\n}\r\n\r\nvar zip_qcopy = function(buff, off, buff_size) {\r\n    var n, i, j;\r\n\r\n    n = 0;\r\n    while(zip_qhead != null && n < buff_size)\r\n    {\r\n\ti = buff_size - n;\r\n\tif(i > zip_qhead.len)\r\n\t    i = zip_qhead.len;\r\n//      System.arraycopy(qhead.ptr, qhead.off, buff, off + n, i);\r\n\tfor(j = 0; j < i; j++)\r\n\t    buff[off + n + j] = zip_qhead.ptr[zip_qhead.off + j];\r\n\t\r\n\tzip_qhead.off += i;\r\n\tzip_qhead.len -= i;\r\n\tn += i;\r\n\tif(zip_qhead.len == 0) {\r\n\t    var p;\r\n\t    p = zip_qhead;\r\n\t    zip_qhead = zip_qhead.next;\r\n\t    zip_reuse_queue(p);\r\n\t}\r\n    }\r\n\r\n    if(n == buff_size)\r\n\treturn n;\r\n\r\n    if(zip_outoff < zip_outcnt) {\r\n\ti = buff_size - n;\r\n\tif(i > zip_outcnt - zip_outoff)\r\n\t    i = zip_outcnt - zip_outoff;\r\n\t// System.arraycopy(outbuf, outoff, buff, off + n, i);\r\n\tfor(j = 0; j < i; j++)\r\n\t    buff[off + n + j] = zip_outbuf[zip_outoff + j];\r\n\tzip_outoff += i;\r\n\tn += i;\r\n\tif(zip_outcnt == zip_outoff)\r\n\t    zip_outcnt = zip_outoff = 0;\r\n    }\r\n    return n;\r\n}\r\n\r\n/* ==========================================================================\r\n * Allocate the match buffer, initialize the various tables and save the\r\n * location of the internal file attribute (ascii/binary) and method\r\n * (DEFLATE/STORE).\r\n */\r\nvar zip_ct_init = function() {\r\n    var n;\t// iterates over tree elements\r\n    var bits;\t// bit counter\r\n    var length;\t// length value\r\n    var code;\t// code value\r\n    var dist;\t// distance index\r\n\r\n    if(zip_static_dtree[0].dl != 0) return; // ct_init already called\r\n\r\n    zip_l_desc.dyn_tree\t\t= zip_dyn_ltree;\r\n    zip_l_desc.static_tree\t= zip_static_ltree;\r\n    zip_l_desc.extra_bits\t= zip_extra_lbits;\r\n    zip_l_desc.extra_base\t= zip_LITERALS + 1;\r\n    zip_l_desc.elems\t\t= zip_L_CODES;\r\n    zip_l_desc.max_length\t= zip_MAX_BITS;\r\n    zip_l_desc.max_code\t\t= 0;\r\n\r\n    zip_d_desc.dyn_tree\t\t= zip_dyn_dtree;\r\n    zip_d_desc.static_tree\t= zip_static_dtree;\r\n    zip_d_desc.extra_bits\t= zip_extra_dbits;\r\n    zip_d_desc.extra_base\t= 0;\r\n    zip_d_desc.elems\t\t= zip_D_CODES;\r\n    zip_d_desc.max_length\t= zip_MAX_BITS;\r\n    zip_d_desc.max_code\t\t= 0;\r\n\r\n    zip_bl_desc.dyn_tree\t= zip_bl_tree;\r\n    zip_bl_desc.static_tree\t= null;\r\n    zip_bl_desc.extra_bits\t= zip_extra_blbits;\r\n    zip_bl_desc.extra_base\t= 0;\r\n    zip_bl_desc.elems\t\t= zip_BL_CODES;\r\n    zip_bl_desc.max_length\t= zip_MAX_BL_BITS;\r\n    zip_bl_desc.max_code\t= 0;\r\n\r\n    // Initialize the mapping length (0..255) -> length code (0..28)\r\n    length = 0;\r\n    for(code = 0; code < zip_LENGTH_CODES-1; code++) {\r\n\tzip_base_length[code] = length;\r\n\tfor(n = 0; n < (1<<zip_extra_lbits[code]); n++)\r\n\t    zip_length_code[length++] = code;\r\n    }\r\n    // Assert (length == 256, \"ct_init: length != 256\");\r\n\r\n    /* Note that the length 255 (match length 258) can be represented\r\n     * in two different ways: code 284 + 5 bits or code 285, so we\r\n     * overwrite length_code[255] to use the best encoding:\r\n     */\r\n    zip_length_code[length-1] = code;\r\n\r\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\r\n    dist = 0;\r\n    for(code = 0 ; code < 16; code++) {\r\n\tzip_base_dist[code] = dist;\r\n\tfor(n = 0; n < (1<<zip_extra_dbits[code]); n++) {\r\n\t    zip_dist_code[dist++] = code;\r\n\t}\r\n    }\r\n    // Assert (dist == 256, \"ct_init: dist != 256\");\r\n    dist >>= 7; // from now on, all distances are divided by 128\r\n    for( ; code < zip_D_CODES; code++) {\r\n\tzip_base_dist[code] = dist << 7;\r\n\tfor(n = 0; n < (1<<(zip_extra_dbits[code]-7)); n++)\r\n\t    zip_dist_code[256 + dist++] = code;\r\n    }\r\n    // Assert (dist == 256, \"ct_init: 256+dist != 512\");\r\n\r\n    // Construct the codes of the static literal tree\r\n    for(bits = 0; bits <= zip_MAX_BITS; bits++)\r\n\tzip_bl_count[bits] = 0;\r\n    n = 0;\r\n    while(n <= 143) { zip_static_ltree[n++].dl = 8; zip_bl_count[8]++; }\r\n    while(n <= 255) { zip_static_ltree[n++].dl = 9; zip_bl_count[9]++; }\r\n    while(n <= 279) { zip_static_ltree[n++].dl = 7; zip_bl_count[7]++; }\r\n    while(n <= 287) { zip_static_ltree[n++].dl = 8; zip_bl_count[8]++; }\r\n    /* Codes 286 and 287 do not exist, but we must include them in the\r\n     * tree construction to get a canonical Huffman tree (longest code\r\n     * all ones)\r\n     */\r\n    zip_gen_codes(zip_static_ltree, zip_L_CODES + 1);\r\n\r\n    /* The static distance tree is trivial: */\r\n    for(n = 0; n < zip_D_CODES; n++) {\r\n\tzip_static_dtree[n].dl = 5;\r\n\tzip_static_dtree[n].fc = zip_bi_reverse(n, 5);\r\n    }\r\n\r\n    // Initialize the first block of the first file:\r\n    zip_init_block();\r\n}\r\n\r\n/* ==========================================================================\r\n * Initialize a new block.\r\n */\r\nvar zip_init_block = function() {\r\n    var n; // iterates over tree elements\r\n\r\n    // Initialize the trees.\r\n    for(n = 0; n < zip_L_CODES;  n++) zip_dyn_ltree[n].fc = 0;\r\n    for(n = 0; n < zip_D_CODES;  n++) zip_dyn_dtree[n].fc = 0;\r\n    for(n = 0; n < zip_BL_CODES; n++) zip_bl_tree[n].fc = 0;\r\n\r\n    zip_dyn_ltree[zip_END_BLOCK].fc = 1;\r\n    zip_opt_len = zip_static_len = 0;\r\n    zip_last_lit = zip_last_dist = zip_last_flags = 0;\r\n    zip_flags = 0;\r\n    zip_flag_bit = 1;\r\n}\r\n\r\n/* ==========================================================================\r\n * Restore the heap property by moving down the tree starting at node k,\r\n * exchanging a node with the smallest of its two sons if necessary, stopping\r\n * when the heap property is re-established (each father smaller than its\r\n * two sons).\r\n */\r\nvar zip_pqdownheap = function(\r\n    tree,\t// the tree to restore\r\n    k) {\t// node to move down\r\n    var v = zip_heap[k];\r\n    var j = k << 1;\t// left son of k\r\n\r\n    while(j <= zip_heap_len) {\r\n\t// Set j to the smallest of the two sons:\r\n\tif(j < zip_heap_len &&\r\n\t   zip_SMALLER(tree, zip_heap[j + 1], zip_heap[j]))\r\n\t    j++;\r\n\r\n\t// Exit if v is smaller than both sons\r\n\tif(zip_SMALLER(tree, v, zip_heap[j]))\r\n\t    break;\r\n\r\n\t// Exchange v with the smallest son\r\n\tzip_heap[k] = zip_heap[j];\r\n\tk = j;\r\n\r\n\t// And continue down the tree, setting j to the left son of k\r\n\tj <<= 1;\r\n    }\r\n    zip_heap[k] = v;\r\n}\r\n\r\n/* ==========================================================================\r\n * Compute the optimal bit lengths for a tree and update the total bit length\r\n * for the current block.\r\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\r\n *    above are the tree nodes sorted by increasing frequency.\r\n * OUT assertions: the field len is set to the optimal bit length, the\r\n *     array bl_count contains the frequencies for each bit length.\r\n *     The length opt_len is updated; static_len is also updated if stree is\r\n *     not null.\r\n */\r\nvar zip_gen_bitlen = function(desc) { // the tree descriptor\r\n    var tree\t\t= desc.dyn_tree;\r\n    var extra\t\t= desc.extra_bits;\r\n    var base\t\t= desc.extra_base;\r\n    var max_code\t= desc.max_code;\r\n    var max_length\t= desc.max_length;\r\n    var stree\t\t= desc.static_tree;\r\n    var h;\t\t// heap index\r\n    var n, m;\t\t// iterate over the tree elements\r\n    var bits;\t\t// bit length\r\n    var xbits;\t\t// extra bits\r\n    var f;\t\t// frequency\r\n    var overflow = 0;\t// number of elements with bit length too large\r\n\r\n    for(bits = 0; bits <= zip_MAX_BITS; bits++)\r\n\tzip_bl_count[bits] = 0;\r\n\r\n    /* In a first pass, compute the optimal bit lengths (which may\r\n     * overflow in the case of the bit length tree).\r\n     */\r\n    tree[zip_heap[zip_heap_max]].dl = 0; // root of the heap\r\n\r\n    for(h = zip_heap_max + 1; h < zip_HEAP_SIZE; h++) {\r\n\tn = zip_heap[h];\r\n\tbits = tree[tree[n].dl].dl + 1;\r\n\tif(bits > max_length) {\r\n\t    bits = max_length;\r\n\t    overflow++;\r\n\t}\r\n\ttree[n].dl = bits;\r\n\t// We overwrite tree[n].dl which is no longer needed\r\n\r\n\tif(n > max_code)\r\n\t    continue; // not a leaf node\r\n\r\n\tzip_bl_count[bits]++;\r\n\txbits = 0;\r\n\tif(n >= base)\r\n\t    xbits = extra[n - base];\r\n\tf = tree[n].fc;\r\n\tzip_opt_len += f * (bits + xbits);\r\n\tif(stree != null)\r\n\t    zip_static_len += f * (stree[n].dl + xbits);\r\n    }\r\n    if(overflow == 0)\r\n\treturn;\r\n\r\n    // This happens for example on obj2 and pic of the Calgary corpus\r\n\r\n    // Find the first bit length which could increase:\r\n    do {\r\n\tbits = max_length - 1;\r\n\twhile(zip_bl_count[bits] == 0)\r\n\t    bits--;\r\n\tzip_bl_count[bits]--;\t\t// move one leaf down the tree\r\n\tzip_bl_count[bits + 1] += 2;\t// move one overflow item as its brother\r\n\tzip_bl_count[max_length]--;\r\n\t/* The brother of the overflow item also moves one step up,\r\n\t * but this does not affect bl_count[max_length]\r\n\t */\r\n\toverflow -= 2;\r\n    } while(overflow > 0);\r\n\r\n    /* Now recompute all bit lengths, scanning in increasing frequency.\r\n     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\r\n     * lengths instead of fixing only the wrong ones. This idea is taken\r\n     * from 'ar' written by Haruhiko Okumura.)\r\n     */\r\n    for(bits = max_length; bits != 0; bits--) {\r\n\tn = zip_bl_count[bits];\r\n\twhile(n != 0) {\r\n\t    m = zip_heap[--h];\r\n\t    if(m > max_code)\r\n\t\tcontinue;\r\n\t    if(tree[m].dl != bits) {\r\n\t\tzip_opt_len += (bits - tree[m].dl) * tree[m].fc;\r\n\t\ttree[m].fc = bits;\r\n\t    }\r\n\t    n--;\r\n\t}\r\n    }\r\n}\r\n\r\n  /* ==========================================================================\r\n   * Generate the codes for a given tree and bit counts (which need not be\r\n   * optimal).\r\n   * IN assertion: the array bl_count contains the bit length statistics for\r\n   * the given tree and the field len is set for all tree elements.\r\n   * OUT assertion: the field code is set for all tree elements of non\r\n   *     zero code length.\r\n   */\r\nvar zip_gen_codes = function(tree,\t// the tree to decorate\r\n\t\t   max_code) {\t// largest code with non zero frequency\r\n    var next_code = new Array(zip_MAX_BITS+1); // next code value for each bit length\r\n    var code = 0;\t\t// running code value\r\n    var bits;\t\t\t// bit index\r\n    var n;\t\t\t// code index\r\n\r\n    /* The distribution counts are first used to generate the code values\r\n     * without bit reversal.\r\n     */\r\n    for(bits = 1; bits <= zip_MAX_BITS; bits++) {\r\n\tcode = ((code + zip_bl_count[bits-1]) << 1);\r\n\tnext_code[bits] = code;\r\n    }\r\n\r\n    /* Check that the bit counts in bl_count are consistent. The last code\r\n     * must be all ones.\r\n     */\r\n//    Assert (code + encoder->bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\r\n//\t    \"inconsistent bit counts\");\r\n//    Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\r\n\r\n    for(n = 0; n <= max_code; n++) {\r\n\tvar len = tree[n].dl;\r\n\tif(len == 0)\r\n\t    continue;\r\n\t// Now reverse the bits\r\n\ttree[n].fc = zip_bi_reverse(next_code[len]++, len);\r\n\r\n//      Tracec(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\r\n//\t  n, (isgraph(n) ? n : ' '), len, tree[n].fc, next_code[len]-1));\r\n    }\r\n}\r\n\r\n/* ==========================================================================\r\n * Construct one Huffman tree and assigns the code bit strings and lengths.\r\n * Update the total bit length for the current block.\r\n * IN assertion: the field freq is set for all tree elements.\r\n * OUT assertions: the fields len and code are set to the optimal bit length\r\n *     and corresponding code. The length opt_len is updated; static_len is\r\n *     also updated if stree is not null. The field max_code is set.\r\n */\r\nvar zip_build_tree = function(desc) { // the tree descriptor\r\n    var tree\t= desc.dyn_tree;\r\n    var stree\t= desc.static_tree;\r\n    var elems\t= desc.elems;\r\n    var n, m;\t\t// iterate over heap elements\r\n    var max_code = -1;\t// largest code with non zero frequency\r\n    var node = elems;\t// next internal node of the tree\r\n\r\n    /* Construct the initial heap, with least frequent element in\r\n     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\r\n     * heap[0] is not used.\r\n     */\r\n    zip_heap_len = 0;\r\n    zip_heap_max = zip_HEAP_SIZE;\r\n\r\n    for(n = 0; n < elems; n++) {\r\n\tif(tree[n].fc != 0) {\r\n\t    zip_heap[++zip_heap_len] = max_code = n;\r\n\t    zip_depth[n] = 0;\r\n\t} else\r\n\t    tree[n].dl = 0;\r\n    }\r\n\r\n    /* The pkzip format requires that at least one distance code exists,\r\n     * and that at least one bit should be sent even if there is only one\r\n     * possible code. So to avoid special checks later on we force at least\r\n     * two codes of non zero frequency.\r\n     */\r\n    while(zip_heap_len < 2) {\r\n\tvar xnew = zip_heap[++zip_heap_len] = (max_code < 2 ? ++max_code : 0);\r\n\ttree[xnew].fc = 1;\r\n\tzip_depth[xnew] = 0;\r\n\tzip_opt_len--;\r\n\tif(stree != null)\r\n\t    zip_static_len -= stree[xnew].dl;\r\n\t// new is 0 or 1 so it does not have extra bits\r\n    }\r\n    desc.max_code = max_code;\r\n\r\n    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\r\n     * establish sub-heaps of increasing lengths:\r\n     */\r\n    for(n = zip_heap_len >> 1; n >= 1; n--)\r\n\tzip_pqdownheap(tree, n);\r\n\r\n    /* Construct the Huffman tree by repeatedly combining the least two\r\n     * frequent nodes.\r\n     */\r\n    do {\r\n\tn = zip_heap[zip_SMALLEST];\r\n\tzip_heap[zip_SMALLEST] = zip_heap[zip_heap_len--];\r\n\tzip_pqdownheap(tree, zip_SMALLEST);\r\n\r\n\tm = zip_heap[zip_SMALLEST];  // m = node of next least frequency\r\n\r\n\t// keep the nodes sorted by frequency\r\n\tzip_heap[--zip_heap_max] = n;\r\n\tzip_heap[--zip_heap_max] = m;\r\n\r\n\t// Create a new node father of n and m\r\n\ttree[node].fc = tree[n].fc + tree[m].fc;\r\n//\tdepth[node] = (char)(MAX(depth[n], depth[m]) + 1);\r\n\tif(zip_depth[n] > zip_depth[m] + 1)\r\n\t    zip_depth[node] = zip_depth[n];\r\n\telse\r\n\t    zip_depth[node] = zip_depth[m] + 1;\r\n\ttree[n].dl = tree[m].dl = node;\r\n\r\n\t// and insert the new node in the heap\r\n\tzip_heap[zip_SMALLEST] = node++;\r\n\tzip_pqdownheap(tree, zip_SMALLEST);\r\n\r\n    } while(zip_heap_len >= 2);\r\n\r\n    zip_heap[--zip_heap_max] = zip_heap[zip_SMALLEST];\r\n\r\n    /* At this point, the fields freq and dad are set. We can now\r\n     * generate the bit lengths.\r\n     */\r\n    zip_gen_bitlen(desc);\r\n\r\n    // The field len is now set, we can generate the bit codes\r\n    zip_gen_codes(tree, max_code);\r\n}\r\n\r\n/* ==========================================================================\r\n * Scan a literal or distance tree to determine the frequencies of the codes\r\n * in the bit length tree. Updates opt_len to take into account the repeat\r\n * counts. (The contribution of the bit length codes will be added later\r\n * during the construction of bl_tree.)\r\n */\r\nvar zip_scan_tree = function(tree,// the tree to be scanned\r\n\t\t       max_code) {  // and its largest code of non zero frequency\r\n    var n;\t\t\t// iterates over all tree elements\r\n    var prevlen = -1;\t\t// last emitted length\r\n    var curlen;\t\t\t// length of current code\r\n    var nextlen = tree[0].dl;\t// length of next code\r\n    var count = 0;\t\t// repeat count of the current code\r\n    var max_count = 7;\t\t// max repeat count\r\n    var min_count = 4;\t\t// min repeat count\r\n\r\n    if(nextlen == 0) {\r\n\tmax_count = 138;\r\n\tmin_count = 3;\r\n    }\r\n    tree[max_code + 1].dl = 0xffff; // guard\r\n\r\n    for(n = 0; n <= max_code; n++) {\r\n\tcurlen = nextlen;\r\n\tnextlen = tree[n + 1].dl;\r\n\tif(++count < max_count && curlen == nextlen)\r\n\t    continue;\r\n\telse if(count < min_count)\r\n\t    zip_bl_tree[curlen].fc += count;\r\n\telse if(curlen != 0) {\r\n\t    if(curlen != prevlen)\r\n\t\tzip_bl_tree[curlen].fc++;\r\n\t    zip_bl_tree[zip_REP_3_6].fc++;\r\n\t} else if(count <= 10)\r\n\t    zip_bl_tree[zip_REPZ_3_10].fc++;\r\n\telse\r\n\t    zip_bl_tree[zip_REPZ_11_138].fc++;\r\n\tcount = 0; prevlen = curlen;\r\n\tif(nextlen == 0) {\r\n\t    max_count = 138;\r\n\t    min_count = 3;\r\n\t} else if(curlen == nextlen) {\r\n\t    max_count = 6;\r\n\t    min_count = 3;\r\n\t} else {\r\n\t    max_count = 7;\r\n\t    min_count = 4;\r\n\t}\r\n    }\r\n}\r\n\r\n  /* ==========================================================================\r\n   * Send a literal or distance tree in compressed form, using the codes in\r\n   * bl_tree.\r\n   */\r\nvar zip_send_tree = function(tree, // the tree to be scanned\r\n\t\t   max_code) { // and its largest code of non zero frequency\r\n    var n;\t\t\t// iterates over all tree elements\r\n    var prevlen = -1;\t\t// last emitted length\r\n    var curlen;\t\t\t// length of current code\r\n    var nextlen = tree[0].dl;\t// length of next code\r\n    var count = 0;\t\t// repeat count of the current code\r\n    var max_count = 7;\t\t// max repeat count\r\n    var min_count = 4;\t\t// min repeat count\r\n\r\n    /* tree[max_code+1].dl = -1; */  /* guard already set */\r\n    if(nextlen == 0) {\r\n      max_count = 138;\r\n      min_count = 3;\r\n    }\r\n\r\n    for(n = 0; n <= max_code; n++) {\r\n\tcurlen = nextlen;\r\n\tnextlen = tree[n+1].dl;\r\n\tif(++count < max_count && curlen == nextlen) {\r\n\t    continue;\r\n\t} else if(count < min_count) {\r\n\t    do { zip_SEND_CODE(curlen, zip_bl_tree); } while(--count != 0);\r\n\t} else if(curlen != 0) {\r\n\t    if(curlen != prevlen) {\r\n\t\tzip_SEND_CODE(curlen, zip_bl_tree);\r\n\t\tcount--;\r\n\t    }\r\n\t    // Assert(count >= 3 && count <= 6, \" 3_6?\");\r\n\t    zip_SEND_CODE(zip_REP_3_6, zip_bl_tree);\r\n\t    zip_send_bits(count - 3, 2);\r\n\t} else if(count <= 10) {\r\n\t    zip_SEND_CODE(zip_REPZ_3_10, zip_bl_tree);\r\n\t    zip_send_bits(count-3, 3);\r\n\t} else {\r\n\t    zip_SEND_CODE(zip_REPZ_11_138, zip_bl_tree);\r\n\t    zip_send_bits(count-11, 7);\r\n\t}\r\n\tcount = 0;\r\n\tprevlen = curlen;\r\n\tif(nextlen == 0) {\r\n\t    max_count = 138;\r\n\t    min_count = 3;\r\n\t} else if(curlen == nextlen) {\r\n\t    max_count = 6;\r\n\t    min_count = 3;\r\n\t} else {\r\n\t    max_count = 7;\r\n\t    min_count = 4;\r\n\t}\r\n    }\r\n}\r\n\r\n/* ==========================================================================\r\n * Construct the Huffman tree for the bit lengths and return the index in\r\n * bl_order of the last bit length code to send.\r\n */\r\nvar zip_build_bl_tree = function() {\r\n    var max_blindex;  // index of last bit length code of non zero freq\r\n\r\n    // Determine the bit length frequencies for literal and distance trees\r\n    zip_scan_tree(zip_dyn_ltree, zip_l_desc.max_code);\r\n    zip_scan_tree(zip_dyn_dtree, zip_d_desc.max_code);\r\n\r\n    // Build the bit length tree:\r\n    zip_build_tree(zip_bl_desc);\r\n    /* opt_len now includes the length of the tree representations, except\r\n     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\r\n     */\r\n\r\n    /* Determine the number of bit length codes to send. The pkzip format\r\n     * requires that at least 4 bit length codes be sent. (appnote.txt says\r\n     * 3 but the actual value used is 4.)\r\n     */\r\n    for(max_blindex = zip_BL_CODES-1; max_blindex >= 3; max_blindex--) {\r\n\tif(zip_bl_tree[zip_bl_order[max_blindex]].dl != 0) break;\r\n    }\r\n    /* Update opt_len to include the bit length tree and counts */\r\n    zip_opt_len += 3*(max_blindex+1) + 5+5+4;\r\n//    Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\r\n//\t    encoder->opt_len, encoder->static_len));\r\n\r\n    return max_blindex;\r\n}\r\n\r\n/* ==========================================================================\r\n * Send the header for a block using dynamic Huffman trees: the counts, the\r\n * lengths of the bit length codes, the literal tree and the distance tree.\r\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\r\n */\r\nvar zip_send_all_trees = function(lcodes, dcodes, blcodes) { // number of codes for each tree\r\n    var rank; // index in bl_order\r\n\r\n//    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\r\n//    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\r\n//\t    \"too many codes\");\r\n//    Tracev((stderr, \"\\nbl counts: \"));\r\n    zip_send_bits(lcodes-257, 5); // not +255 as stated in appnote.txt\r\n    zip_send_bits(dcodes-1,   5);\r\n    zip_send_bits(blcodes-4,  4); // not -3 as stated in appnote.txt\r\n    for(rank = 0; rank < blcodes; rank++) {\r\n//      Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\r\n\tzip_send_bits(zip_bl_tree[zip_bl_order[rank]].dl, 3);\r\n    }\r\n\r\n    // send the literal tree\r\n    zip_send_tree(zip_dyn_ltree,lcodes-1);\r\n\r\n    // send the distance tree\r\n    zip_send_tree(zip_dyn_dtree,dcodes-1);\r\n}\r\n\r\n/* ==========================================================================\r\n * Determine the best encoding for the current block: dynamic trees, static\r\n * trees or store, and output the encoded block to the zip file.\r\n */\r\nvar zip_flush_block = function(eof) { // true if this is the last block for a file\r\n    var opt_lenb, static_lenb; // opt_len and static_len in bytes\r\n    var max_blindex;\t// index of last bit length code of non zero freq\r\n    var stored_len;\t// length of input block\r\n\r\n    stored_len = zip_strstart - zip_block_start;\r\n    zip_flag_buf[zip_last_flags] = zip_flags; // Save the flags for the last 8 items\r\n\r\n    // Construct the literal and distance trees\r\n    zip_build_tree(zip_l_desc);\r\n//    Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\",\r\n//\t    encoder->opt_len, encoder->static_len));\r\n\r\n    zip_build_tree(zip_d_desc);\r\n//    Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\",\r\n//\t    encoder->opt_len, encoder->static_len));\r\n    /* At this point, opt_len and static_len are the total bit lengths of\r\n     * the compressed block data, excluding the tree representations.\r\n     */\r\n\r\n    /* Build the bit length tree for the above two trees, and get the index\r\n     * in bl_order of the last bit length code to send.\r\n     */\r\n    max_blindex = zip_build_bl_tree();\r\n\r\n    // Determine the best encoding. Compute first the block length in bytes\r\n    opt_lenb\t= (zip_opt_len   +3+7)>>3;\r\n    static_lenb = (zip_static_len+3+7)>>3;\r\n\r\n//    Trace((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u \",\r\n//\t   opt_lenb, encoder->opt_len,\r\n//\t   static_lenb, encoder->static_len, stored_len,\r\n//\t   encoder->last_lit, encoder->last_dist));\r\n\r\n    if(static_lenb <= opt_lenb)\r\n\topt_lenb = static_lenb;\r\n    if(stored_len + 4 <= opt_lenb // 4: two words for the lengths\r\n       && zip_block_start >= 0) {\r\n\tvar i;\r\n\r\n\t/* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\r\n\t * Otherwise we can't have processed more than WSIZE input bytes since\r\n\t * the last block flush, because compression would have been\r\n\t * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\r\n\t * transform a block into a stored block.\r\n\t */\r\n\tzip_send_bits((zip_STORED_BLOCK<<1)+eof, 3);  /* send block type */\r\n\tzip_bi_windup();\t\t /* align on byte boundary */\r\n\tzip_put_short(stored_len);\r\n\tzip_put_short(~stored_len);\r\n\r\n      // copy block\r\n/*\r\n      p = &window[block_start];\r\n      for(i = 0; i < stored_len; i++)\r\n\tput_byte(p[i]);\r\n*/\r\n\tfor(i = 0; i < stored_len; i++)\r\n\t    zip_put_byte(zip_window[zip_block_start + i]);\r\n\r\n    } else if(static_lenb == opt_lenb) {\r\n\tzip_send_bits((zip_STATIC_TREES<<1)+eof, 3);\r\n\tzip_compress_block(zip_static_ltree, zip_static_dtree);\r\n    } else {\r\n\tzip_send_bits((zip_DYN_TREES<<1)+eof, 3);\r\n\tzip_send_all_trees(zip_l_desc.max_code+1,\r\n\t\t\t   zip_d_desc.max_code+1,\r\n\t\t\t   max_blindex+1);\r\n\tzip_compress_block(zip_dyn_ltree, zip_dyn_dtree);\r\n    }\r\n\r\n    zip_init_block();\r\n\r\n    if(eof != 0)\r\n\tzip_bi_windup();\r\n}\r\n\r\n/* ==========================================================================\r\n * Save the match info and tally the frequency counts. Return true if\r\n * the current block must be flushed.\r\n */\r\nvar zip_ct_tally = function(\r\n\tdist, // distance of matched string\r\n\tlc) { // match length-MIN_MATCH or unmatched char (if dist==0)\r\n    zip_l_buf[zip_last_lit++] = lc;\r\n    if(dist == 0) {\r\n\t// lc is the unmatched char\r\n\tzip_dyn_ltree[lc].fc++;\r\n    } else {\r\n\t// Here, lc is the match length - MIN_MATCH\r\n\tdist--;\t\t    // dist = match distance - 1\r\n//      Assert((ush)dist < (ush)MAX_DIST &&\r\n//\t     (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\r\n//\t     (ush)D_CODE(dist) < (ush)D_CODES,  \"ct_tally: bad match\");\r\n\r\n\tzip_dyn_ltree[zip_length_code[lc]+zip_LITERALS+1].fc++;\r\n\tzip_dyn_dtree[zip_D_CODE(dist)].fc++;\r\n\r\n\tzip_d_buf[zip_last_dist++] = dist;\r\n\tzip_flags |= zip_flag_bit;\r\n    }\r\n    zip_flag_bit <<= 1;\r\n\r\n    // Output the flags if they fill a byte\r\n    if((zip_last_lit & 7) == 0) {\r\n\tzip_flag_buf[zip_last_flags++] = zip_flags;\r\n\tzip_flags = 0;\r\n\tzip_flag_bit = 1;\r\n    }\r\n    // Try to guess if it is profitable to stop the current block here\r\n    if(zip_compr_level > 2 && (zip_last_lit & 0xfff) == 0) {\r\n\t// Compute an upper bound for the compressed length\r\n\tvar out_length = zip_last_lit * 8;\r\n\tvar in_length = zip_strstart - zip_block_start;\r\n\tvar dcode;\r\n\r\n\tfor(dcode = 0; dcode < zip_D_CODES; dcode++) {\r\n\t    out_length += zip_dyn_dtree[dcode].fc * (5 + zip_extra_dbits[dcode]);\r\n\t}\r\n\tout_length >>= 3;\r\n//      Trace((stderr,\"\\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) \",\r\n//\t     encoder->last_lit, encoder->last_dist, in_length, out_length,\r\n//\t     100L - out_length*100L/in_length));\r\n\tif(zip_last_dist < parseInt(zip_last_lit/2) &&\r\n\t   out_length < parseInt(in_length/2))\r\n\t    return true;\r\n    }\r\n    return (zip_last_lit == zip_LIT_BUFSIZE-1 ||\r\n\t    zip_last_dist == zip_DIST_BUFSIZE);\r\n    /* We avoid equality with LIT_BUFSIZE because of wraparound at 64K\r\n     * on 16 bit machines and because stored blocks are restricted to\r\n     * 64K-1 bytes.\r\n     */\r\n}\r\n\r\n  /* ==========================================================================\r\n   * Send the block data compressed using the given Huffman trees\r\n   */\r\nvar zip_compress_block = function(\r\n\tltree,\t// literal tree\r\n\tdtree) {\t// distance tree\r\n    var dist;\t\t// distance of matched string\r\n    var lc;\t\t// match length or unmatched char (if dist == 0)\r\n    var lx = 0;\t\t// running index in l_buf\r\n    var dx = 0;\t\t// running index in d_buf\r\n    var fx = 0;\t\t// running index in flag_buf\r\n    var flag = 0;\t// current flags\r\n    var code;\t\t// the code to send\r\n    var extra;\t\t// number of extra bits to send\r\n\r\n    if(zip_last_lit != 0) do {\r\n\tif((lx & 7) == 0)\r\n\t    flag = zip_flag_buf[fx++];\r\n\tlc = zip_l_buf[lx++] & 0xff;\r\n\tif((flag & 1) == 0) {\r\n\t    zip_SEND_CODE(lc, ltree); /* send a literal byte */\r\n//\tTracecv(isgraph(lc), (stderr,\" '%c' \", lc));\r\n\t} else {\r\n\t    // Here, lc is the match length - MIN_MATCH\r\n\t    code = zip_length_code[lc];\r\n\t    zip_SEND_CODE(code+zip_LITERALS+1, ltree); // send the length code\r\n\t    extra = zip_extra_lbits[code];\r\n\t    if(extra != 0) {\r\n\t\tlc -= zip_base_length[code];\r\n\t\tzip_send_bits(lc, extra); // send the extra length bits\r\n\t    }\r\n\t    dist = zip_d_buf[dx++];\r\n\t    // Here, dist is the match distance - 1\r\n\t    code = zip_D_CODE(dist);\r\n//\tAssert (code < D_CODES, \"bad d_code\");\r\n\r\n\t    zip_SEND_CODE(code, dtree);\t  // send the distance code\r\n\t    extra = zip_extra_dbits[code];\r\n\t    if(extra != 0) {\r\n\t\tdist -= zip_base_dist[code];\r\n\t\tzip_send_bits(dist, extra);   // send the extra distance bits\r\n\t    }\r\n\t} // literal or match pair ?\r\n\tflag >>= 1;\r\n    } while(lx < zip_last_lit);\r\n\r\n    zip_SEND_CODE(zip_END_BLOCK, ltree);\r\n}\r\n\r\n/* ==========================================================================\r\n * Send a value on a given number of bits.\r\n * IN assertion: length <= 16 and value fits in length bits.\r\n */\r\nvar zip_Buf_size = 16; // bit size of bi_buf\r\nvar zip_send_bits = function(\r\n\tvalue,\t// value to send\r\n\tlength) {\t// number of bits\r\n    /* If not enough room in bi_buf, use (valid) bits from bi_buf and\r\n     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))\r\n     * unused bits in value.\r\n     */\r\n    if(zip_bi_valid > zip_Buf_size - length) {\r\n\tzip_bi_buf |= (value << zip_bi_valid);\r\n\tzip_put_short(zip_bi_buf);\r\n\tzip_bi_buf = (value >> (zip_Buf_size - zip_bi_valid));\r\n\tzip_bi_valid += length - zip_Buf_size;\r\n    } else {\r\n\tzip_bi_buf |= value << zip_bi_valid;\r\n\tzip_bi_valid += length;\r\n    }\r\n}\r\n\r\n/* ==========================================================================\r\n * Reverse the first len bits of a code, using straightforward code (a faster\r\n * method would use a table)\r\n * IN assertion: 1 <= len <= 15\r\n */\r\nvar zip_bi_reverse = function(\r\n\tcode,\t// the value to invert\r\n\tlen) {\t// its bit length\r\n    var res = 0;\r\n    do {\r\n\tres |= code & 1;\r\n\tcode >>= 1;\r\n\tres <<= 1;\r\n    } while(--len > 0);\r\n    return res >> 1;\r\n}\r\n\r\n/* ==========================================================================\r\n * Write out any remaining bits in an incomplete byte.\r\n */\r\nvar zip_bi_windup = function() {\r\n    if(zip_bi_valid > 8) {\r\n\tzip_put_short(zip_bi_buf);\r\n    } else if(zip_bi_valid > 0) {\r\n\tzip_put_byte(zip_bi_buf);\r\n    }\r\n    zip_bi_buf = 0;\r\n    zip_bi_valid = 0;\r\n}\r\n\r\nvar zip_qoutbuf = function() {\r\n    if(zip_outcnt != 0) {\r\n\tvar q, i;\r\n\tq = zip_new_queue();\r\n\tif(zip_qhead == null)\r\n\t    zip_qhead = zip_qtail = q;\r\n\telse\r\n\t    zip_qtail = zip_qtail.next = q;\r\n\tq.len = zip_outcnt - zip_outoff;\r\n//      System.arraycopy(zip_outbuf, zip_outoff, q.ptr, 0, q.len);\r\n\tfor(i = 0; i < q.len; i++)\r\n\t    q.ptr[i] = zip_outbuf[zip_outoff + i];\r\n\tzip_outcnt = zip_outoff = 0;\r\n    }\r\n}\r\n\r\nvar zip_deflate = function(str, level) {\r\n    var i, j;\r\n\r\n    zip_deflate_data = str;\r\n    zip_deflate_pos = 0;\r\n    if(typeof level == \"undefined\")\r\n\tlevel = zip_DEFAULT_LEVEL;\r\n    zip_deflate_start(level);\r\n\r\n    var buff = new Array(1024);\r\n    var aout = [];\r\n    while((i = zip_deflate_internal(buff, 0, buff.length)) > 0) {\r\n\tvar cbuf = new Array(i);\r\n\tfor(j = 0; j < i; j++){\r\n\t    cbuf[j] = String.fromCharCode(buff[j]);\r\n\t}\r\n\taout[aout.length] = cbuf.join(\"\");\r\n    }\r\n    zip_deflate_data = null; // G.C.\r\n    return aout.join(\"\");\r\n}\r\n\r\nif (! window.RawDeflate) RawDeflate = {};\r\nRawDeflate.deflate = zip_deflate;\r\n\r\n})();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvcmF3ZGVmbGF0ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9yYXdkZWZsYXRlLmpzPzllZDQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogJElkOiByYXdkZWZsYXRlLmpzLHYgMC4zIDIwMDkvMDMvMDEgMTk6MDU6MDUgZGFua29nYWkgRXhwIGRhbmtvZ2FpICRcclxuICpcclxuICogT3JpZ2luYWw6XHJcbiAqICAgaHR0cDovL3d3dy5vbmljb3MuY29tL3N0YWZmL2l6L2FtdXNlL2phdmFzY3JpcHQvZXhwZXJ0L2RlZmxhdGUudHh0XHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uKCl7XHJcblxyXG4vKiBDb3B5cmlnaHQgKEMpIDE5OTkgTWFzYW5hbyBJenVtbyA8aXpAb25pY29zLmNvLmpwPlxyXG4gKiBWZXJzaW9uOiAxLjAuMVxyXG4gKiBMYXN0TW9kaWZpZWQ6IERlYyAyNSAxOTk5XHJcbiAqL1xyXG5cclxuLyogSW50ZXJmYWNlOlxyXG4gKiBkYXRhID0gemlwX2RlZmxhdGUoc3JjKTtcclxuICovXHJcblxyXG4vKiBjb25zdGFudCBwYXJhbWV0ZXJzICovXHJcbnZhciB6aXBfV1NJWkUgPSAzMjc2ODtcdFx0Ly8gU2xpZGluZyBXaW5kb3cgc2l6ZVxyXG52YXIgemlwX1NUT1JFRF9CTE9DSyA9IDA7XHJcbnZhciB6aXBfU1RBVElDX1RSRUVTID0gMTtcclxudmFyIHppcF9EWU5fVFJFRVMgICAgPSAyO1xyXG5cclxuLyogZm9yIGRlZmxhdGUgKi9cclxudmFyIHppcF9ERUZBVUxUX0xFVkVMID0gNjtcclxudmFyIHppcF9GVUxMX1NFQVJDSCA9IHRydWU7XHJcbnZhciB6aXBfSU5CVUZTSVogPSAzMjc2ODtcdC8vIElucHV0IGJ1ZmZlciBzaXplXHJcbnZhciB6aXBfSU5CVUZfRVhUUkEgPSA2NDtcdC8vIEV4dHJhIGJ1ZmZlclxyXG52YXIgemlwX09VVEJVRlNJWiA9IDEwMjQgKiA4O1xyXG52YXIgemlwX3dpbmRvd19zaXplID0gMiAqIHppcF9XU0laRTtcclxudmFyIHppcF9NSU5fTUFUQ0ggPSAzO1xyXG52YXIgemlwX01BWF9NQVRDSCA9IDI1ODtcclxudmFyIHppcF9CSVRTID0gMTY7XHJcbi8vIGZvciBTTUFMTF9NRU1cclxudmFyIHppcF9MSVRfQlVGU0laRSA9IDB4MjAwMDtcclxudmFyIHppcF9IQVNIX0JJVFMgPSAxMztcclxuLy8gZm9yIE1FRElVTV9NRU1cclxuLy8gdmFyIHppcF9MSVRfQlVGU0laRSA9IDB4NDAwMDtcclxuLy8gdmFyIHppcF9IQVNIX0JJVFMgPSAxNDtcclxuLy8gZm9yIEJJR19NRU1cclxuLy8gdmFyIHppcF9MSVRfQlVGU0laRSA9IDB4ODAwMDtcclxuLy8gdmFyIHppcF9IQVNIX0JJVFMgPSAxNTtcclxuaWYoemlwX0xJVF9CVUZTSVpFID4gemlwX0lOQlVGU0laKVxyXG4gICAgYWxlcnQoXCJlcnJvcjogemlwX0lOQlVGU0laIGlzIHRvbyBzbWFsbFwiKTtcclxuaWYoKHppcF9XU0laRTw8MSkgPiAoMTw8emlwX0JJVFMpKVxyXG4gICAgYWxlcnQoXCJlcnJvcjogemlwX1dTSVpFIGlzIHRvbyBsYXJnZVwiKTtcclxuaWYoemlwX0hBU0hfQklUUyA+IHppcF9CSVRTLTEpXHJcbiAgICBhbGVydChcImVycm9yOiB6aXBfSEFTSF9CSVRTIGlzIHRvbyBsYXJnZVwiKTtcclxuaWYoemlwX0hBU0hfQklUUyA8IDggfHwgemlwX01BWF9NQVRDSCAhPSAyNTgpXHJcbiAgICBhbGVydChcImVycm9yOiBDb2RlIHRvbyBjbGV2ZXJcIik7XHJcbnZhciB6aXBfRElTVF9CVUZTSVpFID0gemlwX0xJVF9CVUZTSVpFO1xyXG52YXIgemlwX0hBU0hfU0laRSA9IDEgPDwgemlwX0hBU0hfQklUUztcclxudmFyIHppcF9IQVNIX01BU0sgPSB6aXBfSEFTSF9TSVpFIC0gMTtcclxudmFyIHppcF9XTUFTSyA9IHppcF9XU0laRSAtIDE7XHJcbnZhciB6aXBfTklMID0gMDsgLy8gVGFpbCBvZiBoYXNoIGNoYWluc1xyXG52YXIgemlwX1RPT19GQVIgPSA0MDk2O1xyXG52YXIgemlwX01JTl9MT09LQUhFQUQgPSB6aXBfTUFYX01BVENIICsgemlwX01JTl9NQVRDSCArIDE7XHJcbnZhciB6aXBfTUFYX0RJU1QgPSB6aXBfV1NJWkUgLSB6aXBfTUlOX0xPT0tBSEVBRDtcclxudmFyIHppcF9TTUFMTEVTVCA9IDE7XHJcbnZhciB6aXBfTUFYX0JJVFMgPSAxNTtcclxudmFyIHppcF9NQVhfQkxfQklUUyA9IDc7XHJcbnZhciB6aXBfTEVOR1RIX0NPREVTID0gMjk7XHJcbnZhciB6aXBfTElURVJBTFMgPTI1NjtcclxudmFyIHppcF9FTkRfQkxPQ0sgPSAyNTY7XHJcbnZhciB6aXBfTF9DT0RFUyA9IHppcF9MSVRFUkFMUyArIDEgKyB6aXBfTEVOR1RIX0NPREVTO1xyXG52YXIgemlwX0RfQ09ERVMgPSAzMDtcclxudmFyIHppcF9CTF9DT0RFUyA9IDE5O1xyXG52YXIgemlwX1JFUF8zXzYgPSAxNjtcclxudmFyIHppcF9SRVBaXzNfMTAgPSAxNztcclxudmFyIHppcF9SRVBaXzExXzEzOCA9IDE4O1xyXG52YXIgemlwX0hFQVBfU0laRSA9IDIgKiB6aXBfTF9DT0RFUyArIDE7XHJcbnZhciB6aXBfSF9TSElGVCA9IHBhcnNlSW50KCh6aXBfSEFTSF9CSVRTICsgemlwX01JTl9NQVRDSCAtIDEpIC9cclxuXHRcdFx0ICAgemlwX01JTl9NQVRDSCk7XHJcblxyXG4vKiB2YXJpYWJsZXMgKi9cclxudmFyIHppcF9mcmVlX3F1ZXVlO1xyXG52YXIgemlwX3FoZWFkLCB6aXBfcXRhaWw7XHJcbnZhciB6aXBfaW5pdGZsYWc7XHJcbnZhciB6aXBfb3V0YnVmID0gbnVsbDtcclxudmFyIHppcF9vdXRjbnQsIHppcF9vdXRvZmY7XHJcbnZhciB6aXBfY29tcGxldGU7XHJcbnZhciB6aXBfd2luZG93O1xyXG52YXIgemlwX2RfYnVmO1xyXG52YXIgemlwX2xfYnVmO1xyXG52YXIgemlwX3ByZXY7XHJcbnZhciB6aXBfYmlfYnVmO1xyXG52YXIgemlwX2JpX3ZhbGlkO1xyXG52YXIgemlwX2Jsb2NrX3N0YXJ0O1xyXG52YXIgemlwX2luc19oO1xyXG52YXIgemlwX2hhc2hfaGVhZDtcclxudmFyIHppcF9wcmV2X21hdGNoO1xyXG52YXIgemlwX21hdGNoX2F2YWlsYWJsZTtcclxudmFyIHppcF9tYXRjaF9sZW5ndGg7XHJcbnZhciB6aXBfcHJldl9sZW5ndGg7XHJcbnZhciB6aXBfc3Ryc3RhcnQ7XHJcbnZhciB6aXBfbWF0Y2hfc3RhcnQ7XHJcbnZhciB6aXBfZW9maWxlO1xyXG52YXIgemlwX2xvb2thaGVhZDtcclxudmFyIHppcF9tYXhfY2hhaW5fbGVuZ3RoO1xyXG52YXIgemlwX21heF9sYXp5X21hdGNoO1xyXG52YXIgemlwX2NvbXByX2xldmVsO1xyXG52YXIgemlwX2dvb2RfbWF0Y2g7XHJcbnZhciB6aXBfbmljZV9tYXRjaDtcclxudmFyIHppcF9keW5fbHRyZWU7XHJcbnZhciB6aXBfZHluX2R0cmVlO1xyXG52YXIgemlwX3N0YXRpY19sdHJlZTtcclxudmFyIHppcF9zdGF0aWNfZHRyZWU7XHJcbnZhciB6aXBfYmxfdHJlZTtcclxudmFyIHppcF9sX2Rlc2M7XHJcbnZhciB6aXBfZF9kZXNjO1xyXG52YXIgemlwX2JsX2Rlc2M7XHJcbnZhciB6aXBfYmxfY291bnQ7XHJcbnZhciB6aXBfaGVhcDtcclxudmFyIHppcF9oZWFwX2xlbjtcclxudmFyIHppcF9oZWFwX21heDtcclxudmFyIHppcF9kZXB0aDtcclxudmFyIHppcF9sZW5ndGhfY29kZTtcclxudmFyIHppcF9kaXN0X2NvZGU7XHJcbnZhciB6aXBfYmFzZV9sZW5ndGg7XHJcbnZhciB6aXBfYmFzZV9kaXN0O1xyXG52YXIgemlwX2ZsYWdfYnVmO1xyXG52YXIgemlwX2xhc3RfbGl0O1xyXG52YXIgemlwX2xhc3RfZGlzdDtcclxudmFyIHppcF9sYXN0X2ZsYWdzO1xyXG52YXIgemlwX2ZsYWdzO1xyXG52YXIgemlwX2ZsYWdfYml0O1xyXG52YXIgemlwX29wdF9sZW47XHJcbnZhciB6aXBfc3RhdGljX2xlbjtcclxudmFyIHppcF9kZWZsYXRlX2RhdGE7XHJcbnZhciB6aXBfZGVmbGF0ZV9wb3M7XHJcblxyXG4vKiBvYmplY3RzIChkZWZsYXRlKSAqL1xyXG5cclxudmFyIHppcF9EZWZsYXRlQ1QgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuZmMgPSAwOyAvLyBmcmVxdWVuY3kgY291bnQgb3IgYml0IHN0cmluZ1xyXG4gICAgdGhpcy5kbCA9IDA7IC8vIGZhdGhlciBub2RlIGluIEh1ZmZtYW4gdHJlZSBvciBsZW5ndGggb2YgYml0IHN0cmluZ1xyXG59XHJcblxyXG52YXIgemlwX0RlZmxhdGVUcmVlRGVzYyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5keW5fdHJlZSA9IG51bGw7XHQvLyB0aGUgZHluYW1pYyB0cmVlXHJcbiAgICB0aGlzLnN0YXRpY190cmVlID0gbnVsbDtcdC8vIGNvcnJlc3BvbmRpbmcgc3RhdGljIHRyZWUgb3IgTlVMTFxyXG4gICAgdGhpcy5leHRyYV9iaXRzID0gbnVsbDtcdC8vIGV4dHJhIGJpdHMgZm9yIGVhY2ggY29kZSBvciBOVUxMXHJcbiAgICB0aGlzLmV4dHJhX2Jhc2UgPSAwO1x0Ly8gYmFzZSBpbmRleCBmb3IgZXh0cmFfYml0c1xyXG4gICAgdGhpcy5lbGVtcyA9IDA7XHRcdC8vIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRyZWVcclxuICAgIHRoaXMubWF4X2xlbmd0aCA9IDA7XHQvLyBtYXggYml0IGxlbmd0aCBmb3IgdGhlIGNvZGVzXHJcbiAgICB0aGlzLm1heF9jb2RlID0gMDtcdFx0Ly8gbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5XHJcbn1cclxuXHJcbi8qIFZhbHVlcyBmb3IgbWF4X2xhenlfbWF0Y2gsIGdvb2RfbWF0Y2ggYW5kIG1heF9jaGFpbl9sZW5ndGgsIGRlcGVuZGluZyBvblxyXG4gKiB0aGUgZGVzaXJlZCBwYWNrIGxldmVsICgwLi45KS4gVGhlIHZhbHVlcyBnaXZlbiBiZWxvdyBoYXZlIGJlZW4gdHVuZWQgdG9cclxuICogZXhjbHVkZSB3b3JzdCBjYXNlIHBlcmZvcm1hbmNlIGZvciBwYXRob2xvZ2ljYWwgZmlsZXMuIEJldHRlciB2YWx1ZXMgbWF5IGJlXHJcbiAqIGZvdW5kIGZvciBzcGVjaWZpYyBmaWxlcy5cclxuICovXHJcbnZhciB6aXBfRGVmbGF0ZUNvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XHJcbiAgICB0aGlzLmdvb2RfbGVuZ3RoID0gYTsgLy8gcmVkdWNlIGxhenkgc2VhcmNoIGFib3ZlIHRoaXMgbWF0Y2ggbGVuZ3RoXHJcbiAgICB0aGlzLm1heF9sYXp5ID0gYjsgICAgLy8gZG8gbm90IHBlcmZvcm0gbGF6eSBzZWFyY2ggYWJvdmUgdGhpcyBtYXRjaCBsZW5ndGhcclxuICAgIHRoaXMubmljZV9sZW5ndGggPSBjOyAvLyBxdWl0IHNlYXJjaCBhYm92ZSB0aGlzIG1hdGNoIGxlbmd0aFxyXG4gICAgdGhpcy5tYXhfY2hhaW4gPSBkO1xyXG59XHJcblxyXG52YXIgemlwX0RlZmxhdGVCdWZmZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMubmV4dCA9IG51bGw7XHJcbiAgICB0aGlzLmxlbiA9IDA7XHJcbiAgICB0aGlzLnB0ciA9IG5ldyBBcnJheSh6aXBfT1VUQlVGU0laKTtcclxuICAgIHRoaXMub2ZmID0gMDtcclxufVxyXG5cclxuLyogY29uc3RhbnQgdGFibGVzICovXHJcbnZhciB6aXBfZXh0cmFfbGJpdHMgPSBuZXcgQXJyYXkoXHJcbiAgICAwLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDApO1xyXG52YXIgemlwX2V4dHJhX2RiaXRzID0gbmV3IEFycmF5KFxyXG4gICAgMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxMyk7XHJcbnZhciB6aXBfZXh0cmFfYmxiaXRzID0gbmV3IEFycmF5KFxyXG4gICAgMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDMsNyk7XHJcbnZhciB6aXBfYmxfb3JkZXIgPSBuZXcgQXJyYXkoXHJcbiAgICAxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1KTtcclxudmFyIHppcF9jb25maWd1cmF0aW9uX3RhYmxlID0gbmV3IEFycmF5KFxyXG5cdG5ldyB6aXBfRGVmbGF0ZUNvbmZpZ3VyYXRpb24oMCwgICAgMCwgICAwLCAgICAwKSxcclxuXHRuZXcgemlwX0RlZmxhdGVDb25maWd1cmF0aW9uKDQsICAgIDQsICAgOCwgICAgNCksXHJcblx0bmV3IHppcF9EZWZsYXRlQ29uZmlndXJhdGlvbig0LCAgICA1LCAgMTYsICAgIDgpLFxyXG5cdG5ldyB6aXBfRGVmbGF0ZUNvbmZpZ3VyYXRpb24oNCwgICAgNiwgIDMyLCAgIDMyKSxcclxuXHRuZXcgemlwX0RlZmxhdGVDb25maWd1cmF0aW9uKDQsICAgIDQsICAxNiwgICAxNiksXHJcblx0bmV3IHppcF9EZWZsYXRlQ29uZmlndXJhdGlvbig4LCAgIDE2LCAgMzIsICAgMzIpLFxyXG5cdG5ldyB6aXBfRGVmbGF0ZUNvbmZpZ3VyYXRpb24oOCwgICAxNiwgMTI4LCAgMTI4KSxcclxuXHRuZXcgemlwX0RlZmxhdGVDb25maWd1cmF0aW9uKDgsICAgMzIsIDEyOCwgIDI1NiksXHJcblx0bmV3IHppcF9EZWZsYXRlQ29uZmlndXJhdGlvbigzMiwgMTI4LCAyNTgsIDEwMjQpLFxyXG5cdG5ldyB6aXBfRGVmbGF0ZUNvbmZpZ3VyYXRpb24oMzIsIDI1OCwgMjU4LCA0MDk2KSk7XHJcblxyXG5cclxuLyogcm91dGluZXMgKGRlZmxhdGUpICovXHJcblxyXG52YXIgemlwX2RlZmxhdGVfc3RhcnQgPSBmdW5jdGlvbihsZXZlbCkge1xyXG4gICAgdmFyIGk7XHJcblxyXG4gICAgaWYoIWxldmVsKVxyXG5cdGxldmVsID0gemlwX0RFRkFVTFRfTEVWRUw7XHJcbiAgICBlbHNlIGlmKGxldmVsIDwgMSlcclxuXHRsZXZlbCA9IDE7XHJcbiAgICBlbHNlIGlmKGxldmVsID4gOSlcclxuXHRsZXZlbCA9IDk7XHJcblxyXG4gICAgemlwX2NvbXByX2xldmVsID0gbGV2ZWw7XHJcbiAgICB6aXBfaW5pdGZsYWcgPSBmYWxzZTtcclxuICAgIHppcF9lb2ZpbGUgPSBmYWxzZTtcclxuICAgIGlmKHppcF9vdXRidWYgIT0gbnVsbClcclxuXHRyZXR1cm47XHJcblxyXG4gICAgemlwX2ZyZWVfcXVldWUgPSB6aXBfcWhlYWQgPSB6aXBfcXRhaWwgPSBudWxsO1xyXG4gICAgemlwX291dGJ1ZiA9IG5ldyBBcnJheSh6aXBfT1VUQlVGU0laKTtcclxuICAgIHppcF93aW5kb3cgPSBuZXcgQXJyYXkoemlwX3dpbmRvd19zaXplKTtcclxuICAgIHppcF9kX2J1ZiA9IG5ldyBBcnJheSh6aXBfRElTVF9CVUZTSVpFKTtcclxuICAgIHppcF9sX2J1ZiA9IG5ldyBBcnJheSh6aXBfSU5CVUZTSVogKyB6aXBfSU5CVUZfRVhUUkEpO1xyXG4gICAgemlwX3ByZXYgPSBuZXcgQXJyYXkoMSA8PCB6aXBfQklUUyk7XHJcbiAgICB6aXBfZHluX2x0cmVlID0gbmV3IEFycmF5KHppcF9IRUFQX1NJWkUpO1xyXG4gICAgZm9yKGkgPSAwOyBpIDwgemlwX0hFQVBfU0laRTsgaSsrKVxyXG5cdHppcF9keW5fbHRyZWVbaV0gPSBuZXcgemlwX0RlZmxhdGVDVCgpO1xyXG4gICAgemlwX2R5bl9kdHJlZSA9IG5ldyBBcnJheSgyKnppcF9EX0NPREVTKzEpO1xyXG4gICAgZm9yKGkgPSAwOyBpIDwgMip6aXBfRF9DT0RFUysxOyBpKyspXHJcblx0emlwX2R5bl9kdHJlZVtpXSA9IG5ldyB6aXBfRGVmbGF0ZUNUKCk7XHJcbiAgICB6aXBfc3RhdGljX2x0cmVlID0gbmV3IEFycmF5KHppcF9MX0NPREVTKzIpO1xyXG4gICAgZm9yKGkgPSAwOyBpIDwgemlwX0xfQ09ERVMrMjsgaSsrKVxyXG5cdHppcF9zdGF0aWNfbHRyZWVbaV0gPSBuZXcgemlwX0RlZmxhdGVDVCgpO1xyXG4gICAgemlwX3N0YXRpY19kdHJlZSA9IG5ldyBBcnJheSh6aXBfRF9DT0RFUyk7XHJcbiAgICBmb3IoaSA9IDA7IGkgPCB6aXBfRF9DT0RFUzsgaSsrKVxyXG5cdHppcF9zdGF0aWNfZHRyZWVbaV0gPSBuZXcgemlwX0RlZmxhdGVDVCgpO1xyXG4gICAgemlwX2JsX3RyZWUgPSBuZXcgQXJyYXkoMip6aXBfQkxfQ09ERVMrMSk7XHJcbiAgICBmb3IoaSA9IDA7IGkgPCAyKnppcF9CTF9DT0RFUysxOyBpKyspXHJcblx0emlwX2JsX3RyZWVbaV0gPSBuZXcgemlwX0RlZmxhdGVDVCgpO1xyXG4gICAgemlwX2xfZGVzYyA9IG5ldyB6aXBfRGVmbGF0ZVRyZWVEZXNjKCk7XHJcbiAgICB6aXBfZF9kZXNjID0gbmV3IHppcF9EZWZsYXRlVHJlZURlc2MoKTtcclxuICAgIHppcF9ibF9kZXNjID0gbmV3IHppcF9EZWZsYXRlVHJlZURlc2MoKTtcclxuICAgIHppcF9ibF9jb3VudCA9IG5ldyBBcnJheSh6aXBfTUFYX0JJVFMrMSk7XHJcbiAgICB6aXBfaGVhcCA9IG5ldyBBcnJheSgyKnppcF9MX0NPREVTKzEpO1xyXG4gICAgemlwX2RlcHRoID0gbmV3IEFycmF5KDIqemlwX0xfQ09ERVMrMSk7XHJcbiAgICB6aXBfbGVuZ3RoX2NvZGUgPSBuZXcgQXJyYXkoemlwX01BWF9NQVRDSC16aXBfTUlOX01BVENIKzEpO1xyXG4gICAgemlwX2Rpc3RfY29kZSA9IG5ldyBBcnJheSg1MTIpO1xyXG4gICAgemlwX2Jhc2VfbGVuZ3RoID0gbmV3IEFycmF5KHppcF9MRU5HVEhfQ09ERVMpO1xyXG4gICAgemlwX2Jhc2VfZGlzdCA9IG5ldyBBcnJheSh6aXBfRF9DT0RFUyk7XHJcbiAgICB6aXBfZmxhZ19idWYgPSBuZXcgQXJyYXkocGFyc2VJbnQoemlwX0xJVF9CVUZTSVpFIC8gOCkpO1xyXG59XHJcblxyXG52YXIgemlwX2RlZmxhdGVfZW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICB6aXBfZnJlZV9xdWV1ZSA9IHppcF9xaGVhZCA9IHppcF9xdGFpbCA9IG51bGw7XHJcbiAgICB6aXBfb3V0YnVmID0gbnVsbDtcclxuICAgIHppcF93aW5kb3cgPSBudWxsO1xyXG4gICAgemlwX2RfYnVmID0gbnVsbDtcclxuICAgIHppcF9sX2J1ZiA9IG51bGw7XHJcbiAgICB6aXBfcHJldiA9IG51bGw7XHJcbiAgICB6aXBfZHluX2x0cmVlID0gbnVsbDtcclxuICAgIHppcF9keW5fZHRyZWUgPSBudWxsO1xyXG4gICAgemlwX3N0YXRpY19sdHJlZSA9IG51bGw7XHJcbiAgICB6aXBfc3RhdGljX2R0cmVlID0gbnVsbDtcclxuICAgIHppcF9ibF90cmVlID0gbnVsbDtcclxuICAgIHppcF9sX2Rlc2MgPSBudWxsO1xyXG4gICAgemlwX2RfZGVzYyA9IG51bGw7XHJcbiAgICB6aXBfYmxfZGVzYyA9IG51bGw7XHJcbiAgICB6aXBfYmxfY291bnQgPSBudWxsO1xyXG4gICAgemlwX2hlYXAgPSBudWxsO1xyXG4gICAgemlwX2RlcHRoID0gbnVsbDtcclxuICAgIHppcF9sZW5ndGhfY29kZSA9IG51bGw7XHJcbiAgICB6aXBfZGlzdF9jb2RlID0gbnVsbDtcclxuICAgIHppcF9iYXNlX2xlbmd0aCA9IG51bGw7XHJcbiAgICB6aXBfYmFzZV9kaXN0ID0gbnVsbDtcclxuICAgIHppcF9mbGFnX2J1ZiA9IG51bGw7XHJcbn1cclxuXHJcbnZhciB6aXBfcmV1c2VfcXVldWUgPSBmdW5jdGlvbihwKSB7XHJcbiAgICBwLm5leHQgPSB6aXBfZnJlZV9xdWV1ZTtcclxuICAgIHppcF9mcmVlX3F1ZXVlID0gcDtcclxufVxyXG5cclxudmFyIHppcF9uZXdfcXVldWUgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBwO1xyXG5cclxuICAgIGlmKHppcF9mcmVlX3F1ZXVlICE9IG51bGwpXHJcbiAgICB7XHJcblx0cCA9IHppcF9mcmVlX3F1ZXVlO1xyXG5cdHppcF9mcmVlX3F1ZXVlID0gemlwX2ZyZWVfcXVldWUubmV4dDtcclxuICAgIH1cclxuICAgIGVsc2VcclxuXHRwID0gbmV3IHppcF9EZWZsYXRlQnVmZmVyKCk7XHJcbiAgICBwLm5leHQgPSBudWxsO1xyXG4gICAgcC5sZW4gPSBwLm9mZiA9IDA7XHJcblxyXG4gICAgcmV0dXJuIHA7XHJcbn1cclxuXHJcbnZhciB6aXBfaGVhZDEgPSBmdW5jdGlvbihpKSB7XHJcbiAgICByZXR1cm4gemlwX3ByZXZbemlwX1dTSVpFICsgaV07XHJcbn1cclxuXHJcbnZhciB6aXBfaGVhZDIgPSBmdW5jdGlvbihpLCB2YWwpIHtcclxuICAgIHJldHVybiB6aXBfcHJldlt6aXBfV1NJWkUgKyBpXSA9IHZhbDtcclxufVxyXG5cclxuLyogcHV0X2J5dGUgaXMgdXNlZCBmb3IgdGhlIGNvbXByZXNzZWQgb3V0cHV0LCBwdXRfdWJ5dGUgZm9yIHRoZVxyXG4gKiB1bmNvbXByZXNzZWQgb3V0cHV0LiBIb3dldmVyIHVubHp3KCkgdXNlcyB3aW5kb3cgZm9yIGl0c1xyXG4gKiBzdWZmaXggdGFibGUgaW5zdGVhZCBvZiBpdHMgb3V0cHV0IGJ1ZmZlciwgc28gaXQgZG9lcyBub3QgdXNlIHB1dF91Ynl0ZVxyXG4gKiAodG8gYmUgY2xlYW5lZCB1cCkuXHJcbiAqL1xyXG52YXIgemlwX3B1dF9ieXRlID0gZnVuY3Rpb24oYykge1xyXG4gICAgemlwX291dGJ1Zlt6aXBfb3V0b2ZmICsgemlwX291dGNudCsrXSA9IGM7XHJcbiAgICBpZih6aXBfb3V0b2ZmICsgemlwX291dGNudCA9PSB6aXBfT1VUQlVGU0laKVxyXG5cdHppcF9xb3V0YnVmKCk7XHJcbn1cclxuXHJcbi8qIE91dHB1dCBhIDE2IGJpdCB2YWx1ZSwgbHNiIGZpcnN0ICovXHJcbnZhciB6aXBfcHV0X3Nob3J0ID0gZnVuY3Rpb24odykge1xyXG4gICAgdyAmPSAweGZmZmY7XHJcbiAgICBpZih6aXBfb3V0b2ZmICsgemlwX291dGNudCA8IHppcF9PVVRCVUZTSVogLSAyKSB7XHJcblx0emlwX291dGJ1Zlt6aXBfb3V0b2ZmICsgemlwX291dGNudCsrXSA9ICh3ICYgMHhmZik7XHJcblx0emlwX291dGJ1Zlt6aXBfb3V0b2ZmICsgemlwX291dGNudCsrXSA9ICh3ID4+PiA4KTtcclxuICAgIH0gZWxzZSB7XHJcblx0emlwX3B1dF9ieXRlKHcgJiAweGZmKTtcclxuXHR6aXBfcHV0X2J5dGUodyA+Pj4gOCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIEluc2VydCBzdHJpbmcgcyBpbiB0aGUgZGljdGlvbmFyeSBhbmQgc2V0IG1hdGNoX2hlYWQgdG8gdGhlIHByZXZpb3VzIGhlYWRcclxuICogb2YgdGhlIGhhc2ggY2hhaW4gKHRoZSBtb3N0IHJlY2VudCBzdHJpbmcgd2l0aCBzYW1lIGhhc2gga2V5KS4gUmV0dXJuXHJcbiAqIHRoZSBwcmV2aW91cyBsZW5ndGggb2YgdGhlIGhhc2ggY2hhaW4uXHJcbiAqIElOICBhc3NlcnRpb246IGFsbCBjYWxscyB0byB0byBJTlNFUlRfU1RSSU5HIGFyZSBtYWRlIHdpdGggY29uc2VjdXRpdmVcclxuICogICAgaW5wdXQgY2hhcmFjdGVycyBhbmQgdGhlIGZpcnN0IE1JTl9NQVRDSCBieXRlcyBvZiBzIGFyZSB2YWxpZFxyXG4gKiAgICAoZXhjZXB0IGZvciB0aGUgbGFzdCBNSU5fTUFUQ0gtMSBieXRlcyBvZiB0aGUgaW5wdXQgZmlsZSkuXHJcbiAqL1xyXG52YXIgemlwX0lOU0VSVF9TVFJJTkcgPSBmdW5jdGlvbigpIHtcclxuICAgIHppcF9pbnNfaCA9ICgoemlwX2luc19oIDw8IHppcF9IX1NISUZUKVxyXG5cdFx0IF4gKHppcF93aW5kb3dbemlwX3N0cnN0YXJ0ICsgemlwX01JTl9NQVRDSCAtIDFdICYgMHhmZikpXHJcblx0JiB6aXBfSEFTSF9NQVNLO1xyXG4gICAgemlwX2hhc2hfaGVhZCA9IHppcF9oZWFkMSh6aXBfaW5zX2gpO1xyXG4gICAgemlwX3ByZXZbemlwX3N0cnN0YXJ0ICYgemlwX1dNQVNLXSA9IHppcF9oYXNoX2hlYWQ7XHJcbiAgICB6aXBfaGVhZDIoemlwX2luc19oLCB6aXBfc3Ryc3RhcnQpO1xyXG59XHJcblxyXG4vKiBTZW5kIGEgY29kZSBvZiB0aGUgZ2l2ZW4gdHJlZS4gYyBhbmQgdHJlZSBtdXN0IG5vdCBoYXZlIHNpZGUgZWZmZWN0cyAqL1xyXG52YXIgemlwX1NFTkRfQ09ERSA9IGZ1bmN0aW9uKGMsIHRyZWUpIHtcclxuICAgIHppcF9zZW5kX2JpdHModHJlZVtjXS5mYywgdHJlZVtjXS5kbCk7XHJcbn1cclxuXHJcbi8qIE1hcHBpbmcgZnJvbSBhIGRpc3RhbmNlIHRvIGEgZGlzdGFuY2UgY29kZS4gZGlzdCBpcyB0aGUgZGlzdGFuY2UgLSAxIGFuZFxyXG4gKiBtdXN0IG5vdCBoYXZlIHNpZGUgZWZmZWN0cy4gZGlzdF9jb2RlWzI1Nl0gYW5kIGRpc3RfY29kZVsyNTddIGFyZSBuZXZlclxyXG4gKiB1c2VkLlxyXG4gKi9cclxudmFyIHppcF9EX0NPREUgPSBmdW5jdGlvbihkaXN0KSB7XHJcbiAgICByZXR1cm4gKGRpc3QgPCAyNTYgPyB6aXBfZGlzdF9jb2RlW2Rpc3RdXHJcblx0ICAgIDogemlwX2Rpc3RfY29kZVsyNTYgKyAoZGlzdD4+NyldKSAmIDB4ZmY7XHJcbn1cclxuXHJcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIENvbXBhcmVzIHRvIHN1YnRyZWVzLCB1c2luZyB0aGUgdHJlZSBkZXB0aCBhcyB0aWUgYnJlYWtlciB3aGVuXHJcbiAqIHRoZSBzdWJ0cmVlcyBoYXZlIGVxdWFsIGZyZXF1ZW5jeS4gVGhpcyBtaW5pbWl6ZXMgdGhlIHdvcnN0IGNhc2UgbGVuZ3RoLlxyXG4gKi9cclxudmFyIHppcF9TTUFMTEVSID0gZnVuY3Rpb24odHJlZSwgbiwgbSkge1xyXG4gICAgcmV0dXJuIHRyZWVbbl0uZmMgPCB0cmVlW21dLmZjIHx8XHJcbiAgICAgICh0cmVlW25dLmZjID09IHRyZWVbbV0uZmMgJiYgemlwX2RlcHRoW25dIDw9IHppcF9kZXB0aFttXSk7XHJcbn1cclxuXHJcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIHJlYWQgc3RyaW5nIGRhdGFcclxuICovXHJcbnZhciB6aXBfcmVhZF9idWZmID0gZnVuY3Rpb24oYnVmZiwgb2Zmc2V0LCBuKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIGZvcihpID0gMDsgaSA8IG4gJiYgemlwX2RlZmxhdGVfcG9zIDwgemlwX2RlZmxhdGVfZGF0YS5sZW5ndGg7IGkrKylcclxuXHRidWZmW29mZnNldCArIGldID1cclxuXHQgICAgemlwX2RlZmxhdGVfZGF0YS5jaGFyQ29kZUF0KHppcF9kZWZsYXRlX3BvcysrKSAmIDB4ZmY7XHJcbiAgICByZXR1cm4gaTtcclxufVxyXG5cclxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogSW5pdGlhbGl6ZSB0aGUgXCJsb25nZXN0IG1hdGNoXCIgcm91dGluZXMgZm9yIGEgbmV3IGZpbGVcclxuICovXHJcbnZhciB6aXBfbG1faW5pdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGo7XHJcblxyXG4gICAgLyogSW5pdGlhbGl6ZSB0aGUgaGFzaCB0YWJsZS4gKi9cclxuICAgIGZvcihqID0gMDsgaiA8IHppcF9IQVNIX1NJWkU7IGorKylcclxuLy9cdHppcF9oZWFkMihqLCB6aXBfTklMKTtcclxuXHR6aXBfcHJldlt6aXBfV1NJWkUgKyBqXSA9IDA7XHJcbiAgICAvKiBwcmV2IHdpbGwgYmUgaW5pdGlhbGl6ZWQgb24gdGhlIGZseSAqL1xyXG5cclxuICAgIC8qIFNldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnM6XHJcbiAgICAgKi9cclxuICAgIHppcF9tYXhfbGF6eV9tYXRjaCA9IHppcF9jb25maWd1cmF0aW9uX3RhYmxlW3ppcF9jb21wcl9sZXZlbF0ubWF4X2xhenk7XHJcbiAgICB6aXBfZ29vZF9tYXRjaCAgICAgPSB6aXBfY29uZmlndXJhdGlvbl90YWJsZVt6aXBfY29tcHJfbGV2ZWxdLmdvb2RfbGVuZ3RoO1xyXG4gICAgaWYoIXppcF9GVUxMX1NFQVJDSClcclxuXHR6aXBfbmljZV9tYXRjaCA9IHppcF9jb25maWd1cmF0aW9uX3RhYmxlW3ppcF9jb21wcl9sZXZlbF0ubmljZV9sZW5ndGg7XHJcbiAgICB6aXBfbWF4X2NoYWluX2xlbmd0aCA9IHppcF9jb25maWd1cmF0aW9uX3RhYmxlW3ppcF9jb21wcl9sZXZlbF0ubWF4X2NoYWluO1xyXG5cclxuICAgIHppcF9zdHJzdGFydCA9IDA7XHJcbiAgICB6aXBfYmxvY2tfc3RhcnQgPSAwO1xyXG5cclxuICAgIHppcF9sb29rYWhlYWQgPSB6aXBfcmVhZF9idWZmKHppcF93aW5kb3csIDAsIDIgKiB6aXBfV1NJWkUpO1xyXG4gICAgaWYoemlwX2xvb2thaGVhZCA8PSAwKSB7XHJcblx0emlwX2VvZmlsZSA9IHRydWU7XHJcblx0emlwX2xvb2thaGVhZCA9IDA7XHJcblx0cmV0dXJuO1xyXG4gICAgfVxyXG4gICAgemlwX2VvZmlsZSA9IGZhbHNlO1xyXG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZC4gVGhpcyBpcyBpbXBvcnRhbnRcclxuICAgICAqIGlmIGlucHV0IGNvbWVzIGZyb20gYSBkZXZpY2Ugc3VjaCBhcyBhIHR0eS5cclxuICAgICAqL1xyXG4gICAgd2hpbGUoemlwX2xvb2thaGVhZCA8IHppcF9NSU5fTE9PS0FIRUFEICYmICF6aXBfZW9maWxlKVxyXG5cdHppcF9maWxsX3dpbmRvdygpO1xyXG5cclxuICAgIC8qIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSCwgaW5zX2ggaXMgZ2FyYmFnZSwgYnV0IHRoaXMgaXNcclxuICAgICAqIG5vdCBpbXBvcnRhbnQgc2luY2Ugb25seSBsaXRlcmFsIGJ5dGVzIHdpbGwgYmUgZW1pdHRlZC5cclxuICAgICAqL1xyXG4gICAgemlwX2luc19oID0gMDtcclxuICAgIGZvcihqID0gMDsgaiA8IHppcF9NSU5fTUFUQ0ggLSAxOyBqKyspIHtcclxuLy8gICAgICBVUERBVEVfSEFTSChpbnNfaCwgd2luZG93W2pdKTtcclxuXHR6aXBfaW5zX2ggPSAoKHppcF9pbnNfaCA8PCB6aXBfSF9TSElGVCkgXiAoemlwX3dpbmRvd1tqXSAmIDB4ZmYpKSAmIHppcF9IQVNIX01BU0s7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIFNldCBtYXRjaF9zdGFydCB0byB0aGUgbG9uZ2VzdCBtYXRjaCBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gc3RyaW5nIGFuZFxyXG4gKiByZXR1cm4gaXRzIGxlbmd0aC4gTWF0Y2hlcyBzaG9ydGVyIG9yIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFyZSBkaXNjYXJkZWQsXHJcbiAqIGluIHdoaWNoIGNhc2UgdGhlIHJlc3VsdCBpcyBlcXVhbCB0byBwcmV2X2xlbmd0aCBhbmQgbWF0Y2hfc3RhcnQgaXNcclxuICogZ2FyYmFnZS5cclxuICogSU4gYXNzZXJ0aW9uczogY3VyX21hdGNoIGlzIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluIGZvciB0aGUgY3VycmVudFxyXG4gKiAgIHN0cmluZyAoc3Ryc3RhcnQpIGFuZCBpdHMgZGlzdGFuY2UgaXMgPD0gTUFYX0RJU1QsIGFuZCBwcmV2X2xlbmd0aCA+PSAxXHJcbiAqL1xyXG52YXIgemlwX2xvbmdlc3RfbWF0Y2ggPSBmdW5jdGlvbihjdXJfbWF0Y2gpIHtcclxuICAgIHZhciBjaGFpbl9sZW5ndGggPSB6aXBfbWF4X2NoYWluX2xlbmd0aDsgLy8gbWF4IGhhc2ggY2hhaW4gbGVuZ3RoXHJcbiAgICB2YXIgc2NhbnAgPSB6aXBfc3Ryc3RhcnQ7IC8vIGN1cnJlbnQgc3RyaW5nXHJcbiAgICB2YXIgbWF0Y2hwO1x0XHQvLyBtYXRjaGVkIHN0cmluZ1xyXG4gICAgdmFyIGxlbjtcdFx0Ly8gbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2hcclxuICAgIHZhciBiZXN0X2xlbiA9IHppcF9wcmV2X2xlbmd0aDtcdC8vIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhclxyXG5cclxuICAgIC8qIFN0b3Agd2hlbiBjdXJfbWF0Y2ggYmVjb21lcyA8PSBsaW1pdC4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsXHJcbiAgICAgKiB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nIG9mIHdpbmRvdyBpbmRleCAwLlxyXG4gICAgICovXHJcbiAgICB2YXIgbGltaXQgPSAoemlwX3N0cnN0YXJ0ID4gemlwX01BWF9ESVNUID8gemlwX3N0cnN0YXJ0IC0gemlwX01BWF9ESVNUIDogemlwX05JTCk7XHJcblxyXG4gICAgdmFyIHN0cmVuZHAgPSB6aXBfc3Ryc3RhcnQgKyB6aXBfTUFYX01BVENIO1xyXG4gICAgdmFyIHNjYW5fZW5kMSA9IHppcF93aW5kb3dbc2NhbnAgKyBiZXN0X2xlbiAtIDFdO1xyXG4gICAgdmFyIHNjYW5fZW5kICA9IHppcF93aW5kb3dbc2NhbnAgKyBiZXN0X2xlbl07XHJcblxyXG4gICAgLyogRG8gbm90IHdhc3RlIHRvbyBtdWNoIHRpbWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgZ29vZCBtYXRjaDogKi9cclxuICAgIGlmKHppcF9wcmV2X2xlbmd0aCA+PSB6aXBfZ29vZF9tYXRjaClcclxuXHRjaGFpbl9sZW5ndGggPj49IDI7XHJcblxyXG4vLyAgQXNzZXJ0KGVuY29kZXItPnN0cnN0YXJ0IDw9IHdpbmRvd19zaXplLU1JTl9MT09LQUhFQUQsIFwiaW5zdWZmaWNpZW50IGxvb2thaGVhZFwiKTtcclxuXHJcbiAgICBkbyB7XHJcbi8vICAgIEFzc2VydChjdXJfbWF0Y2ggPCBlbmNvZGVyLT5zdHJzdGFydCwgXCJubyBmdXR1cmVcIik7XHJcblx0bWF0Y2hwID0gY3VyX21hdGNoO1xyXG5cclxuXHQvKiBTa2lwIHRvIG5leHQgbWF0Y2ggaWYgdGhlIG1hdGNoIGxlbmd0aCBjYW5ub3QgaW5jcmVhc2VcclxuXHQgICAgKiBvciBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiAyOlxyXG5cdCovXHJcblx0aWYoemlwX3dpbmRvd1ttYXRjaHAgKyBiZXN0X2xlbl1cdCE9IHNjYW5fZW5kICB8fFxyXG5cdCAgIHppcF93aW5kb3dbbWF0Y2hwICsgYmVzdF9sZW4gLSAxXVx0IT0gc2Nhbl9lbmQxIHx8XHJcblx0ICAgemlwX3dpbmRvd1ttYXRjaHBdXHRcdFx0IT0gemlwX3dpbmRvd1tzY2FucF0gfHxcclxuXHQgICB6aXBfd2luZG93WysrbWF0Y2hwXVx0XHRcdCE9IHppcF93aW5kb3dbc2NhbnAgKyAxXSkge1xyXG5cdCAgICBjb250aW51ZTtcclxuXHR9XHJcblxyXG5cdC8qIFRoZSBjaGVjayBhdCBiZXN0X2xlbi0xIGNhbiBiZSByZW1vdmVkIGJlY2F1c2UgaXQgd2lsbCBiZSBtYWRlXHJcbiAgICAgICAgICogYWdhaW4gbGF0ZXIuIChUaGlzIGhldXJpc3RpYyBpcyBub3QgYWx3YXlzIGEgd2luLilcclxuICAgICAgICAgKiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXBhcmUgc2NhblsyXSBhbmQgbWF0Y2hbMl0gc2luY2UgdGhleVxyXG4gICAgICAgICAqIGFyZSBhbHdheXMgZXF1YWwgd2hlbiB0aGUgb3RoZXIgYnl0ZXMgbWF0Y2gsIGdpdmVuIHRoYXRcclxuICAgICAgICAgKiB0aGUgaGFzaCBrZXlzIGFyZSBlcXVhbCBhbmQgdGhhdCBIQVNIX0JJVFMgPj0gOC5cclxuICAgICAgICAgKi9cclxuXHRzY2FucCArPSAyO1xyXG5cdG1hdGNocCsrO1xyXG5cclxuXHQvKiBXZSBjaGVjayBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IGV2ZXJ5IDh0aCBjb21wYXJpc29uO1xyXG4gICAgICAgICAqIHRoZSAyNTZ0aCBjaGVjayB3aWxsIGJlIG1hZGUgYXQgc3Ryc3RhcnQrMjU4LlxyXG4gICAgICAgICAqL1xyXG5cdGRvIHtcclxuXHR9IHdoaWxlKHppcF93aW5kb3dbKytzY2FucF0gPT0gemlwX3dpbmRvd1srK21hdGNocF0gJiZcclxuXHRcdHppcF93aW5kb3dbKytzY2FucF0gPT0gemlwX3dpbmRvd1srK21hdGNocF0gJiZcclxuXHRcdHppcF93aW5kb3dbKytzY2FucF0gPT0gemlwX3dpbmRvd1srK21hdGNocF0gJiZcclxuXHRcdHppcF93aW5kb3dbKytzY2FucF0gPT0gemlwX3dpbmRvd1srK21hdGNocF0gJiZcclxuXHRcdHppcF93aW5kb3dbKytzY2FucF0gPT0gemlwX3dpbmRvd1srK21hdGNocF0gJiZcclxuXHRcdHppcF93aW5kb3dbKytzY2FucF0gPT0gemlwX3dpbmRvd1srK21hdGNocF0gJiZcclxuXHRcdHppcF93aW5kb3dbKytzY2FucF0gPT0gemlwX3dpbmRvd1srK21hdGNocF0gJiZcclxuXHRcdHppcF93aW5kb3dbKytzY2FucF0gPT0gemlwX3dpbmRvd1srK21hdGNocF0gJiZcclxuXHRcdHNjYW5wIDwgc3RyZW5kcCk7XHJcblxyXG4gICAgICBsZW4gPSB6aXBfTUFYX01BVENIIC0gKHN0cmVuZHAgLSBzY2FucCk7XHJcbiAgICAgIHNjYW5wID0gc3RyZW5kcCAtIHppcF9NQVhfTUFUQ0g7XHJcblxyXG4gICAgICBpZihsZW4gPiBiZXN0X2xlbikge1xyXG5cdCAgemlwX21hdGNoX3N0YXJ0ID0gY3VyX21hdGNoO1xyXG5cdCAgYmVzdF9sZW4gPSBsZW47XHJcblx0ICBpZih6aXBfRlVMTF9TRUFSQ0gpIHtcclxuXHQgICAgICBpZihsZW4gPj0gemlwX01BWF9NQVRDSCkgYnJlYWs7XHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICAgIGlmKGxlbiA+PSB6aXBfbmljZV9tYXRjaCkgYnJlYWs7XHJcblx0ICB9XHJcblxyXG5cdCAgc2Nhbl9lbmQxICA9IHppcF93aW5kb3dbc2NhbnAgKyBiZXN0X2xlbi0xXTtcclxuXHQgIHNjYW5fZW5kICAgPSB6aXBfd2luZG93W3NjYW5wICsgYmVzdF9sZW5dO1xyXG4gICAgICB9XHJcbiAgICB9IHdoaWxlKChjdXJfbWF0Y2ggPSB6aXBfcHJldltjdXJfbWF0Y2ggJiB6aXBfV01BU0tdKSA+IGxpbWl0XHJcblx0ICAgICYmIC0tY2hhaW5fbGVuZ3RoICE9IDApO1xyXG5cclxuICAgIHJldHVybiBiZXN0X2xlbjtcclxufVxyXG5cclxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogRmlsbCB0aGUgd2luZG93IHdoZW4gdGhlIGxvb2thaGVhZCBiZWNvbWVzIGluc3VmZmljaWVudC5cclxuICogVXBkYXRlcyBzdHJzdGFydCBhbmQgbG9va2FoZWFkLCBhbmQgc2V0cyBlb2ZpbGUgaWYgZW5kIG9mIGlucHV0IGZpbGUuXHJcbiAqIElOIGFzc2VydGlvbjogbG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzdHJzdGFydCArIGxvb2thaGVhZCA+IDBcclxuICogT1VUIGFzc2VydGlvbnM6IGF0IGxlYXN0IG9uZSBieXRlIGhhcyBiZWVuIHJlYWQsIG9yIGVvZmlsZSBpcyBzZXQ7XHJcbiAqICAgIGZpbGUgcmVhZHMgYXJlIHBlcmZvcm1lZCBmb3IgYXQgbGVhc3QgdHdvIGJ5dGVzIChyZXF1aXJlZCBmb3IgdGhlXHJcbiAqICAgIHRyYW5zbGF0ZV9lb2wgb3B0aW9uKS5cclxuICovXHJcbnZhciB6aXBfZmlsbF93aW5kb3cgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBuLCBtO1xyXG5cclxuICAgIC8vIEFtb3VudCBvZiBmcmVlIHNwYWNlIGF0IHRoZSBlbmQgb2YgdGhlIHdpbmRvdy5cclxuICAgIHZhciBtb3JlID0gemlwX3dpbmRvd19zaXplIC0gemlwX2xvb2thaGVhZCAtIHppcF9zdHJzdGFydDtcclxuXHJcbiAgICAvKiBJZiB0aGUgd2luZG93IGlzIGFsbW9zdCBmdWxsIGFuZCB0aGVyZSBpcyBpbnN1ZmZpY2llbnQgbG9va2FoZWFkLFxyXG4gICAgICogbW92ZSB0aGUgdXBwZXIgaGFsZiB0byB0aGUgbG93ZXIgb25lIHRvIG1ha2Ugcm9vbSBpbiB0aGUgdXBwZXIgaGFsZi5cclxuICAgICAqL1xyXG4gICAgaWYobW9yZSA9PSAtMSkge1xyXG5cdC8qIFZlcnkgdW5saWtlbHksIGJ1dCBwb3NzaWJsZSBvbiAxNiBiaXQgbWFjaGluZSBpZiBzdHJzdGFydCA9PSAwXHJcbiAgICAgICAgICogYW5kIGxvb2thaGVhZCA9PSAxIChpbnB1dCBkb25lIG9uZSBieXRlIGF0IHRpbWUpXHJcbiAgICAgICAgICovXHJcblx0bW9yZS0tO1xyXG4gICAgfSBlbHNlIGlmKHppcF9zdHJzdGFydCA+PSB6aXBfV1NJWkUgKyB6aXBfTUFYX0RJU1QpIHtcclxuXHQvKiBCeSB0aGUgSU4gYXNzZXJ0aW9uLCB0aGUgd2luZG93IGlzIG5vdCBlbXB0eSBzbyB3ZSBjYW4ndCBjb25mdXNlXHJcbiAgICAgICAgICogbW9yZSA9PSAwIHdpdGggbW9yZSA9PSA2NEsgb24gYSAxNiBiaXQgbWFjaGluZS5cclxuICAgICAgICAgKi9cclxuLy9cdEFzc2VydCh3aW5kb3dfc2l6ZSA9PSAodWxnKTIqV1NJWkUsIFwibm8gc2xpZGluZyB3aXRoIEJJR19NRU1cIik7XHJcblxyXG4vL1x0U3lzdGVtLmFycmF5Y29weSh3aW5kb3csIFdTSVpFLCB3aW5kb3csIDAsIFdTSVpFKTtcclxuXHRmb3IobiA9IDA7IG4gPCB6aXBfV1NJWkU7IG4rKylcclxuXHQgICAgemlwX3dpbmRvd1tuXSA9IHppcF93aW5kb3dbbiArIHppcF9XU0laRV07XHJcbiAgICAgIFxyXG5cdHppcF9tYXRjaF9zdGFydCAtPSB6aXBfV1NJWkU7XHJcblx0emlwX3N0cnN0YXJ0ICAgIC09IHppcF9XU0laRTsgLyogd2Ugbm93IGhhdmUgc3Ryc3RhcnQgPj0gTUFYX0RJU1Q6ICovXHJcblx0emlwX2Jsb2NrX3N0YXJ0IC09IHppcF9XU0laRTtcclxuXHJcblx0Zm9yKG4gPSAwOyBuIDwgemlwX0hBU0hfU0laRTsgbisrKSB7XHJcblx0ICAgIG0gPSB6aXBfaGVhZDEobik7XHJcblx0ICAgIHppcF9oZWFkMihuLCBtID49IHppcF9XU0laRSA/IG0gLSB6aXBfV1NJWkUgOiB6aXBfTklMKTtcclxuXHR9XHJcblx0Zm9yKG4gPSAwOyBuIDwgemlwX1dTSVpFOyBuKyspIHtcclxuXHQgICAgLyogSWYgbiBpcyBub3Qgb24gYW55IGhhc2ggY2hhaW4sIHByZXZbbl0gaXMgZ2FyYmFnZSBidXRcclxuXHQgICAgICogaXRzIHZhbHVlIHdpbGwgbmV2ZXIgYmUgdXNlZC5cclxuXHQgICAgICovXHJcblx0ICAgIG0gPSB6aXBfcHJldltuXTtcclxuXHQgICAgemlwX3ByZXZbbl0gPSAobSA+PSB6aXBfV1NJWkUgPyBtIC0gemlwX1dTSVpFIDogemlwX05JTCk7XHJcblx0fVxyXG5cdG1vcmUgKz0gemlwX1dTSVpFO1xyXG4gICAgfVxyXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgbW9yZSA+PSAyXHJcbiAgICBpZighemlwX2VvZmlsZSkge1xyXG5cdG4gPSB6aXBfcmVhZF9idWZmKHppcF93aW5kb3csIHppcF9zdHJzdGFydCArIHppcF9sb29rYWhlYWQsIG1vcmUpO1xyXG5cdGlmKG4gPD0gMClcclxuXHQgICAgemlwX2VvZmlsZSA9IHRydWU7XHJcblx0ZWxzZVxyXG5cdCAgICB6aXBfbG9va2FoZWFkICs9IG47XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIFByb2Nlc3NlcyBhIG5ldyBpbnB1dCBmaWxlIGFuZCByZXR1cm4gaXRzIGNvbXByZXNzZWQgbGVuZ3RoLiBUaGlzXHJcbiAqIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9ub2YgbWF0Y2hlcyBhbmQgaW5zZXJ0c1xyXG4gKiBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBvbmx5IGZvciB1bm1hdGNoZWQgc3RyaW5ncyBvciBmb3Igc2hvcnRcclxuICogbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxyXG4gKi9cclxudmFyIHppcF9kZWZsYXRlX2Zhc3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHdoaWxlKHppcF9sb29rYWhlYWQgIT0gMCAmJiB6aXBfcWhlYWQgPT0gbnVsbCkge1xyXG5cdHZhciBmbHVzaDsgLy8gc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkXHJcblxyXG5cdC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcclxuXHQgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcclxuXHQgKi9cclxuXHR6aXBfSU5TRVJUX1NUUklORygpO1xyXG5cclxuXHQvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxyXG5cdCAqIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhbHdheXMgbWF0Y2hfbGVuZ3RoIDwgTUlOX01BVENIXHJcblx0ICovXHJcblx0aWYoemlwX2hhc2hfaGVhZCAhPSB6aXBfTklMICYmXHJcblx0ICAgemlwX3N0cnN0YXJ0IC0gemlwX2hhc2hfaGVhZCA8PSB6aXBfTUFYX0RJU1QpIHtcclxuXHQgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcclxuXHQgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXHJcblx0ICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cclxuXHQgICAgICovXHJcblx0ICAgIHppcF9tYXRjaF9sZW5ndGggPSB6aXBfbG9uZ2VzdF9tYXRjaCh6aXBfaGFzaF9oZWFkKTtcclxuXHQgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cclxuXHQgICAgaWYoemlwX21hdGNoX2xlbmd0aCA+IHppcF9sb29rYWhlYWQpXHJcblx0XHR6aXBfbWF0Y2hfbGVuZ3RoID0gemlwX2xvb2thaGVhZDtcclxuXHR9XHJcblx0aWYoemlwX21hdGNoX2xlbmd0aCA+PSB6aXBfTUlOX01BVENIKSB7XHJcbi8vXHQgICAgY2hlY2tfbWF0Y2goc3Ryc3RhcnQsIG1hdGNoX3N0YXJ0LCBtYXRjaF9sZW5ndGgpO1xyXG5cclxuXHQgICAgZmx1c2ggPSB6aXBfY3RfdGFsbHkoemlwX3N0cnN0YXJ0IC0gemlwX21hdGNoX3N0YXJ0LFxyXG5cdFx0XHRcdCB6aXBfbWF0Y2hfbGVuZ3RoIC0gemlwX01JTl9NQVRDSCk7XHJcblx0ICAgIHppcF9sb29rYWhlYWQgLT0gemlwX21hdGNoX2xlbmd0aDtcclxuXHJcblx0ICAgIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcclxuXHQgICAgICogaXMgbm90IHRvbyBsYXJnZS4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cclxuXHQgICAgICovXHJcblx0ICAgIGlmKHppcF9tYXRjaF9sZW5ndGggPD0gemlwX21heF9sYXp5X21hdGNoKSB7XHJcblx0XHR6aXBfbWF0Y2hfbGVuZ3RoLS07IC8vIHN0cmluZyBhdCBzdHJzdGFydCBhbHJlYWR5IGluIGhhc2ggdGFibGVcclxuXHRcdGRvIHtcclxuXHRcdCAgICB6aXBfc3Ryc3RhcnQrKztcclxuXHRcdCAgICB6aXBfSU5TRVJUX1NUUklORygpO1xyXG5cdFx0ICAgIC8qIHN0cnN0YXJ0IG5ldmVyIGV4Y2VlZHMgV1NJWkUtTUFYX01BVENILCBzbyB0aGVyZSBhcmVcclxuXHRcdCAgICAgKiBhbHdheXMgTUlOX01BVENIIGJ5dGVzIGFoZWFkLiBJZiBsb29rYWhlYWQgPCBNSU5fTUFUQ0hcclxuXHRcdCAgICAgKiB0aGVzZSBieXRlcyBhcmUgZ2FyYmFnZSwgYnV0IGl0IGRvZXMgbm90IG1hdHRlciBzaW5jZVxyXG5cdFx0ICAgICAqIHRoZSBuZXh0IGxvb2thaGVhZCBieXRlcyB3aWxsIGJlIGVtaXR0ZWQgYXMgbGl0ZXJhbHMuXHJcblx0XHQgICAgICovXHJcblx0XHR9IHdoaWxlKC0temlwX21hdGNoX2xlbmd0aCAhPSAwKTtcclxuXHRcdHppcF9zdHJzdGFydCsrO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdFx0emlwX3N0cnN0YXJ0ICs9IHppcF9tYXRjaF9sZW5ndGg7XHJcblx0XHR6aXBfbWF0Y2hfbGVuZ3RoID0gMDtcclxuXHRcdHppcF9pbnNfaCA9IHppcF93aW5kb3dbemlwX3N0cnN0YXJ0XSAmIDB4ZmY7XHJcbi8vXHRcdFVQREFURV9IQVNIKGluc19oLCB3aW5kb3dbc3Ryc3RhcnQgKyAxXSk7XHJcblx0XHR6aXBfaW5zX2ggPSAoKHppcF9pbnNfaDw8emlwX0hfU0hJRlQpIF4gKHppcF93aW5kb3dbemlwX3N0cnN0YXJ0ICsgMV0gJiAweGZmKSkgJiB6aXBfSEFTSF9NQVNLO1xyXG5cclxuLy8jaWYgTUlOX01BVENIICE9IDNcclxuLy9cdFx0Q2FsbCBVUERBVEVfSEFTSCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcclxuLy8jZW5kaWZcclxuXHJcblx0ICAgIH1cclxuXHR9IGVsc2Uge1xyXG5cdCAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXHJcblx0ICAgIGZsdXNoID0gemlwX2N0X3RhbGx5KDAsIHppcF93aW5kb3dbemlwX3N0cnN0YXJ0XSAmIDB4ZmYpO1xyXG5cdCAgICB6aXBfbG9va2FoZWFkLS07XHJcblx0ICAgIHppcF9zdHJzdGFydCsrO1xyXG5cdH1cclxuXHRpZihmbHVzaCkge1xyXG5cdCAgICB6aXBfZmx1c2hfYmxvY2soMCk7XHJcblx0ICAgIHppcF9ibG9ja19zdGFydCA9IHppcF9zdHJzdGFydDtcclxuXHR9XHJcblxyXG5cdC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxyXG5cdCAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXHJcblx0ICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXHJcblx0ICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cclxuXHQgKi9cclxuXHR3aGlsZSh6aXBfbG9va2FoZWFkIDwgemlwX01JTl9MT09LQUhFQUQgJiYgIXppcF9lb2ZpbGUpXHJcblx0ICAgIHppcF9maWxsX3dpbmRvdygpO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgemlwX2RlZmxhdGVfYmV0dGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAvKiBQcm9jZXNzIHRoZSBpbnB1dCBibG9jay4gKi9cclxuICAgIHdoaWxlKHppcF9sb29rYWhlYWQgIT0gMCAmJiB6aXBfcWhlYWQgPT0gbnVsbCkge1xyXG5cdC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcclxuXHQgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcclxuXHQgKi9cclxuXHR6aXBfSU5TRVJUX1NUUklORygpO1xyXG5cclxuXHQvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxyXG5cdCAqL1xyXG5cdHppcF9wcmV2X2xlbmd0aCA9IHppcF9tYXRjaF9sZW5ndGg7XHJcblx0emlwX3ByZXZfbWF0Y2ggPSB6aXBfbWF0Y2hfc3RhcnQ7XHJcblx0emlwX21hdGNoX2xlbmd0aCA9IHppcF9NSU5fTUFUQ0ggLSAxO1xyXG5cclxuXHRpZih6aXBfaGFzaF9oZWFkICE9IHppcF9OSUwgJiZcclxuXHQgICB6aXBfcHJldl9sZW5ndGggPCB6aXBfbWF4X2xhenlfbWF0Y2ggJiZcclxuXHQgICB6aXBfc3Ryc3RhcnQgLSB6aXBfaGFzaF9oZWFkIDw9IHppcF9NQVhfRElTVCkge1xyXG5cdCAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xyXG5cdCAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcclxuXHQgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxyXG5cdCAgICAgKi9cclxuXHQgICAgemlwX21hdGNoX2xlbmd0aCA9IHppcF9sb25nZXN0X21hdGNoKHppcF9oYXNoX2hlYWQpO1xyXG5cdCAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xyXG5cdCAgICBpZih6aXBfbWF0Y2hfbGVuZ3RoID4gemlwX2xvb2thaGVhZClcclxuXHRcdHppcF9tYXRjaF9sZW5ndGggPSB6aXBfbG9va2FoZWFkO1xyXG5cclxuXHQgICAgLyogSWdub3JlIGEgbGVuZ3RoIDMgbWF0Y2ggaWYgaXQgaXMgdG9vIGRpc3RhbnQ6ICovXHJcblx0ICAgIGlmKHppcF9tYXRjaF9sZW5ndGggPT0gemlwX01JTl9NQVRDSCAmJlxyXG5cdCAgICAgICB6aXBfc3Ryc3RhcnQgLSB6aXBfbWF0Y2hfc3RhcnQgPiB6aXBfVE9PX0ZBUikge1xyXG5cdFx0LyogSWYgcHJldl9tYXRjaCBpcyBhbHNvIE1JTl9NQVRDSCwgbWF0Y2hfc3RhcnQgaXMgZ2FyYmFnZVxyXG5cdFx0ICogYnV0IHdlIHdpbGwgaWdub3JlIHRoZSBjdXJyZW50IG1hdGNoIGFueXdheS5cclxuXHRcdCAqL1xyXG5cdFx0emlwX21hdGNoX2xlbmd0aC0tO1xyXG5cdCAgICB9XHJcblx0fVxyXG5cdC8qIElmIHRoZXJlIHdhcyBhIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBzdGVwIGFuZCB0aGUgY3VycmVudFxyXG5cdCAqIG1hdGNoIGlzIG5vdCBiZXR0ZXIsIG91dHB1dCB0aGUgcHJldmlvdXMgbWF0Y2g6XHJcblx0ICovXHJcblx0aWYoemlwX3ByZXZfbGVuZ3RoID49IHppcF9NSU5fTUFUQ0ggJiZcclxuXHQgICB6aXBfbWF0Y2hfbGVuZ3RoIDw9IHppcF9wcmV2X2xlbmd0aCkge1xyXG5cdCAgICB2YXIgZmx1c2g7IC8vIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZFxyXG5cclxuLy9cdCAgICBjaGVja19tYXRjaChzdHJzdGFydCAtIDEsIHByZXZfbWF0Y2gsIHByZXZfbGVuZ3RoKTtcclxuXHQgICAgZmx1c2ggPSB6aXBfY3RfdGFsbHkoemlwX3N0cnN0YXJ0IC0gMSAtIHppcF9wcmV2X21hdGNoLFxyXG5cdFx0XHRcdCB6aXBfcHJldl9sZW5ndGggLSB6aXBfTUlOX01BVENIKTtcclxuXHJcblx0ICAgIC8qIEluc2VydCBpbiBoYXNoIHRhYmxlIGFsbCBzdHJpbmdzIHVwIHRvIHRoZSBlbmQgb2YgdGhlIG1hdGNoLlxyXG5cdCAgICAgKiBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC5cclxuXHQgICAgICovXHJcblx0ICAgIHppcF9sb29rYWhlYWQgLT0gemlwX3ByZXZfbGVuZ3RoIC0gMTtcclxuXHQgICAgemlwX3ByZXZfbGVuZ3RoIC09IDI7XHJcblx0ICAgIGRvIHtcclxuXHRcdHppcF9zdHJzdGFydCsrO1xyXG5cdFx0emlwX0lOU0VSVF9TVFJJTkcoKTtcclxuXHRcdC8qIHN0cnN0YXJ0IG5ldmVyIGV4Y2VlZHMgV1NJWkUtTUFYX01BVENILCBzbyB0aGVyZSBhcmVcclxuXHRcdCAqIGFsd2F5cyBNSU5fTUFUQ0ggYnl0ZXMgYWhlYWQuIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSFxyXG5cdFx0ICogdGhlc2UgYnl0ZXMgYXJlIGdhcmJhZ2UsIGJ1dCBpdCBkb2VzIG5vdCBtYXR0ZXIgc2luY2UgdGhlXHJcblx0XHQgKiBuZXh0IGxvb2thaGVhZCBieXRlcyB3aWxsIGFsd2F5cyBiZSBlbWl0dGVkIGFzIGxpdGVyYWxzLlxyXG5cdFx0ICovXHJcblx0ICAgIH0gd2hpbGUoLS16aXBfcHJldl9sZW5ndGggIT0gMCk7XHJcblx0ICAgIHppcF9tYXRjaF9hdmFpbGFibGUgPSAwO1xyXG5cdCAgICB6aXBfbWF0Y2hfbGVuZ3RoID0gemlwX01JTl9NQVRDSCAtIDE7XHJcblx0ICAgIHppcF9zdHJzdGFydCsrO1xyXG5cdCAgICBpZihmbHVzaCkge1xyXG5cdFx0emlwX2ZsdXNoX2Jsb2NrKDApO1xyXG5cdFx0emlwX2Jsb2NrX3N0YXJ0ID0gemlwX3N0cnN0YXJ0O1xyXG5cdCAgICB9XHJcblx0fSBlbHNlIGlmKHppcF9tYXRjaF9hdmFpbGFibGUgIT0gMCkge1xyXG5cdCAgICAvKiBJZiB0aGVyZSB3YXMgbm8gbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHBvc2l0aW9uLCBvdXRwdXQgYVxyXG5cdCAgICAgKiBzaW5nbGUgbGl0ZXJhbC4gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYnV0IHRoZSBjdXJyZW50IG1hdGNoXHJcblx0ICAgICAqIGlzIGxvbmdlciwgdHJ1bmNhdGUgdGhlIHByZXZpb3VzIG1hdGNoIHRvIGEgc2luZ2xlIGxpdGVyYWwuXHJcblx0ICAgICAqL1xyXG5cdCAgICBpZih6aXBfY3RfdGFsbHkoMCwgemlwX3dpbmRvd1t6aXBfc3Ryc3RhcnQgLSAxXSAmIDB4ZmYpKSB7XHJcblx0XHR6aXBfZmx1c2hfYmxvY2soMCk7XHJcblx0XHR6aXBfYmxvY2tfc3RhcnQgPSB6aXBfc3Ryc3RhcnQ7XHJcblx0ICAgIH1cclxuXHQgICAgemlwX3N0cnN0YXJ0Kys7XHJcblx0ICAgIHppcF9sb29rYWhlYWQtLTtcclxuXHR9IGVsc2Uge1xyXG5cdCAgICAvKiBUaGVyZSBpcyBubyBwcmV2aW91cyBtYXRjaCB0byBjb21wYXJlIHdpdGgsIHdhaXQgZm9yXHJcblx0ICAgICAqIHRoZSBuZXh0IHN0ZXAgdG8gZGVjaWRlLlxyXG5cdCAgICAgKi9cclxuXHQgICAgemlwX21hdGNoX2F2YWlsYWJsZSA9IDE7XHJcblx0ICAgIHppcF9zdHJzdGFydCsrO1xyXG5cdCAgICB6aXBfbG9va2FoZWFkLS07XHJcblx0fVxyXG5cclxuXHQvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcclxuXHQgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xyXG5cdCAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxyXG5cdCAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXHJcblx0ICovXHJcblx0d2hpbGUoemlwX2xvb2thaGVhZCA8IHppcF9NSU5fTE9PS0FIRUFEICYmICF6aXBfZW9maWxlKVxyXG5cdCAgICB6aXBfZmlsbF93aW5kb3coKTtcclxuICAgIH1cclxufVxyXG5cclxudmFyIHppcF9pbml0X2RlZmxhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmKHppcF9lb2ZpbGUpXHJcblx0cmV0dXJuO1xyXG4gICAgemlwX2JpX2J1ZiA9IDA7XHJcbiAgICB6aXBfYmlfdmFsaWQgPSAwO1xyXG4gICAgemlwX2N0X2luaXQoKTtcclxuICAgIHppcF9sbV9pbml0KCk7XHJcblxyXG4gICAgemlwX3FoZWFkID0gbnVsbDtcclxuICAgIHppcF9vdXRjbnQgPSAwO1xyXG4gICAgemlwX291dG9mZiA9IDA7XHJcblxyXG4gICAgaWYoemlwX2NvbXByX2xldmVsIDw9IDMpXHJcbiAgICB7XHJcblx0emlwX3ByZXZfbGVuZ3RoID0gemlwX01JTl9NQVRDSCAtIDE7XHJcblx0emlwX21hdGNoX2xlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICB7XHJcblx0emlwX21hdGNoX2xlbmd0aCA9IHppcF9NSU5fTUFUQ0ggLSAxO1xyXG5cdHppcF9tYXRjaF9hdmFpbGFibGUgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHppcF9jb21wbGV0ZSA9IGZhbHNlO1xyXG59XHJcblxyXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5XHJcbiAqIGV2YWx1YXRpb24gZm9yIG1hdGNoZXM6IGEgbWF0Y2ggaXMgZmluYWxseSBhZG9wdGVkIG9ubHkgaWYgdGhlcmUgaXNcclxuICogbm8gYmV0dGVyIG1hdGNoIGF0IHRoZSBuZXh0IHdpbmRvdyBwb3NpdGlvbi5cclxuICovXHJcbnZhciB6aXBfZGVmbGF0ZV9pbnRlcm5hbCA9IGZ1bmN0aW9uKGJ1ZmYsIG9mZiwgYnVmZl9zaXplKSB7XHJcbiAgICB2YXIgbjtcclxuXHJcbiAgICBpZighemlwX2luaXRmbGFnKVxyXG4gICAge1xyXG5cdHppcF9pbml0X2RlZmxhdGUoKTtcclxuXHR6aXBfaW5pdGZsYWcgPSB0cnVlO1xyXG5cdGlmKHppcF9sb29rYWhlYWQgPT0gMCkgeyAvLyBlbXB0eVxyXG5cdCAgICB6aXBfY29tcGxldGUgPSB0cnVlO1xyXG5cdCAgICByZXR1cm4gMDtcclxuXHR9XHJcbiAgICB9XHJcblxyXG4gICAgaWYoKG4gPSB6aXBfcWNvcHkoYnVmZiwgb2ZmLCBidWZmX3NpemUpKSA9PSBidWZmX3NpemUpXHJcblx0cmV0dXJuIGJ1ZmZfc2l6ZTtcclxuXHJcbiAgICBpZih6aXBfY29tcGxldGUpXHJcblx0cmV0dXJuIG47XHJcblxyXG4gICAgaWYoemlwX2NvbXByX2xldmVsIDw9IDMpIC8vIG9wdGltaXplZCBmb3Igc3BlZWRcclxuXHR6aXBfZGVmbGF0ZV9mYXN0KCk7XHJcbiAgICBlbHNlXHJcblx0emlwX2RlZmxhdGVfYmV0dGVyKCk7XHJcbiAgICBpZih6aXBfbG9va2FoZWFkID09IDApIHtcclxuXHRpZih6aXBfbWF0Y2hfYXZhaWxhYmxlICE9IDApXHJcblx0ICAgIHppcF9jdF90YWxseSgwLCB6aXBfd2luZG93W3ppcF9zdHJzdGFydCAtIDFdICYgMHhmZik7XHJcblx0emlwX2ZsdXNoX2Jsb2NrKDEpO1xyXG5cdHppcF9jb21wbGV0ZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbiArIHppcF9xY29weShidWZmLCBuICsgb2ZmLCBidWZmX3NpemUgLSBuKTtcclxufVxyXG5cclxudmFyIHppcF9xY29weSA9IGZ1bmN0aW9uKGJ1ZmYsIG9mZiwgYnVmZl9zaXplKSB7XHJcbiAgICB2YXIgbiwgaSwgajtcclxuXHJcbiAgICBuID0gMDtcclxuICAgIHdoaWxlKHppcF9xaGVhZCAhPSBudWxsICYmIG4gPCBidWZmX3NpemUpXHJcbiAgICB7XHJcblx0aSA9IGJ1ZmZfc2l6ZSAtIG47XHJcblx0aWYoaSA+IHppcF9xaGVhZC5sZW4pXHJcblx0ICAgIGkgPSB6aXBfcWhlYWQubGVuO1xyXG4vLyAgICAgIFN5c3RlbS5hcnJheWNvcHkocWhlYWQucHRyLCBxaGVhZC5vZmYsIGJ1ZmYsIG9mZiArIG4sIGkpO1xyXG5cdGZvcihqID0gMDsgaiA8IGk7IGorKylcclxuXHQgICAgYnVmZltvZmYgKyBuICsgal0gPSB6aXBfcWhlYWQucHRyW3ppcF9xaGVhZC5vZmYgKyBqXTtcclxuXHRcclxuXHR6aXBfcWhlYWQub2ZmICs9IGk7XHJcblx0emlwX3FoZWFkLmxlbiAtPSBpO1xyXG5cdG4gKz0gaTtcclxuXHRpZih6aXBfcWhlYWQubGVuID09IDApIHtcclxuXHQgICAgdmFyIHA7XHJcblx0ICAgIHAgPSB6aXBfcWhlYWQ7XHJcblx0ICAgIHppcF9xaGVhZCA9IHppcF9xaGVhZC5uZXh0O1xyXG5cdCAgICB6aXBfcmV1c2VfcXVldWUocCk7XHJcblx0fVxyXG4gICAgfVxyXG5cclxuICAgIGlmKG4gPT0gYnVmZl9zaXplKVxyXG5cdHJldHVybiBuO1xyXG5cclxuICAgIGlmKHppcF9vdXRvZmYgPCB6aXBfb3V0Y250KSB7XHJcblx0aSA9IGJ1ZmZfc2l6ZSAtIG47XHJcblx0aWYoaSA+IHppcF9vdXRjbnQgLSB6aXBfb3V0b2ZmKVxyXG5cdCAgICBpID0gemlwX291dGNudCAtIHppcF9vdXRvZmY7XHJcblx0Ly8gU3lzdGVtLmFycmF5Y29weShvdXRidWYsIG91dG9mZiwgYnVmZiwgb2ZmICsgbiwgaSk7XHJcblx0Zm9yKGogPSAwOyBqIDwgaTsgaisrKVxyXG5cdCAgICBidWZmW29mZiArIG4gKyBqXSA9IHppcF9vdXRidWZbemlwX291dG9mZiArIGpdO1xyXG5cdHppcF9vdXRvZmYgKz0gaTtcclxuXHRuICs9IGk7XHJcblx0aWYoemlwX291dGNudCA9PSB6aXBfb3V0b2ZmKVxyXG5cdCAgICB6aXBfb3V0Y250ID0gemlwX291dG9mZiA9IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbjtcclxufVxyXG5cclxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogQWxsb2NhdGUgdGhlIG1hdGNoIGJ1ZmZlciwgaW5pdGlhbGl6ZSB0aGUgdmFyaW91cyB0YWJsZXMgYW5kIHNhdmUgdGhlXHJcbiAqIGxvY2F0aW9uIG9mIHRoZSBpbnRlcm5hbCBmaWxlIGF0dHJpYnV0ZSAoYXNjaWkvYmluYXJ5KSBhbmQgbWV0aG9kXHJcbiAqIChERUZMQVRFL1NUT1JFKS5cclxuICovXHJcbnZhciB6aXBfY3RfaW5pdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG47XHQvLyBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHNcclxuICAgIHZhciBiaXRzO1x0Ly8gYml0IGNvdW50ZXJcclxuICAgIHZhciBsZW5ndGg7XHQvLyBsZW5ndGggdmFsdWVcclxuICAgIHZhciBjb2RlO1x0Ly8gY29kZSB2YWx1ZVxyXG4gICAgdmFyIGRpc3Q7XHQvLyBkaXN0YW5jZSBpbmRleFxyXG5cclxuICAgIGlmKHppcF9zdGF0aWNfZHRyZWVbMF0uZGwgIT0gMCkgcmV0dXJuOyAvLyBjdF9pbml0IGFscmVhZHkgY2FsbGVkXHJcblxyXG4gICAgemlwX2xfZGVzYy5keW5fdHJlZVx0XHQ9IHppcF9keW5fbHRyZWU7XHJcbiAgICB6aXBfbF9kZXNjLnN0YXRpY190cmVlXHQ9IHppcF9zdGF0aWNfbHRyZWU7XHJcbiAgICB6aXBfbF9kZXNjLmV4dHJhX2JpdHNcdD0gemlwX2V4dHJhX2xiaXRzO1xyXG4gICAgemlwX2xfZGVzYy5leHRyYV9iYXNlXHQ9IHppcF9MSVRFUkFMUyArIDE7XHJcbiAgICB6aXBfbF9kZXNjLmVsZW1zXHRcdD0gemlwX0xfQ09ERVM7XHJcbiAgICB6aXBfbF9kZXNjLm1heF9sZW5ndGhcdD0gemlwX01BWF9CSVRTO1xyXG4gICAgemlwX2xfZGVzYy5tYXhfY29kZVx0XHQ9IDA7XHJcblxyXG4gICAgemlwX2RfZGVzYy5keW5fdHJlZVx0XHQ9IHppcF9keW5fZHRyZWU7XHJcbiAgICB6aXBfZF9kZXNjLnN0YXRpY190cmVlXHQ9IHppcF9zdGF0aWNfZHRyZWU7XHJcbiAgICB6aXBfZF9kZXNjLmV4dHJhX2JpdHNcdD0gemlwX2V4dHJhX2RiaXRzO1xyXG4gICAgemlwX2RfZGVzYy5leHRyYV9iYXNlXHQ9IDA7XHJcbiAgICB6aXBfZF9kZXNjLmVsZW1zXHRcdD0gemlwX0RfQ09ERVM7XHJcbiAgICB6aXBfZF9kZXNjLm1heF9sZW5ndGhcdD0gemlwX01BWF9CSVRTO1xyXG4gICAgemlwX2RfZGVzYy5tYXhfY29kZVx0XHQ9IDA7XHJcblxyXG4gICAgemlwX2JsX2Rlc2MuZHluX3RyZWVcdD0gemlwX2JsX3RyZWU7XHJcbiAgICB6aXBfYmxfZGVzYy5zdGF0aWNfdHJlZVx0PSBudWxsO1xyXG4gICAgemlwX2JsX2Rlc2MuZXh0cmFfYml0c1x0PSB6aXBfZXh0cmFfYmxiaXRzO1xyXG4gICAgemlwX2JsX2Rlc2MuZXh0cmFfYmFzZVx0PSAwO1xyXG4gICAgemlwX2JsX2Rlc2MuZWxlbXNcdFx0PSB6aXBfQkxfQ09ERVM7XHJcbiAgICB6aXBfYmxfZGVzYy5tYXhfbGVuZ3RoXHQ9IHppcF9NQVhfQkxfQklUUztcclxuICAgIHppcF9ibF9kZXNjLm1heF9jb2RlXHQ9IDA7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBsZW5ndGggKDAuLjI1NSkgLT4gbGVuZ3RoIGNvZGUgKDAuLjI4KVxyXG4gICAgbGVuZ3RoID0gMDtcclxuICAgIGZvcihjb2RlID0gMDsgY29kZSA8IHppcF9MRU5HVEhfQ09ERVMtMTsgY29kZSsrKSB7XHJcblx0emlwX2Jhc2VfbGVuZ3RoW2NvZGVdID0gbGVuZ3RoO1xyXG5cdGZvcihuID0gMDsgbiA8ICgxPDx6aXBfZXh0cmFfbGJpdHNbY29kZV0pOyBuKyspXHJcblx0ICAgIHppcF9sZW5ndGhfY29kZVtsZW5ndGgrK10gPSBjb2RlO1xyXG4gICAgfVxyXG4gICAgLy8gQXNzZXJ0IChsZW5ndGggPT0gMjU2LCBcImN0X2luaXQ6IGxlbmd0aCAhPSAyNTZcIik7XHJcblxyXG4gICAgLyogTm90ZSB0aGF0IHRoZSBsZW5ndGggMjU1IChtYXRjaCBsZW5ndGggMjU4KSBjYW4gYmUgcmVwcmVzZW50ZWRcclxuICAgICAqIGluIHR3byBkaWZmZXJlbnQgd2F5czogY29kZSAyODQgKyA1IGJpdHMgb3IgY29kZSAyODUsIHNvIHdlXHJcbiAgICAgKiBvdmVyd3JpdGUgbGVuZ3RoX2NvZGVbMjU1XSB0byB1c2UgdGhlIGJlc3QgZW5jb2Rpbmc6XHJcbiAgICAgKi9cclxuICAgIHppcF9sZW5ndGhfY29kZVtsZW5ndGgtMV0gPSBjb2RlO1xyXG5cclxuICAgIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgZGlzdCAoMC4uMzJLKSAtPiBkaXN0IGNvZGUgKDAuLjI5KSAqL1xyXG4gICAgZGlzdCA9IDA7XHJcbiAgICBmb3IoY29kZSA9IDAgOyBjb2RlIDwgMTY7IGNvZGUrKykge1xyXG5cdHppcF9iYXNlX2Rpc3RbY29kZV0gPSBkaXN0O1xyXG5cdGZvcihuID0gMDsgbiA8ICgxPDx6aXBfZXh0cmFfZGJpdHNbY29kZV0pOyBuKyspIHtcclxuXHQgICAgemlwX2Rpc3RfY29kZVtkaXN0KytdID0gY29kZTtcclxuXHR9XHJcbiAgICB9XHJcbiAgICAvLyBBc3NlcnQgKGRpc3QgPT0gMjU2LCBcImN0X2luaXQ6IGRpc3QgIT0gMjU2XCIpO1xyXG4gICAgZGlzdCA+Pj0gNzsgLy8gZnJvbSBub3cgb24sIGFsbCBkaXN0YW5jZXMgYXJlIGRpdmlkZWQgYnkgMTI4XHJcbiAgICBmb3IoIDsgY29kZSA8IHppcF9EX0NPREVTOyBjb2RlKyspIHtcclxuXHR6aXBfYmFzZV9kaXN0W2NvZGVdID0gZGlzdCA8PCA3O1xyXG5cdGZvcihuID0gMDsgbiA8ICgxPDwoemlwX2V4dHJhX2RiaXRzW2NvZGVdLTcpKTsgbisrKVxyXG5cdCAgICB6aXBfZGlzdF9jb2RlWzI1NiArIGRpc3QrK10gPSBjb2RlO1xyXG4gICAgfVxyXG4gICAgLy8gQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJjdF9pbml0OiAyNTYrZGlzdCAhPSA1MTJcIik7XHJcblxyXG4gICAgLy8gQ29uc3RydWN0IHRoZSBjb2RlcyBvZiB0aGUgc3RhdGljIGxpdGVyYWwgdHJlZVxyXG4gICAgZm9yKGJpdHMgPSAwOyBiaXRzIDw9IHppcF9NQVhfQklUUzsgYml0cysrKVxyXG5cdHppcF9ibF9jb3VudFtiaXRzXSA9IDA7XHJcbiAgICBuID0gMDtcclxuICAgIHdoaWxlKG4gPD0gMTQzKSB7IHppcF9zdGF0aWNfbHRyZWVbbisrXS5kbCA9IDg7IHppcF9ibF9jb3VudFs4XSsrOyB9XHJcbiAgICB3aGlsZShuIDw9IDI1NSkgeyB6aXBfc3RhdGljX2x0cmVlW24rK10uZGwgPSA5OyB6aXBfYmxfY291bnRbOV0rKzsgfVxyXG4gICAgd2hpbGUobiA8PSAyNzkpIHsgemlwX3N0YXRpY19sdHJlZVtuKytdLmRsID0gNzsgemlwX2JsX2NvdW50WzddKys7IH1cclxuICAgIHdoaWxlKG4gPD0gMjg3KSB7IHppcF9zdGF0aWNfbHRyZWVbbisrXS5kbCA9IDg7IHppcF9ibF9jb3VudFs4XSsrOyB9XHJcbiAgICAvKiBDb2RlcyAyODYgYW5kIDI4NyBkbyBub3QgZXhpc3QsIGJ1dCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGVcclxuICAgICAqIHRyZWUgY29uc3RydWN0aW9uIHRvIGdldCBhIGNhbm9uaWNhbCBIdWZmbWFuIHRyZWUgKGxvbmdlc3QgY29kZVxyXG4gICAgICogYWxsIG9uZXMpXHJcbiAgICAgKi9cclxuICAgIHppcF9nZW5fY29kZXMoemlwX3N0YXRpY19sdHJlZSwgemlwX0xfQ09ERVMgKyAxKTtcclxuXHJcbiAgICAvKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUgaXMgdHJpdmlhbDogKi9cclxuICAgIGZvcihuID0gMDsgbiA8IHppcF9EX0NPREVTOyBuKyspIHtcclxuXHR6aXBfc3RhdGljX2R0cmVlW25dLmRsID0gNTtcclxuXHR6aXBfc3RhdGljX2R0cmVlW25dLmZjID0gemlwX2JpX3JldmVyc2UobiwgNSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgZmlyc3QgYmxvY2sgb2YgdGhlIGZpcnN0IGZpbGU6XHJcbiAgICB6aXBfaW5pdF9ibG9jaygpO1xyXG59XHJcblxyXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGJsb2NrLlxyXG4gKi9cclxudmFyIHppcF9pbml0X2Jsb2NrID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgbjsgLy8gaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzXHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgdHJlZXMuXHJcbiAgICBmb3IobiA9IDA7IG4gPCB6aXBfTF9DT0RFUzsgIG4rKykgemlwX2R5bl9sdHJlZVtuXS5mYyA9IDA7XHJcbiAgICBmb3IobiA9IDA7IG4gPCB6aXBfRF9DT0RFUzsgIG4rKykgemlwX2R5bl9kdHJlZVtuXS5mYyA9IDA7XHJcbiAgICBmb3IobiA9IDA7IG4gPCB6aXBfQkxfQ09ERVM7IG4rKykgemlwX2JsX3RyZWVbbl0uZmMgPSAwO1xyXG5cclxuICAgIHppcF9keW5fbHRyZWVbemlwX0VORF9CTE9DS10uZmMgPSAxO1xyXG4gICAgemlwX29wdF9sZW4gPSB6aXBfc3RhdGljX2xlbiA9IDA7XHJcbiAgICB6aXBfbGFzdF9saXQgPSB6aXBfbGFzdF9kaXN0ID0gemlwX2xhc3RfZmxhZ3MgPSAwO1xyXG4gICAgemlwX2ZsYWdzID0gMDtcclxuICAgIHppcF9mbGFnX2JpdCA9IDE7XHJcbn1cclxuXHJcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIFJlc3RvcmUgdGhlIGhlYXAgcHJvcGVydHkgYnkgbW92aW5nIGRvd24gdGhlIHRyZWUgc3RhcnRpbmcgYXQgbm9kZSBrLFxyXG4gKiBleGNoYW5naW5nIGEgbm9kZSB3aXRoIHRoZSBzbWFsbGVzdCBvZiBpdHMgdHdvIHNvbnMgaWYgbmVjZXNzYXJ5LCBzdG9wcGluZ1xyXG4gKiB3aGVuIHRoZSBoZWFwIHByb3BlcnR5IGlzIHJlLWVzdGFibGlzaGVkIChlYWNoIGZhdGhlciBzbWFsbGVyIHRoYW4gaXRzXHJcbiAqIHR3byBzb25zKS5cclxuICovXHJcbnZhciB6aXBfcHFkb3duaGVhcCA9IGZ1bmN0aW9uKFxyXG4gICAgdHJlZSxcdC8vIHRoZSB0cmVlIHRvIHJlc3RvcmVcclxuICAgIGspIHtcdC8vIG5vZGUgdG8gbW92ZSBkb3duXHJcbiAgICB2YXIgdiA9IHppcF9oZWFwW2tdO1xyXG4gICAgdmFyIGogPSBrIDw8IDE7XHQvLyBsZWZ0IHNvbiBvZiBrXHJcblxyXG4gICAgd2hpbGUoaiA8PSB6aXBfaGVhcF9sZW4pIHtcclxuXHQvLyBTZXQgaiB0byB0aGUgc21hbGxlc3Qgb2YgdGhlIHR3byBzb25zOlxyXG5cdGlmKGogPCB6aXBfaGVhcF9sZW4gJiZcclxuXHQgICB6aXBfU01BTExFUih0cmVlLCB6aXBfaGVhcFtqICsgMV0sIHppcF9oZWFwW2pdKSlcclxuXHQgICAgaisrO1xyXG5cclxuXHQvLyBFeGl0IGlmIHYgaXMgc21hbGxlciB0aGFuIGJvdGggc29uc1xyXG5cdGlmKHppcF9TTUFMTEVSKHRyZWUsIHYsIHppcF9oZWFwW2pdKSlcclxuXHQgICAgYnJlYWs7XHJcblxyXG5cdC8vIEV4Y2hhbmdlIHYgd2l0aCB0aGUgc21hbGxlc3Qgc29uXHJcblx0emlwX2hlYXBba10gPSB6aXBfaGVhcFtqXTtcclxuXHRrID0gajtcclxuXHJcblx0Ly8gQW5kIGNvbnRpbnVlIGRvd24gdGhlIHRyZWUsIHNldHRpbmcgaiB0byB0aGUgbGVmdCBzb24gb2Yga1xyXG5cdGogPDw9IDE7XHJcbiAgICB9XHJcbiAgICB6aXBfaGVhcFtrXSA9IHY7XHJcbn1cclxuXHJcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIENvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgZm9yIGEgdHJlZSBhbmQgdXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoXHJcbiAqIGZvciB0aGUgY3VycmVudCBibG9jay5cclxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LCBoZWFwW2hlYXBfbWF4XSBhbmRcclxuICogICAgYWJvdmUgYXJlIHRoZSB0cmVlIG5vZGVzIHNvcnRlZCBieSBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cclxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZCBsZW4gaXMgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGgsIHRoZVxyXG4gKiAgICAgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGZyZXF1ZW5jaWVzIGZvciBlYWNoIGJpdCBsZW5ndGguXHJcbiAqICAgICBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpcyBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXNcclxuICogICAgIG5vdCBudWxsLlxyXG4gKi9cclxudmFyIHppcF9nZW5fYml0bGVuID0gZnVuY3Rpb24oZGVzYykgeyAvLyB0aGUgdHJlZSBkZXNjcmlwdG9yXHJcbiAgICB2YXIgdHJlZVx0XHQ9IGRlc2MuZHluX3RyZWU7XHJcbiAgICB2YXIgZXh0cmFcdFx0PSBkZXNjLmV4dHJhX2JpdHM7XHJcbiAgICB2YXIgYmFzZVx0XHQ9IGRlc2MuZXh0cmFfYmFzZTtcclxuICAgIHZhciBtYXhfY29kZVx0PSBkZXNjLm1heF9jb2RlO1xyXG4gICAgdmFyIG1heF9sZW5ndGhcdD0gZGVzYy5tYXhfbGVuZ3RoO1xyXG4gICAgdmFyIHN0cmVlXHRcdD0gZGVzYy5zdGF0aWNfdHJlZTtcclxuICAgIHZhciBoO1x0XHQvLyBoZWFwIGluZGV4XHJcbiAgICB2YXIgbiwgbTtcdFx0Ly8gaXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGVsZW1lbnRzXHJcbiAgICB2YXIgYml0cztcdFx0Ly8gYml0IGxlbmd0aFxyXG4gICAgdmFyIHhiaXRzO1x0XHQvLyBleHRyYSBiaXRzXHJcbiAgICB2YXIgZjtcdFx0Ly8gZnJlcXVlbmN5XHJcbiAgICB2YXIgb3ZlcmZsb3cgPSAwO1x0Ly8gbnVtYmVyIG9mIGVsZW1lbnRzIHdpdGggYml0IGxlbmd0aCB0b28gbGFyZ2VcclxuXHJcbiAgICBmb3IoYml0cyA9IDA7IGJpdHMgPD0gemlwX01BWF9CSVRTOyBiaXRzKyspXHJcblx0emlwX2JsX2NvdW50W2JpdHNdID0gMDtcclxuXHJcbiAgICAvKiBJbiBhIGZpcnN0IHBhc3MsIGNvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgKHdoaWNoIG1heVxyXG4gICAgICogb3ZlcmZsb3cgaW4gdGhlIGNhc2Ugb2YgdGhlIGJpdCBsZW5ndGggdHJlZSkuXHJcbiAgICAgKi9cclxuICAgIHRyZWVbemlwX2hlYXBbemlwX2hlYXBfbWF4XV0uZGwgPSAwOyAvLyByb290IG9mIHRoZSBoZWFwXHJcblxyXG4gICAgZm9yKGggPSB6aXBfaGVhcF9tYXggKyAxOyBoIDwgemlwX0hFQVBfU0laRTsgaCsrKSB7XHJcblx0biA9IHppcF9oZWFwW2hdO1xyXG5cdGJpdHMgPSB0cmVlW3RyZWVbbl0uZGxdLmRsICsgMTtcclxuXHRpZihiaXRzID4gbWF4X2xlbmd0aCkge1xyXG5cdCAgICBiaXRzID0gbWF4X2xlbmd0aDtcclxuXHQgICAgb3ZlcmZsb3crKztcclxuXHR9XHJcblx0dHJlZVtuXS5kbCA9IGJpdHM7XHJcblx0Ly8gV2Ugb3ZlcndyaXRlIHRyZWVbbl0uZGwgd2hpY2ggaXMgbm8gbG9uZ2VyIG5lZWRlZFxyXG5cclxuXHRpZihuID4gbWF4X2NvZGUpXHJcblx0ICAgIGNvbnRpbnVlOyAvLyBub3QgYSBsZWFmIG5vZGVcclxuXHJcblx0emlwX2JsX2NvdW50W2JpdHNdKys7XHJcblx0eGJpdHMgPSAwO1xyXG5cdGlmKG4gPj0gYmFzZSlcclxuXHQgICAgeGJpdHMgPSBleHRyYVtuIC0gYmFzZV07XHJcblx0ZiA9IHRyZWVbbl0uZmM7XHJcblx0emlwX29wdF9sZW4gKz0gZiAqIChiaXRzICsgeGJpdHMpO1xyXG5cdGlmKHN0cmVlICE9IG51bGwpXHJcblx0ICAgIHppcF9zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbl0uZGwgKyB4Yml0cyk7XHJcbiAgICB9XHJcbiAgICBpZihvdmVyZmxvdyA9PSAwKVxyXG5cdHJldHVybjtcclxuXHJcbiAgICAvLyBUaGlzIGhhcHBlbnMgZm9yIGV4YW1wbGUgb24gb2JqMiBhbmQgcGljIG9mIHRoZSBDYWxnYXJ5IGNvcnB1c1xyXG5cclxuICAgIC8vIEZpbmQgdGhlIGZpcnN0IGJpdCBsZW5ndGggd2hpY2ggY291bGQgaW5jcmVhc2U6XHJcbiAgICBkbyB7XHJcblx0Yml0cyA9IG1heF9sZW5ndGggLSAxO1xyXG5cdHdoaWxlKHppcF9ibF9jb3VudFtiaXRzXSA9PSAwKVxyXG5cdCAgICBiaXRzLS07XHJcblx0emlwX2JsX2NvdW50W2JpdHNdLS07XHRcdC8vIG1vdmUgb25lIGxlYWYgZG93biB0aGUgdHJlZVxyXG5cdHppcF9ibF9jb3VudFtiaXRzICsgMV0gKz0gMjtcdC8vIG1vdmUgb25lIG92ZXJmbG93IGl0ZW0gYXMgaXRzIGJyb3RoZXJcclxuXHR6aXBfYmxfY291bnRbbWF4X2xlbmd0aF0tLTtcclxuXHQvKiBUaGUgYnJvdGhlciBvZiB0aGUgb3ZlcmZsb3cgaXRlbSBhbHNvIG1vdmVzIG9uZSBzdGVwIHVwLFxyXG5cdCAqIGJ1dCB0aGlzIGRvZXMgbm90IGFmZmVjdCBibF9jb3VudFttYXhfbGVuZ3RoXVxyXG5cdCAqL1xyXG5cdG92ZXJmbG93IC09IDI7XHJcbiAgICB9IHdoaWxlKG92ZXJmbG93ID4gMCk7XHJcblxyXG4gICAgLyogTm93IHJlY29tcHV0ZSBhbGwgYml0IGxlbmd0aHMsIHNjYW5uaW5nIGluIGluY3JlYXNpbmcgZnJlcXVlbmN5LlxyXG4gICAgICogaCBpcyBzdGlsbCBlcXVhbCB0byBIRUFQX1NJWkUuIChJdCBpcyBzaW1wbGVyIHRvIHJlY29uc3RydWN0IGFsbFxyXG4gICAgICogbGVuZ3RocyBpbnN0ZWFkIG9mIGZpeGluZyBvbmx5IHRoZSB3cm9uZyBvbmVzLiBUaGlzIGlkZWEgaXMgdGFrZW5cclxuICAgICAqIGZyb20gJ2FyJyB3cml0dGVuIGJ5IEhhcnVoaWtvIE9rdW11cmEuKVxyXG4gICAgICovXHJcbiAgICBmb3IoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT0gMDsgYml0cy0tKSB7XHJcblx0biA9IHppcF9ibF9jb3VudFtiaXRzXTtcclxuXHR3aGlsZShuICE9IDApIHtcclxuXHQgICAgbSA9IHppcF9oZWFwWy0taF07XHJcblx0ICAgIGlmKG0gPiBtYXhfY29kZSlcclxuXHRcdGNvbnRpbnVlO1xyXG5cdCAgICBpZih0cmVlW21dLmRsICE9IGJpdHMpIHtcclxuXHRcdHppcF9vcHRfbGVuICs9IChiaXRzIC0gdHJlZVttXS5kbCkgKiB0cmVlW21dLmZjO1xyXG5cdFx0dHJlZVttXS5mYyA9IGJpdHM7XHJcblx0ICAgIH1cclxuXHQgICAgbi0tO1xyXG5cdH1cclxuICAgIH1cclxufVxyXG5cclxuICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAqIEdlbmVyYXRlIHRoZSBjb2RlcyBmb3IgYSBnaXZlbiB0cmVlIGFuZCBiaXQgY291bnRzICh3aGljaCBuZWVkIG5vdCBiZVxyXG4gICAqIG9wdGltYWwpLlxyXG4gICAqIElOIGFzc2VydGlvbjogdGhlIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBiaXQgbGVuZ3RoIHN0YXRpc3RpY3MgZm9yXHJcbiAgICogdGhlIGdpdmVuIHRyZWUgYW5kIHRoZSBmaWVsZCBsZW4gaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cclxuICAgKiBPVVQgYXNzZXJ0aW9uOiB0aGUgZmllbGQgY29kZSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzIG9mIG5vblxyXG4gICAqICAgICB6ZXJvIGNvZGUgbGVuZ3RoLlxyXG4gICAqL1xyXG52YXIgemlwX2dlbl9jb2RlcyA9IGZ1bmN0aW9uKHRyZWUsXHQvLyB0aGUgdHJlZSB0byBkZWNvcmF0ZVxyXG5cdFx0ICAgbWF4X2NvZGUpIHtcdC8vIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeVxyXG4gICAgdmFyIG5leHRfY29kZSA9IG5ldyBBcnJheSh6aXBfTUFYX0JJVFMrMSk7IC8vIG5leHQgY29kZSB2YWx1ZSBmb3IgZWFjaCBiaXQgbGVuZ3RoXHJcbiAgICB2YXIgY29kZSA9IDA7XHRcdC8vIHJ1bm5pbmcgY29kZSB2YWx1ZVxyXG4gICAgdmFyIGJpdHM7XHRcdFx0Ly8gYml0IGluZGV4XHJcbiAgICB2YXIgbjtcdFx0XHQvLyBjb2RlIGluZGV4XHJcblxyXG4gICAgLyogVGhlIGRpc3RyaWJ1dGlvbiBjb3VudHMgYXJlIGZpcnN0IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNvZGUgdmFsdWVzXHJcbiAgICAgKiB3aXRob3V0IGJpdCByZXZlcnNhbC5cclxuICAgICAqL1xyXG4gICAgZm9yKGJpdHMgPSAxOyBiaXRzIDw9IHppcF9NQVhfQklUUzsgYml0cysrKSB7XHJcblx0Y29kZSA9ICgoY29kZSArIHppcF9ibF9jb3VudFtiaXRzLTFdKSA8PCAxKTtcclxuXHRuZXh0X2NvZGVbYml0c10gPSBjb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qIENoZWNrIHRoYXQgdGhlIGJpdCBjb3VudHMgaW4gYmxfY291bnQgYXJlIGNvbnNpc3RlbnQuIFRoZSBsYXN0IGNvZGVcclxuICAgICAqIG11c3QgYmUgYWxsIG9uZXMuXHJcbiAgICAgKi9cclxuLy8gICAgQXNzZXJ0IChjb2RlICsgZW5jb2Rlci0+YmxfY291bnRbTUFYX0JJVFNdLTEgPT0gKDE8PE1BWF9CSVRTKS0xLFxyXG4vL1x0ICAgIFwiaW5jb25zaXN0ZW50IGJpdCBjb3VudHNcIik7XHJcbi8vICAgIFRyYWNldigoc3RkZXJyLFwiXFxuZ2VuX2NvZGVzOiBtYXhfY29kZSAlZCBcIiwgbWF4X2NvZGUpKTtcclxuXHJcbiAgICBmb3IobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xyXG5cdHZhciBsZW4gPSB0cmVlW25dLmRsO1xyXG5cdGlmKGxlbiA9PSAwKVxyXG5cdCAgICBjb250aW51ZTtcclxuXHQvLyBOb3cgcmV2ZXJzZSB0aGUgYml0c1xyXG5cdHRyZWVbbl0uZmMgPSB6aXBfYmlfcmV2ZXJzZShuZXh0X2NvZGVbbGVuXSsrLCBsZW4pO1xyXG5cclxuLy8gICAgICBUcmFjZWModHJlZSAhPSBzdGF0aWNfbHRyZWUsIChzdGRlcnIsXCJcXG5uICUzZCAlYyBsICUyZCBjICU0eCAoJXgpIFwiLFxyXG4vL1x0ICBuLCAoaXNncmFwaChuKSA/IG4gOiAnICcpLCBsZW4sIHRyZWVbbl0uZmMsIG5leHRfY29kZVtsZW5dLTEpKTtcclxuICAgIH1cclxufVxyXG5cclxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogQ29uc3RydWN0IG9uZSBIdWZmbWFuIHRyZWUgYW5kIGFzc2lnbnMgdGhlIGNvZGUgYml0IHN0cmluZ3MgYW5kIGxlbmd0aHMuXHJcbiAqIFVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aCBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXHJcbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkIGZyZXEgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cclxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZHMgbGVuIGFuZCBjb2RlIGFyZSBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aFxyXG4gKiAgICAgYW5kIGNvcnJlc3BvbmRpbmcgY29kZS4gVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXNcclxuICogICAgIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpcyBub3QgbnVsbC4gVGhlIGZpZWxkIG1heF9jb2RlIGlzIHNldC5cclxuICovXHJcbnZhciB6aXBfYnVpbGRfdHJlZSA9IGZ1bmN0aW9uKGRlc2MpIHsgLy8gdGhlIHRyZWUgZGVzY3JpcHRvclxyXG4gICAgdmFyIHRyZWVcdD0gZGVzYy5keW5fdHJlZTtcclxuICAgIHZhciBzdHJlZVx0PSBkZXNjLnN0YXRpY190cmVlO1xyXG4gICAgdmFyIGVsZW1zXHQ9IGRlc2MuZWxlbXM7XHJcbiAgICB2YXIgbiwgbTtcdFx0Ly8gaXRlcmF0ZSBvdmVyIGhlYXAgZWxlbWVudHNcclxuICAgIHZhciBtYXhfY29kZSA9IC0xO1x0Ly8gbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5XHJcbiAgICB2YXIgbm9kZSA9IGVsZW1zO1x0Ly8gbmV4dCBpbnRlcm5hbCBub2RlIG9mIHRoZSB0cmVlXHJcblxyXG4gICAgLyogQ29uc3RydWN0IHRoZSBpbml0aWFsIGhlYXAsIHdpdGggbGVhc3QgZnJlcXVlbnQgZWxlbWVudCBpblxyXG4gICAgICogaGVhcFtTTUFMTEVTVF0uIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uXHJcbiAgICAgKiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxyXG4gICAgICovXHJcbiAgICB6aXBfaGVhcF9sZW4gPSAwO1xyXG4gICAgemlwX2hlYXBfbWF4ID0gemlwX0hFQVBfU0laRTtcclxuXHJcbiAgICBmb3IobiA9IDA7IG4gPCBlbGVtczsgbisrKSB7XHJcblx0aWYodHJlZVtuXS5mYyAhPSAwKSB7XHJcblx0ICAgIHppcF9oZWFwWysremlwX2hlYXBfbGVuXSA9IG1heF9jb2RlID0gbjtcclxuXHQgICAgemlwX2RlcHRoW25dID0gMDtcclxuXHR9IGVsc2VcclxuXHQgICAgdHJlZVtuXS5kbCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyogVGhlIHBremlwIGZvcm1hdCByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IG9uZSBkaXN0YW5jZSBjb2RlIGV4aXN0cyxcclxuICAgICAqIGFuZCB0aGF0IGF0IGxlYXN0IG9uZSBiaXQgc2hvdWxkIGJlIHNlbnQgZXZlbiBpZiB0aGVyZSBpcyBvbmx5IG9uZVxyXG4gICAgICogcG9zc2libGUgY29kZS4gU28gdG8gYXZvaWQgc3BlY2lhbCBjaGVja3MgbGF0ZXIgb24gd2UgZm9yY2UgYXQgbGVhc3RcclxuICAgICAqIHR3byBjb2RlcyBvZiBub24gemVybyBmcmVxdWVuY3kuXHJcbiAgICAgKi9cclxuICAgIHdoaWxlKHppcF9oZWFwX2xlbiA8IDIpIHtcclxuXHR2YXIgeG5ldyA9IHppcF9oZWFwWysremlwX2hlYXBfbGVuXSA9IChtYXhfY29kZSA8IDIgPyArK21heF9jb2RlIDogMCk7XHJcblx0dHJlZVt4bmV3XS5mYyA9IDE7XHJcblx0emlwX2RlcHRoW3huZXddID0gMDtcclxuXHR6aXBfb3B0X2xlbi0tO1xyXG5cdGlmKHN0cmVlICE9IG51bGwpXHJcblx0ICAgIHppcF9zdGF0aWNfbGVuIC09IHN0cmVlW3huZXddLmRsO1xyXG5cdC8vIG5ldyBpcyAwIG9yIDEgc28gaXQgZG9lcyBub3QgaGF2ZSBleHRyYSBiaXRzXHJcbiAgICB9XHJcbiAgICBkZXNjLm1heF9jb2RlID0gbWF4X2NvZGU7XHJcblxyXG4gICAgLyogVGhlIGVsZW1lbnRzIGhlYXBbaGVhcF9sZW4vMisxIC4uIGhlYXBfbGVuXSBhcmUgbGVhdmVzIG9mIHRoZSB0cmVlLFxyXG4gICAgICogZXN0YWJsaXNoIHN1Yi1oZWFwcyBvZiBpbmNyZWFzaW5nIGxlbmd0aHM6XHJcbiAgICAgKi9cclxuICAgIGZvcihuID0gemlwX2hlYXBfbGVuID4+IDE7IG4gPj0gMTsgbi0tKVxyXG5cdHppcF9wcWRvd25oZWFwKHRyZWUsIG4pO1xyXG5cclxuICAgIC8qIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGJ5IHJlcGVhdGVkbHkgY29tYmluaW5nIHRoZSBsZWFzdCB0d29cclxuICAgICAqIGZyZXF1ZW50IG5vZGVzLlxyXG4gICAgICovXHJcbiAgICBkbyB7XHJcblx0biA9IHppcF9oZWFwW3ppcF9TTUFMTEVTVF07XHJcblx0emlwX2hlYXBbemlwX1NNQUxMRVNUXSA9IHppcF9oZWFwW3ppcF9oZWFwX2xlbi0tXTtcclxuXHR6aXBfcHFkb3duaGVhcCh0cmVlLCB6aXBfU01BTExFU1QpO1xyXG5cclxuXHRtID0gemlwX2hlYXBbemlwX1NNQUxMRVNUXTsgIC8vIG0gPSBub2RlIG9mIG5leHQgbGVhc3QgZnJlcXVlbmN5XHJcblxyXG5cdC8vIGtlZXAgdGhlIG5vZGVzIHNvcnRlZCBieSBmcmVxdWVuY3lcclxuXHR6aXBfaGVhcFstLXppcF9oZWFwX21heF0gPSBuO1xyXG5cdHppcF9oZWFwWy0temlwX2hlYXBfbWF4XSA9IG07XHJcblxyXG5cdC8vIENyZWF0ZSBhIG5ldyBub2RlIGZhdGhlciBvZiBuIGFuZCBtXHJcblx0dHJlZVtub2RlXS5mYyA9IHRyZWVbbl0uZmMgKyB0cmVlW21dLmZjO1xyXG4vL1x0ZGVwdGhbbm9kZV0gPSAoY2hhcikoTUFYKGRlcHRoW25dLCBkZXB0aFttXSkgKyAxKTtcclxuXHRpZih6aXBfZGVwdGhbbl0gPiB6aXBfZGVwdGhbbV0gKyAxKVxyXG5cdCAgICB6aXBfZGVwdGhbbm9kZV0gPSB6aXBfZGVwdGhbbl07XHJcblx0ZWxzZVxyXG5cdCAgICB6aXBfZGVwdGhbbm9kZV0gPSB6aXBfZGVwdGhbbV0gKyAxO1xyXG5cdHRyZWVbbl0uZGwgPSB0cmVlW21dLmRsID0gbm9kZTtcclxuXHJcblx0Ly8gYW5kIGluc2VydCB0aGUgbmV3IG5vZGUgaW4gdGhlIGhlYXBcclxuXHR6aXBfaGVhcFt6aXBfU01BTExFU1RdID0gbm9kZSsrO1xyXG5cdHppcF9wcWRvd25oZWFwKHRyZWUsIHppcF9TTUFMTEVTVCk7XHJcblxyXG4gICAgfSB3aGlsZSh6aXBfaGVhcF9sZW4gPj0gMik7XHJcblxyXG4gICAgemlwX2hlYXBbLS16aXBfaGVhcF9tYXhdID0gemlwX2hlYXBbemlwX1NNQUxMRVNUXTtcclxuXHJcbiAgICAvKiBBdCB0aGlzIHBvaW50LCB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LiBXZSBjYW4gbm93XHJcbiAgICAgKiBnZW5lcmF0ZSB0aGUgYml0IGxlbmd0aHMuXHJcbiAgICAgKi9cclxuICAgIHppcF9nZW5fYml0bGVuKGRlc2MpO1xyXG5cclxuICAgIC8vIFRoZSBmaWVsZCBsZW4gaXMgbm93IHNldCwgd2UgY2FuIGdlbmVyYXRlIHRoZSBiaXQgY29kZXNcclxuICAgIHppcF9nZW5fY29kZXModHJlZSwgbWF4X2NvZGUpO1xyXG59XHJcblxyXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBTY2FuIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIHRvIGRldGVybWluZSB0aGUgZnJlcXVlbmNpZXMgb2YgdGhlIGNvZGVzXHJcbiAqIGluIHRoZSBiaXQgbGVuZ3RoIHRyZWUuIFVwZGF0ZXMgb3B0X2xlbiB0byB0YWtlIGludG8gYWNjb3VudCB0aGUgcmVwZWF0XHJcbiAqIGNvdW50cy4gKFRoZSBjb250cmlidXRpb24gb2YgdGhlIGJpdCBsZW5ndGggY29kZXMgd2lsbCBiZSBhZGRlZCBsYXRlclxyXG4gKiBkdXJpbmcgdGhlIGNvbnN0cnVjdGlvbiBvZiBibF90cmVlLilcclxuICovXHJcbnZhciB6aXBfc2Nhbl90cmVlID0gZnVuY3Rpb24odHJlZSwvLyB0aGUgdHJlZSB0byBiZSBzY2FubmVkXHJcblx0XHQgICAgICAgbWF4X2NvZGUpIHsgIC8vIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeVxyXG4gICAgdmFyIG47XHRcdFx0Ly8gaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50c1xyXG4gICAgdmFyIHByZXZsZW4gPSAtMTtcdFx0Ly8gbGFzdCBlbWl0dGVkIGxlbmd0aFxyXG4gICAgdmFyIGN1cmxlbjtcdFx0XHQvLyBsZW5ndGggb2YgY3VycmVudCBjb2RlXHJcbiAgICB2YXIgbmV4dGxlbiA9IHRyZWVbMF0uZGw7XHQvLyBsZW5ndGggb2YgbmV4dCBjb2RlXHJcbiAgICB2YXIgY291bnQgPSAwO1x0XHQvLyByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZVxyXG4gICAgdmFyIG1heF9jb3VudCA9IDc7XHRcdC8vIG1heCByZXBlYXQgY291bnRcclxuICAgIHZhciBtaW5fY291bnQgPSA0O1x0XHQvLyBtaW4gcmVwZWF0IGNvdW50XHJcblxyXG4gICAgaWYobmV4dGxlbiA9PSAwKSB7XHJcblx0bWF4X2NvdW50ID0gMTM4O1xyXG5cdG1pbl9jb3VudCA9IDM7XHJcbiAgICB9XHJcbiAgICB0cmVlW21heF9jb2RlICsgMV0uZGwgPSAweGZmZmY7IC8vIGd1YXJkXHJcblxyXG4gICAgZm9yKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcclxuXHRjdXJsZW4gPSBuZXh0bGVuO1xyXG5cdG5leHRsZW4gPSB0cmVlW24gKyAxXS5kbDtcclxuXHRpZigrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PSBuZXh0bGVuKVxyXG5cdCAgICBjb250aW51ZTtcclxuXHRlbHNlIGlmKGNvdW50IDwgbWluX2NvdW50KVxyXG5cdCAgICB6aXBfYmxfdHJlZVtjdXJsZW5dLmZjICs9IGNvdW50O1xyXG5cdGVsc2UgaWYoY3VybGVuICE9IDApIHtcclxuXHQgICAgaWYoY3VybGVuICE9IHByZXZsZW4pXHJcblx0XHR6aXBfYmxfdHJlZVtjdXJsZW5dLmZjKys7XHJcblx0ICAgIHppcF9ibF90cmVlW3ppcF9SRVBfM182XS5mYysrO1xyXG5cdH0gZWxzZSBpZihjb3VudCA8PSAxMClcclxuXHQgICAgemlwX2JsX3RyZWVbemlwX1JFUFpfM18xMF0uZmMrKztcclxuXHRlbHNlXHJcblx0ICAgIHppcF9ibF90cmVlW3ppcF9SRVBaXzExXzEzOF0uZmMrKztcclxuXHRjb3VudCA9IDA7IHByZXZsZW4gPSBjdXJsZW47XHJcblx0aWYobmV4dGxlbiA9PSAwKSB7XHJcblx0ICAgIG1heF9jb3VudCA9IDEzODtcclxuXHQgICAgbWluX2NvdW50ID0gMztcclxuXHR9IGVsc2UgaWYoY3VybGVuID09IG5leHRsZW4pIHtcclxuXHQgICAgbWF4X2NvdW50ID0gNjtcclxuXHQgICAgbWluX2NvdW50ID0gMztcclxuXHR9IGVsc2Uge1xyXG5cdCAgICBtYXhfY291bnQgPSA3O1xyXG5cdCAgICBtaW5fY291bnQgPSA0O1xyXG5cdH1cclxuICAgIH1cclxufVxyXG5cclxuICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAqIFNlbmQgYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgaW4gY29tcHJlc3NlZCBmb3JtLCB1c2luZyB0aGUgY29kZXMgaW5cclxuICAgKiBibF90cmVlLlxyXG4gICAqL1xyXG52YXIgemlwX3NlbmRfdHJlZSA9IGZ1bmN0aW9uKHRyZWUsIC8vIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWRcclxuXHRcdCAgIG1heF9jb2RlKSB7IC8vIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeVxyXG4gICAgdmFyIG47XHRcdFx0Ly8gaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50c1xyXG4gICAgdmFyIHByZXZsZW4gPSAtMTtcdFx0Ly8gbGFzdCBlbWl0dGVkIGxlbmd0aFxyXG4gICAgdmFyIGN1cmxlbjtcdFx0XHQvLyBsZW5ndGggb2YgY3VycmVudCBjb2RlXHJcbiAgICB2YXIgbmV4dGxlbiA9IHRyZWVbMF0uZGw7XHQvLyBsZW5ndGggb2YgbmV4dCBjb2RlXHJcbiAgICB2YXIgY291bnQgPSAwO1x0XHQvLyByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZVxyXG4gICAgdmFyIG1heF9jb3VudCA9IDc7XHRcdC8vIG1heCByZXBlYXQgY291bnRcclxuICAgIHZhciBtaW5fY291bnQgPSA0O1x0XHQvLyBtaW4gcmVwZWF0IGNvdW50XHJcblxyXG4gICAgLyogdHJlZVttYXhfY29kZSsxXS5kbCA9IC0xOyAqLyAgLyogZ3VhcmQgYWxyZWFkeSBzZXQgKi9cclxuICAgIGlmKG5leHRsZW4gPT0gMCkge1xyXG4gICAgICBtYXhfY291bnQgPSAxMzg7XHJcbiAgICAgIG1pbl9jb3VudCA9IDM7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcclxuXHRjdXJsZW4gPSBuZXh0bGVuO1xyXG5cdG5leHRsZW4gPSB0cmVlW24rMV0uZGw7XHJcblx0aWYoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT0gbmV4dGxlbikge1xyXG5cdCAgICBjb250aW51ZTtcclxuXHR9IGVsc2UgaWYoY291bnQgPCBtaW5fY291bnQpIHtcclxuXHQgICAgZG8geyB6aXBfU0VORF9DT0RFKGN1cmxlbiwgemlwX2JsX3RyZWUpOyB9IHdoaWxlKC0tY291bnQgIT0gMCk7XHJcblx0fSBlbHNlIGlmKGN1cmxlbiAhPSAwKSB7XHJcblx0ICAgIGlmKGN1cmxlbiAhPSBwcmV2bGVuKSB7XHJcblx0XHR6aXBfU0VORF9DT0RFKGN1cmxlbiwgemlwX2JsX3RyZWUpO1xyXG5cdFx0Y291bnQtLTtcclxuXHQgICAgfVxyXG5cdCAgICAvLyBBc3NlcnQoY291bnQgPj0gMyAmJiBjb3VudCA8PSA2LCBcIiAzXzY/XCIpO1xyXG5cdCAgICB6aXBfU0VORF9DT0RFKHppcF9SRVBfM182LCB6aXBfYmxfdHJlZSk7XHJcblx0ICAgIHppcF9zZW5kX2JpdHMoY291bnQgLSAzLCAyKTtcclxuXHR9IGVsc2UgaWYoY291bnQgPD0gMTApIHtcclxuXHQgICAgemlwX1NFTkRfQ09ERSh6aXBfUkVQWl8zXzEwLCB6aXBfYmxfdHJlZSk7XHJcblx0ICAgIHppcF9zZW5kX2JpdHMoY291bnQtMywgMyk7XHJcblx0fSBlbHNlIHtcclxuXHQgICAgemlwX1NFTkRfQ09ERSh6aXBfUkVQWl8xMV8xMzgsIHppcF9ibF90cmVlKTtcclxuXHQgICAgemlwX3NlbmRfYml0cyhjb3VudC0xMSwgNyk7XHJcblx0fVxyXG5cdGNvdW50ID0gMDtcclxuXHRwcmV2bGVuID0gY3VybGVuO1xyXG5cdGlmKG5leHRsZW4gPT0gMCkge1xyXG5cdCAgICBtYXhfY291bnQgPSAxMzg7XHJcblx0ICAgIG1pbl9jb3VudCA9IDM7XHJcblx0fSBlbHNlIGlmKGN1cmxlbiA9PSBuZXh0bGVuKSB7XHJcblx0ICAgIG1heF9jb3VudCA9IDY7XHJcblx0ICAgIG1pbl9jb3VudCA9IDM7XHJcblx0fSBlbHNlIHtcclxuXHQgICAgbWF4X2NvdW50ID0gNztcclxuXHQgICAgbWluX2NvdW50ID0gNDtcclxuXHR9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGZvciB0aGUgYml0IGxlbmd0aHMgYW5kIHJldHVybiB0aGUgaW5kZXggaW5cclxuICogYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXHJcbiAqL1xyXG52YXIgemlwX2J1aWxkX2JsX3RyZWUgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBtYXhfYmxpbmRleDsgIC8vIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXFcclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgdGhlIGJpdCBsZW5ndGggZnJlcXVlbmNpZXMgZm9yIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzXHJcbiAgICB6aXBfc2Nhbl90cmVlKHppcF9keW5fbHRyZWUsIHppcF9sX2Rlc2MubWF4X2NvZGUpO1xyXG4gICAgemlwX3NjYW5fdHJlZSh6aXBfZHluX2R0cmVlLCB6aXBfZF9kZXNjLm1heF9jb2RlKTtcclxuXHJcbiAgICAvLyBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlOlxyXG4gICAgemlwX2J1aWxkX3RyZWUoemlwX2JsX2Rlc2MpO1xyXG4gICAgLyogb3B0X2xlbiBub3cgaW5jbHVkZXMgdGhlIGxlbmd0aCBvZiB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMsIGV4Y2VwdFxyXG4gICAgICogdGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGhzIGNvZGVzIGFuZCB0aGUgNSs1KzQgYml0cyBmb3IgdGhlIGNvdW50cy5cclxuICAgICAqL1xyXG5cclxuICAgIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJpdCBsZW5ndGggY29kZXMgdG8gc2VuZC4gVGhlIHBremlwIGZvcm1hdFxyXG4gICAgICogcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCA0IGJpdCBsZW5ndGggY29kZXMgYmUgc2VudC4gKGFwcG5vdGUudHh0IHNheXNcclxuICAgICAqIDMgYnV0IHRoZSBhY3R1YWwgdmFsdWUgdXNlZCBpcyA0LilcclxuICAgICAqL1xyXG4gICAgZm9yKG1heF9ibGluZGV4ID0gemlwX0JMX0NPREVTLTE7IG1heF9ibGluZGV4ID49IDM7IG1heF9ibGluZGV4LS0pIHtcclxuXHRpZih6aXBfYmxfdHJlZVt6aXBfYmxfb3JkZXJbbWF4X2JsaW5kZXhdXS5kbCAhPSAwKSBicmVhaztcclxuICAgIH1cclxuICAgIC8qIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzICovXHJcbiAgICB6aXBfb3B0X2xlbiArPSAzKihtYXhfYmxpbmRleCsxKSArIDUrNSs0O1xyXG4vLyAgICBUcmFjZXYoKHN0ZGVyciwgXCJcXG5keW4gdHJlZXM6IGR5biAlbGQsIHN0YXQgJWxkXCIsXHJcbi8vXHQgICAgZW5jb2Rlci0+b3B0X2xlbiwgZW5jb2Rlci0+c3RhdGljX2xlbikpO1xyXG5cclxuICAgIHJldHVybiBtYXhfYmxpbmRleDtcclxufVxyXG5cclxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogU2VuZCB0aGUgaGVhZGVyIGZvciBhIGJsb2NrIHVzaW5nIGR5bmFtaWMgSHVmZm1hbiB0cmVlczogdGhlIGNvdW50cywgdGhlXHJcbiAqIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMsIHRoZSBsaXRlcmFsIHRyZWUgYW5kIHRoZSBkaXN0YW5jZSB0cmVlLlxyXG4gKiBJTiBhc3NlcnRpb246IGxjb2RlcyA+PSAyNTcsIGRjb2RlcyA+PSAxLCBibGNvZGVzID49IDQuXHJcbiAqL1xyXG52YXIgemlwX3NlbmRfYWxsX3RyZWVzID0gZnVuY3Rpb24obGNvZGVzLCBkY29kZXMsIGJsY29kZXMpIHsgLy8gbnVtYmVyIG9mIGNvZGVzIGZvciBlYWNoIHRyZWVcclxuICAgIHZhciByYW5rOyAvLyBpbmRleCBpbiBibF9vcmRlclxyXG5cclxuLy8gICAgQXNzZXJ0IChsY29kZXMgPj0gMjU3ICYmIGRjb2RlcyA+PSAxICYmIGJsY29kZXMgPj0gNCwgXCJub3QgZW5vdWdoIGNvZGVzXCIpO1xyXG4vLyAgICBBc3NlcnQgKGxjb2RlcyA8PSBMX0NPREVTICYmIGRjb2RlcyA8PSBEX0NPREVTICYmIGJsY29kZXMgPD0gQkxfQ09ERVMsXHJcbi8vXHQgICAgXCJ0b28gbWFueSBjb2Rlc1wiKTtcclxuLy8gICAgVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY291bnRzOiBcIikpO1xyXG4gICAgemlwX3NlbmRfYml0cyhsY29kZXMtMjU3LCA1KTsgLy8gbm90ICsyNTUgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0XHJcbiAgICB6aXBfc2VuZF9iaXRzKGRjb2Rlcy0xLCAgIDUpO1xyXG4gICAgemlwX3NlbmRfYml0cyhibGNvZGVzLTQsICA0KTsgLy8gbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dFxyXG4gICAgZm9yKHJhbmsgPSAwOyByYW5rIDwgYmxjb2RlczsgcmFuaysrKSB7XHJcbi8vICAgICAgVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY29kZSAlMmQgXCIsIGJsX29yZGVyW3JhbmtdKSk7XHJcblx0emlwX3NlbmRfYml0cyh6aXBfYmxfdHJlZVt6aXBfYmxfb3JkZXJbcmFua11dLmRsLCAzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBzZW5kIHRoZSBsaXRlcmFsIHRyZWVcclxuICAgIHppcF9zZW5kX3RyZWUoemlwX2R5bl9sdHJlZSxsY29kZXMtMSk7XHJcblxyXG4gICAgLy8gc2VuZCB0aGUgZGlzdGFuY2UgdHJlZVxyXG4gICAgemlwX3NlbmRfdHJlZSh6aXBfZHluX2R0cmVlLGRjb2Rlcy0xKTtcclxufVxyXG5cclxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nIGZvciB0aGUgY3VycmVudCBibG9jazogZHluYW1pYyB0cmVlcywgc3RhdGljXHJcbiAqIHRyZWVzIG9yIHN0b3JlLCBhbmQgb3V0cHV0IHRoZSBlbmNvZGVkIGJsb2NrIHRvIHRoZSB6aXAgZmlsZS5cclxuICovXHJcbnZhciB6aXBfZmx1c2hfYmxvY2sgPSBmdW5jdGlvbihlb2YpIHsgLy8gdHJ1ZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGVcclxuICAgIHZhciBvcHRfbGVuYiwgc3RhdGljX2xlbmI7IC8vIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gaW4gYnl0ZXNcclxuICAgIHZhciBtYXhfYmxpbmRleDtcdC8vIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXFcclxuICAgIHZhciBzdG9yZWRfbGVuO1x0Ly8gbGVuZ3RoIG9mIGlucHV0IGJsb2NrXHJcblxyXG4gICAgc3RvcmVkX2xlbiA9IHppcF9zdHJzdGFydCAtIHppcF9ibG9ja19zdGFydDtcclxuICAgIHppcF9mbGFnX2J1Zlt6aXBfbGFzdF9mbGFnc10gPSB6aXBfZmxhZ3M7IC8vIFNhdmUgdGhlIGZsYWdzIGZvciB0aGUgbGFzdCA4IGl0ZW1zXHJcblxyXG4gICAgLy8gQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlc1xyXG4gICAgemlwX2J1aWxkX3RyZWUoemlwX2xfZGVzYyk7XHJcbi8vICAgIFRyYWNldigoc3RkZXJyLCBcIlxcbmxpdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLFxyXG4vL1x0ICAgIGVuY29kZXItPm9wdF9sZW4sIGVuY29kZXItPnN0YXRpY19sZW4pKTtcclxuXHJcbiAgICB6aXBfYnVpbGRfdHJlZSh6aXBfZF9kZXNjKTtcclxuLy8gICAgVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLFxyXG4vL1x0ICAgIGVuY29kZXItPm9wdF9sZW4sIGVuY29kZXItPnN0YXRpY19sZW4pKTtcclxuICAgIC8qIEF0IHRoaXMgcG9pbnQsIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gYXJlIHRoZSB0b3RhbCBiaXQgbGVuZ3RocyBvZlxyXG4gICAgICogdGhlIGNvbXByZXNzZWQgYmxvY2sgZGF0YSwgZXhjbHVkaW5nIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucy5cclxuICAgICAqL1xyXG5cclxuICAgIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWUgZm9yIHRoZSBhYm92ZSB0d28gdHJlZXMsIGFuZCBnZXQgdGhlIGluZGV4XHJcbiAgICAgKiBpbiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cclxuICAgICAqL1xyXG4gICAgbWF4X2JsaW5kZXggPSB6aXBfYnVpbGRfYmxfdHJlZSgpO1xyXG5cclxuICAgIC8vIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZy4gQ29tcHV0ZSBmaXJzdCB0aGUgYmxvY2sgbGVuZ3RoIGluIGJ5dGVzXHJcbiAgICBvcHRfbGVuYlx0PSAoemlwX29wdF9sZW4gICArMys3KT4+MztcclxuICAgIHN0YXRpY19sZW5iID0gKHppcF9zdGF0aWNfbGVuKzMrNyk+PjM7XHJcblxyXG4vLyAgICBUcmFjZSgoc3RkZXJyLCBcIlxcbm9wdCAlbHUoJWx1KSBzdGF0ICVsdSglbHUpIHN0b3JlZCAlbHUgbGl0ICV1IGRpc3QgJXUgXCIsXHJcbi8vXHQgICBvcHRfbGVuYiwgZW5jb2Rlci0+b3B0X2xlbixcclxuLy9cdCAgIHN0YXRpY19sZW5iLCBlbmNvZGVyLT5zdGF0aWNfbGVuLCBzdG9yZWRfbGVuLFxyXG4vL1x0ICAgZW5jb2Rlci0+bGFzdF9saXQsIGVuY29kZXItPmxhc3RfZGlzdCkpO1xyXG5cclxuICAgIGlmKHN0YXRpY19sZW5iIDw9IG9wdF9sZW5iKVxyXG5cdG9wdF9sZW5iID0gc3RhdGljX2xlbmI7XHJcbiAgICBpZihzdG9yZWRfbGVuICsgNCA8PSBvcHRfbGVuYiAvLyA0OiB0d28gd29yZHMgZm9yIHRoZSBsZW5ndGhzXHJcbiAgICAgICAmJiB6aXBfYmxvY2tfc3RhcnQgPj0gMCkge1xyXG5cdHZhciBpO1xyXG5cclxuXHQvKiBUaGUgdGVzdCBidWYgIT0gTlVMTCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBMSVRfQlVGU0laRSA+IFdTSVpFLlxyXG5cdCAqIE90aGVyd2lzZSB3ZSBjYW4ndCBoYXZlIHByb2Nlc3NlZCBtb3JlIHRoYW4gV1NJWkUgaW5wdXQgYnl0ZXMgc2luY2VcclxuXHQgKiB0aGUgbGFzdCBibG9jayBmbHVzaCwgYmVjYXVzZSBjb21wcmVzc2lvbiB3b3VsZCBoYXZlIGJlZW5cclxuXHQgKiBzdWNjZXNzZnVsLiBJZiBMSVRfQlVGU0laRSA8PSBXU0laRSwgaXQgaXMgbmV2ZXIgdG9vIGxhdGUgdG9cclxuXHQgKiB0cmFuc2Zvcm0gYSBibG9jayBpbnRvIGEgc3RvcmVkIGJsb2NrLlxyXG5cdCAqL1xyXG5cdHppcF9zZW5kX2JpdHMoKHppcF9TVE9SRURfQkxPQ0s8PDEpK2VvZiwgMyk7ICAvKiBzZW5kIGJsb2NrIHR5cGUgKi9cclxuXHR6aXBfYmlfd2luZHVwKCk7XHRcdCAvKiBhbGlnbiBvbiBieXRlIGJvdW5kYXJ5ICovXHJcblx0emlwX3B1dF9zaG9ydChzdG9yZWRfbGVuKTtcclxuXHR6aXBfcHV0X3Nob3J0KH5zdG9yZWRfbGVuKTtcclxuXHJcbiAgICAgIC8vIGNvcHkgYmxvY2tcclxuLypcclxuICAgICAgcCA9ICZ3aW5kb3dbYmxvY2tfc3RhcnRdO1xyXG4gICAgICBmb3IoaSA9IDA7IGkgPCBzdG9yZWRfbGVuOyBpKyspXHJcblx0cHV0X2J5dGUocFtpXSk7XHJcbiovXHJcblx0Zm9yKGkgPSAwOyBpIDwgc3RvcmVkX2xlbjsgaSsrKVxyXG5cdCAgICB6aXBfcHV0X2J5dGUoemlwX3dpbmRvd1t6aXBfYmxvY2tfc3RhcnQgKyBpXSk7XHJcblxyXG4gICAgfSBlbHNlIGlmKHN0YXRpY19sZW5iID09IG9wdF9sZW5iKSB7XHJcblx0emlwX3NlbmRfYml0cygoemlwX1NUQVRJQ19UUkVFUzw8MSkrZW9mLCAzKTtcclxuXHR6aXBfY29tcHJlc3NfYmxvY2soemlwX3N0YXRpY19sdHJlZSwgemlwX3N0YXRpY19kdHJlZSk7XHJcbiAgICB9IGVsc2Uge1xyXG5cdHppcF9zZW5kX2JpdHMoKHppcF9EWU5fVFJFRVM8PDEpK2VvZiwgMyk7XHJcblx0emlwX3NlbmRfYWxsX3RyZWVzKHppcF9sX2Rlc2MubWF4X2NvZGUrMSxcclxuXHRcdFx0ICAgemlwX2RfZGVzYy5tYXhfY29kZSsxLFxyXG5cdFx0XHQgICBtYXhfYmxpbmRleCsxKTtcclxuXHR6aXBfY29tcHJlc3NfYmxvY2soemlwX2R5bl9sdHJlZSwgemlwX2R5bl9kdHJlZSk7XHJcbiAgICB9XHJcblxyXG4gICAgemlwX2luaXRfYmxvY2soKTtcclxuXHJcbiAgICBpZihlb2YgIT0gMClcclxuXHR6aXBfYmlfd2luZHVwKCk7XHJcbn1cclxuXHJcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxyXG4gKiB0aGUgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQuXHJcbiAqL1xyXG52YXIgemlwX2N0X3RhbGx5ID0gZnVuY3Rpb24oXHJcblx0ZGlzdCwgLy8gZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmdcclxuXHRsYykgeyAvLyBtYXRjaCBsZW5ndGgtTUlOX01BVENIIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0PT0wKVxyXG4gICAgemlwX2xfYnVmW3ppcF9sYXN0X2xpdCsrXSA9IGxjO1xyXG4gICAgaWYoZGlzdCA9PSAwKSB7XHJcblx0Ly8gbGMgaXMgdGhlIHVubWF0Y2hlZCBjaGFyXHJcblx0emlwX2R5bl9sdHJlZVtsY10uZmMrKztcclxuICAgIH0gZWxzZSB7XHJcblx0Ly8gSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSFxyXG5cdGRpc3QtLTtcdFx0ICAgIC8vIGRpc3QgPSBtYXRjaCBkaXN0YW5jZSAtIDFcclxuLy8gICAgICBBc3NlcnQoKHVzaClkaXN0IDwgKHVzaClNQVhfRElTVCAmJlxyXG4vL1x0ICAgICAodXNoKWxjIDw9ICh1c2gpKE1BWF9NQVRDSC1NSU5fTUFUQ0gpICYmXHJcbi8vXHQgICAgICh1c2gpRF9DT0RFKGRpc3QpIDwgKHVzaClEX0NPREVTLCAgXCJjdF90YWxseTogYmFkIG1hdGNoXCIpO1xyXG5cclxuXHR6aXBfZHluX2x0cmVlW3ppcF9sZW5ndGhfY29kZVtsY10remlwX0xJVEVSQUxTKzFdLmZjKys7XHJcblx0emlwX2R5bl9kdHJlZVt6aXBfRF9DT0RFKGRpc3QpXS5mYysrO1xyXG5cclxuXHR6aXBfZF9idWZbemlwX2xhc3RfZGlzdCsrXSA9IGRpc3Q7XHJcblx0emlwX2ZsYWdzIHw9IHppcF9mbGFnX2JpdDtcclxuICAgIH1cclxuICAgIHppcF9mbGFnX2JpdCA8PD0gMTtcclxuXHJcbiAgICAvLyBPdXRwdXQgdGhlIGZsYWdzIGlmIHRoZXkgZmlsbCBhIGJ5dGVcclxuICAgIGlmKCh6aXBfbGFzdF9saXQgJiA3KSA9PSAwKSB7XHJcblx0emlwX2ZsYWdfYnVmW3ppcF9sYXN0X2ZsYWdzKytdID0gemlwX2ZsYWdzO1xyXG5cdHppcF9mbGFncyA9IDA7XHJcblx0emlwX2ZsYWdfYml0ID0gMTtcclxuICAgIH1cclxuICAgIC8vIFRyeSB0byBndWVzcyBpZiBpdCBpcyBwcm9maXRhYmxlIHRvIHN0b3AgdGhlIGN1cnJlbnQgYmxvY2sgaGVyZVxyXG4gICAgaWYoemlwX2NvbXByX2xldmVsID4gMiAmJiAoemlwX2xhc3RfbGl0ICYgMHhmZmYpID09IDApIHtcclxuXHQvLyBDb21wdXRlIGFuIHVwcGVyIGJvdW5kIGZvciB0aGUgY29tcHJlc3NlZCBsZW5ndGhcclxuXHR2YXIgb3V0X2xlbmd0aCA9IHppcF9sYXN0X2xpdCAqIDg7XHJcblx0dmFyIGluX2xlbmd0aCA9IHppcF9zdHJzdGFydCAtIHppcF9ibG9ja19zdGFydDtcclxuXHR2YXIgZGNvZGU7XHJcblxyXG5cdGZvcihkY29kZSA9IDA7IGRjb2RlIDwgemlwX0RfQ09ERVM7IGRjb2RlKyspIHtcclxuXHQgICAgb3V0X2xlbmd0aCArPSB6aXBfZHluX2R0cmVlW2Rjb2RlXS5mYyAqICg1ICsgemlwX2V4dHJhX2RiaXRzW2Rjb2RlXSk7XHJcblx0fVxyXG5cdG91dF9sZW5ndGggPj49IDM7XHJcbi8vICAgICAgVHJhY2UoKHN0ZGVycixcIlxcbmxhc3RfbGl0ICV1LCBsYXN0X2Rpc3QgJXUsIGluICVsZCwgb3V0IH4lbGQoJWxkJSUpIFwiLFxyXG4vL1x0ICAgICBlbmNvZGVyLT5sYXN0X2xpdCwgZW5jb2Rlci0+bGFzdF9kaXN0LCBpbl9sZW5ndGgsIG91dF9sZW5ndGgsXHJcbi8vXHQgICAgIDEwMEwgLSBvdXRfbGVuZ3RoKjEwMEwvaW5fbGVuZ3RoKSk7XHJcblx0aWYoemlwX2xhc3RfZGlzdCA8IHBhcnNlSW50KHppcF9sYXN0X2xpdC8yKSAmJlxyXG5cdCAgIG91dF9sZW5ndGggPCBwYXJzZUludChpbl9sZW5ndGgvMikpXHJcblx0ICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICh6aXBfbGFzdF9saXQgPT0gemlwX0xJVF9CVUZTSVpFLTEgfHxcclxuXHQgICAgemlwX2xhc3RfZGlzdCA9PSB6aXBfRElTVF9CVUZTSVpFKTtcclxuICAgIC8qIFdlIGF2b2lkIGVxdWFsaXR5IHdpdGggTElUX0JVRlNJWkUgYmVjYXVzZSBvZiB3cmFwYXJvdW5kIGF0IDY0S1xyXG4gICAgICogb24gMTYgYml0IG1hY2hpbmVzIGFuZCBiZWNhdXNlIHN0b3JlZCBibG9ja3MgYXJlIHJlc3RyaWN0ZWQgdG9cclxuICAgICAqIDY0Sy0xIGJ5dGVzLlxyXG4gICAgICovXHJcbn1cclxuXHJcbiAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgKiBTZW5kIHRoZSBibG9jayBkYXRhIGNvbXByZXNzZWQgdXNpbmcgdGhlIGdpdmVuIEh1ZmZtYW4gdHJlZXNcclxuICAgKi9cclxudmFyIHppcF9jb21wcmVzc19ibG9jayA9IGZ1bmN0aW9uKFxyXG5cdGx0cmVlLFx0Ly8gbGl0ZXJhbCB0cmVlXHJcblx0ZHRyZWUpIHtcdC8vIGRpc3RhbmNlIHRyZWVcclxuICAgIHZhciBkaXN0O1x0XHQvLyBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZ1xyXG4gICAgdmFyIGxjO1x0XHQvLyBtYXRjaCBsZW5ndGggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3QgPT0gMClcclxuICAgIHZhciBseCA9IDA7XHRcdC8vIHJ1bm5pbmcgaW5kZXggaW4gbF9idWZcclxuICAgIHZhciBkeCA9IDA7XHRcdC8vIHJ1bm5pbmcgaW5kZXggaW4gZF9idWZcclxuICAgIHZhciBmeCA9IDA7XHRcdC8vIHJ1bm5pbmcgaW5kZXggaW4gZmxhZ19idWZcclxuICAgIHZhciBmbGFnID0gMDtcdC8vIGN1cnJlbnQgZmxhZ3NcclxuICAgIHZhciBjb2RlO1x0XHQvLyB0aGUgY29kZSB0byBzZW5kXHJcbiAgICB2YXIgZXh0cmE7XHRcdC8vIG51bWJlciBvZiBleHRyYSBiaXRzIHRvIHNlbmRcclxuXHJcbiAgICBpZih6aXBfbGFzdF9saXQgIT0gMCkgZG8ge1xyXG5cdGlmKChseCAmIDcpID09IDApXHJcblx0ICAgIGZsYWcgPSB6aXBfZmxhZ19idWZbZngrK107XHJcblx0bGMgPSB6aXBfbF9idWZbbHgrK10gJiAweGZmO1xyXG5cdGlmKChmbGFnICYgMSkgPT0gMCkge1xyXG5cdCAgICB6aXBfU0VORF9DT0RFKGxjLCBsdHJlZSk7IC8qIHNlbmQgYSBsaXRlcmFsIGJ5dGUgKi9cclxuLy9cdFRyYWNlY3YoaXNncmFwaChsYyksIChzdGRlcnIsXCIgJyVjJyBcIiwgbGMpKTtcclxuXHR9IGVsc2Uge1xyXG5cdCAgICAvLyBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIXHJcblx0ICAgIGNvZGUgPSB6aXBfbGVuZ3RoX2NvZGVbbGNdO1xyXG5cdCAgICB6aXBfU0VORF9DT0RFKGNvZGUremlwX0xJVEVSQUxTKzEsIGx0cmVlKTsgLy8gc2VuZCB0aGUgbGVuZ3RoIGNvZGVcclxuXHQgICAgZXh0cmEgPSB6aXBfZXh0cmFfbGJpdHNbY29kZV07XHJcblx0ICAgIGlmKGV4dHJhICE9IDApIHtcclxuXHRcdGxjIC09IHppcF9iYXNlX2xlbmd0aFtjb2RlXTtcclxuXHRcdHppcF9zZW5kX2JpdHMobGMsIGV4dHJhKTsgLy8gc2VuZCB0aGUgZXh0cmEgbGVuZ3RoIGJpdHNcclxuXHQgICAgfVxyXG5cdCAgICBkaXN0ID0gemlwX2RfYnVmW2R4KytdO1xyXG5cdCAgICAvLyBIZXJlLCBkaXN0IGlzIHRoZSBtYXRjaCBkaXN0YW5jZSAtIDFcclxuXHQgICAgY29kZSA9IHppcF9EX0NPREUoZGlzdCk7XHJcbi8vXHRBc3NlcnQgKGNvZGUgPCBEX0NPREVTLCBcImJhZCBkX2NvZGVcIik7XHJcblxyXG5cdCAgICB6aXBfU0VORF9DT0RFKGNvZGUsIGR0cmVlKTtcdCAgLy8gc2VuZCB0aGUgZGlzdGFuY2UgY29kZVxyXG5cdCAgICBleHRyYSA9IHppcF9leHRyYV9kYml0c1tjb2RlXTtcclxuXHQgICAgaWYoZXh0cmEgIT0gMCkge1xyXG5cdFx0ZGlzdCAtPSB6aXBfYmFzZV9kaXN0W2NvZGVdO1xyXG5cdFx0emlwX3NlbmRfYml0cyhkaXN0LCBleHRyYSk7ICAgLy8gc2VuZCB0aGUgZXh0cmEgZGlzdGFuY2UgYml0c1xyXG5cdCAgICB9XHJcblx0fSAvLyBsaXRlcmFsIG9yIG1hdGNoIHBhaXIgP1xyXG5cdGZsYWcgPj49IDE7XHJcbiAgICB9IHdoaWxlKGx4IDwgemlwX2xhc3RfbGl0KTtcclxuXHJcbiAgICB6aXBfU0VORF9DT0RFKHppcF9FTkRfQkxPQ0ssIGx0cmVlKTtcclxufVxyXG5cclxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogU2VuZCBhIHZhbHVlIG9uIGEgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXHJcbiAqIElOIGFzc2VydGlvbjogbGVuZ3RoIDw9IDE2IGFuZCB2YWx1ZSBmaXRzIGluIGxlbmd0aCBiaXRzLlxyXG4gKi9cclxudmFyIHppcF9CdWZfc2l6ZSA9IDE2OyAvLyBiaXQgc2l6ZSBvZiBiaV9idWZcclxudmFyIHppcF9zZW5kX2JpdHMgPSBmdW5jdGlvbihcclxuXHR2YWx1ZSxcdC8vIHZhbHVlIHRvIHNlbmRcclxuXHRsZW5ndGgpIHtcdC8vIG51bWJlciBvZiBiaXRzXHJcbiAgICAvKiBJZiBub3QgZW5vdWdoIHJvb20gaW4gYmlfYnVmLCB1c2UgKHZhbGlkKSBiaXRzIGZyb20gYmlfYnVmIGFuZFxyXG4gICAgICogKDE2IC0gYmlfdmFsaWQpIGJpdHMgZnJvbSB2YWx1ZSwgbGVhdmluZyAod2lkdGggLSAoMTYtYmlfdmFsaWQpKVxyXG4gICAgICogdW51c2VkIGJpdHMgaW4gdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIGlmKHppcF9iaV92YWxpZCA+IHppcF9CdWZfc2l6ZSAtIGxlbmd0aCkge1xyXG5cdHppcF9iaV9idWYgfD0gKHZhbHVlIDw8IHppcF9iaV92YWxpZCk7XHJcblx0emlwX3B1dF9zaG9ydCh6aXBfYmlfYnVmKTtcclxuXHR6aXBfYmlfYnVmID0gKHZhbHVlID4+ICh6aXBfQnVmX3NpemUgLSB6aXBfYmlfdmFsaWQpKTtcclxuXHR6aXBfYmlfdmFsaWQgKz0gbGVuZ3RoIC0gemlwX0J1Zl9zaXplO1xyXG4gICAgfSBlbHNlIHtcclxuXHR6aXBfYmlfYnVmIHw9IHZhbHVlIDw8IHppcF9iaV92YWxpZDtcclxuXHR6aXBfYmlfdmFsaWQgKz0gbGVuZ3RoO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBSZXZlcnNlIHRoZSBmaXJzdCBsZW4gYml0cyBvZiBhIGNvZGUsIHVzaW5nIHN0cmFpZ2h0Zm9yd2FyZCBjb2RlIChhIGZhc3RlclxyXG4gKiBtZXRob2Qgd291bGQgdXNlIGEgdGFibGUpXHJcbiAqIElOIGFzc2VydGlvbjogMSA8PSBsZW4gPD0gMTVcclxuICovXHJcbnZhciB6aXBfYmlfcmV2ZXJzZSA9IGZ1bmN0aW9uKFxyXG5cdGNvZGUsXHQvLyB0aGUgdmFsdWUgdG8gaW52ZXJ0XHJcblx0bGVuKSB7XHQvLyBpdHMgYml0IGxlbmd0aFxyXG4gICAgdmFyIHJlcyA9IDA7XHJcbiAgICBkbyB7XHJcblx0cmVzIHw9IGNvZGUgJiAxO1xyXG5cdGNvZGUgPj49IDE7XHJcblx0cmVzIDw8PSAxO1xyXG4gICAgfSB3aGlsZSgtLWxlbiA+IDApO1xyXG4gICAgcmV0dXJuIHJlcyA+PiAxO1xyXG59XHJcblxyXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBXcml0ZSBvdXQgYW55IHJlbWFpbmluZyBiaXRzIGluIGFuIGluY29tcGxldGUgYnl0ZS5cclxuICovXHJcbnZhciB6aXBfYmlfd2luZHVwID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZih6aXBfYmlfdmFsaWQgPiA4KSB7XHJcblx0emlwX3B1dF9zaG9ydCh6aXBfYmlfYnVmKTtcclxuICAgIH0gZWxzZSBpZih6aXBfYmlfdmFsaWQgPiAwKSB7XHJcblx0emlwX3B1dF9ieXRlKHppcF9iaV9idWYpO1xyXG4gICAgfVxyXG4gICAgemlwX2JpX2J1ZiA9IDA7XHJcbiAgICB6aXBfYmlfdmFsaWQgPSAwO1xyXG59XHJcblxyXG52YXIgemlwX3FvdXRidWYgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmKHppcF9vdXRjbnQgIT0gMCkge1xyXG5cdHZhciBxLCBpO1xyXG5cdHEgPSB6aXBfbmV3X3F1ZXVlKCk7XHJcblx0aWYoemlwX3FoZWFkID09IG51bGwpXHJcblx0ICAgIHppcF9xaGVhZCA9IHppcF9xdGFpbCA9IHE7XHJcblx0ZWxzZVxyXG5cdCAgICB6aXBfcXRhaWwgPSB6aXBfcXRhaWwubmV4dCA9IHE7XHJcblx0cS5sZW4gPSB6aXBfb3V0Y250IC0gemlwX291dG9mZjtcclxuLy8gICAgICBTeXN0ZW0uYXJyYXljb3B5KHppcF9vdXRidWYsIHppcF9vdXRvZmYsIHEucHRyLCAwLCBxLmxlbik7XHJcblx0Zm9yKGkgPSAwOyBpIDwgcS5sZW47IGkrKylcclxuXHQgICAgcS5wdHJbaV0gPSB6aXBfb3V0YnVmW3ppcF9vdXRvZmYgKyBpXTtcclxuXHR6aXBfb3V0Y250ID0gemlwX291dG9mZiA9IDA7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciB6aXBfZGVmbGF0ZSA9IGZ1bmN0aW9uKHN0ciwgbGV2ZWwpIHtcclxuICAgIHZhciBpLCBqO1xyXG5cclxuICAgIHppcF9kZWZsYXRlX2RhdGEgPSBzdHI7XHJcbiAgICB6aXBfZGVmbGF0ZV9wb3MgPSAwO1xyXG4gICAgaWYodHlwZW9mIGxldmVsID09IFwidW5kZWZpbmVkXCIpXHJcblx0bGV2ZWwgPSB6aXBfREVGQVVMVF9MRVZFTDtcclxuICAgIHppcF9kZWZsYXRlX3N0YXJ0KGxldmVsKTtcclxuXHJcbiAgICB2YXIgYnVmZiA9IG5ldyBBcnJheSgxMDI0KTtcclxuICAgIHZhciBhb3V0ID0gW107XHJcbiAgICB3aGlsZSgoaSA9IHppcF9kZWZsYXRlX2ludGVybmFsKGJ1ZmYsIDAsIGJ1ZmYubGVuZ3RoKSkgPiAwKSB7XHJcblx0dmFyIGNidWYgPSBuZXcgQXJyYXkoaSk7XHJcblx0Zm9yKGogPSAwOyBqIDwgaTsgaisrKXtcclxuXHQgICAgY2J1ZltqXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZltqXSk7XHJcblx0fVxyXG5cdGFvdXRbYW91dC5sZW5ndGhdID0gY2J1Zi5qb2luKFwiXCIpO1xyXG4gICAgfVxyXG4gICAgemlwX2RlZmxhdGVfZGF0YSA9IG51bGw7IC8vIEcuQy5cclxuICAgIHJldHVybiBhb3V0LmpvaW4oXCJcIik7XHJcbn1cclxuXHJcbmlmICghIHdpbmRvdy5SYXdEZWZsYXRlKSBSYXdEZWZsYXRlID0ge307XHJcblJhd0RlZmxhdGUuZGVmbGF0ZSA9IHppcF9kZWZsYXRlO1xyXG5cclxufSkoKTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/rawdeflate.js\n");

/***/ }),

/***/ "./lib/rawinflate.js":
/*!***************************!*\
  !*** ./lib/rawinflate.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\r\n * $Id: rawinflate.js,v 0.2 2009/03/01 18:32:24 dankogai Exp $\r\n *\r\n * original:\r\n * http://www.onicos.com/staff/iz/amuse/javascript/expert/inflate.txt\r\n */\r\n\r\n(function(){\r\n\r\n/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\r\n * Version: 1.0.0.1\r\n * LastModified: Dec 25 1999\r\n */\r\n\r\n/* Interface:\r\n * data = zip_inflate(src);\r\n */\r\n\r\n/* constant parameters */\r\nvar zip_WSIZE = 32768;\t\t// Sliding Window size\r\nvar zip_STORED_BLOCK = 0;\r\nvar zip_STATIC_TREES = 1;\r\nvar zip_DYN_TREES    = 2;\r\n\r\n/* for inflate */\r\nvar zip_lbits = 9; \t\t// bits in base literal/length lookup table\r\nvar zip_dbits = 6; \t\t// bits in base distance lookup table\r\nvar zip_INBUFSIZ = 32768;\t// Input buffer size\r\nvar zip_INBUF_EXTRA = 64;\t// Extra buffer\r\n\r\n/* variables (inflate) */\r\nvar zip_slide;\r\nvar zip_wp;\t\t\t// current position in slide\r\nvar zip_fixed_tl = null;\t// inflate static\r\nvar zip_fixed_td;\t\t// inflate static\r\nvar zip_fixed_bl, fixed_bd;\t// inflate static\r\nvar zip_bit_buf;\t\t// bit buffer\r\nvar zip_bit_len;\t\t// bits in bit buffer\r\nvar zip_method;\r\nvar zip_eof;\r\nvar zip_copy_leng;\r\nvar zip_copy_dist;\r\nvar zip_tl, zip_td;\t// literal/length and distance decoder tables\r\nvar zip_bl, zip_bd;\t// number of bits decoded by tl and td\r\n\r\nvar zip_inflate_data;\r\nvar zip_inflate_pos;\r\n\r\n\r\n/* constant tables (inflate) */\r\nvar zip_MASK_BITS = new Array(\r\n    0x0000,\r\n    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,\r\n    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff);\r\n// Tables for deflate from PKZIP's appnote.txt.\r\nvar zip_cplens = new Array( // Copy lengths for literal codes 257..285\r\n    3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\r\n    35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0);\r\n/* note: see note #13 above about the 258 in this list. */\r\nvar zip_cplext = new Array( // Extra bits for literal codes 257..285\r\n    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\r\n    3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99); // 99==invalid\r\nvar zip_cpdist = new Array( // Copy offsets for distance codes 0..29\r\n    1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\r\n    257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\r\n    8193, 12289, 16385, 24577);\r\nvar zip_cpdext = new Array( // Extra bits for distance codes\r\n    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\r\n    7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\r\n    12, 12, 13, 13);\r\nvar zip_border = new Array(  // Order of the bit length code lengths\r\n    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15);\r\n/* objects (inflate) */\r\n\r\nvar zip_HuftList = function() {\r\n    this.next = null;\r\n    this.list = null;\r\n}\r\n\r\nvar zip_HuftNode = function() {\r\n    this.e = 0; // number of extra bits or operation\r\n    this.b = 0; // number of bits in this code or subcode\r\n\r\n    // union\r\n    this.n = 0; // literal, length base, or distance base\r\n    this.t = null; // (zip_HuftNode) pointer to next level of table\r\n}\r\n\r\nvar zip_HuftBuild = function(b,\t// code lengths in bits (all assumed <= BMAX)\r\n\t\t       n,\t// number of codes (assumed <= N_MAX)\r\n\t\t       s,\t// number of simple-valued codes (0..s-1)\r\n\t\t       d,\t// list of base values for non-simple codes\r\n\t\t       e,\t// list of extra bits for non-simple codes\r\n\t\t       mm\t// maximum lookup bits\r\n\t\t   ) {\r\n    this.BMAX = 16;   // maximum bit length of any code\r\n    this.N_MAX = 288; // maximum number of codes in any set\r\n    this.status = 0;\t// 0: success, 1: incomplete table, 2: bad input\r\n    this.root = null;\t// (zip_HuftList) starting table\r\n    this.m = 0;\t\t// maximum lookup bits, returns actual\r\n\r\n/* Given a list of code lengths and a maximum table size, make a set of\r\n   tables to decode that set of codes.\tReturn zero on success, one if\r\n   the given code set is incomplete (the tables are still built in this\r\n   case), two if the input is invalid (all zero length codes or an\r\n   oversubscribed set of lengths), and three if not enough memory.\r\n   The code with value 256 is special, and the tables are constructed\r\n   so that no bits beyond that code are fetched when that code is\r\n   decoded. */\r\n    {\r\n\tvar a;\t\t\t// counter for codes of length k\r\n\tvar c = new Array(this.BMAX+1);\t// bit length count table\r\n\tvar el;\t\t\t// length of EOB code (value 256)\r\n\tvar f;\t\t\t// i repeats in table every f entries\r\n\tvar g;\t\t\t// maximum code length\r\n\tvar h;\t\t\t// table level\r\n\tvar i;\t\t\t// counter, current code\r\n\tvar j;\t\t\t// counter\r\n\tvar k;\t\t\t// number of bits in current code\r\n\tvar lx = new Array(this.BMAX+1);\t// stack of bits per table\r\n\tvar p;\t\t\t// pointer into c[], b[], or v[]\r\n\tvar pidx;\t\t// index of p\r\n\tvar q;\t\t\t// (zip_HuftNode) points to current table\r\n\tvar r = new zip_HuftNode(); // table entry for structure assignment\r\n\tvar u = new Array(this.BMAX); // zip_HuftNode[BMAX][]  table stack\r\n\tvar v = new Array(this.N_MAX); // values in order of bit length\r\n\tvar w;\r\n\tvar x = new Array(this.BMAX+1);// bit offsets, then code stack\r\n\tvar xp;\t\t\t// pointer into x or c\r\n\tvar y;\t\t\t// number of dummy codes added\r\n\tvar z;\t\t\t// number of entries in current table\r\n\tvar o;\r\n\tvar tail;\t\t// (zip_HuftList)\r\n\r\n\ttail = this.root = null;\r\n\tfor(i = 0; i < c.length; i++)\r\n\t    c[i] = 0;\r\n\tfor(i = 0; i < lx.length; i++)\r\n\t    lx[i] = 0;\r\n\tfor(i = 0; i < u.length; i++)\r\n\t    u[i] = null;\r\n\tfor(i = 0; i < v.length; i++)\r\n\t    v[i] = 0;\r\n\tfor(i = 0; i < x.length; i++)\r\n\t    x[i] = 0;\r\n\r\n\t// Generate counts for each bit length\r\n\tel = n > 256 ? b[256] : this.BMAX; // set length of EOB code, if any\r\n\tp = b; pidx = 0;\r\n\ti = n;\r\n\tdo {\r\n\t    c[p[pidx]]++;\t// assume all entries <= BMAX\r\n\t    pidx++;\r\n\t} while(--i > 0);\r\n\tif(c[0] == n) {\t// null input--all zero length codes\r\n\t    this.root = null;\r\n\t    this.m = 0;\r\n\t    this.status = 0;\r\n\t    return;\r\n\t}\r\n\r\n\t// Find minimum and maximum length, bound *m by those\r\n\tfor(j = 1; j <= this.BMAX; j++)\r\n\t    if(c[j] != 0)\r\n\t\tbreak;\r\n\tk = j;\t\t\t// minimum code length\r\n\tif(mm < j)\r\n\t    mm = j;\r\n\tfor(i = this.BMAX; i != 0; i--)\r\n\t    if(c[i] != 0)\r\n\t\tbreak;\r\n\tg = i;\t\t\t// maximum code length\r\n\tif(mm > i)\r\n\t    mm = i;\r\n\r\n\t// Adjust last length count to fill out codes, if needed\r\n\tfor(y = 1 << j; j < i; j++, y <<= 1)\r\n\t    if((y -= c[j]) < 0) {\r\n\t\tthis.status = 2;\t// bad input: more codes than bits\r\n\t\tthis.m = mm;\r\n\t\treturn;\r\n\t    }\r\n\tif((y -= c[i]) < 0) {\r\n\t    this.status = 2;\r\n\t    this.m = mm;\r\n\t    return;\r\n\t}\r\n\tc[i] += y;\r\n\r\n\t// Generate starting offsets into the value table for each length\r\n\tx[1] = j = 0;\r\n\tp = c;\r\n\tpidx = 1;\r\n\txp = 2;\r\n\twhile(--i > 0)\t\t// note that i == g from above\r\n\t    x[xp++] = (j += p[pidx++]);\r\n\r\n\t// Make a table of values in order of bit lengths\r\n\tp = b; pidx = 0;\r\n\ti = 0;\r\n\tdo {\r\n\t    if((j = p[pidx++]) != 0)\r\n\t\tv[x[j]++] = i;\r\n\t} while(++i < n);\r\n\tn = x[g];\t\t\t// set n to length of v\r\n\r\n\t// Generate the Huffman codes and for each, make the table entries\r\n\tx[0] = i = 0;\t\t// first Huffman code is zero\r\n\tp = v; pidx = 0;\t\t// grab values in bit order\r\n\th = -1;\t\t\t// no tables yet--level -1\r\n\tw = lx[0] = 0;\t\t// no bits decoded yet\r\n\tq = null;\t\t\t// ditto\r\n\tz = 0;\t\t\t// ditto\r\n\r\n\t// go through the bit lengths (k already is bits in shortest code)\r\n\tfor(; k <= g; k++) {\r\n\t    a = c[k];\r\n\t    while(a-- > 0) {\r\n\t\t// here i is the Huffman code of length k bits for value p[pidx]\r\n\t\t// make tables up to required level\r\n\t\twhile(k > w + lx[1 + h]) {\r\n\t\t    w += lx[1 + h]; // add bits already decoded\r\n\t\t    h++;\r\n\r\n\t\t    // compute minimum size table less than or equal to *m bits\r\n\t\t    z = (z = g - w) > mm ? mm : z; // upper limit\r\n\t\t    if((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table\r\n\t\t\t// too few codes for k-w bit table\r\n\t\t\tf -= a + 1;\t// deduct codes from patterns left\r\n\t\t\txp = k;\r\n\t\t\twhile(++j < z) { // try smaller tables up to z bits\r\n\t\t\t    if((f <<= 1) <= c[++xp])\r\n\t\t\t\tbreak;\t// enough codes to use up j bits\r\n\t\t\t    f -= c[xp];\t// else deduct codes from patterns\r\n\t\t\t}\r\n\t\t    }\r\n\t\t    if(w + j > el && w < el)\r\n\t\t\tj = el - w;\t// make EOB code end at table\r\n\t\t    z = 1 << j;\t// table entries for j-bit table\r\n\t\t    lx[1 + h] = j; // set table size in stack\r\n\r\n\t\t    // allocate and link in new table\r\n\t\t    q = new Array(z);\r\n\t\t    for(o = 0; o < z; o++) {\r\n\t\t\tq[o] = new zip_HuftNode();\r\n\t\t    }\r\n\r\n\t\t    if(tail == null)\r\n\t\t\ttail = this.root = new zip_HuftList();\r\n\t\t    else\r\n\t\t\ttail = tail.next = new zip_HuftList();\r\n\t\t    tail.next = null;\r\n\t\t    tail.list = q;\r\n\t\t    u[h] = q;\t// table starts after link\r\n\r\n\t\t    /* connect to last table, if there is one */\r\n\t\t    if(h > 0) {\r\n\t\t\tx[h] = i;\t\t// save pattern for backing up\r\n\t\t\tr.b = lx[h];\t// bits to dump before this table\r\n\t\t\tr.e = 16 + j;\t// bits in this table\r\n\t\t\tr.t = q;\t\t// pointer to this table\r\n\t\t\tj = (i & ((1 << w) - 1)) >> (w - lx[h]);\r\n\t\t\tu[h-1][j].e = r.e;\r\n\t\t\tu[h-1][j].b = r.b;\r\n\t\t\tu[h-1][j].n = r.n;\r\n\t\t\tu[h-1][j].t = r.t;\r\n\t\t    }\r\n\t\t}\r\n\r\n\t\t// set up table entry in r\r\n\t\tr.b = k - w;\r\n\t\tif(pidx >= n)\r\n\t\t    r.e = 99;\t\t// out of values--invalid code\r\n\t\telse if(p[pidx] < s) {\r\n\t\t    r.e = (p[pidx] < 256 ? 16 : 15); // 256 is end-of-block code\r\n\t\t    r.n = p[pidx++];\t// simple code is just the value\r\n\t\t} else {\r\n\t\t    r.e = e[p[pidx] - s];\t// non-simple--look up in lists\r\n\t\t    r.n = d[p[pidx++] - s];\r\n\t\t}\r\n\r\n\t\t// fill code-like entries with r //\r\n\t\tf = 1 << (k - w);\r\n\t\tfor(j = i >> w; j < z; j += f) {\r\n\t\t    q[j].e = r.e;\r\n\t\t    q[j].b = r.b;\r\n\t\t    q[j].n = r.n;\r\n\t\t    q[j].t = r.t;\r\n\t\t}\r\n\r\n\t\t// backwards increment the k-bit code i\r\n\t\tfor(j = 1 << (k - 1); (i & j) != 0; j >>= 1)\r\n\t\t    i ^= j;\r\n\t\ti ^= j;\r\n\r\n\t\t// backup over finished tables\r\n\t\twhile((i & ((1 << w) - 1)) != x[h]) {\r\n\t\t    w -= lx[h];\t\t// don't need to update q\r\n\t\t    h--;\r\n\t\t}\r\n\t    }\r\n\t}\r\n\r\n\t/* return actual size of base table */\r\n\tthis.m = lx[1];\r\n\r\n\t/* Return true (1) if we were given an incomplete table */\r\n\tthis.status = ((y != 0 && g != 1) ? 1 : 0);\r\n    } /* end of constructor */\r\n}\r\n\r\n\r\n/* routines (inflate) */\r\n\r\nvar zip_GET_BYTE = function() {\r\n    if(zip_inflate_data.length == zip_inflate_pos)\r\n\treturn -1;\r\n    return zip_inflate_data.charCodeAt(zip_inflate_pos++) & 0xff;\r\n}\r\n\r\nvar zip_NEEDBITS = function(n) {\r\n    while(zip_bit_len < n) {\r\n\tzip_bit_buf |= zip_GET_BYTE() << zip_bit_len;\r\n\tzip_bit_len += 8;\r\n    }\r\n}\r\n\r\nvar zip_GETBITS = function(n) {\r\n    return zip_bit_buf & zip_MASK_BITS[n];\r\n}\r\n\r\nvar zip_DUMPBITS = function(n) {\r\n    zip_bit_buf >>= n;\r\n    zip_bit_len -= n;\r\n}\r\n\r\nvar zip_inflate_codes = function(buff, off, size) {\r\n    /* inflate (decompress) the codes in a deflated (compressed) block.\r\n       Return an error code or zero if it all goes ok. */\r\n    var e;\t\t// table entry flag/number of extra bits\r\n    var t;\t\t// (zip_HuftNode) pointer to table entry\r\n    var n;\r\n\r\n    if(size == 0)\r\n      return 0;\r\n\r\n    // inflate the coded data\r\n    n = 0;\r\n    for(;;) {\t\t\t// do until end of block\r\n\tzip_NEEDBITS(zip_bl);\r\n\tt = zip_tl.list[zip_GETBITS(zip_bl)];\r\n\te = t.e;\r\n\twhile(e > 16) {\r\n\t    if(e == 99)\r\n\t\treturn -1;\r\n\t    zip_DUMPBITS(t.b);\r\n\t    e -= 16;\r\n\t    zip_NEEDBITS(e);\r\n\t    t = t.t[zip_GETBITS(e)];\r\n\t    e = t.e;\r\n\t}\r\n\tzip_DUMPBITS(t.b);\r\n\r\n\tif(e == 16) {\t\t// then it's a literal\r\n\t    zip_wp &= zip_WSIZE - 1;\r\n\t    buff[off + n++] = zip_slide[zip_wp++] = t.n;\r\n\t    if(n == size)\r\n\t\treturn size;\r\n\t    continue;\r\n\t}\r\n\r\n\t// exit if end of block\r\n\tif(e == 15)\r\n\t    break;\r\n\r\n\t// it's an EOB or a length\r\n\r\n\t// get length of block to copy\r\n\tzip_NEEDBITS(e);\r\n\tzip_copy_leng = t.n + zip_GETBITS(e);\r\n\tzip_DUMPBITS(e);\r\n\r\n\t// decode distance of block to copy\r\n\tzip_NEEDBITS(zip_bd);\r\n\tt = zip_td.list[zip_GETBITS(zip_bd)];\r\n\te = t.e;\r\n\r\n\twhile(e > 16) {\r\n\t    if(e == 99)\r\n\t\treturn -1;\r\n\t    zip_DUMPBITS(t.b);\r\n\t    e -= 16;\r\n\t    zip_NEEDBITS(e);\r\n\t    t = t.t[zip_GETBITS(e)];\r\n\t    e = t.e;\r\n\t}\r\n\tzip_DUMPBITS(t.b);\r\n\tzip_NEEDBITS(e);\r\n\tzip_copy_dist = zip_wp - t.n - zip_GETBITS(e);\r\n\tzip_DUMPBITS(e);\r\n\r\n\t// do the copy\r\n\twhile(zip_copy_leng > 0 && n < size) {\r\n\t    zip_copy_leng--;\r\n\t    zip_copy_dist &= zip_WSIZE - 1;\r\n\t    zip_wp &= zip_WSIZE - 1;\r\n\t    buff[off + n++] = zip_slide[zip_wp++]\r\n\t\t= zip_slide[zip_copy_dist++];\r\n\t}\r\n\r\n\tif(n == size)\r\n\t    return size;\r\n    }\r\n\r\n    zip_method = -1; // done\r\n    return n;\r\n}\r\n\r\nvar zip_inflate_stored = function(buff, off, size) {\r\n    /* \"decompress\" an inflated type 0 (stored) block. */\r\n    var n;\r\n\r\n    // go to byte boundary\r\n    n = zip_bit_len & 7;\r\n    zip_DUMPBITS(n);\r\n\r\n    // get the length and its complement\r\n    zip_NEEDBITS(16);\r\n    n = zip_GETBITS(16);\r\n    zip_DUMPBITS(16);\r\n    zip_NEEDBITS(16);\r\n    if(n != ((~zip_bit_buf) & 0xffff))\r\n\treturn -1;\t\t\t// error in compressed data\r\n    zip_DUMPBITS(16);\r\n\r\n    // read and output the compressed data\r\n    zip_copy_leng = n;\r\n\r\n    n = 0;\r\n    while(zip_copy_leng > 0 && n < size) {\r\n\tzip_copy_leng--;\r\n\tzip_wp &= zip_WSIZE - 1;\r\n\tzip_NEEDBITS(8);\r\n\tbuff[off + n++] = zip_slide[zip_wp++] =\r\n\t    zip_GETBITS(8);\r\n\tzip_DUMPBITS(8);\r\n    }\r\n\r\n    if(zip_copy_leng == 0)\r\n      zip_method = -1; // done\r\n    return n;\r\n}\r\n\r\nvar zip_inflate_fixed = function(buff, off, size) {\r\n    /* decompress an inflated type 1 (fixed Huffman codes) block.  We should\r\n       either replace this with a custom decoder, or at least precompute the\r\n       Huffman tables. */\r\n\r\n    // if first time, set up tables for fixed blocks\r\n    if(zip_fixed_tl == null) {\r\n\tvar i;\t\t\t// temporary variable\r\n\tvar l = new Array(288);\t// length list for huft_build\r\n\tvar h;\t// zip_HuftBuild\r\n\r\n\t// literal table\r\n\tfor(i = 0; i < 144; i++)\r\n\t    l[i] = 8;\r\n\tfor(; i < 256; i++)\r\n\t    l[i] = 9;\r\n\tfor(; i < 280; i++)\r\n\t    l[i] = 7;\r\n\tfor(; i < 288; i++)\t// make a complete, but wrong code set\r\n\t    l[i] = 8;\r\n\tzip_fixed_bl = 7;\r\n\r\n\th = new zip_HuftBuild(l, 288, 257, zip_cplens, zip_cplext,\r\n\t\t\t      zip_fixed_bl);\r\n\tif(h.status != 0) {\r\n\t    alert(\"HufBuild error: \"+h.status);\r\n\t    return -1;\r\n\t}\r\n\tzip_fixed_tl = h.root;\r\n\tzip_fixed_bl = h.m;\r\n\r\n\t// distance table\r\n\tfor(i = 0; i < 30; i++)\t// make an incomplete code set\r\n\t    l[i] = 5;\r\n\tzip_fixed_bd = 5;\r\n\r\n\th = new zip_HuftBuild(l, 30, 0, zip_cpdist, zip_cpdext, zip_fixed_bd);\r\n\tif(h.status > 1) {\r\n\t    zip_fixed_tl = null;\r\n\t    alert(\"HufBuild error: \"+h.status);\r\n\t    return -1;\r\n\t}\r\n\tzip_fixed_td = h.root;\r\n\tzip_fixed_bd = h.m;\r\n    }\r\n\r\n    zip_tl = zip_fixed_tl;\r\n    zip_td = zip_fixed_td;\r\n    zip_bl = zip_fixed_bl;\r\n    zip_bd = zip_fixed_bd;\r\n    return zip_inflate_codes(buff, off, size);\r\n}\r\n\r\nvar zip_inflate_dynamic = function(buff, off, size) {\r\n    // decompress an inflated type 2 (dynamic Huffman codes) block.\r\n    var i;\t\t// temporary variables\r\n    var j;\r\n    var l;\t\t// last length\r\n    var n;\t\t// number of lengths to get\r\n    var t;\t\t// (zip_HuftNode) literal/length code table\r\n    var nb;\t\t// number of bit length codes\r\n    var nl;\t\t// number of literal/length codes\r\n    var nd;\t\t// number of distance codes\r\n    var ll = new Array(286+30); // literal/length and distance code lengths\r\n    var h;\t\t// (zip_HuftBuild)\r\n\r\n    for(i = 0; i < ll.length; i++)\r\n\tll[i] = 0;\r\n\r\n    // read in table lengths\r\n    zip_NEEDBITS(5);\r\n    nl = 257 + zip_GETBITS(5);\t// number of literal/length codes\r\n    zip_DUMPBITS(5);\r\n    zip_NEEDBITS(5);\r\n    nd = 1 + zip_GETBITS(5);\t// number of distance codes\r\n    zip_DUMPBITS(5);\r\n    zip_NEEDBITS(4);\r\n    nb = 4 + zip_GETBITS(4);\t// number of bit length codes\r\n    zip_DUMPBITS(4);\r\n    if(nl > 286 || nd > 30)\r\n      return -1;\t\t// bad lengths\r\n\r\n    // read in bit-length-code lengths\r\n    for(j = 0; j < nb; j++)\r\n    {\r\n\tzip_NEEDBITS(3);\r\n\tll[zip_border[j]] = zip_GETBITS(3);\r\n\tzip_DUMPBITS(3);\r\n    }\r\n    for(; j < 19; j++)\r\n\tll[zip_border[j]] = 0;\r\n\r\n    // build decoding table for trees--single level, 7 bit lookup\r\n    zip_bl = 7;\r\n    h = new zip_HuftBuild(ll, 19, 19, null, null, zip_bl);\r\n    if(h.status != 0)\r\n\treturn -1;\t// incomplete code set\r\n\r\n    zip_tl = h.root;\r\n    zip_bl = h.m;\r\n\r\n    // read in literal and distance code lengths\r\n    n = nl + nd;\r\n    i = l = 0;\r\n    while(i < n) {\r\n\tzip_NEEDBITS(zip_bl);\r\n\tt = zip_tl.list[zip_GETBITS(zip_bl)];\r\n\tj = t.b;\r\n\tzip_DUMPBITS(j);\r\n\tj = t.n;\r\n\tif(j < 16)\t\t// length of code in bits (0..15)\r\n\t    ll[i++] = l = j;\t// save last length in l\r\n\telse if(j == 16) {\t// repeat last length 3 to 6 times\r\n\t    zip_NEEDBITS(2);\r\n\t    j = 3 + zip_GETBITS(2);\r\n\t    zip_DUMPBITS(2);\r\n\t    if(i + j > n)\r\n\t\treturn -1;\r\n\t    while(j-- > 0)\r\n\t\tll[i++] = l;\r\n\t} else if(j == 17) {\t// 3 to 10 zero length codes\r\n\t    zip_NEEDBITS(3);\r\n\t    j = 3 + zip_GETBITS(3);\r\n\t    zip_DUMPBITS(3);\r\n\t    if(i + j > n)\r\n\t\treturn -1;\r\n\t    while(j-- > 0)\r\n\t\tll[i++] = 0;\r\n\t    l = 0;\r\n\t} else {\t\t// j == 18: 11 to 138 zero length codes\r\n\t    zip_NEEDBITS(7);\r\n\t    j = 11 + zip_GETBITS(7);\r\n\t    zip_DUMPBITS(7);\r\n\t    if(i + j > n)\r\n\t\treturn -1;\r\n\t    while(j-- > 0)\r\n\t\tll[i++] = 0;\r\n\t    l = 0;\r\n\t}\r\n    }\r\n\r\n    // build the decoding tables for literal/length and distance codes\r\n    zip_bl = zip_lbits;\r\n    h = new zip_HuftBuild(ll, nl, 257, zip_cplens, zip_cplext, zip_bl);\r\n    if(zip_bl == 0)\t// no literals or lengths\r\n\th.status = 1;\r\n    if(h.status != 0) {\r\n\tif(h.status == 1)\r\n\t    ;// **incomplete literal tree**\r\n\treturn -1;\t\t// incomplete code set\r\n    }\r\n    zip_tl = h.root;\r\n    zip_bl = h.m;\r\n\r\n    for(i = 0; i < nd; i++)\r\n\tll[i] = ll[i + nl];\r\n    zip_bd = zip_dbits;\r\n    h = new zip_HuftBuild(ll, nd, 0, zip_cpdist, zip_cpdext, zip_bd);\r\n    zip_td = h.root;\r\n    zip_bd = h.m;\r\n\r\n    if(zip_bd == 0 && nl > 257) {   // lengths but no distances\r\n\t// **incomplete distance tree**\r\n\treturn -1;\r\n    }\r\n\r\n    if(h.status == 1) {\r\n\t;// **incomplete distance tree**\r\n    }\r\n    if(h.status != 0)\r\n\treturn -1;\r\n\r\n    // decompress until an end-of-block code\r\n    return zip_inflate_codes(buff, off, size);\r\n}\r\n\r\nvar zip_inflate_start = function() {\r\n    var i;\r\n\r\n    if(zip_slide == null)\r\n\tzip_slide = new Array(2 * zip_WSIZE);\r\n    zip_wp = 0;\r\n    zip_bit_buf = 0;\r\n    zip_bit_len = 0;\r\n    zip_method = -1;\r\n    zip_eof = false;\r\n    zip_copy_leng = zip_copy_dist = 0;\r\n    zip_tl = null;\r\n}\r\n\r\nvar zip_inflate_internal = function(buff, off, size) {\r\n    // decompress an inflated entry\r\n    var n, i;\r\n\r\n    n = 0;\r\n    while(n < size) {\r\n\tif(zip_eof && zip_method == -1)\r\n\t    return n;\r\n\r\n\tif(zip_copy_leng > 0) {\r\n\t    if(zip_method != zip_STORED_BLOCK) {\r\n\t\t// STATIC_TREES or DYN_TREES\r\n\t\twhile(zip_copy_leng > 0 && n < size) {\r\n\t\t    zip_copy_leng--;\r\n\t\t    zip_copy_dist &= zip_WSIZE - 1;\r\n\t\t    zip_wp &= zip_WSIZE - 1;\r\n\t\t    buff[off + n++] = zip_slide[zip_wp++] =\r\n\t\t\tzip_slide[zip_copy_dist++];\r\n\t\t}\r\n\t    } else {\r\n\t\twhile(zip_copy_leng > 0 && n < size) {\r\n\t\t    zip_copy_leng--;\r\n\t\t    zip_wp &= zip_WSIZE - 1;\r\n\t\t    zip_NEEDBITS(8);\r\n\t\t    buff[off + n++] = zip_slide[zip_wp++] = zip_GETBITS(8);\r\n\t\t    zip_DUMPBITS(8);\r\n\t\t}\r\n\t\tif(zip_copy_leng == 0)\r\n\t\t    zip_method = -1; // done\r\n\t    }\r\n\t    if(n == size)\r\n\t\treturn n;\r\n\t}\r\n\r\n\tif(zip_method == -1) {\r\n\t    if(zip_eof)\r\n\t\tbreak;\r\n\r\n\t    // read in last block bit\r\n\t    zip_NEEDBITS(1);\r\n\t    if(zip_GETBITS(1) != 0)\r\n\t\tzip_eof = true;\r\n\t    zip_DUMPBITS(1);\r\n\r\n\t    // read in block type\r\n\t    zip_NEEDBITS(2);\r\n\t    zip_method = zip_GETBITS(2);\r\n\t    zip_DUMPBITS(2);\r\n\t    zip_tl = null;\r\n\t    zip_copy_leng = 0;\r\n\t}\r\n\r\n\tswitch(zip_method) {\r\n\t  case 0: // zip_STORED_BLOCK\r\n\t    i = zip_inflate_stored(buff, off + n, size - n);\r\n\t    break;\r\n\r\n\t  case 1: // zip_STATIC_TREES\r\n\t    if(zip_tl != null)\r\n\t\ti = zip_inflate_codes(buff, off + n, size - n);\r\n\t    else\r\n\t\ti = zip_inflate_fixed(buff, off + n, size - n);\r\n\t    break;\r\n\r\n\t  case 2: // zip_DYN_TREES\r\n\t    if(zip_tl != null)\r\n\t\ti = zip_inflate_codes(buff, off + n, size - n);\r\n\t    else\r\n\t\ti = zip_inflate_dynamic(buff, off + n, size - n);\r\n\t    break;\r\n\r\n\t  default: // error\r\n\t    i = -1;\r\n\t    break;\r\n\t}\r\n\r\n\tif(i == -1) {\r\n\t    if(zip_eof)\r\n\t\treturn 0;\r\n\t    return -1;\r\n\t}\r\n\tn += i;\r\n    }\r\n    return n;\r\n}\r\n\r\nvar zip_inflate = function(str) {\r\n    var i, j;\r\n\r\n    zip_inflate_start();\r\n    zip_inflate_data = str;\r\n    zip_inflate_pos = 0;\r\n\r\n    var buff = new Array(1024);\r\n    var aout = [];\r\n    while((i = zip_inflate_internal(buff, 0, buff.length)) > 0) {\r\n\tvar cbuf = new Array(i);\r\n\tfor(j = 0; j < i; j++){\r\n\t    cbuf[j] = String.fromCharCode(buff[j]);\r\n\t}\r\n\taout[aout.length] = cbuf.join(\"\");\r\n    }\r\n    zip_inflate_data = null; // G.C.\r\n    return aout.join(\"\");\r\n}\r\n\r\nif (! window.RawDeflate) RawDeflate = {};\r\nRawDeflate.inflate = zip_inflate;\r\n\r\n})();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvcmF3aW5mbGF0ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9yYXdpbmZsYXRlLmpzPzY1NjAiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogJElkOiByYXdpbmZsYXRlLmpzLHYgMC4yIDIwMDkvMDMvMDEgMTg6MzI6MjQgZGFua29nYWkgRXhwICRcclxuICpcclxuICogb3JpZ2luYWw6XHJcbiAqIGh0dHA6Ly93d3cub25pY29zLmNvbS9zdGFmZi9pei9hbXVzZS9qYXZhc2NyaXB0L2V4cGVydC9pbmZsYXRlLnR4dFxyXG4gKi9cclxuXHJcbihmdW5jdGlvbigpe1xyXG5cclxuLyogQ29weXJpZ2h0IChDKSAxOTk5IE1hc2FuYW8gSXp1bW8gPGl6QG9uaWNvcy5jby5qcD5cclxuICogVmVyc2lvbjogMS4wLjAuMVxyXG4gKiBMYXN0TW9kaWZpZWQ6IERlYyAyNSAxOTk5XHJcbiAqL1xyXG5cclxuLyogSW50ZXJmYWNlOlxyXG4gKiBkYXRhID0gemlwX2luZmxhdGUoc3JjKTtcclxuICovXHJcblxyXG4vKiBjb25zdGFudCBwYXJhbWV0ZXJzICovXHJcbnZhciB6aXBfV1NJWkUgPSAzMjc2ODtcdFx0Ly8gU2xpZGluZyBXaW5kb3cgc2l6ZVxyXG52YXIgemlwX1NUT1JFRF9CTE9DSyA9IDA7XHJcbnZhciB6aXBfU1RBVElDX1RSRUVTID0gMTtcclxudmFyIHppcF9EWU5fVFJFRVMgICAgPSAyO1xyXG5cclxuLyogZm9yIGluZmxhdGUgKi9cclxudmFyIHppcF9sYml0cyA9IDk7IFx0XHQvLyBiaXRzIGluIGJhc2UgbGl0ZXJhbC9sZW5ndGggbG9va3VwIHRhYmxlXHJcbnZhciB6aXBfZGJpdHMgPSA2OyBcdFx0Ly8gYml0cyBpbiBiYXNlIGRpc3RhbmNlIGxvb2t1cCB0YWJsZVxyXG52YXIgemlwX0lOQlVGU0laID0gMzI3Njg7XHQvLyBJbnB1dCBidWZmZXIgc2l6ZVxyXG52YXIgemlwX0lOQlVGX0VYVFJBID0gNjQ7XHQvLyBFeHRyYSBidWZmZXJcclxuXHJcbi8qIHZhcmlhYmxlcyAoaW5mbGF0ZSkgKi9cclxudmFyIHppcF9zbGlkZTtcclxudmFyIHppcF93cDtcdFx0XHQvLyBjdXJyZW50IHBvc2l0aW9uIGluIHNsaWRlXHJcbnZhciB6aXBfZml4ZWRfdGwgPSBudWxsO1x0Ly8gaW5mbGF0ZSBzdGF0aWNcclxudmFyIHppcF9maXhlZF90ZDtcdFx0Ly8gaW5mbGF0ZSBzdGF0aWNcclxudmFyIHppcF9maXhlZF9ibCwgZml4ZWRfYmQ7XHQvLyBpbmZsYXRlIHN0YXRpY1xyXG52YXIgemlwX2JpdF9idWY7XHRcdC8vIGJpdCBidWZmZXJcclxudmFyIHppcF9iaXRfbGVuO1x0XHQvLyBiaXRzIGluIGJpdCBidWZmZXJcclxudmFyIHppcF9tZXRob2Q7XHJcbnZhciB6aXBfZW9mO1xyXG52YXIgemlwX2NvcHlfbGVuZztcclxudmFyIHppcF9jb3B5X2Rpc3Q7XHJcbnZhciB6aXBfdGwsIHppcF90ZDtcdC8vIGxpdGVyYWwvbGVuZ3RoIGFuZCBkaXN0YW5jZSBkZWNvZGVyIHRhYmxlc1xyXG52YXIgemlwX2JsLCB6aXBfYmQ7XHQvLyBudW1iZXIgb2YgYml0cyBkZWNvZGVkIGJ5IHRsIGFuZCB0ZFxyXG5cclxudmFyIHppcF9pbmZsYXRlX2RhdGE7XHJcbnZhciB6aXBfaW5mbGF0ZV9wb3M7XHJcblxyXG5cclxuLyogY29uc3RhbnQgdGFibGVzIChpbmZsYXRlKSAqL1xyXG52YXIgemlwX01BU0tfQklUUyA9IG5ldyBBcnJheShcclxuICAgIDB4MDAwMCxcclxuICAgIDB4MDAwMSwgMHgwMDAzLCAweDAwMDcsIDB4MDAwZiwgMHgwMDFmLCAweDAwM2YsIDB4MDA3ZiwgMHgwMGZmLFxyXG4gICAgMHgwMWZmLCAweDAzZmYsIDB4MDdmZiwgMHgwZmZmLCAweDFmZmYsIDB4M2ZmZiwgMHg3ZmZmLCAweGZmZmYpO1xyXG4vLyBUYWJsZXMgZm9yIGRlZmxhdGUgZnJvbSBQS1pJUCdzIGFwcG5vdGUudHh0LlxyXG52YXIgemlwX2NwbGVucyA9IG5ldyBBcnJheSggLy8gQ29weSBsZW5ndGhzIGZvciBsaXRlcmFsIGNvZGVzIDI1Ny4uMjg1XHJcbiAgICAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEzLCAxNSwgMTcsIDE5LCAyMywgMjcsIDMxLFxyXG4gICAgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDApO1xyXG4vKiBub3RlOiBzZWUgbm90ZSAjMTMgYWJvdmUgYWJvdXQgdGhlIDI1OCBpbiB0aGlzIGxpc3QuICovXHJcbnZhciB6aXBfY3BsZXh0ID0gbmV3IEFycmF5KCAvLyBFeHRyYSBiaXRzIGZvciBsaXRlcmFsIGNvZGVzIDI1Ny4uMjg1XHJcbiAgICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAxLCAxLCAxLCAyLCAyLCAyLCAyLFxyXG4gICAgMywgMywgMywgMywgNCwgNCwgNCwgNCwgNSwgNSwgNSwgNSwgMCwgOTksIDk5KTsgLy8gOTk9PWludmFsaWRcclxudmFyIHppcF9jcGRpc3QgPSBuZXcgQXJyYXkoIC8vIENvcHkgb2Zmc2V0cyBmb3IgZGlzdGFuY2UgY29kZXMgMC4uMjlcclxuICAgIDEsIDIsIDMsIDQsIDUsIDcsIDksIDEzLCAxNywgMjUsIDMzLCA0OSwgNjUsIDk3LCAxMjksIDE5MyxcclxuICAgIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSxcclxuICAgIDgxOTMsIDEyMjg5LCAxNjM4NSwgMjQ1NzcpO1xyXG52YXIgemlwX2NwZGV4dCA9IG5ldyBBcnJheSggLy8gRXh0cmEgYml0cyBmb3IgZGlzdGFuY2UgY29kZXNcclxuICAgIDAsIDAsIDAsIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDQsIDQsIDUsIDUsIDYsIDYsXHJcbiAgICA3LCA3LCA4LCA4LCA5LCA5LCAxMCwgMTAsIDExLCAxMSxcclxuICAgIDEyLCAxMiwgMTMsIDEzKTtcclxudmFyIHppcF9ib3JkZXIgPSBuZXcgQXJyYXkoICAvLyBPcmRlciBvZiB0aGUgYml0IGxlbmd0aCBjb2RlIGxlbmd0aHNcclxuICAgIDE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTUpO1xyXG4vKiBvYmplY3RzIChpbmZsYXRlKSAqL1xyXG5cclxudmFyIHppcF9IdWZ0TGlzdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcclxuICAgIHRoaXMubGlzdCA9IG51bGw7XHJcbn1cclxuXHJcbnZhciB6aXBfSHVmdE5vZGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuZSA9IDA7IC8vIG51bWJlciBvZiBleHRyYSBiaXRzIG9yIG9wZXJhdGlvblxyXG4gICAgdGhpcy5iID0gMDsgLy8gbnVtYmVyIG9mIGJpdHMgaW4gdGhpcyBjb2RlIG9yIHN1YmNvZGVcclxuXHJcbiAgICAvLyB1bmlvblxyXG4gICAgdGhpcy5uID0gMDsgLy8gbGl0ZXJhbCwgbGVuZ3RoIGJhc2UsIG9yIGRpc3RhbmNlIGJhc2VcclxuICAgIHRoaXMudCA9IG51bGw7IC8vICh6aXBfSHVmdE5vZGUpIHBvaW50ZXIgdG8gbmV4dCBsZXZlbCBvZiB0YWJsZVxyXG59XHJcblxyXG52YXIgemlwX0h1ZnRCdWlsZCA9IGZ1bmN0aW9uKGIsXHQvLyBjb2RlIGxlbmd0aHMgaW4gYml0cyAoYWxsIGFzc3VtZWQgPD0gQk1BWClcclxuXHRcdCAgICAgICBuLFx0Ly8gbnVtYmVyIG9mIGNvZGVzIChhc3N1bWVkIDw9IE5fTUFYKVxyXG5cdFx0ICAgICAgIHMsXHQvLyBudW1iZXIgb2Ygc2ltcGxlLXZhbHVlZCBjb2RlcyAoMC4ucy0xKVxyXG5cdFx0ICAgICAgIGQsXHQvLyBsaXN0IG9mIGJhc2UgdmFsdWVzIGZvciBub24tc2ltcGxlIGNvZGVzXHJcblx0XHQgICAgICAgZSxcdC8vIGxpc3Qgb2YgZXh0cmEgYml0cyBmb3Igbm9uLXNpbXBsZSBjb2Rlc1xyXG5cdFx0ICAgICAgIG1tXHQvLyBtYXhpbXVtIGxvb2t1cCBiaXRzXHJcblx0XHQgICApIHtcclxuICAgIHRoaXMuQk1BWCA9IDE2OyAgIC8vIG1heGltdW0gYml0IGxlbmd0aCBvZiBhbnkgY29kZVxyXG4gICAgdGhpcy5OX01BWCA9IDI4ODsgLy8gbWF4aW11bSBudW1iZXIgb2YgY29kZXMgaW4gYW55IHNldFxyXG4gICAgdGhpcy5zdGF0dXMgPSAwO1x0Ly8gMDogc3VjY2VzcywgMTogaW5jb21wbGV0ZSB0YWJsZSwgMjogYmFkIGlucHV0XHJcbiAgICB0aGlzLnJvb3QgPSBudWxsO1x0Ly8gKHppcF9IdWZ0TGlzdCkgc3RhcnRpbmcgdGFibGVcclxuICAgIHRoaXMubSA9IDA7XHRcdC8vIG1heGltdW0gbG9va3VwIGJpdHMsIHJldHVybnMgYWN0dWFsXHJcblxyXG4vKiBHaXZlbiBhIGxpc3Qgb2YgY29kZSBsZW5ndGhzIGFuZCBhIG1heGltdW0gdGFibGUgc2l6ZSwgbWFrZSBhIHNldCBvZlxyXG4gICB0YWJsZXMgdG8gZGVjb2RlIHRoYXQgc2V0IG9mIGNvZGVzLlx0UmV0dXJuIHplcm8gb24gc3VjY2Vzcywgb25lIGlmXHJcbiAgIHRoZSBnaXZlbiBjb2RlIHNldCBpcyBpbmNvbXBsZXRlICh0aGUgdGFibGVzIGFyZSBzdGlsbCBidWlsdCBpbiB0aGlzXHJcbiAgIGNhc2UpLCB0d28gaWYgdGhlIGlucHV0IGlzIGludmFsaWQgKGFsbCB6ZXJvIGxlbmd0aCBjb2RlcyBvciBhblxyXG4gICBvdmVyc3Vic2NyaWJlZCBzZXQgb2YgbGVuZ3RocyksIGFuZCB0aHJlZSBpZiBub3QgZW5vdWdoIG1lbW9yeS5cclxuICAgVGhlIGNvZGUgd2l0aCB2YWx1ZSAyNTYgaXMgc3BlY2lhbCwgYW5kIHRoZSB0YWJsZXMgYXJlIGNvbnN0cnVjdGVkXHJcbiAgIHNvIHRoYXQgbm8gYml0cyBiZXlvbmQgdGhhdCBjb2RlIGFyZSBmZXRjaGVkIHdoZW4gdGhhdCBjb2RlIGlzXHJcbiAgIGRlY29kZWQuICovXHJcbiAgICB7XHJcblx0dmFyIGE7XHRcdFx0Ly8gY291bnRlciBmb3IgY29kZXMgb2YgbGVuZ3RoIGtcclxuXHR2YXIgYyA9IG5ldyBBcnJheSh0aGlzLkJNQVgrMSk7XHQvLyBiaXQgbGVuZ3RoIGNvdW50IHRhYmxlXHJcblx0dmFyIGVsO1x0XHRcdC8vIGxlbmd0aCBvZiBFT0IgY29kZSAodmFsdWUgMjU2KVxyXG5cdHZhciBmO1x0XHRcdC8vIGkgcmVwZWF0cyBpbiB0YWJsZSBldmVyeSBmIGVudHJpZXNcclxuXHR2YXIgZztcdFx0XHQvLyBtYXhpbXVtIGNvZGUgbGVuZ3RoXHJcblx0dmFyIGg7XHRcdFx0Ly8gdGFibGUgbGV2ZWxcclxuXHR2YXIgaTtcdFx0XHQvLyBjb3VudGVyLCBjdXJyZW50IGNvZGVcclxuXHR2YXIgajtcdFx0XHQvLyBjb3VudGVyXHJcblx0dmFyIGs7XHRcdFx0Ly8gbnVtYmVyIG9mIGJpdHMgaW4gY3VycmVudCBjb2RlXHJcblx0dmFyIGx4ID0gbmV3IEFycmF5KHRoaXMuQk1BWCsxKTtcdC8vIHN0YWNrIG9mIGJpdHMgcGVyIHRhYmxlXHJcblx0dmFyIHA7XHRcdFx0Ly8gcG9pbnRlciBpbnRvIGNbXSwgYltdLCBvciB2W11cclxuXHR2YXIgcGlkeDtcdFx0Ly8gaW5kZXggb2YgcFxyXG5cdHZhciBxO1x0XHRcdC8vICh6aXBfSHVmdE5vZGUpIHBvaW50cyB0byBjdXJyZW50IHRhYmxlXHJcblx0dmFyIHIgPSBuZXcgemlwX0h1ZnROb2RlKCk7IC8vIHRhYmxlIGVudHJ5IGZvciBzdHJ1Y3R1cmUgYXNzaWdubWVudFxyXG5cdHZhciB1ID0gbmV3IEFycmF5KHRoaXMuQk1BWCk7IC8vIHppcF9IdWZ0Tm9kZVtCTUFYXVtdICB0YWJsZSBzdGFja1xyXG5cdHZhciB2ID0gbmV3IEFycmF5KHRoaXMuTl9NQVgpOyAvLyB2YWx1ZXMgaW4gb3JkZXIgb2YgYml0IGxlbmd0aFxyXG5cdHZhciB3O1xyXG5cdHZhciB4ID0gbmV3IEFycmF5KHRoaXMuQk1BWCsxKTsvLyBiaXQgb2Zmc2V0cywgdGhlbiBjb2RlIHN0YWNrXHJcblx0dmFyIHhwO1x0XHRcdC8vIHBvaW50ZXIgaW50byB4IG9yIGNcclxuXHR2YXIgeTtcdFx0XHQvLyBudW1iZXIgb2YgZHVtbXkgY29kZXMgYWRkZWRcclxuXHR2YXIgejtcdFx0XHQvLyBudW1iZXIgb2YgZW50cmllcyBpbiBjdXJyZW50IHRhYmxlXHJcblx0dmFyIG87XHJcblx0dmFyIHRhaWw7XHRcdC8vICh6aXBfSHVmdExpc3QpXHJcblxyXG5cdHRhaWwgPSB0aGlzLnJvb3QgPSBudWxsO1xyXG5cdGZvcihpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspXHJcblx0ICAgIGNbaV0gPSAwO1xyXG5cdGZvcihpID0gMDsgaSA8IGx4Lmxlbmd0aDsgaSsrKVxyXG5cdCAgICBseFtpXSA9IDA7XHJcblx0Zm9yKGkgPSAwOyBpIDwgdS5sZW5ndGg7IGkrKylcclxuXHQgICAgdVtpXSA9IG51bGw7XHJcblx0Zm9yKGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkrKylcclxuXHQgICAgdltpXSA9IDA7XHJcblx0Zm9yKGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkrKylcclxuXHQgICAgeFtpXSA9IDA7XHJcblxyXG5cdC8vIEdlbmVyYXRlIGNvdW50cyBmb3IgZWFjaCBiaXQgbGVuZ3RoXHJcblx0ZWwgPSBuID4gMjU2ID8gYlsyNTZdIDogdGhpcy5CTUFYOyAvLyBzZXQgbGVuZ3RoIG9mIEVPQiBjb2RlLCBpZiBhbnlcclxuXHRwID0gYjsgcGlkeCA9IDA7XHJcblx0aSA9IG47XHJcblx0ZG8ge1xyXG5cdCAgICBjW3BbcGlkeF1dKys7XHQvLyBhc3N1bWUgYWxsIGVudHJpZXMgPD0gQk1BWFxyXG5cdCAgICBwaWR4Kys7XHJcblx0fSB3aGlsZSgtLWkgPiAwKTtcclxuXHRpZihjWzBdID09IG4pIHtcdC8vIG51bGwgaW5wdXQtLWFsbCB6ZXJvIGxlbmd0aCBjb2Rlc1xyXG5cdCAgICB0aGlzLnJvb3QgPSBudWxsO1xyXG5cdCAgICB0aGlzLm0gPSAwO1xyXG5cdCAgICB0aGlzLnN0YXR1cyA9IDA7XHJcblx0ICAgIHJldHVybjtcclxuXHR9XHJcblxyXG5cdC8vIEZpbmQgbWluaW11bSBhbmQgbWF4aW11bSBsZW5ndGgsIGJvdW5kICptIGJ5IHRob3NlXHJcblx0Zm9yKGogPSAxOyBqIDw9IHRoaXMuQk1BWDsgaisrKVxyXG5cdCAgICBpZihjW2pdICE9IDApXHJcblx0XHRicmVhaztcclxuXHRrID0gajtcdFx0XHQvLyBtaW5pbXVtIGNvZGUgbGVuZ3RoXHJcblx0aWYobW0gPCBqKVxyXG5cdCAgICBtbSA9IGo7XHJcblx0Zm9yKGkgPSB0aGlzLkJNQVg7IGkgIT0gMDsgaS0tKVxyXG5cdCAgICBpZihjW2ldICE9IDApXHJcblx0XHRicmVhaztcclxuXHRnID0gaTtcdFx0XHQvLyBtYXhpbXVtIGNvZGUgbGVuZ3RoXHJcblx0aWYobW0gPiBpKVxyXG5cdCAgICBtbSA9IGk7XHJcblxyXG5cdC8vIEFkanVzdCBsYXN0IGxlbmd0aCBjb3VudCB0byBmaWxsIG91dCBjb2RlcywgaWYgbmVlZGVkXHJcblx0Zm9yKHkgPSAxIDw8IGo7IGogPCBpOyBqKyssIHkgPDw9IDEpXHJcblx0ICAgIGlmKCh5IC09IGNbal0pIDwgMCkge1xyXG5cdFx0dGhpcy5zdGF0dXMgPSAyO1x0Ly8gYmFkIGlucHV0OiBtb3JlIGNvZGVzIHRoYW4gYml0c1xyXG5cdFx0dGhpcy5tID0gbW07XHJcblx0XHRyZXR1cm47XHJcblx0ICAgIH1cclxuXHRpZigoeSAtPSBjW2ldKSA8IDApIHtcclxuXHQgICAgdGhpcy5zdGF0dXMgPSAyO1xyXG5cdCAgICB0aGlzLm0gPSBtbTtcclxuXHQgICAgcmV0dXJuO1xyXG5cdH1cclxuXHRjW2ldICs9IHk7XHJcblxyXG5cdC8vIEdlbmVyYXRlIHN0YXJ0aW5nIG9mZnNldHMgaW50byB0aGUgdmFsdWUgdGFibGUgZm9yIGVhY2ggbGVuZ3RoXHJcblx0eFsxXSA9IGogPSAwO1xyXG5cdHAgPSBjO1xyXG5cdHBpZHggPSAxO1xyXG5cdHhwID0gMjtcclxuXHR3aGlsZSgtLWkgPiAwKVx0XHQvLyBub3RlIHRoYXQgaSA9PSBnIGZyb20gYWJvdmVcclxuXHQgICAgeFt4cCsrXSA9IChqICs9IHBbcGlkeCsrXSk7XHJcblxyXG5cdC8vIE1ha2UgYSB0YWJsZSBvZiB2YWx1ZXMgaW4gb3JkZXIgb2YgYml0IGxlbmd0aHNcclxuXHRwID0gYjsgcGlkeCA9IDA7XHJcblx0aSA9IDA7XHJcblx0ZG8ge1xyXG5cdCAgICBpZigoaiA9IHBbcGlkeCsrXSkgIT0gMClcclxuXHRcdHZbeFtqXSsrXSA9IGk7XHJcblx0fSB3aGlsZSgrK2kgPCBuKTtcclxuXHRuID0geFtnXTtcdFx0XHQvLyBzZXQgbiB0byBsZW5ndGggb2YgdlxyXG5cclxuXHQvLyBHZW5lcmF0ZSB0aGUgSHVmZm1hbiBjb2RlcyBhbmQgZm9yIGVhY2gsIG1ha2UgdGhlIHRhYmxlIGVudHJpZXNcclxuXHR4WzBdID0gaSA9IDA7XHRcdC8vIGZpcnN0IEh1ZmZtYW4gY29kZSBpcyB6ZXJvXHJcblx0cCA9IHY7IHBpZHggPSAwO1x0XHQvLyBncmFiIHZhbHVlcyBpbiBiaXQgb3JkZXJcclxuXHRoID0gLTE7XHRcdFx0Ly8gbm8gdGFibGVzIHlldC0tbGV2ZWwgLTFcclxuXHR3ID0gbHhbMF0gPSAwO1x0XHQvLyBubyBiaXRzIGRlY29kZWQgeWV0XHJcblx0cSA9IG51bGw7XHRcdFx0Ly8gZGl0dG9cclxuXHR6ID0gMDtcdFx0XHQvLyBkaXR0b1xyXG5cclxuXHQvLyBnbyB0aHJvdWdoIHRoZSBiaXQgbGVuZ3RocyAoayBhbHJlYWR5IGlzIGJpdHMgaW4gc2hvcnRlc3QgY29kZSlcclxuXHRmb3IoOyBrIDw9IGc7IGsrKykge1xyXG5cdCAgICBhID0gY1trXTtcclxuXHQgICAgd2hpbGUoYS0tID4gMCkge1xyXG5cdFx0Ly8gaGVyZSBpIGlzIHRoZSBIdWZmbWFuIGNvZGUgb2YgbGVuZ3RoIGsgYml0cyBmb3IgdmFsdWUgcFtwaWR4XVxyXG5cdFx0Ly8gbWFrZSB0YWJsZXMgdXAgdG8gcmVxdWlyZWQgbGV2ZWxcclxuXHRcdHdoaWxlKGsgPiB3ICsgbHhbMSArIGhdKSB7XHJcblx0XHQgICAgdyArPSBseFsxICsgaF07IC8vIGFkZCBiaXRzIGFscmVhZHkgZGVjb2RlZFxyXG5cdFx0ICAgIGgrKztcclxuXHJcblx0XHQgICAgLy8gY29tcHV0ZSBtaW5pbXVtIHNpemUgdGFibGUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICptIGJpdHNcclxuXHRcdCAgICB6ID0gKHogPSBnIC0gdykgPiBtbSA/IG1tIDogejsgLy8gdXBwZXIgbGltaXRcclxuXHRcdCAgICBpZigoZiA9IDEgPDwgKGogPSBrIC0gdykpID4gYSArIDEpIHsgLy8gdHJ5IGEgay13IGJpdCB0YWJsZVxyXG5cdFx0XHQvLyB0b28gZmV3IGNvZGVzIGZvciBrLXcgYml0IHRhYmxlXHJcblx0XHRcdGYgLT0gYSArIDE7XHQvLyBkZWR1Y3QgY29kZXMgZnJvbSBwYXR0ZXJucyBsZWZ0XHJcblx0XHRcdHhwID0gaztcclxuXHRcdFx0d2hpbGUoKytqIDwgeikgeyAvLyB0cnkgc21hbGxlciB0YWJsZXMgdXAgdG8geiBiaXRzXHJcblx0XHRcdCAgICBpZigoZiA8PD0gMSkgPD0gY1srK3hwXSlcclxuXHRcdFx0XHRicmVhaztcdC8vIGVub3VnaCBjb2RlcyB0byB1c2UgdXAgaiBiaXRzXHJcblx0XHRcdCAgICBmIC09IGNbeHBdO1x0Ly8gZWxzZSBkZWR1Y3QgY29kZXMgZnJvbSBwYXR0ZXJuc1xyXG5cdFx0XHR9XHJcblx0XHQgICAgfVxyXG5cdFx0ICAgIGlmKHcgKyBqID4gZWwgJiYgdyA8IGVsKVxyXG5cdFx0XHRqID0gZWwgLSB3O1x0Ly8gbWFrZSBFT0IgY29kZSBlbmQgYXQgdGFibGVcclxuXHRcdCAgICB6ID0gMSA8PCBqO1x0Ly8gdGFibGUgZW50cmllcyBmb3Igai1iaXQgdGFibGVcclxuXHRcdCAgICBseFsxICsgaF0gPSBqOyAvLyBzZXQgdGFibGUgc2l6ZSBpbiBzdGFja1xyXG5cclxuXHRcdCAgICAvLyBhbGxvY2F0ZSBhbmQgbGluayBpbiBuZXcgdGFibGVcclxuXHRcdCAgICBxID0gbmV3IEFycmF5KHopO1xyXG5cdFx0ICAgIGZvcihvID0gMDsgbyA8IHo7IG8rKykge1xyXG5cdFx0XHRxW29dID0gbmV3IHppcF9IdWZ0Tm9kZSgpO1xyXG5cdFx0ICAgIH1cclxuXHJcblx0XHQgICAgaWYodGFpbCA9PSBudWxsKVxyXG5cdFx0XHR0YWlsID0gdGhpcy5yb290ID0gbmV3IHppcF9IdWZ0TGlzdCgpO1xyXG5cdFx0ICAgIGVsc2VcclxuXHRcdFx0dGFpbCA9IHRhaWwubmV4dCA9IG5ldyB6aXBfSHVmdExpc3QoKTtcclxuXHRcdCAgICB0YWlsLm5leHQgPSBudWxsO1xyXG5cdFx0ICAgIHRhaWwubGlzdCA9IHE7XHJcblx0XHQgICAgdVtoXSA9IHE7XHQvLyB0YWJsZSBzdGFydHMgYWZ0ZXIgbGlua1xyXG5cclxuXHRcdCAgICAvKiBjb25uZWN0IHRvIGxhc3QgdGFibGUsIGlmIHRoZXJlIGlzIG9uZSAqL1xyXG5cdFx0ICAgIGlmKGggPiAwKSB7XHJcblx0XHRcdHhbaF0gPSBpO1x0XHQvLyBzYXZlIHBhdHRlcm4gZm9yIGJhY2tpbmcgdXBcclxuXHRcdFx0ci5iID0gbHhbaF07XHQvLyBiaXRzIHRvIGR1bXAgYmVmb3JlIHRoaXMgdGFibGVcclxuXHRcdFx0ci5lID0gMTYgKyBqO1x0Ly8gYml0cyBpbiB0aGlzIHRhYmxlXHJcblx0XHRcdHIudCA9IHE7XHRcdC8vIHBvaW50ZXIgdG8gdGhpcyB0YWJsZVxyXG5cdFx0XHRqID0gKGkgJiAoKDEgPDwgdykgLSAxKSkgPj4gKHcgLSBseFtoXSk7XHJcblx0XHRcdHVbaC0xXVtqXS5lID0gci5lO1xyXG5cdFx0XHR1W2gtMV1bal0uYiA9IHIuYjtcclxuXHRcdFx0dVtoLTFdW2pdLm4gPSByLm47XHJcblx0XHRcdHVbaC0xXVtqXS50ID0gci50O1xyXG5cdFx0ICAgIH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBzZXQgdXAgdGFibGUgZW50cnkgaW4gclxyXG5cdFx0ci5iID0gayAtIHc7XHJcblx0XHRpZihwaWR4ID49IG4pXHJcblx0XHQgICAgci5lID0gOTk7XHRcdC8vIG91dCBvZiB2YWx1ZXMtLWludmFsaWQgY29kZVxyXG5cdFx0ZWxzZSBpZihwW3BpZHhdIDwgcykge1xyXG5cdFx0ICAgIHIuZSA9IChwW3BpZHhdIDwgMjU2ID8gMTYgOiAxNSk7IC8vIDI1NiBpcyBlbmQtb2YtYmxvY2sgY29kZVxyXG5cdFx0ICAgIHIubiA9IHBbcGlkeCsrXTtcdC8vIHNpbXBsZSBjb2RlIGlzIGp1c3QgdGhlIHZhbHVlXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0ICAgIHIuZSA9IGVbcFtwaWR4XSAtIHNdO1x0Ly8gbm9uLXNpbXBsZS0tbG9vayB1cCBpbiBsaXN0c1xyXG5cdFx0ICAgIHIubiA9IGRbcFtwaWR4KytdIC0gc107XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZmlsbCBjb2RlLWxpa2UgZW50cmllcyB3aXRoIHIgLy9cclxuXHRcdGYgPSAxIDw8IChrIC0gdyk7XHJcblx0XHRmb3IoaiA9IGkgPj4gdzsgaiA8IHo7IGogKz0gZikge1xyXG5cdFx0ICAgIHFbal0uZSA9IHIuZTtcclxuXHRcdCAgICBxW2pdLmIgPSByLmI7XHJcblx0XHQgICAgcVtqXS5uID0gci5uO1xyXG5cdFx0ICAgIHFbal0udCA9IHIudDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBiYWNrd2FyZHMgaW5jcmVtZW50IHRoZSBrLWJpdCBjb2RlIGlcclxuXHRcdGZvcihqID0gMSA8PCAoayAtIDEpOyAoaSAmIGopICE9IDA7IGogPj49IDEpXHJcblx0XHQgICAgaSBePSBqO1xyXG5cdFx0aSBePSBqO1xyXG5cclxuXHRcdC8vIGJhY2t1cCBvdmVyIGZpbmlzaGVkIHRhYmxlc1xyXG5cdFx0d2hpbGUoKGkgJiAoKDEgPDwgdykgLSAxKSkgIT0geFtoXSkge1xyXG5cdFx0ICAgIHcgLT0gbHhbaF07XHRcdC8vIGRvbid0IG5lZWQgdG8gdXBkYXRlIHFcclxuXHRcdCAgICBoLS07XHJcblx0XHR9XHJcblx0ICAgIH1cclxuXHR9XHJcblxyXG5cdC8qIHJldHVybiBhY3R1YWwgc2l6ZSBvZiBiYXNlIHRhYmxlICovXHJcblx0dGhpcy5tID0gbHhbMV07XHJcblxyXG5cdC8qIFJldHVybiB0cnVlICgxKSBpZiB3ZSB3ZXJlIGdpdmVuIGFuIGluY29tcGxldGUgdGFibGUgKi9cclxuXHR0aGlzLnN0YXR1cyA9ICgoeSAhPSAwICYmIGcgIT0gMSkgPyAxIDogMCk7XHJcbiAgICB9IC8qIGVuZCBvZiBjb25zdHJ1Y3RvciAqL1xyXG59XHJcblxyXG5cclxuLyogcm91dGluZXMgKGluZmxhdGUpICovXHJcblxyXG52YXIgemlwX0dFVF9CWVRFID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZih6aXBfaW5mbGF0ZV9kYXRhLmxlbmd0aCA9PSB6aXBfaW5mbGF0ZV9wb3MpXHJcblx0cmV0dXJuIC0xO1xyXG4gICAgcmV0dXJuIHppcF9pbmZsYXRlX2RhdGEuY2hhckNvZGVBdCh6aXBfaW5mbGF0ZV9wb3MrKykgJiAweGZmO1xyXG59XHJcblxyXG52YXIgemlwX05FRURCSVRTID0gZnVuY3Rpb24obikge1xyXG4gICAgd2hpbGUoemlwX2JpdF9sZW4gPCBuKSB7XHJcblx0emlwX2JpdF9idWYgfD0gemlwX0dFVF9CWVRFKCkgPDwgemlwX2JpdF9sZW47XHJcblx0emlwX2JpdF9sZW4gKz0gODtcclxuICAgIH1cclxufVxyXG5cclxudmFyIHppcF9HRVRCSVRTID0gZnVuY3Rpb24obikge1xyXG4gICAgcmV0dXJuIHppcF9iaXRfYnVmICYgemlwX01BU0tfQklUU1tuXTtcclxufVxyXG5cclxudmFyIHppcF9EVU1QQklUUyA9IGZ1bmN0aW9uKG4pIHtcclxuICAgIHppcF9iaXRfYnVmID4+PSBuO1xyXG4gICAgemlwX2JpdF9sZW4gLT0gbjtcclxufVxyXG5cclxudmFyIHppcF9pbmZsYXRlX2NvZGVzID0gZnVuY3Rpb24oYnVmZiwgb2ZmLCBzaXplKSB7XHJcbiAgICAvKiBpbmZsYXRlIChkZWNvbXByZXNzKSB0aGUgY29kZXMgaW4gYSBkZWZsYXRlZCAoY29tcHJlc3NlZCkgYmxvY2suXHJcbiAgICAgICBSZXR1cm4gYW4gZXJyb3IgY29kZSBvciB6ZXJvIGlmIGl0IGFsbCBnb2VzIG9rLiAqL1xyXG4gICAgdmFyIGU7XHRcdC8vIHRhYmxlIGVudHJ5IGZsYWcvbnVtYmVyIG9mIGV4dHJhIGJpdHNcclxuICAgIHZhciB0O1x0XHQvLyAoemlwX0h1ZnROb2RlKSBwb2ludGVyIHRvIHRhYmxlIGVudHJ5XHJcbiAgICB2YXIgbjtcclxuXHJcbiAgICBpZihzaXplID09IDApXHJcbiAgICAgIHJldHVybiAwO1xyXG5cclxuICAgIC8vIGluZmxhdGUgdGhlIGNvZGVkIGRhdGFcclxuICAgIG4gPSAwO1xyXG4gICAgZm9yKDs7KSB7XHRcdFx0Ly8gZG8gdW50aWwgZW5kIG9mIGJsb2NrXHJcblx0emlwX05FRURCSVRTKHppcF9ibCk7XHJcblx0dCA9IHppcF90bC5saXN0W3ppcF9HRVRCSVRTKHppcF9ibCldO1xyXG5cdGUgPSB0LmU7XHJcblx0d2hpbGUoZSA+IDE2KSB7XHJcblx0ICAgIGlmKGUgPT0gOTkpXHJcblx0XHRyZXR1cm4gLTE7XHJcblx0ICAgIHppcF9EVU1QQklUUyh0LmIpO1xyXG5cdCAgICBlIC09IDE2O1xyXG5cdCAgICB6aXBfTkVFREJJVFMoZSk7XHJcblx0ICAgIHQgPSB0LnRbemlwX0dFVEJJVFMoZSldO1xyXG5cdCAgICBlID0gdC5lO1xyXG5cdH1cclxuXHR6aXBfRFVNUEJJVFModC5iKTtcclxuXHJcblx0aWYoZSA9PSAxNikge1x0XHQvLyB0aGVuIGl0J3MgYSBsaXRlcmFsXHJcblx0ICAgIHppcF93cCAmPSB6aXBfV1NJWkUgLSAxO1xyXG5cdCAgICBidWZmW29mZiArIG4rK10gPSB6aXBfc2xpZGVbemlwX3dwKytdID0gdC5uO1xyXG5cdCAgICBpZihuID09IHNpemUpXHJcblx0XHRyZXR1cm4gc2l6ZTtcclxuXHQgICAgY29udGludWU7XHJcblx0fVxyXG5cclxuXHQvLyBleGl0IGlmIGVuZCBvZiBibG9ja1xyXG5cdGlmKGUgPT0gMTUpXHJcblx0ICAgIGJyZWFrO1xyXG5cclxuXHQvLyBpdCdzIGFuIEVPQiBvciBhIGxlbmd0aFxyXG5cclxuXHQvLyBnZXQgbGVuZ3RoIG9mIGJsb2NrIHRvIGNvcHlcclxuXHR6aXBfTkVFREJJVFMoZSk7XHJcblx0emlwX2NvcHlfbGVuZyA9IHQubiArIHppcF9HRVRCSVRTKGUpO1xyXG5cdHppcF9EVU1QQklUUyhlKTtcclxuXHJcblx0Ly8gZGVjb2RlIGRpc3RhbmNlIG9mIGJsb2NrIHRvIGNvcHlcclxuXHR6aXBfTkVFREJJVFMoemlwX2JkKTtcclxuXHR0ID0gemlwX3RkLmxpc3RbemlwX0dFVEJJVFMoemlwX2JkKV07XHJcblx0ZSA9IHQuZTtcclxuXHJcblx0d2hpbGUoZSA+IDE2KSB7XHJcblx0ICAgIGlmKGUgPT0gOTkpXHJcblx0XHRyZXR1cm4gLTE7XHJcblx0ICAgIHppcF9EVU1QQklUUyh0LmIpO1xyXG5cdCAgICBlIC09IDE2O1xyXG5cdCAgICB6aXBfTkVFREJJVFMoZSk7XHJcblx0ICAgIHQgPSB0LnRbemlwX0dFVEJJVFMoZSldO1xyXG5cdCAgICBlID0gdC5lO1xyXG5cdH1cclxuXHR6aXBfRFVNUEJJVFModC5iKTtcclxuXHR6aXBfTkVFREJJVFMoZSk7XHJcblx0emlwX2NvcHlfZGlzdCA9IHppcF93cCAtIHQubiAtIHppcF9HRVRCSVRTKGUpO1xyXG5cdHppcF9EVU1QQklUUyhlKTtcclxuXHJcblx0Ly8gZG8gdGhlIGNvcHlcclxuXHR3aGlsZSh6aXBfY29weV9sZW5nID4gMCAmJiBuIDwgc2l6ZSkge1xyXG5cdCAgICB6aXBfY29weV9sZW5nLS07XHJcblx0ICAgIHppcF9jb3B5X2Rpc3QgJj0gemlwX1dTSVpFIC0gMTtcclxuXHQgICAgemlwX3dwICY9IHppcF9XU0laRSAtIDE7XHJcblx0ICAgIGJ1ZmZbb2ZmICsgbisrXSA9IHppcF9zbGlkZVt6aXBfd3ArK11cclxuXHRcdD0gemlwX3NsaWRlW3ppcF9jb3B5X2Rpc3QrK107XHJcblx0fVxyXG5cclxuXHRpZihuID09IHNpemUpXHJcblx0ICAgIHJldHVybiBzaXplO1xyXG4gICAgfVxyXG5cclxuICAgIHppcF9tZXRob2QgPSAtMTsgLy8gZG9uZVxyXG4gICAgcmV0dXJuIG47XHJcbn1cclxuXHJcbnZhciB6aXBfaW5mbGF0ZV9zdG9yZWQgPSBmdW5jdGlvbihidWZmLCBvZmYsIHNpemUpIHtcclxuICAgIC8qIFwiZGVjb21wcmVzc1wiIGFuIGluZmxhdGVkIHR5cGUgMCAoc3RvcmVkKSBibG9jay4gKi9cclxuICAgIHZhciBuO1xyXG5cclxuICAgIC8vIGdvIHRvIGJ5dGUgYm91bmRhcnlcclxuICAgIG4gPSB6aXBfYml0X2xlbiAmIDc7XHJcbiAgICB6aXBfRFVNUEJJVFMobik7XHJcblxyXG4gICAgLy8gZ2V0IHRoZSBsZW5ndGggYW5kIGl0cyBjb21wbGVtZW50XHJcbiAgICB6aXBfTkVFREJJVFMoMTYpO1xyXG4gICAgbiA9IHppcF9HRVRCSVRTKDE2KTtcclxuICAgIHppcF9EVU1QQklUUygxNik7XHJcbiAgICB6aXBfTkVFREJJVFMoMTYpO1xyXG4gICAgaWYobiAhPSAoKH56aXBfYml0X2J1ZikgJiAweGZmZmYpKVxyXG5cdHJldHVybiAtMTtcdFx0XHQvLyBlcnJvciBpbiBjb21wcmVzc2VkIGRhdGFcclxuICAgIHppcF9EVU1QQklUUygxNik7XHJcblxyXG4gICAgLy8gcmVhZCBhbmQgb3V0cHV0IHRoZSBjb21wcmVzc2VkIGRhdGFcclxuICAgIHppcF9jb3B5X2xlbmcgPSBuO1xyXG5cclxuICAgIG4gPSAwO1xyXG4gICAgd2hpbGUoemlwX2NvcHlfbGVuZyA+IDAgJiYgbiA8IHNpemUpIHtcclxuXHR6aXBfY29weV9sZW5nLS07XHJcblx0emlwX3dwICY9IHppcF9XU0laRSAtIDE7XHJcblx0emlwX05FRURCSVRTKDgpO1xyXG5cdGJ1ZmZbb2ZmICsgbisrXSA9IHppcF9zbGlkZVt6aXBfd3ArK10gPVxyXG5cdCAgICB6aXBfR0VUQklUUyg4KTtcclxuXHR6aXBfRFVNUEJJVFMoOCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYoemlwX2NvcHlfbGVuZyA9PSAwKVxyXG4gICAgICB6aXBfbWV0aG9kID0gLTE7IC8vIGRvbmVcclxuICAgIHJldHVybiBuO1xyXG59XHJcblxyXG52YXIgemlwX2luZmxhdGVfZml4ZWQgPSBmdW5jdGlvbihidWZmLCBvZmYsIHNpemUpIHtcclxuICAgIC8qIGRlY29tcHJlc3MgYW4gaW5mbGF0ZWQgdHlwZSAxIChmaXhlZCBIdWZmbWFuIGNvZGVzKSBibG9jay4gIFdlIHNob3VsZFxyXG4gICAgICAgZWl0aGVyIHJlcGxhY2UgdGhpcyB3aXRoIGEgY3VzdG9tIGRlY29kZXIsIG9yIGF0IGxlYXN0IHByZWNvbXB1dGUgdGhlXHJcbiAgICAgICBIdWZmbWFuIHRhYmxlcy4gKi9cclxuXHJcbiAgICAvLyBpZiBmaXJzdCB0aW1lLCBzZXQgdXAgdGFibGVzIGZvciBmaXhlZCBibG9ja3NcclxuICAgIGlmKHppcF9maXhlZF90bCA9PSBudWxsKSB7XHJcblx0dmFyIGk7XHRcdFx0Ly8gdGVtcG9yYXJ5IHZhcmlhYmxlXHJcblx0dmFyIGwgPSBuZXcgQXJyYXkoMjg4KTtcdC8vIGxlbmd0aCBsaXN0IGZvciBodWZ0X2J1aWxkXHJcblx0dmFyIGg7XHQvLyB6aXBfSHVmdEJ1aWxkXHJcblxyXG5cdC8vIGxpdGVyYWwgdGFibGVcclxuXHRmb3IoaSA9IDA7IGkgPCAxNDQ7IGkrKylcclxuXHQgICAgbFtpXSA9IDg7XHJcblx0Zm9yKDsgaSA8IDI1NjsgaSsrKVxyXG5cdCAgICBsW2ldID0gOTtcclxuXHRmb3IoOyBpIDwgMjgwOyBpKyspXHJcblx0ICAgIGxbaV0gPSA3O1xyXG5cdGZvcig7IGkgPCAyODg7IGkrKylcdC8vIG1ha2UgYSBjb21wbGV0ZSwgYnV0IHdyb25nIGNvZGUgc2V0XHJcblx0ICAgIGxbaV0gPSA4O1xyXG5cdHppcF9maXhlZF9ibCA9IDc7XHJcblxyXG5cdGggPSBuZXcgemlwX0h1ZnRCdWlsZChsLCAyODgsIDI1NywgemlwX2NwbGVucywgemlwX2NwbGV4dCxcclxuXHRcdFx0ICAgICAgemlwX2ZpeGVkX2JsKTtcclxuXHRpZihoLnN0YXR1cyAhPSAwKSB7XHJcblx0ICAgIGFsZXJ0KFwiSHVmQnVpbGQgZXJyb3I6IFwiK2guc3RhdHVzKTtcclxuXHQgICAgcmV0dXJuIC0xO1xyXG5cdH1cclxuXHR6aXBfZml4ZWRfdGwgPSBoLnJvb3Q7XHJcblx0emlwX2ZpeGVkX2JsID0gaC5tO1xyXG5cclxuXHQvLyBkaXN0YW5jZSB0YWJsZVxyXG5cdGZvcihpID0gMDsgaSA8IDMwOyBpKyspXHQvLyBtYWtlIGFuIGluY29tcGxldGUgY29kZSBzZXRcclxuXHQgICAgbFtpXSA9IDU7XHJcblx0emlwX2ZpeGVkX2JkID0gNTtcclxuXHJcblx0aCA9IG5ldyB6aXBfSHVmdEJ1aWxkKGwsIDMwLCAwLCB6aXBfY3BkaXN0LCB6aXBfY3BkZXh0LCB6aXBfZml4ZWRfYmQpO1xyXG5cdGlmKGguc3RhdHVzID4gMSkge1xyXG5cdCAgICB6aXBfZml4ZWRfdGwgPSBudWxsO1xyXG5cdCAgICBhbGVydChcIkh1ZkJ1aWxkIGVycm9yOiBcIitoLnN0YXR1cyk7XHJcblx0ICAgIHJldHVybiAtMTtcclxuXHR9XHJcblx0emlwX2ZpeGVkX3RkID0gaC5yb290O1xyXG5cdHppcF9maXhlZF9iZCA9IGgubTtcclxuICAgIH1cclxuXHJcbiAgICB6aXBfdGwgPSB6aXBfZml4ZWRfdGw7XHJcbiAgICB6aXBfdGQgPSB6aXBfZml4ZWRfdGQ7XHJcbiAgICB6aXBfYmwgPSB6aXBfZml4ZWRfYmw7XHJcbiAgICB6aXBfYmQgPSB6aXBfZml4ZWRfYmQ7XHJcbiAgICByZXR1cm4gemlwX2luZmxhdGVfY29kZXMoYnVmZiwgb2ZmLCBzaXplKTtcclxufVxyXG5cclxudmFyIHppcF9pbmZsYXRlX2R5bmFtaWMgPSBmdW5jdGlvbihidWZmLCBvZmYsIHNpemUpIHtcclxuICAgIC8vIGRlY29tcHJlc3MgYW4gaW5mbGF0ZWQgdHlwZSAyIChkeW5hbWljIEh1ZmZtYW4gY29kZXMpIGJsb2NrLlxyXG4gICAgdmFyIGk7XHRcdC8vIHRlbXBvcmFyeSB2YXJpYWJsZXNcclxuICAgIHZhciBqO1xyXG4gICAgdmFyIGw7XHRcdC8vIGxhc3QgbGVuZ3RoXHJcbiAgICB2YXIgbjtcdFx0Ly8gbnVtYmVyIG9mIGxlbmd0aHMgdG8gZ2V0XHJcbiAgICB2YXIgdDtcdFx0Ly8gKHppcF9IdWZ0Tm9kZSkgbGl0ZXJhbC9sZW5ndGggY29kZSB0YWJsZVxyXG4gICAgdmFyIG5iO1x0XHQvLyBudW1iZXIgb2YgYml0IGxlbmd0aCBjb2Rlc1xyXG4gICAgdmFyIG5sO1x0XHQvLyBudW1iZXIgb2YgbGl0ZXJhbC9sZW5ndGggY29kZXNcclxuICAgIHZhciBuZDtcdFx0Ly8gbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzXHJcbiAgICB2YXIgbGwgPSBuZXcgQXJyYXkoMjg2KzMwKTsgLy8gbGl0ZXJhbC9sZW5ndGggYW5kIGRpc3RhbmNlIGNvZGUgbGVuZ3Roc1xyXG4gICAgdmFyIGg7XHRcdC8vICh6aXBfSHVmdEJ1aWxkKVxyXG5cclxuICAgIGZvcihpID0gMDsgaSA8IGxsLmxlbmd0aDsgaSsrKVxyXG5cdGxsW2ldID0gMDtcclxuXHJcbiAgICAvLyByZWFkIGluIHRhYmxlIGxlbmd0aHNcclxuICAgIHppcF9ORUVEQklUUyg1KTtcclxuICAgIG5sID0gMjU3ICsgemlwX0dFVEJJVFMoNSk7XHQvLyBudW1iZXIgb2YgbGl0ZXJhbC9sZW5ndGggY29kZXNcclxuICAgIHppcF9EVU1QQklUUyg1KTtcclxuICAgIHppcF9ORUVEQklUUyg1KTtcclxuICAgIG5kID0gMSArIHppcF9HRVRCSVRTKDUpO1x0Ly8gbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzXHJcbiAgICB6aXBfRFVNUEJJVFMoNSk7XHJcbiAgICB6aXBfTkVFREJJVFMoNCk7XHJcbiAgICBuYiA9IDQgKyB6aXBfR0VUQklUUyg0KTtcdC8vIG51bWJlciBvZiBiaXQgbGVuZ3RoIGNvZGVzXHJcbiAgICB6aXBfRFVNUEJJVFMoNCk7XHJcbiAgICBpZihubCA+IDI4NiB8fCBuZCA+IDMwKVxyXG4gICAgICByZXR1cm4gLTE7XHRcdC8vIGJhZCBsZW5ndGhzXHJcblxyXG4gICAgLy8gcmVhZCBpbiBiaXQtbGVuZ3RoLWNvZGUgbGVuZ3Roc1xyXG4gICAgZm9yKGogPSAwOyBqIDwgbmI7IGorKylcclxuICAgIHtcclxuXHR6aXBfTkVFREJJVFMoMyk7XHJcblx0bGxbemlwX2JvcmRlcltqXV0gPSB6aXBfR0VUQklUUygzKTtcclxuXHR6aXBfRFVNUEJJVFMoMyk7XHJcbiAgICB9XHJcbiAgICBmb3IoOyBqIDwgMTk7IGorKylcclxuXHRsbFt6aXBfYm9yZGVyW2pdXSA9IDA7XHJcblxyXG4gICAgLy8gYnVpbGQgZGVjb2RpbmcgdGFibGUgZm9yIHRyZWVzLS1zaW5nbGUgbGV2ZWwsIDcgYml0IGxvb2t1cFxyXG4gICAgemlwX2JsID0gNztcclxuICAgIGggPSBuZXcgemlwX0h1ZnRCdWlsZChsbCwgMTksIDE5LCBudWxsLCBudWxsLCB6aXBfYmwpO1xyXG4gICAgaWYoaC5zdGF0dXMgIT0gMClcclxuXHRyZXR1cm4gLTE7XHQvLyBpbmNvbXBsZXRlIGNvZGUgc2V0XHJcblxyXG4gICAgemlwX3RsID0gaC5yb290O1xyXG4gICAgemlwX2JsID0gaC5tO1xyXG5cclxuICAgIC8vIHJlYWQgaW4gbGl0ZXJhbCBhbmQgZGlzdGFuY2UgY29kZSBsZW5ndGhzXHJcbiAgICBuID0gbmwgKyBuZDtcclxuICAgIGkgPSBsID0gMDtcclxuICAgIHdoaWxlKGkgPCBuKSB7XHJcblx0emlwX05FRURCSVRTKHppcF9ibCk7XHJcblx0dCA9IHppcF90bC5saXN0W3ppcF9HRVRCSVRTKHppcF9ibCldO1xyXG5cdGogPSB0LmI7XHJcblx0emlwX0RVTVBCSVRTKGopO1xyXG5cdGogPSB0Lm47XHJcblx0aWYoaiA8IDE2KVx0XHQvLyBsZW5ndGggb2YgY29kZSBpbiBiaXRzICgwLi4xNSlcclxuXHQgICAgbGxbaSsrXSA9IGwgPSBqO1x0Ly8gc2F2ZSBsYXN0IGxlbmd0aCBpbiBsXHJcblx0ZWxzZSBpZihqID09IDE2KSB7XHQvLyByZXBlYXQgbGFzdCBsZW5ndGggMyB0byA2IHRpbWVzXHJcblx0ICAgIHppcF9ORUVEQklUUygyKTtcclxuXHQgICAgaiA9IDMgKyB6aXBfR0VUQklUUygyKTtcclxuXHQgICAgemlwX0RVTVBCSVRTKDIpO1xyXG5cdCAgICBpZihpICsgaiA+IG4pXHJcblx0XHRyZXR1cm4gLTE7XHJcblx0ICAgIHdoaWxlKGotLSA+IDApXHJcblx0XHRsbFtpKytdID0gbDtcclxuXHR9IGVsc2UgaWYoaiA9PSAxNykge1x0Ly8gMyB0byAxMCB6ZXJvIGxlbmd0aCBjb2Rlc1xyXG5cdCAgICB6aXBfTkVFREJJVFMoMyk7XHJcblx0ICAgIGogPSAzICsgemlwX0dFVEJJVFMoMyk7XHJcblx0ICAgIHppcF9EVU1QQklUUygzKTtcclxuXHQgICAgaWYoaSArIGogPiBuKVxyXG5cdFx0cmV0dXJuIC0xO1xyXG5cdCAgICB3aGlsZShqLS0gPiAwKVxyXG5cdFx0bGxbaSsrXSA9IDA7XHJcblx0ICAgIGwgPSAwO1xyXG5cdH0gZWxzZSB7XHRcdC8vIGogPT0gMTg6IDExIHRvIDEzOCB6ZXJvIGxlbmd0aCBjb2Rlc1xyXG5cdCAgICB6aXBfTkVFREJJVFMoNyk7XHJcblx0ICAgIGogPSAxMSArIHppcF9HRVRCSVRTKDcpO1xyXG5cdCAgICB6aXBfRFVNUEJJVFMoNyk7XHJcblx0ICAgIGlmKGkgKyBqID4gbilcclxuXHRcdHJldHVybiAtMTtcclxuXHQgICAgd2hpbGUoai0tID4gMClcclxuXHRcdGxsW2krK10gPSAwO1xyXG5cdCAgICBsID0gMDtcclxuXHR9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYnVpbGQgdGhlIGRlY29kaW5nIHRhYmxlcyBmb3IgbGl0ZXJhbC9sZW5ndGggYW5kIGRpc3RhbmNlIGNvZGVzXHJcbiAgICB6aXBfYmwgPSB6aXBfbGJpdHM7XHJcbiAgICBoID0gbmV3IHppcF9IdWZ0QnVpbGQobGwsIG5sLCAyNTcsIHppcF9jcGxlbnMsIHppcF9jcGxleHQsIHppcF9ibCk7XHJcbiAgICBpZih6aXBfYmwgPT0gMClcdC8vIG5vIGxpdGVyYWxzIG9yIGxlbmd0aHNcclxuXHRoLnN0YXR1cyA9IDE7XHJcbiAgICBpZihoLnN0YXR1cyAhPSAwKSB7XHJcblx0aWYoaC5zdGF0dXMgPT0gMSlcclxuXHQgICAgOy8vICoqaW5jb21wbGV0ZSBsaXRlcmFsIHRyZWUqKlxyXG5cdHJldHVybiAtMTtcdFx0Ly8gaW5jb21wbGV0ZSBjb2RlIHNldFxyXG4gICAgfVxyXG4gICAgemlwX3RsID0gaC5yb290O1xyXG4gICAgemlwX2JsID0gaC5tO1xyXG5cclxuICAgIGZvcihpID0gMDsgaSA8IG5kOyBpKyspXHJcblx0bGxbaV0gPSBsbFtpICsgbmxdO1xyXG4gICAgemlwX2JkID0gemlwX2RiaXRzO1xyXG4gICAgaCA9IG5ldyB6aXBfSHVmdEJ1aWxkKGxsLCBuZCwgMCwgemlwX2NwZGlzdCwgemlwX2NwZGV4dCwgemlwX2JkKTtcclxuICAgIHppcF90ZCA9IGgucm9vdDtcclxuICAgIHppcF9iZCA9IGgubTtcclxuXHJcbiAgICBpZih6aXBfYmQgPT0gMCAmJiBubCA+IDI1NykgeyAgIC8vIGxlbmd0aHMgYnV0IG5vIGRpc3RhbmNlc1xyXG5cdC8vICoqaW5jb21wbGV0ZSBkaXN0YW5jZSB0cmVlKipcclxuXHRyZXR1cm4gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgaWYoaC5zdGF0dXMgPT0gMSkge1xyXG5cdDsvLyAqKmluY29tcGxldGUgZGlzdGFuY2UgdHJlZSoqXHJcbiAgICB9XHJcbiAgICBpZihoLnN0YXR1cyAhPSAwKVxyXG5cdHJldHVybiAtMTtcclxuXHJcbiAgICAvLyBkZWNvbXByZXNzIHVudGlsIGFuIGVuZC1vZi1ibG9jayBjb2RlXHJcbiAgICByZXR1cm4gemlwX2luZmxhdGVfY29kZXMoYnVmZiwgb2ZmLCBzaXplKTtcclxufVxyXG5cclxudmFyIHppcF9pbmZsYXRlX3N0YXJ0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgaTtcclxuXHJcbiAgICBpZih6aXBfc2xpZGUgPT0gbnVsbClcclxuXHR6aXBfc2xpZGUgPSBuZXcgQXJyYXkoMiAqIHppcF9XU0laRSk7XHJcbiAgICB6aXBfd3AgPSAwO1xyXG4gICAgemlwX2JpdF9idWYgPSAwO1xyXG4gICAgemlwX2JpdF9sZW4gPSAwO1xyXG4gICAgemlwX21ldGhvZCA9IC0xO1xyXG4gICAgemlwX2VvZiA9IGZhbHNlO1xyXG4gICAgemlwX2NvcHlfbGVuZyA9IHppcF9jb3B5X2Rpc3QgPSAwO1xyXG4gICAgemlwX3RsID0gbnVsbDtcclxufVxyXG5cclxudmFyIHppcF9pbmZsYXRlX2ludGVybmFsID0gZnVuY3Rpb24oYnVmZiwgb2ZmLCBzaXplKSB7XHJcbiAgICAvLyBkZWNvbXByZXNzIGFuIGluZmxhdGVkIGVudHJ5XHJcbiAgICB2YXIgbiwgaTtcclxuXHJcbiAgICBuID0gMDtcclxuICAgIHdoaWxlKG4gPCBzaXplKSB7XHJcblx0aWYoemlwX2VvZiAmJiB6aXBfbWV0aG9kID09IC0xKVxyXG5cdCAgICByZXR1cm4gbjtcclxuXHJcblx0aWYoemlwX2NvcHlfbGVuZyA+IDApIHtcclxuXHQgICAgaWYoemlwX21ldGhvZCAhPSB6aXBfU1RPUkVEX0JMT0NLKSB7XHJcblx0XHQvLyBTVEFUSUNfVFJFRVMgb3IgRFlOX1RSRUVTXHJcblx0XHR3aGlsZSh6aXBfY29weV9sZW5nID4gMCAmJiBuIDwgc2l6ZSkge1xyXG5cdFx0ICAgIHppcF9jb3B5X2xlbmctLTtcclxuXHRcdCAgICB6aXBfY29weV9kaXN0ICY9IHppcF9XU0laRSAtIDE7XHJcblx0XHQgICAgemlwX3dwICY9IHppcF9XU0laRSAtIDE7XHJcblx0XHQgICAgYnVmZltvZmYgKyBuKytdID0gemlwX3NsaWRlW3ppcF93cCsrXSA9XHJcblx0XHRcdHppcF9zbGlkZVt6aXBfY29weV9kaXN0KytdO1xyXG5cdFx0fVxyXG5cdCAgICB9IGVsc2Uge1xyXG5cdFx0d2hpbGUoemlwX2NvcHlfbGVuZyA+IDAgJiYgbiA8IHNpemUpIHtcclxuXHRcdCAgICB6aXBfY29weV9sZW5nLS07XHJcblx0XHQgICAgemlwX3dwICY9IHppcF9XU0laRSAtIDE7XHJcblx0XHQgICAgemlwX05FRURCSVRTKDgpO1xyXG5cdFx0ICAgIGJ1ZmZbb2ZmICsgbisrXSA9IHppcF9zbGlkZVt6aXBfd3ArK10gPSB6aXBfR0VUQklUUyg4KTtcclxuXHRcdCAgICB6aXBfRFVNUEJJVFMoOCk7XHJcblx0XHR9XHJcblx0XHRpZih6aXBfY29weV9sZW5nID09IDApXHJcblx0XHQgICAgemlwX21ldGhvZCA9IC0xOyAvLyBkb25lXHJcblx0ICAgIH1cclxuXHQgICAgaWYobiA9PSBzaXplKVxyXG5cdFx0cmV0dXJuIG47XHJcblx0fVxyXG5cclxuXHRpZih6aXBfbWV0aG9kID09IC0xKSB7XHJcblx0ICAgIGlmKHppcF9lb2YpXHJcblx0XHRicmVhaztcclxuXHJcblx0ICAgIC8vIHJlYWQgaW4gbGFzdCBibG9jayBiaXRcclxuXHQgICAgemlwX05FRURCSVRTKDEpO1xyXG5cdCAgICBpZih6aXBfR0VUQklUUygxKSAhPSAwKVxyXG5cdFx0emlwX2VvZiA9IHRydWU7XHJcblx0ICAgIHppcF9EVU1QQklUUygxKTtcclxuXHJcblx0ICAgIC8vIHJlYWQgaW4gYmxvY2sgdHlwZVxyXG5cdCAgICB6aXBfTkVFREJJVFMoMik7XHJcblx0ICAgIHppcF9tZXRob2QgPSB6aXBfR0VUQklUUygyKTtcclxuXHQgICAgemlwX0RVTVBCSVRTKDIpO1xyXG5cdCAgICB6aXBfdGwgPSBudWxsO1xyXG5cdCAgICB6aXBfY29weV9sZW5nID0gMDtcclxuXHR9XHJcblxyXG5cdHN3aXRjaCh6aXBfbWV0aG9kKSB7XHJcblx0ICBjYXNlIDA6IC8vIHppcF9TVE9SRURfQkxPQ0tcclxuXHQgICAgaSA9IHppcF9pbmZsYXRlX3N0b3JlZChidWZmLCBvZmYgKyBuLCBzaXplIC0gbik7XHJcblx0ICAgIGJyZWFrO1xyXG5cclxuXHQgIGNhc2UgMTogLy8gemlwX1NUQVRJQ19UUkVFU1xyXG5cdCAgICBpZih6aXBfdGwgIT0gbnVsbClcclxuXHRcdGkgPSB6aXBfaW5mbGF0ZV9jb2RlcyhidWZmLCBvZmYgKyBuLCBzaXplIC0gbik7XHJcblx0ICAgIGVsc2VcclxuXHRcdGkgPSB6aXBfaW5mbGF0ZV9maXhlZChidWZmLCBvZmYgKyBuLCBzaXplIC0gbik7XHJcblx0ICAgIGJyZWFrO1xyXG5cclxuXHQgIGNhc2UgMjogLy8gemlwX0RZTl9UUkVFU1xyXG5cdCAgICBpZih6aXBfdGwgIT0gbnVsbClcclxuXHRcdGkgPSB6aXBfaW5mbGF0ZV9jb2RlcyhidWZmLCBvZmYgKyBuLCBzaXplIC0gbik7XHJcblx0ICAgIGVsc2VcclxuXHRcdGkgPSB6aXBfaW5mbGF0ZV9keW5hbWljKGJ1ZmYsIG9mZiArIG4sIHNpemUgLSBuKTtcclxuXHQgICAgYnJlYWs7XHJcblxyXG5cdCAgZGVmYXVsdDogLy8gZXJyb3JcclxuXHQgICAgaSA9IC0xO1xyXG5cdCAgICBicmVhaztcclxuXHR9XHJcblxyXG5cdGlmKGkgPT0gLTEpIHtcclxuXHQgICAgaWYoemlwX2VvZilcclxuXHRcdHJldHVybiAwO1xyXG5cdCAgICByZXR1cm4gLTE7XHJcblx0fVxyXG5cdG4gKz0gaTtcclxuICAgIH1cclxuICAgIHJldHVybiBuO1xyXG59XHJcblxyXG52YXIgemlwX2luZmxhdGUgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgIHZhciBpLCBqO1xyXG5cclxuICAgIHppcF9pbmZsYXRlX3N0YXJ0KCk7XHJcbiAgICB6aXBfaW5mbGF0ZV9kYXRhID0gc3RyO1xyXG4gICAgemlwX2luZmxhdGVfcG9zID0gMDtcclxuXHJcbiAgICB2YXIgYnVmZiA9IG5ldyBBcnJheSgxMDI0KTtcclxuICAgIHZhciBhb3V0ID0gW107XHJcbiAgICB3aGlsZSgoaSA9IHppcF9pbmZsYXRlX2ludGVybmFsKGJ1ZmYsIDAsIGJ1ZmYubGVuZ3RoKSkgPiAwKSB7XHJcblx0dmFyIGNidWYgPSBuZXcgQXJyYXkoaSk7XHJcblx0Zm9yKGogPSAwOyBqIDwgaTsgaisrKXtcclxuXHQgICAgY2J1ZltqXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZltqXSk7XHJcblx0fVxyXG5cdGFvdXRbYW91dC5sZW5ndGhdID0gY2J1Zi5qb2luKFwiXCIpO1xyXG4gICAgfVxyXG4gICAgemlwX2luZmxhdGVfZGF0YSA9IG51bGw7IC8vIEcuQy5cclxuICAgIHJldHVybiBhb3V0LmpvaW4oXCJcIik7XHJcbn1cclxuXHJcbmlmICghIHdpbmRvdy5SYXdEZWZsYXRlKSBSYXdEZWZsYXRlID0ge307XHJcblJhd0RlZmxhdGUuaW5mbGF0ZSA9IHppcF9pbmZsYXRlO1xyXG5cclxufSkoKTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/rawinflate.js\n");

/***/ }),

/***/ "./lib/spell-checker.min.js":
/*!**********************************!*\
  !*** ./lib/spell-checker.min.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/**\r\n * codemirror-spell-checker v1.2.1\r\n * Copyright Next Step Webs, Inc.\r\n * @link https://github.com/NextStepWebs/codemirror-spell-checker\r\n * @license MIT\r\n */\r\n!function(t){if(true)module.exports=t();else { var e; }}(function(){return function t(e,r,n){function i(s,a){if(!r[s]){if(!e[s]){var f=\"function\"==typeof require&&require;if(!a&&f)return require(s,!0);if(o)return o(s,!0);var u=new Error(\"Cannot find module '\"+s+\"'\");throw u.code=\"MODULE_NOT_FOUND\",u}var h=r[s]={exports:{}};e[s][0].call(h.exports,function(t){var r=e[s][1][t];return i(r?r:t)},h,h.exports,t,e,r,n)}return r[s].exports}for(var o=\"function\"==typeof require&&require,s=0;s<n.length;s++)i(n[s]);return i}({1:[function(t,e,r){\"use strict\";function n(){for(var t=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",e=0,r=t.length;r>e;++e)f[e]=t[e],u[t.charCodeAt(e)]=e;u[\"-\".charCodeAt(0)]=62,u[\"_\".charCodeAt(0)]=63}function i(t){var e,r,n,i,o,s,a=t.length;if(a%4>0)throw new Error(\"Invalid string. Length must be a multiple of 4\");o=\"=\"===t[a-2]?2:\"=\"===t[a-1]?1:0,s=new h(3*a/4-o),n=o>0?a-4:a;var f=0;for(e=0,r=0;n>e;e+=4,r+=3)i=u[t.charCodeAt(e)]<<18|u[t.charCodeAt(e+1)]<<12|u[t.charCodeAt(e+2)]<<6|u[t.charCodeAt(e+3)],s[f++]=i>>16&255,s[f++]=i>>8&255,s[f++]=255&i;return 2===o?(i=u[t.charCodeAt(e)]<<2|u[t.charCodeAt(e+1)]>>4,s[f++]=255&i):1===o&&(i=u[t.charCodeAt(e)]<<10|u[t.charCodeAt(e+1)]<<4|u[t.charCodeAt(e+2)]>>2,s[f++]=i>>8&255,s[f++]=255&i),s}function o(t){return f[t>>18&63]+f[t>>12&63]+f[t>>6&63]+f[63&t]}function s(t,e,r){for(var n,i=[],s=e;r>s;s+=3)n=(t[s]<<16)+(t[s+1]<<8)+t[s+2],i.push(o(n));return i.join(\"\")}function a(t){for(var e,r=t.length,n=r%3,i=\"\",o=[],a=16383,u=0,h=r-n;h>u;u+=a)o.push(s(t,u,u+a>h?h:u+a));return 1===n?(e=t[r-1],i+=f[e>>2],i+=f[e<<4&63],i+=\"==\"):2===n&&(e=(t[r-2]<<8)+t[r-1],i+=f[e>>10],i+=f[e>>4&63],i+=f[e<<2&63],i+=\"=\"),o.push(i),o.join(\"\")}r.toByteArray=i,r.fromByteArray=a;var f=[],u=[],h=\"undefined\"!=typeof Uint8Array?Uint8Array:Array;n()},{}],2:[function(t,e,r){},{}],3:[function(t,e,r){(function(e){\"use strict\";function n(){try{var t=new Uint8Array(1);return t.foo=function(){return 42},42===t.foo()&&\"function\"==typeof t.subarray&&0===t.subarray(1,1).byteLength}catch(e){return!1}}function i(){return s.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function o(t,e){if(i()<e)throw new RangeError(\"Invalid typed array length\");return s.TYPED_ARRAY_SUPPORT?(t=new Uint8Array(e),t.__proto__=s.prototype):(null===t&&(t=new s(e)),t.length=e),t}function s(t,e,r){if(!(s.TYPED_ARRAY_SUPPORT||this instanceof s))return new s(t,e,r);if(\"number\"==typeof t){if(\"string\"==typeof e)throw new Error(\"If encoding is specified then the first argument must be a string\");return h(this,t)}return a(this,t,e,r)}function a(t,e,r,n){if(\"number\"==typeof e)throw new TypeError('\"value\" argument must not be a number');return\"undefined\"!=typeof ArrayBuffer&&e instanceof ArrayBuffer?p(t,e,r,n):\"string\"==typeof e?l(t,e,r):d(t,e)}function f(t){if(\"number\"!=typeof t)throw new TypeError('\"size\" argument must be a number')}function u(t,e,r,n){return f(e),0>=e?o(t,e):void 0!==r?\"string\"==typeof n?o(t,e).fill(r,n):o(t,e).fill(r):o(t,e)}function h(t,e){if(f(e),t=o(t,0>e?0:0|g(e)),!s.TYPED_ARRAY_SUPPORT)for(var r=0;e>r;r++)t[r]=0;return t}function l(t,e,r){if(\"string\"==typeof r&&\"\"!==r||(r=\"utf8\"),!s.isEncoding(r))throw new TypeError('\"encoding\" must be a valid string encoding');var n=0|v(e,r);return t=o(t,n),t.write(e,r),t}function c(t,e){var r=0|g(e.length);t=o(t,r);for(var n=0;r>n;n+=1)t[n]=255&e[n];return t}function p(t,e,r,n){if(e.byteLength,0>r||e.byteLength<r)throw new RangeError(\"'offset' is out of bounds\");if(e.byteLength<r+(n||0))throw new RangeError(\"'length' is out of bounds\");return e=void 0===n?new Uint8Array(e,r):new Uint8Array(e,r,n),s.TYPED_ARRAY_SUPPORT?(t=e,t.__proto__=s.prototype):t=c(t,e),t}function d(t,e){if(s.isBuffer(e)){var r=0|g(e.length);return t=o(t,r),0===t.length?t:(e.copy(t,0,0,r),t)}if(e){if(\"undefined\"!=typeof ArrayBuffer&&e.buffer instanceof ArrayBuffer||\"length\"in e)return\"number\"!=typeof e.length||V(e.length)?o(t,0):c(t,e);if(\"Buffer\"===e.type&&Q(e.data))return c(t,e.data)}throw new TypeError(\"First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\")}function g(t){if(t>=i())throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\"+i().toString(16)+\" bytes\");return 0|t}function y(t){return+t!=t&&(t=0),s.alloc(+t)}function v(t,e){if(s.isBuffer(t))return t.length;if(\"undefined\"!=typeof ArrayBuffer&&\"function\"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(t)||t instanceof ArrayBuffer))return t.byteLength;\"string\"!=typeof t&&(t=\"\"+t);var r=t.length;if(0===r)return 0;for(var n=!1;;)switch(e){case\"ascii\":case\"binary\":case\"raw\":case\"raws\":return r;case\"utf8\":case\"utf-8\":case void 0:return z(t).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return 2*r;case\"hex\":return r>>>1;case\"base64\":return H(t).length;default:if(n)return z(t).length;e=(\"\"+e).toLowerCase(),n=!0}}function w(t,e,r){var n=!1;if((void 0===e||0>e)&&(e=0),e>this.length)return\"\";if((void 0===r||r>this.length)&&(r=this.length),0>=r)return\"\";if(r>>>=0,e>>>=0,e>=r)return\"\";for(t||(t=\"utf8\");;)switch(t){case\"hex\":return x(this,e,r);case\"utf8\":case\"utf-8\":return C(this,e,r);case\"ascii\":return B(this,e,r);case\"binary\":return M(this,e,r);case\"base64\":return S(this,e,r);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return I(this,e,r);default:if(n)throw new TypeError(\"Unknown encoding: \"+t);t=(t+\"\").toLowerCase(),n=!0}}function m(t,e,r){var n=t[e];t[e]=t[r],t[r]=n}function E(t,e,r,n){function i(t,e){return 1===o?t[e]:t.readUInt16BE(e*o)}var o=1,s=t.length,a=e.length;if(void 0!==n&&(n=String(n).toLowerCase(),\"ucs2\"===n||\"ucs-2\"===n||\"utf16le\"===n||\"utf-16le\"===n)){if(t.length<2||e.length<2)return-1;o=2,s/=2,a/=2,r/=2}for(var f=-1,u=0;s>r+u;u++)if(i(t,r+u)===i(e,-1===f?0:u-f)){if(-1===f&&(f=u),u-f+1===a)return(r+f)*o}else-1!==f&&(u-=u-f),f=-1;return-1}function b(t,e,r,n){r=Number(r)||0;var i=t.length-r;n?(n=Number(n),n>i&&(n=i)):n=i;var o=e.length;if(o%2!==0)throw new Error(\"Invalid hex string\");n>o/2&&(n=o/2);for(var s=0;n>s;s++){var a=parseInt(e.substr(2*s,2),16);if(isNaN(a))return s;t[r+s]=a}return s}function R(t,e,r,n){return K(z(e,t.length-r),t,r,n)}function _(t,e,r,n){return K(G(e),t,r,n)}function A(t,e,r,n){return _(t,e,r,n)}function P(t,e,r,n){return K(H(e),t,r,n)}function T(t,e,r,n){return K($(e,t.length-r),t,r,n)}function S(t,e,r){return 0===e&&r===t.length?J.fromByteArray(t):J.fromByteArray(t.slice(e,r))}function C(t,e,r){r=Math.min(t.length,r);for(var n=[],i=e;r>i;){var o=t[i],s=null,a=o>239?4:o>223?3:o>191?2:1;if(r>=i+a){var f,u,h,l;switch(a){case 1:128>o&&(s=o);break;case 2:f=t[i+1],128===(192&f)&&(l=(31&o)<<6|63&f,l>127&&(s=l));break;case 3:f=t[i+1],u=t[i+2],128===(192&f)&&128===(192&u)&&(l=(15&o)<<12|(63&f)<<6|63&u,l>2047&&(55296>l||l>57343)&&(s=l));break;case 4:f=t[i+1],u=t[i+2],h=t[i+3],128===(192&f)&&128===(192&u)&&128===(192&h)&&(l=(15&o)<<18|(63&f)<<12|(63&u)<<6|63&h,l>65535&&1114112>l&&(s=l))}}null===s?(s=65533,a=1):s>65535&&(s-=65536,n.push(s>>>10&1023|55296),s=56320|1023&s),n.push(s),i+=a}return U(n)}function U(t){var e=t.length;if(W>=e)return String.fromCharCode.apply(String,t);for(var r=\"\",n=0;e>n;)r+=String.fromCharCode.apply(String,t.slice(n,n+=W));return r}function B(t,e,r){var n=\"\";r=Math.min(t.length,r);for(var i=e;r>i;i++)n+=String.fromCharCode(127&t[i]);return n}function M(t,e,r){var n=\"\";r=Math.min(t.length,r);for(var i=e;r>i;i++)n+=String.fromCharCode(t[i]);return n}function x(t,e,r){var n=t.length;(!e||0>e)&&(e=0),(!r||0>r||r>n)&&(r=n);for(var i=\"\",o=e;r>o;o++)i+=q(t[o]);return i}function I(t,e,r){for(var n=t.slice(e,r),i=\"\",o=0;o<n.length;o+=2)i+=String.fromCharCode(n[o]+256*n[o+1]);return i}function O(t,e,r){if(t%1!==0||0>t)throw new RangeError(\"offset is not uint\");if(t+e>r)throw new RangeError(\"Trying to access beyond buffer length\")}function Y(t,e,r,n,i,o){if(!s.isBuffer(t))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(e>i||o>e)throw new RangeError('\"value\" argument is out of bounds');if(r+n>t.length)throw new RangeError(\"Index out of range\")}function L(t,e,r,n){0>e&&(e=65535+e+1);for(var i=0,o=Math.min(t.length-r,2);o>i;i++)t[r+i]=(e&255<<8*(n?i:1-i))>>>8*(n?i:1-i)}function D(t,e,r,n){0>e&&(e=4294967295+e+1);for(var i=0,o=Math.min(t.length-r,4);o>i;i++)t[r+i]=e>>>8*(n?i:3-i)&255}function F(t,e,r,n,i,o){if(r+n>t.length)throw new RangeError(\"Index out of range\");if(0>r)throw new RangeError(\"Index out of range\")}function k(t,e,r,n,i){return i||F(t,e,r,4,3.4028234663852886e38,-3.4028234663852886e38),Z.write(t,e,r,n,23,4),r+4}function N(t,e,r,n,i){return i||F(t,e,r,8,1.7976931348623157e308,-1.7976931348623157e308),Z.write(t,e,r,n,52,8),r+8}function j(t){if(t=X(t).replace(tt,\"\"),t.length<2)return\"\";for(;t.length%4!==0;)t+=\"=\";return t}function X(t){return t.trim?t.trim():t.replace(/^\\s+|\\s+$/g,\"\")}function q(t){return 16>t?\"0\"+t.toString(16):t.toString(16)}function z(t,e){e=e||1/0;for(var r,n=t.length,i=null,o=[],s=0;n>s;s++){if(r=t.charCodeAt(s),r>55295&&57344>r){if(!i){if(r>56319){(e-=3)>-1&&o.push(239,191,189);continue}if(s+1===n){(e-=3)>-1&&o.push(239,191,189);continue}i=r;continue}if(56320>r){(e-=3)>-1&&o.push(239,191,189),i=r;continue}r=(i-55296<<10|r-56320)+65536}else i&&(e-=3)>-1&&o.push(239,191,189);if(i=null,128>r){if((e-=1)<0)break;o.push(r)}else if(2048>r){if((e-=2)<0)break;o.push(r>>6|192,63&r|128)}else if(65536>r){if((e-=3)<0)break;o.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(1114112>r))throw new Error(\"Invalid code point\");if((e-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return o}function G(t){for(var e=[],r=0;r<t.length;r++)e.push(255&t.charCodeAt(r));return e}function $(t,e){for(var r,n,i,o=[],s=0;s<t.length&&!((e-=2)<0);s++)r=t.charCodeAt(s),n=r>>8,i=r%256,o.push(i),o.push(n);return o}function H(t){return J.toByteArray(j(t))}function K(t,e,r,n){for(var i=0;n>i&&!(i+r>=e.length||i>=t.length);i++)e[i+r]=t[i];return i}function V(t){return t!==t}var J=t(\"base64-js\"),Z=t(\"ieee754\"),Q=t(\"isarray\");r.Buffer=s,r.SlowBuffer=y,r.INSPECT_MAX_BYTES=50,s.TYPED_ARRAY_SUPPORT=void 0!==e.TYPED_ARRAY_SUPPORT?e.TYPED_ARRAY_SUPPORT:n(),r.kMaxLength=i(),s.poolSize=8192,s._augment=function(t){return t.__proto__=s.prototype,t},s.from=function(t,e,r){return a(null,t,e,r)},s.TYPED_ARRAY_SUPPORT&&(s.prototype.__proto__=Uint8Array.prototype,s.__proto__=Uint8Array,\"undefined\"!=typeof Symbol&&Symbol.species&&s[Symbol.species]===s&&Object.defineProperty(s,Symbol.species,{value:null,configurable:!0})),s.alloc=function(t,e,r){return u(null,t,e,r)},s.allocUnsafe=function(t){return h(null,t)},s.allocUnsafeSlow=function(t){return h(null,t)},s.isBuffer=function(t){return!(null==t||!t._isBuffer)},s.compare=function(t,e){if(!s.isBuffer(t)||!s.isBuffer(e))throw new TypeError(\"Arguments must be Buffers\");if(t===e)return 0;for(var r=t.length,n=e.length,i=0,o=Math.min(r,n);o>i;++i)if(t[i]!==e[i]){r=t[i],n=e[i];break}return n>r?-1:r>n?1:0},s.isEncoding=function(t){switch(String(t).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"binary\":case\"base64\":case\"raw\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return!0;default:return!1}},s.concat=function(t,e){if(!Q(t))throw new TypeError('\"list\" argument must be an Array of Buffers');if(0===t.length)return s.alloc(0);var r;if(void 0===e)for(e=0,r=0;r<t.length;r++)e+=t[r].length;var n=s.allocUnsafe(e),i=0;for(r=0;r<t.length;r++){var o=t[r];if(!s.isBuffer(o))throw new TypeError('\"list\" argument must be an Array of Buffers');o.copy(n,i),i+=o.length}return n},s.byteLength=v,s.prototype._isBuffer=!0,s.prototype.swap16=function(){var t=this.length;if(t%2!==0)throw new RangeError(\"Buffer size must be a multiple of 16-bits\");for(var e=0;t>e;e+=2)m(this,e,e+1);return this},s.prototype.swap32=function(){var t=this.length;if(t%4!==0)throw new RangeError(\"Buffer size must be a multiple of 32-bits\");for(var e=0;t>e;e+=4)m(this,e,e+3),m(this,e+1,e+2);return this},s.prototype.toString=function(){var t=0|this.length;return 0===t?\"\":0===arguments.length?C(this,0,t):w.apply(this,arguments)},s.prototype.equals=function(t){if(!s.isBuffer(t))throw new TypeError(\"Argument must be a Buffer\");return this===t?!0:0===s.compare(this,t)},s.prototype.inspect=function(){var t=\"\",e=r.INSPECT_MAX_BYTES;return this.length>0&&(t=this.toString(\"hex\",0,e).match(/.{2}/g).join(\" \"),this.length>e&&(t+=\" ... \")),\"<Buffer \"+t+\">\"},s.prototype.compare=function(t,e,r,n,i){if(!s.isBuffer(t))throw new TypeError(\"Argument must be a Buffer\");if(void 0===e&&(e=0),void 0===r&&(r=t?t.length:0),void 0===n&&(n=0),void 0===i&&(i=this.length),0>e||r>t.length||0>n||i>this.length)throw new RangeError(\"out of range index\");if(n>=i&&e>=r)return 0;if(n>=i)return-1;if(e>=r)return 1;if(e>>>=0,r>>>=0,n>>>=0,i>>>=0,this===t)return 0;for(var o=i-n,a=r-e,f=Math.min(o,a),u=this.slice(n,i),h=t.slice(e,r),l=0;f>l;++l)if(u[l]!==h[l]){o=u[l],a=h[l];break}return a>o?-1:o>a?1:0},s.prototype.indexOf=function(t,e,r){if(\"string\"==typeof e?(r=e,e=0):e>2147483647?e=2147483647:-2147483648>e&&(e=-2147483648),e>>=0,0===this.length)return-1;if(e>=this.length)return-1;if(0>e&&(e=Math.max(this.length+e,0)),\"string\"==typeof t&&(t=s.from(t,r)),s.isBuffer(t))return 0===t.length?-1:E(this,t,e,r);if(\"number\"==typeof t)return s.TYPED_ARRAY_SUPPORT&&\"function\"===Uint8Array.prototype.indexOf?Uint8Array.prototype.indexOf.call(this,t,e):E(this,[t],e,r);throw new TypeError(\"val must be string, number or Buffer\")},s.prototype.includes=function(t,e,r){return-1!==this.indexOf(t,e,r)},s.prototype.write=function(t,e,r,n){if(void 0===e)n=\"utf8\",r=this.length,e=0;else if(void 0===r&&\"string\"==typeof e)n=e,r=this.length,e=0;else{if(!isFinite(e))throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");e=0|e,isFinite(r)?(r=0|r,void 0===n&&(n=\"utf8\")):(n=r,r=void 0)}var i=this.length-e;if((void 0===r||r>i)&&(r=i),t.length>0&&(0>r||0>e)||e>this.length)throw new RangeError(\"Attempt to write outside buffer bounds\");n||(n=\"utf8\");for(var o=!1;;)switch(n){case\"hex\":return b(this,t,e,r);case\"utf8\":case\"utf-8\":return R(this,t,e,r);case\"ascii\":return _(this,t,e,r);case\"binary\":return A(this,t,e,r);case\"base64\":return P(this,t,e,r);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return T(this,t,e,r);default:if(o)throw new TypeError(\"Unknown encoding: \"+n);n=(\"\"+n).toLowerCase(),o=!0}},s.prototype.toJSON=function(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};var W=4096;s.prototype.slice=function(t,e){var r=this.length;t=~~t,e=void 0===e?r:~~e,0>t?(t+=r,0>t&&(t=0)):t>r&&(t=r),0>e?(e+=r,0>e&&(e=0)):e>r&&(e=r),t>e&&(e=t);var n;if(s.TYPED_ARRAY_SUPPORT)n=this.subarray(t,e),n.__proto__=s.prototype;else{var i=e-t;n=new s(i,void 0);for(var o=0;i>o;o++)n[o]=this[o+t]}return n},s.prototype.readUIntLE=function(t,e,r){t=0|t,e=0|e,r||O(t,e,this.length);for(var n=this[t],i=1,o=0;++o<e&&(i*=256);)n+=this[t+o]*i;return n},s.prototype.readUIntBE=function(t,e,r){t=0|t,e=0|e,r||O(t,e,this.length);for(var n=this[t+--e],i=1;e>0&&(i*=256);)n+=this[t+--e]*i;return n},s.prototype.readUInt8=function(t,e){return e||O(t,1,this.length),this[t]},s.prototype.readUInt16LE=function(t,e){return e||O(t,2,this.length),this[t]|this[t+1]<<8},s.prototype.readUInt16BE=function(t,e){return e||O(t,2,this.length),this[t]<<8|this[t+1]},s.prototype.readUInt32LE=function(t,e){return e||O(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},s.prototype.readUInt32BE=function(t,e){return e||O(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},s.prototype.readIntLE=function(t,e,r){t=0|t,e=0|e,r||O(t,e,this.length);for(var n=this[t],i=1,o=0;++o<e&&(i*=256);)n+=this[t+o]*i;return i*=128,n>=i&&(n-=Math.pow(2,8*e)),n},s.prototype.readIntBE=function(t,e,r){t=0|t,e=0|e,r||O(t,e,this.length);for(var n=e,i=1,o=this[t+--n];n>0&&(i*=256);)o+=this[t+--n]*i;return i*=128,o>=i&&(o-=Math.pow(2,8*e)),o},s.prototype.readInt8=function(t,e){return e||O(t,1,this.length),128&this[t]?-1*(255-this[t]+1):this[t]},s.prototype.readInt16LE=function(t,e){e||O(t,2,this.length);var r=this[t]|this[t+1]<<8;return 32768&r?4294901760|r:r},s.prototype.readInt16BE=function(t,e){e||O(t,2,this.length);var r=this[t+1]|this[t]<<8;return 32768&r?4294901760|r:r},s.prototype.readInt32LE=function(t,e){return e||O(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},s.prototype.readInt32BE=function(t,e){return e||O(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},s.prototype.readFloatLE=function(t,e){return e||O(t,4,this.length),Z.read(this,t,!0,23,4)},s.prototype.readFloatBE=function(t,e){return e||O(t,4,this.length),Z.read(this,t,!1,23,4)},s.prototype.readDoubleLE=function(t,e){return e||O(t,8,this.length),Z.read(this,t,!0,52,8)},s.prototype.readDoubleBE=function(t,e){return e||O(t,8,this.length),Z.read(this,t,!1,52,8)},s.prototype.writeUIntLE=function(t,e,r,n){if(t=+t,e=0|e,r=0|r,!n){var i=Math.pow(2,8*r)-1;Y(this,t,e,r,i,0)}var o=1,s=0;for(this[e]=255&t;++s<r&&(o*=256);)this[e+s]=t/o&255;return e+r},s.prototype.writeUIntBE=function(t,e,r,n){if(t=+t,e=0|e,r=0|r,!n){var i=Math.pow(2,8*r)-1;Y(this,t,e,r,i,0)}var o=r-1,s=1;for(this[e+o]=255&t;--o>=0&&(s*=256);)this[e+o]=t/s&255;return e+r},s.prototype.writeUInt8=function(t,e,r){return t=+t,e=0|e,r||Y(this,t,e,1,255,0),s.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),this[e]=255&t,e+1},s.prototype.writeUInt16LE=function(t,e,r){return t=+t,e=0|e,r||Y(this,t,e,2,65535,0),s.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):L(this,t,e,!0),e+2},s.prototype.writeUInt16BE=function(t,e,r){return t=+t,e=0|e,r||Y(this,t,e,2,65535,0),s.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):L(this,t,e,!1),e+2},s.prototype.writeUInt32LE=function(t,e,r){return t=+t,e=0|e,r||Y(this,t,e,4,4294967295,0),s.TYPED_ARRAY_SUPPORT?(this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=255&t):D(this,t,e,!0),e+4},s.prototype.writeUInt32BE=function(t,e,r){return t=+t,e=0|e,r||Y(this,t,e,4,4294967295,0),s.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):D(this,t,e,!1),e+4},s.prototype.writeIntLE=function(t,e,r,n){if(t=+t,e=0|e,!n){var i=Math.pow(2,8*r-1);Y(this,t,e,r,i-1,-i)}var o=0,s=1,a=0;for(this[e]=255&t;++o<r&&(s*=256);)0>t&&0===a&&0!==this[e+o-1]&&(a=1),this[e+o]=(t/s>>0)-a&255;return e+r},s.prototype.writeIntBE=function(t,e,r,n){if(t=+t,e=0|e,!n){var i=Math.pow(2,8*r-1);Y(this,t,e,r,i-1,-i)}var o=r-1,s=1,a=0;for(this[e+o]=255&t;--o>=0&&(s*=256);)0>t&&0===a&&0!==this[e+o+1]&&(a=1),this[e+o]=(t/s>>0)-a&255;return e+r},s.prototype.writeInt8=function(t,e,r){return t=+t,e=0|e,r||Y(this,t,e,1,127,-128),s.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),0>t&&(t=255+t+1),this[e]=255&t,e+1},s.prototype.writeInt16LE=function(t,e,r){return t=+t,e=0|e,r||Y(this,t,e,2,32767,-32768),s.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):L(this,t,e,!0),e+2},s.prototype.writeInt16BE=function(t,e,r){return t=+t,e=0|e,r||Y(this,t,e,2,32767,-32768),s.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):L(this,t,e,!1),e+2},s.prototype.writeInt32LE=function(t,e,r){return t=+t,e=0|e,r||Y(this,t,e,4,2147483647,-2147483648),s.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24):D(this,t,e,!0),e+4},s.prototype.writeInt32BE=function(t,e,r){return t=+t,e=0|e,r||Y(this,t,e,4,2147483647,-2147483648),0>t&&(t=4294967295+t+1),s.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):D(this,t,e,!1),e+4},s.prototype.writeFloatLE=function(t,e,r){return k(this,t,e,!0,r)},s.prototype.writeFloatBE=function(t,e,r){return k(this,t,e,!1,r)},s.prototype.writeDoubleLE=function(t,e,r){return N(this,t,e,!0,r)},s.prototype.writeDoubleBE=function(t,e,r){return N(this,t,e,!1,r)},s.prototype.copy=function(t,e,r,n){if(r||(r=0),n||0===n||(n=this.length),e>=t.length&&(e=t.length),e||(e=0),n>0&&r>n&&(n=r),n===r)return 0;if(0===t.length||0===this.length)return 0;if(0>e)throw new RangeError(\"targetStart out of bounds\");if(0>r||r>=this.length)throw new RangeError(\"sourceStart out of bounds\");if(0>n)throw new RangeError(\"sourceEnd out of bounds\");n>this.length&&(n=this.length),t.length-e<n-r&&(n=t.length-e+r);var i,o=n-r;if(this===t&&e>r&&n>e)for(i=o-1;i>=0;i--)t[i+e]=this[i+r];else if(1e3>o||!s.TYPED_ARRAY_SUPPORT)for(i=0;o>i;i++)t[i+e]=this[i+r];else Uint8Array.prototype.set.call(t,this.subarray(r,r+o),e);return o},s.prototype.fill=function(t,e,r,n){if(\"string\"==typeof t){if(\"string\"==typeof e?(n=e,e=0,r=this.length):\"string\"==typeof r&&(n=r,r=this.length),1===t.length){var i=t.charCodeAt(0);256>i&&(t=i)}if(void 0!==n&&\"string\"!=typeof n)throw new TypeError(\"encoding must be a string\");if(\"string\"==typeof n&&!s.isEncoding(n))throw new TypeError(\"Unknown encoding: \"+n)}else\"number\"==typeof t&&(t=255&t);if(0>e||this.length<e||this.length<r)throw new RangeError(\"Out of range index\");if(e>=r)return this;e>>>=0,r=void 0===r?this.length:r>>>0,t||(t=0);var o;if(\"number\"==typeof t)for(o=e;r>o;o++)this[o]=t;else{var a=s.isBuffer(t)?t:z(new s(t,n).toString()),f=a.length;for(o=0;r-e>o;o++)this[o+e]=a[o%f]}return this};var tt=/[^+\\/0-9A-Za-z-_]/g}).call(this,\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{\"base64-js\":1,ieee754:4,isarray:5}],4:[function(t,e,r){r.read=function(t,e,r,n,i){var o,s,a=8*i-n-1,f=(1<<a)-1,u=f>>1,h=-7,l=r?i-1:0,c=r?-1:1,p=t[e+l];for(l+=c,o=p&(1<<-h)-1,p>>=-h,h+=a;h>0;o=256*o+t[e+l],l+=c,h-=8);for(s=o&(1<<-h)-1,o>>=-h,h+=n;h>0;s=256*s+t[e+l],l+=c,h-=8);if(0===o)o=1-u;else{if(o===f)return s?NaN:(p?-1:1)*(1/0);s+=Math.pow(2,n),o-=u}return(p?-1:1)*s*Math.pow(2,o-n)},r.write=function(t,e,r,n,i,o){var s,a,f,u=8*o-i-1,h=(1<<u)-1,l=h>>1,c=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,p=n?0:o-1,d=n?1:-1,g=0>e||0===e&&0>1/e?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(a=isNaN(e)?1:0,s=h):(s=Math.floor(Math.log(e)/Math.LN2),e*(f=Math.pow(2,-s))<1&&(s--,f*=2),e+=s+l>=1?c/f:c*Math.pow(2,1-l),e*f>=2&&(s++,f/=2),s+l>=h?(a=0,s=h):s+l>=1?(a=(e*f-1)*Math.pow(2,i),s+=l):(a=e*Math.pow(2,l-1)*Math.pow(2,i),s=0));i>=8;t[r+p]=255&a,p+=d,a/=256,i-=8);for(s=s<<i|a,u+=i;u>0;t[r+p]=255&s,p+=d,s/=256,u-=8);t[r+p-d]|=128*g}},{}],5:[function(t,e,r){var n={}.toString;e.exports=Array.isArray||function(t){return\"[object Array]\"==n.call(t)}},{}],6:[function(t,e,r){(function(r,n){\"use strict\";var i=function(t,e,r,i){if(i=i||{},this.dictionary=null,this.rules={},this.dictionaryTable={},this.compoundRules=[],this.compoundRuleCodes={},this.replacementTable=[],this.flags=i.flags||{},t){if(this.dictionary=t,\"undefined\"!=typeof window&&\"chrome\"in window&&\"extension\"in window.chrome&&\"getURL\"in window.chrome.extension)e||(e=this._readFile(chrome.extension.getURL(\"lib/typo/dictionaries/\"+t+\"/\"+t+\".aff\"))),r||(r=this._readFile(chrome.extension.getURL(\"lib/typo/dictionaries/\"+t+\"/\"+t+\".dic\")));else{if(i.dictionaryPath)var o=i.dictionaryPath;else if(\"undefined\"!=typeof n)var o=n+\"/dictionaries\";else var o=\"./dictionaries\";e||(e=this._readFile(o+\"/\"+t+\"/\"+t+\".aff\")),r||(r=this._readFile(o+\"/\"+t+\"/\"+t+\".dic\"))}this.rules=this._parseAFF(e),this.compoundRuleCodes={};for(var s=0,a=this.compoundRules.length;a>s;s++)for(var f=this.compoundRules[s],u=0,h=f.length;h>u;u++)this.compoundRuleCodes[f[u]]=[];\"ONLYINCOMPOUND\"in this.flags&&(this.compoundRuleCodes[this.flags.ONLYINCOMPOUND]=[]),this.dictionaryTable=this._parseDIC(r);for(var s in this.compoundRuleCodes)0==this.compoundRuleCodes[s].length&&delete this.compoundRuleCodes[s];for(var s=0,a=this.compoundRules.length;a>s;s++){for(var l=this.compoundRules[s],c=\"\",u=0,h=l.length;h>u;u++){var p=l[u];c+=p in this.compoundRuleCodes?\"(\"+this.compoundRuleCodes[p].join(\"|\")+\")\":p}this.compoundRules[s]=new RegExp(c,\"i\")}}return this};i.prototype={load:function(t){for(var e in t)this[e]=t[e];return this},_readFile:function(e,n){if(n||(n=\"utf8\"),\"undefined\"!=typeof XMLHttpRequest){var i=new XMLHttpRequest;return i.open(\"GET\",e,!1),i.overrideMimeType&&i.overrideMimeType(\"text/plain; charset=\"+n),i.send(null),i.responseText}if(\"undefined\"!=typeof t){var o=t(\"fs\");try{if(o.existsSync(e)){var s=o.statSync(e),a=o.openSync(e,\"r\"),f=new r(s.size);return o.readSync(a,f,0,f.length,null),f.toString(n,0,f.length)}console.log(\"Path \"+e+\" does not exist.\")}catch(u){return console.log(u),\"\"}}},_parseAFF:function(t){var e={};t=this._removeAffixComments(t);for(var r=t.split(\"\\n\"),n=0,i=r.length;i>n;n++){var o=r[n],s=o.split(/\\s+/),a=s[0];if(\"PFX\"==a||\"SFX\"==a){for(var f=s[1],u=s[2],h=parseInt(s[3],10),l=[],c=n+1,p=n+1+h;p>c;c++){var o=r[c],d=o.split(/\\s+/),g=d[2],y=d[3].split(\"/\"),v=y[0];\"0\"===v&&(v=\"\");var w=this.parseRuleCodes(y[1]),m=d[4],E={};E.add=v,w.length>0&&(E.continuationClasses=w),\".\"!==m&&(\"SFX\"===a?E.match=new RegExp(m+\"$\"):E.match=new RegExp(\"^\"+m)),\"0\"!=g&&(\"SFX\"===a?E.remove=new RegExp(g+\"$\"):E.remove=g),l.push(E)}e[f]={type:a,combineable:\"Y\"==u,entries:l},n+=h}else if(\"COMPOUNDRULE\"===a){for(var h=parseInt(s[1],10),c=n+1,p=n+1+h;p>c;c++){var o=r[c],d=o.split(/\\s+/);this.compoundRules.push(d[1])}n+=h}else if(\"REP\"===a){var d=o.split(/\\s+/);3===d.length&&this.replacementTable.push([d[1],d[2]])}else this.flags[a]=s[1]}return e},_removeAffixComments:function(t){return t=t.replace(/#.*$/gm,\"\"),t=t.replace(/^\\s\\s*/m,\"\").replace(/\\s\\s*$/m,\"\"),t=t.replace(/\\n{2,}/g,\"\\n\"),t=t.replace(/^\\s\\s*/,\"\").replace(/\\s\\s*$/,\"\")},_parseDIC:function(t){function e(t,e){t in n&&\"object\"==typeof n[t]||(n[t]=[]),n[t].push(e)}t=this._removeDicComments(t);for(var r=t.split(\"\\n\"),n={},i=1,o=r.length;o>i;i++){var s=r[i],a=s.split(\"/\",2),f=a[0];if(a.length>1){var u=this.parseRuleCodes(a[1]);\"NEEDAFFIX\"in this.flags&&-1!=u.indexOf(this.flags.NEEDAFFIX)||e(f,u);for(var h=0,l=u.length;l>h;h++){var c=u[h],p=this.rules[c];if(p)for(var d=this._applyRule(f,p),g=0,y=d.length;y>g;g++){var v=d[g];if(e(v,[]),p.combineable)for(var w=h+1;l>w;w++){var m=u[w],E=this.rules[m];if(E&&E.combineable&&p.type!=E.type)for(var b=this._applyRule(v,E),R=0,_=b.length;_>R;R++){var A=b[R];e(A,[])}}}c in this.compoundRuleCodes&&this.compoundRuleCodes[c].push(f)}}else e(f.trim(),[])}return n},_removeDicComments:function(t){return t=t.replace(/^\\t.*$/gm,\"\")},parseRuleCodes:function(t){if(!t)return[];if(!(\"FLAG\"in this.flags))return t.split(\"\");if(\"long\"===this.flags.FLAG){for(var e=[],r=0,n=t.length;n>r;r+=2)e.push(t.substr(r,2));return e}return\"num\"===this.flags.FLAG?textCode.split(\",\"):void 0},_applyRule:function(t,e){for(var r=e.entries,n=[],i=0,o=r.length;o>i;i++){var s=r[i];if(!s.match||t.match(s.match)){var a=t;if(s.remove&&(a=a.replace(s.remove,\"\")),\"SFX\"===e.type?a+=s.add:a=s.add+a,n.push(a),\"continuationClasses\"in s)for(var f=0,u=s.continuationClasses.length;u>f;f++){var h=this.rules[s.continuationClasses[f]];h&&(n=n.concat(this._applyRule(a,h)))}}}return n},check:function(t){var e=t.replace(/^\\s\\s*/,\"\").replace(/\\s\\s*$/,\"\");if(this.checkExact(e))return!0;if(e.toUpperCase()===e){var r=e[0]+e.substring(1).toLowerCase();if(this.hasFlag(r,\"KEEPCASE\"))return!1;if(this.checkExact(r))return!0}var n=e.toLowerCase();if(n!==e){if(this.hasFlag(n,\"KEEPCASE\"))return!1;if(this.checkExact(n))return!0}return!1},checkExact:function(t){var e=this.dictionaryTable[t];if(\"undefined\"==typeof e){if(\"COMPOUNDMIN\"in this.flags&&t.length>=this.flags.COMPOUNDMIN)for(var r=0,n=this.compoundRules.length;n>r;r++)if(t.match(this.compoundRules[r]))return!0;return!1}if(\"object\"==typeof e){for(var r=0,n=e.length;n>r;r++)if(!this.hasFlag(t,\"ONLYINCOMPOUND\",e[r]))return!0;return!1}},hasFlag:function(t,e,r){if(e in this.flags){if(\"undefined\"==typeof r)var r=Array.prototype.concat.apply([],this.dictionaryTable[t]);if(r&&-1!==r.indexOf(this.flags[e]))return!0}return!1},alphabet:\"\",suggest:function(t,e){function r(t){for(var e=[],r=0,n=t.length;n>r;r++){for(var i=t[r],o=[],s=0,a=i.length+1;a>s;s++)o.push([i.substring(0,s),i.substring(s,i.length)]);for(var f=[],s=0,a=o.length;a>s;s++){var h=o[s];h[1]&&f.push(h[0]+h[1].substring(1))}for(var l=[],s=0,a=o.length;a>s;s++){var h=o[s];h[1].length>1&&l.push(h[0]+h[1][1]+h[1][0]+h[1].substring(2))}for(var c=[],s=0,a=o.length;a>s;s++){var h=o[s];if(h[1])for(var p=0,d=u.alphabet.length;d>p;p++)c.push(h[0]+u.alphabet[p]+h[1].substring(1))}for(var g=[],s=0,a=o.length;a>s;s++){var h=o[s];if(h[1])for(var p=0,d=u.alphabet.length;d>p;p++)c.push(h[0]+u.alphabet[p]+h[1])}e=e.concat(f),e=e.concat(l),e=e.concat(c),e=e.concat(g)}return e}function n(t){for(var e=[],r=0;r<t.length;r++)u.check(t[r])&&e.push(t[r]);return e}function i(t){function i(t,e){return t[1]<e[1]?-1:1}for(var o=r([t]),s=r(o),a=n(o).concat(n(s)),f={},h=0,l=a.length;l>h;h++)a[h]in f?f[a[h]]+=1:f[a[h]]=1;var c=[];for(var h in f)c.push([h,f[h]]);c.sort(i).reverse();for(var p=[],h=0,l=Math.min(e,c.length);l>h;h++)u.hasFlag(c[h][0],\"NOSUGGEST\")||p.push(c[h][0]);return p}if(e||(e=5),this.check(t))return[];for(var o=0,s=this.replacementTable.length;s>o;o++){var a=this.replacementTable[o];if(-1!==t.indexOf(a[0])){var f=t.replace(a[0],a[1]);if(this.check(f))return[f]}}var u=this;return u.alphabet=\"abcdefghijklmnopqrstuvwxyz\",i(t)}},\"undefined\"!=typeof e&&(e.exports=i)}).call(this,t(\"buffer\").Buffer,\"/node_modules/typo-js\")},{buffer:3,fs:2}],7:[function(t,e,r){\"use strict\";function n(t){return t=t||{},\"function\"!=typeof t.codeMirrorInstance||\"function\"!=typeof t.codeMirrorInstance.defineMode?void console.log(\"CodeMirror Spell Checker: You must provide an instance of CodeMirror via the option `codeMirrorInstance`\"):(String.prototype.includes||(String.prototype.includes=function(){return-1!==String.prototype.indexOf.apply(this,arguments)}),void t.codeMirrorInstance.defineMode(\"spell-checker\",function(e){if(!n.aff_loading){n.aff_loading=!0;var r=new XMLHttpRequest;r.open(\"GET\",\"https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.aff\",!0),r.onload=function(){4===r.readyState&&200===r.status&&(n.aff_data=r.responseText,n.num_loaded++,2==n.num_loaded&&(n.typo=new i(\"en_US\",n.aff_data,n.dic_data,{platform:\"any\"})))},r.send(null)}if(!n.dic_loading){n.dic_loading=!0;var o=new XMLHttpRequest;o.open(\"GET\",\"https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.dic\",!0),o.onload=function(){4===o.readyState&&200===o.status&&(n.dic_data=o.responseText,n.num_loaded++,2==n.num_loaded&&(n.typo=new i(\"en_US\",n.aff_data,n.dic_data,{platform:\"any\"})))},o.send(null)}var s='!\"#$%&()*+,-./:;<=>?@[\\\\]^_`{|}~ ',a={token:function(t){var e=t.peek(),r=\"\";if(s.includes(e))return t.next(),null;for(;null!=(e=t.peek())&&!s.includes(e);)r+=e,t.next();return n.typo&&!n.typo.check(r)?\"spell-error\":null}},f=t.codeMirrorInstance.getMode(e,e.backdrop||\"text/plain\");return t.codeMirrorInstance.overlayMode(f,a,!0)}))}var i=t(\"typo-js\");n.num_loaded=0,n.aff_loading=!1,n.dic_loading=!1,n.aff_data=\"\",n.dic_data=\"\",n.typo,e.exports=n},{\"typo-js\":6}]},{},[7])(7)});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvc3BlbGwtY2hlY2tlci5taW4uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvc3BlbGwtY2hlY2tlci5taW4uanM/YTE3MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogY29kZW1pcnJvci1zcGVsbC1jaGVja2VyIHYxLjIuMVxyXG4gKiBDb3B5cmlnaHQgTmV4dCBTdGVwIFdlYnMsIEluYy5cclxuICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL05leHRTdGVwV2Vicy9jb2RlbWlycm9yLXNwZWxsLWNoZWNrZXJcclxuICogQGxpY2Vuc2UgTUlUXHJcbiAqL1xyXG4hZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9dCgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSx0KTtlbHNle3ZhciBlO2U9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLGUuQ29kZU1pcnJvclNwZWxsQ2hlY2tlcj10KCl9fShmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbiB0KGUscixuKXtmdW5jdGlvbiBpKHMsYSl7aWYoIXJbc10pe2lmKCFlW3NdKXt2YXIgZj1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFhJiZmKXJldHVybiBmKHMsITApO2lmKG8pcmV0dXJuIG8ocywhMCk7dmFyIHU9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitzK1wiJ1wiKTt0aHJvdyB1LmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsdX12YXIgaD1yW3NdPXtleHBvcnRzOnt9fTtlW3NdWzBdLmNhbGwoaC5leHBvcnRzLGZ1bmN0aW9uKHQpe3ZhciByPWVbc11bMV1bdF07cmV0dXJuIGkocj9yOnQpfSxoLGguZXhwb3J0cyx0LGUscixuKX1yZXR1cm4gcltzXS5leHBvcnRzfWZvcih2YXIgbz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLHM9MDtzPG4ubGVuZ3RoO3MrKylpKG5bc10pO3JldHVybiBpfSh7MTpbZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oKXtmb3IodmFyIHQ9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIsZT0wLHI9dC5sZW5ndGg7cj5lOysrZSlmW2VdPXRbZV0sdVt0LmNoYXJDb2RlQXQoZSldPWU7dVtcIi1cIi5jaGFyQ29kZUF0KDApXT02Mix1W1wiX1wiLmNoYXJDb2RlQXQoMCldPTYzfWZ1bmN0aW9uIGkodCl7dmFyIGUscixuLGksbyxzLGE9dC5sZW5ndGg7aWYoYSU0PjApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNFwiKTtvPVwiPVwiPT09dFthLTJdPzI6XCI9XCI9PT10W2EtMV0/MTowLHM9bmV3IGgoMyphLzQtbyksbj1vPjA/YS00OmE7dmFyIGY9MDtmb3IoZT0wLHI9MDtuPmU7ZSs9NCxyKz0zKWk9dVt0LmNoYXJDb2RlQXQoZSldPDwxOHx1W3QuY2hhckNvZGVBdChlKzEpXTw8MTJ8dVt0LmNoYXJDb2RlQXQoZSsyKV08PDZ8dVt0LmNoYXJDb2RlQXQoZSszKV0sc1tmKytdPWk+PjE2JjI1NSxzW2YrK109aT4+OCYyNTUsc1tmKytdPTI1NSZpO3JldHVybiAyPT09bz8oaT11W3QuY2hhckNvZGVBdChlKV08PDJ8dVt0LmNoYXJDb2RlQXQoZSsxKV0+PjQsc1tmKytdPTI1NSZpKToxPT09byYmKGk9dVt0LmNoYXJDb2RlQXQoZSldPDwxMHx1W3QuY2hhckNvZGVBdChlKzEpXTw8NHx1W3QuY2hhckNvZGVBdChlKzIpXT4+MixzW2YrK109aT4+OCYyNTUsc1tmKytdPTI1NSZpKSxzfWZ1bmN0aW9uIG8odCl7cmV0dXJuIGZbdD4+MTgmNjNdK2ZbdD4+MTImNjNdK2ZbdD4+NiY2M10rZls2MyZ0XX1mdW5jdGlvbiBzKHQsZSxyKXtmb3IodmFyIG4saT1bXSxzPWU7cj5zO3MrPTMpbj0odFtzXTw8MTYpKyh0W3MrMV08PDgpK3RbcysyXSxpLnB1c2gobyhuKSk7cmV0dXJuIGkuam9pbihcIlwiKX1mdW5jdGlvbiBhKHQpe2Zvcih2YXIgZSxyPXQubGVuZ3RoLG49ciUzLGk9XCJcIixvPVtdLGE9MTYzODMsdT0wLGg9ci1uO2g+dTt1Kz1hKW8ucHVzaChzKHQsdSx1K2E+aD9oOnUrYSkpO3JldHVybiAxPT09bj8oZT10W3ItMV0saSs9ZltlPj4yXSxpKz1mW2U8PDQmNjNdLGkrPVwiPT1cIik6Mj09PW4mJihlPSh0W3ItMl08PDgpK3Rbci0xXSxpKz1mW2U+PjEwXSxpKz1mW2U+PjQmNjNdLGkrPWZbZTw8MiY2M10saSs9XCI9XCIpLG8ucHVzaChpKSxvLmpvaW4oXCJcIil9ci50b0J5dGVBcnJheT1pLHIuZnJvbUJ5dGVBcnJheT1hO3ZhciBmPVtdLHU9W10saD1cInVuZGVmaW5lZFwiIT10eXBlb2YgVWludDhBcnJheT9VaW50OEFycmF5OkFycmF5O24oKX0se31dLDI6W2Z1bmN0aW9uKHQsZSxyKXt9LHt9XSwzOltmdW5jdGlvbih0LGUscil7KGZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oKXt0cnl7dmFyIHQ9bmV3IFVpbnQ4QXJyYXkoMSk7cmV0dXJuIHQuZm9vPWZ1bmN0aW9uKCl7cmV0dXJuIDQyfSw0Mj09PXQuZm9vKCkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQuc3ViYXJyYXkmJjA9PT10LnN1YmFycmF5KDEsMSkuYnl0ZUxlbmd0aH1jYXRjaChlKXtyZXR1cm4hMX19ZnVuY3Rpb24gaSgpe3JldHVybiBzLlRZUEVEX0FSUkFZX1NVUFBPUlQ/MjE0NzQ4MzY0NzoxMDczNzQxODIzfWZ1bmN0aW9uIG8odCxlKXtpZihpKCk8ZSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoXCIpO3JldHVybiBzLlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHQ9bmV3IFVpbnQ4QXJyYXkoZSksdC5fX3Byb3RvX189cy5wcm90b3R5cGUpOihudWxsPT09dCYmKHQ9bmV3IHMoZSkpLHQubGVuZ3RoPWUpLHR9ZnVuY3Rpb24gcyh0LGUscil7aWYoIShzLlRZUEVEX0FSUkFZX1NVUFBPUlR8fHRoaXMgaW5zdGFuY2VvZiBzKSlyZXR1cm4gbmV3IHModCxlLHIpO2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0KXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSl0aHJvdyBuZXcgRXJyb3IoXCJJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZ1wiKTtyZXR1cm4gaCh0aGlzLHQpfXJldHVybiBhKHRoaXMsdCxlLHIpfWZ1bmN0aW9uIGEodCxlLHIsbil7aWYoXCJudW1iZXJcIj09dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJyk7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEFycmF5QnVmZmVyJiZlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI/cCh0LGUscixuKTpcInN0cmluZ1wiPT10eXBlb2YgZT9sKHQsZSxyKTpkKHQsZSl9ZnVuY3Rpb24gZih0KXtpZihcIm51bWJlclwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJyl9ZnVuY3Rpb24gdSh0LGUscixuKXtyZXR1cm4gZihlKSwwPj1lP28odCxlKTp2b2lkIDAhPT1yP1wic3RyaW5nXCI9PXR5cGVvZiBuP28odCxlKS5maWxsKHIsbik6byh0LGUpLmZpbGwocik6byh0LGUpfWZ1bmN0aW9uIGgodCxlKXtpZihmKGUpLHQ9byh0LDA+ZT8wOjB8ZyhlKSksIXMuVFlQRURfQVJSQVlfU1VQUE9SVClmb3IodmFyIHI9MDtlPnI7cisrKXRbcl09MDtyZXR1cm4gdH1mdW5jdGlvbiBsKHQsZSxyKXtpZihcInN0cmluZ1wiPT10eXBlb2YgciYmXCJcIiE9PXJ8fChyPVwidXRmOFwiKSwhcy5pc0VuY29kaW5nKHIpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJyk7dmFyIG49MHx2KGUscik7cmV0dXJuIHQ9byh0LG4pLHQud3JpdGUoZSxyKSx0fWZ1bmN0aW9uIGModCxlKXt2YXIgcj0wfGcoZS5sZW5ndGgpO3Q9byh0LHIpO2Zvcih2YXIgbj0wO3I+bjtuKz0xKXRbbl09MjU1JmVbbl07cmV0dXJuIHR9ZnVuY3Rpb24gcCh0LGUscixuKXtpZihlLmJ5dGVMZW5ndGgsMD5yfHxlLmJ5dGVMZW5ndGg8cil0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidvZmZzZXQnIGlzIG91dCBvZiBib3VuZHNcIik7aWYoZS5ieXRlTGVuZ3RoPHIrKG58fDApKXRocm93IG5ldyBSYW5nZUVycm9yKFwiJ2xlbmd0aCcgaXMgb3V0IG9mIGJvdW5kc1wiKTtyZXR1cm4gZT12b2lkIDA9PT1uP25ldyBVaW50OEFycmF5KGUscik6bmV3IFVpbnQ4QXJyYXkoZSxyLG4pLHMuVFlQRURfQVJSQVlfU1VQUE9SVD8odD1lLHQuX19wcm90b19fPXMucHJvdG90eXBlKTp0PWModCxlKSx0fWZ1bmN0aW9uIGQodCxlKXtpZihzLmlzQnVmZmVyKGUpKXt2YXIgcj0wfGcoZS5sZW5ndGgpO3JldHVybiB0PW8odCxyKSwwPT09dC5sZW5ndGg/dDooZS5jb3B5KHQsMCwwLHIpLHQpfWlmKGUpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBBcnJheUJ1ZmZlciYmZS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcnx8XCJsZW5ndGhcImluIGUpcmV0dXJuXCJudW1iZXJcIiE9dHlwZW9mIGUubGVuZ3RofHxWKGUubGVuZ3RoKT9vKHQsMCk6Yyh0LGUpO2lmKFwiQnVmZmVyXCI9PT1lLnR5cGUmJlEoZS5kYXRhKSlyZXR1cm4gYyh0LGUuZGF0YSl9dGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC5cIil9ZnVuY3Rpb24gZyh0KXtpZih0Pj1pKCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtIHNpemU6IDB4XCIraSgpLnRvU3RyaW5nKDE2KStcIiBieXRlc1wiKTtyZXR1cm4gMHx0fWZ1bmN0aW9uIHkodCl7cmV0dXJuK3QhPXQmJih0PTApLHMuYWxsb2MoK3QpfWZ1bmN0aW9uIHYodCxlKXtpZihzLmlzQnVmZmVyKHQpKXJldHVybiB0Lmxlbmd0aDtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgQXJyYXlCdWZmZXImJlwiZnVuY3Rpb25cIj09dHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyYmKEFycmF5QnVmZmVyLmlzVmlldyh0KXx8dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSlyZXR1cm4gdC5ieXRlTGVuZ3RoO1wic3RyaW5nXCIhPXR5cGVvZiB0JiYodD1cIlwiK3QpO3ZhciByPXQubGVuZ3RoO2lmKDA9PT1yKXJldHVybiAwO2Zvcih2YXIgbj0hMTs7KXN3aXRjaChlKXtjYXNlXCJhc2NpaVwiOmNhc2VcImJpbmFyeVwiOmNhc2VcInJhd1wiOmNhc2VcInJhd3NcIjpyZXR1cm4gcjtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpjYXNlIHZvaWQgMDpyZXR1cm4geih0KS5sZW5ndGg7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIDIqcjtjYXNlXCJoZXhcIjpyZXR1cm4gcj4+PjE7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIEgodCkubGVuZ3RoO2RlZmF1bHQ6aWYobilyZXR1cm4geih0KS5sZW5ndGg7ZT0oXCJcIitlKS50b0xvd2VyQ2FzZSgpLG49ITB9fWZ1bmN0aW9uIHcodCxlLHIpe3ZhciBuPSExO2lmKCh2b2lkIDA9PT1lfHwwPmUpJiYoZT0wKSxlPnRoaXMubGVuZ3RoKXJldHVyblwiXCI7aWYoKHZvaWQgMD09PXJ8fHI+dGhpcy5sZW5ndGgpJiYocj10aGlzLmxlbmd0aCksMD49cilyZXR1cm5cIlwiO2lmKHI+Pj49MCxlPj4+PTAsZT49cilyZXR1cm5cIlwiO2Zvcih0fHwodD1cInV0ZjhcIik7Oylzd2l0Y2godCl7Y2FzZVwiaGV4XCI6cmV0dXJuIHgodGhpcyxlLHIpO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiBDKHRoaXMsZSxyKTtjYXNlXCJhc2NpaVwiOnJldHVybiBCKHRoaXMsZSxyKTtjYXNlXCJiaW5hcnlcIjpyZXR1cm4gTSh0aGlzLGUscik7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIFModGhpcyxlLHIpO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiBJKHRoaXMsZSxyKTtkZWZhdWx0OmlmKG4pdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK3QpO3Q9KHQrXCJcIikudG9Mb3dlckNhc2UoKSxuPSEwfX1mdW5jdGlvbiBtKHQsZSxyKXt2YXIgbj10W2VdO3RbZV09dFtyXSx0W3JdPW59ZnVuY3Rpb24gRSh0LGUscixuKXtmdW5jdGlvbiBpKHQsZSl7cmV0dXJuIDE9PT1vP3RbZV06dC5yZWFkVUludDE2QkUoZSpvKX12YXIgbz0xLHM9dC5sZW5ndGgsYT1lLmxlbmd0aDtpZih2b2lkIDAhPT1uJiYobj1TdHJpbmcobikudG9Mb3dlckNhc2UoKSxcInVjczJcIj09PW58fFwidWNzLTJcIj09PW58fFwidXRmMTZsZVwiPT09bnx8XCJ1dGYtMTZsZVwiPT09bikpe2lmKHQubGVuZ3RoPDJ8fGUubGVuZ3RoPDIpcmV0dXJuLTE7bz0yLHMvPTIsYS89MixyLz0yfWZvcih2YXIgZj0tMSx1PTA7cz5yK3U7dSsrKWlmKGkodCxyK3UpPT09aShlLC0xPT09Zj8wOnUtZikpe2lmKC0xPT09ZiYmKGY9dSksdS1mKzE9PT1hKXJldHVybihyK2YpKm99ZWxzZS0xIT09ZiYmKHUtPXUtZiksZj0tMTtyZXR1cm4tMX1mdW5jdGlvbiBiKHQsZSxyLG4pe3I9TnVtYmVyKHIpfHwwO3ZhciBpPXQubGVuZ3RoLXI7bj8obj1OdW1iZXIobiksbj5pJiYobj1pKSk6bj1pO3ZhciBvPWUubGVuZ3RoO2lmKG8lMiE9PTApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBoZXggc3RyaW5nXCIpO24+by8yJiYobj1vLzIpO2Zvcih2YXIgcz0wO24+cztzKyspe3ZhciBhPXBhcnNlSW50KGUuc3Vic3RyKDIqcywyKSwxNik7aWYoaXNOYU4oYSkpcmV0dXJuIHM7dFtyK3NdPWF9cmV0dXJuIHN9ZnVuY3Rpb24gUih0LGUscixuKXtyZXR1cm4gSyh6KGUsdC5sZW5ndGgtciksdCxyLG4pfWZ1bmN0aW9uIF8odCxlLHIsbil7cmV0dXJuIEsoRyhlKSx0LHIsbil9ZnVuY3Rpb24gQSh0LGUscixuKXtyZXR1cm4gXyh0LGUscixuKX1mdW5jdGlvbiBQKHQsZSxyLG4pe3JldHVybiBLKEgoZSksdCxyLG4pfWZ1bmN0aW9uIFQodCxlLHIsbil7cmV0dXJuIEsoJChlLHQubGVuZ3RoLXIpLHQscixuKX1mdW5jdGlvbiBTKHQsZSxyKXtyZXR1cm4gMD09PWUmJnI9PT10Lmxlbmd0aD9KLmZyb21CeXRlQXJyYXkodCk6Si5mcm9tQnl0ZUFycmF5KHQuc2xpY2UoZSxyKSl9ZnVuY3Rpb24gQyh0LGUscil7cj1NYXRoLm1pbih0Lmxlbmd0aCxyKTtmb3IodmFyIG49W10saT1lO3I+aTspe3ZhciBvPXRbaV0scz1udWxsLGE9bz4yMzk/NDpvPjIyMz8zOm8+MTkxPzI6MTtpZihyPj1pK2Epe3ZhciBmLHUsaCxsO3N3aXRjaChhKXtjYXNlIDE6MTI4Pm8mJihzPW8pO2JyZWFrO2Nhc2UgMjpmPXRbaSsxXSwxMjg9PT0oMTkyJmYpJiYobD0oMzEmbyk8PDZ8NjMmZixsPjEyNyYmKHM9bCkpO2JyZWFrO2Nhc2UgMzpmPXRbaSsxXSx1PXRbaSsyXSwxMjg9PT0oMTkyJmYpJiYxMjg9PT0oMTkyJnUpJiYobD0oMTUmbyk8PDEyfCg2MyZmKTw8Nnw2MyZ1LGw+MjA0NyYmKDU1Mjk2Pmx8fGw+NTczNDMpJiYocz1sKSk7YnJlYWs7Y2FzZSA0OmY9dFtpKzFdLHU9dFtpKzJdLGg9dFtpKzNdLDEyOD09PSgxOTImZikmJjEyOD09PSgxOTImdSkmJjEyOD09PSgxOTImaCkmJihsPSgxNSZvKTw8MTh8KDYzJmYpPDwxMnwoNjMmdSk8PDZ8NjMmaCxsPjY1NTM1JiYxMTE0MTEyPmwmJihzPWwpKX19bnVsbD09PXM/KHM9NjU1MzMsYT0xKTpzPjY1NTM1JiYocy09NjU1MzYsbi5wdXNoKHM+Pj4xMCYxMDIzfDU1Mjk2KSxzPTU2MzIwfDEwMjMmcyksbi5wdXNoKHMpLGkrPWF9cmV0dXJuIFUobil9ZnVuY3Rpb24gVSh0KXt2YXIgZT10Lmxlbmd0aDtpZihXPj1lKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyx0KTtmb3IodmFyIHI9XCJcIixuPTA7ZT5uOylyKz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyx0LnNsaWNlKG4sbis9VykpO3JldHVybiByfWZ1bmN0aW9uIEIodCxlLHIpe3ZhciBuPVwiXCI7cj1NYXRoLm1pbih0Lmxlbmd0aCxyKTtmb3IodmFyIGk9ZTtyPmk7aSsrKW4rPVN0cmluZy5mcm9tQ2hhckNvZGUoMTI3JnRbaV0pO3JldHVybiBufWZ1bmN0aW9uIE0odCxlLHIpe3ZhciBuPVwiXCI7cj1NYXRoLm1pbih0Lmxlbmd0aCxyKTtmb3IodmFyIGk9ZTtyPmk7aSsrKW4rPVN0cmluZy5mcm9tQ2hhckNvZGUodFtpXSk7cmV0dXJuIG59ZnVuY3Rpb24geCh0LGUscil7dmFyIG49dC5sZW5ndGg7KCFlfHwwPmUpJiYoZT0wKSwoIXJ8fDA+cnx8cj5uKSYmKHI9bik7Zm9yKHZhciBpPVwiXCIsbz1lO3I+bztvKyspaSs9cSh0W29dKTtyZXR1cm4gaX1mdW5jdGlvbiBJKHQsZSxyKXtmb3IodmFyIG49dC5zbGljZShlLHIpLGk9XCJcIixvPTA7bzxuLmxlbmd0aDtvKz0yKWkrPVN0cmluZy5mcm9tQ2hhckNvZGUobltvXSsyNTYqbltvKzFdKTtyZXR1cm4gaX1mdW5jdGlvbiBPKHQsZSxyKXtpZih0JTEhPT0wfHwwPnQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvZmZzZXQgaXMgbm90IHVpbnRcIik7aWYodCtlPnIpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpfWZ1bmN0aW9uIFkodCxlLHIsbixpLG8pe2lmKCFzLmlzQnVmZmVyKHQpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO2lmKGU+aXx8bz5lKXRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpO2lmKHIrbj50Lmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKX1mdW5jdGlvbiBMKHQsZSxyLG4pezA+ZSYmKGU9NjU1MzUrZSsxKTtmb3IodmFyIGk9MCxvPU1hdGgubWluKHQubGVuZ3RoLXIsMik7bz5pO2krKyl0W3IraV09KGUmMjU1PDw4KihuP2k6MS1pKSk+Pj44KihuP2k6MS1pKX1mdW5jdGlvbiBEKHQsZSxyLG4pezA+ZSYmKGU9NDI5NDk2NzI5NStlKzEpO2Zvcih2YXIgaT0wLG89TWF0aC5taW4odC5sZW5ndGgtciw0KTtvPmk7aSsrKXRbcitpXT1lPj4+OCoobj9pOjMtaSkmMjU1fWZ1bmN0aW9uIEYodCxlLHIsbixpLG8pe2lmKHIrbj50Lmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtpZigwPnIpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9ZnVuY3Rpb24gayh0LGUscixuLGkpe3JldHVybiBpfHxGKHQsZSxyLDQsMy40MDI4MjM0NjYzODUyODg2ZTM4LC0zLjQwMjgyMzQ2NjM4NTI4ODZlMzgpLFoud3JpdGUodCxlLHIsbiwyMyw0KSxyKzR9ZnVuY3Rpb24gTih0LGUscixuLGkpe3JldHVybiBpfHxGKHQsZSxyLDgsMS43OTc2OTMxMzQ4NjIzMTU3ZTMwOCwtMS43OTc2OTMxMzQ4NjIzMTU3ZTMwOCksWi53cml0ZSh0LGUscixuLDUyLDgpLHIrOH1mdW5jdGlvbiBqKHQpe2lmKHQ9WCh0KS5yZXBsYWNlKHR0LFwiXCIpLHQubGVuZ3RoPDIpcmV0dXJuXCJcIjtmb3IoO3QubGVuZ3RoJTQhPT0wOyl0Kz1cIj1cIjtyZXR1cm4gdH1mdW5jdGlvbiBYKHQpe3JldHVybiB0LnRyaW0/dC50cmltKCk6dC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLFwiXCIpfWZ1bmN0aW9uIHEodCl7cmV0dXJuIDE2PnQ/XCIwXCIrdC50b1N0cmluZygxNik6dC50b1N0cmluZygxNil9ZnVuY3Rpb24geih0LGUpe2U9ZXx8MS8wO2Zvcih2YXIgcixuPXQubGVuZ3RoLGk9bnVsbCxvPVtdLHM9MDtuPnM7cysrKXtpZihyPXQuY2hhckNvZGVBdChzKSxyPjU1Mjk1JiY1NzM0ND5yKXtpZighaSl7aWYocj41NjMxOSl7KGUtPTMpPi0xJiZvLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfWlmKHMrMT09PW4peyhlLT0zKT4tMSYmby5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1pPXI7Y29udGludWV9aWYoNTYzMjA+cil7KGUtPTMpPi0xJiZvLnB1c2goMjM5LDE5MSwxODkpLGk9cjtjb250aW51ZX1yPShpLTU1Mjk2PDwxMHxyLTU2MzIwKSs2NTUzNn1lbHNlIGkmJihlLT0zKT4tMSYmby5wdXNoKDIzOSwxOTEsMTg5KTtpZihpPW51bGwsMTI4PnIpe2lmKChlLT0xKTwwKWJyZWFrO28ucHVzaChyKX1lbHNlIGlmKDIwNDg+cil7aWYoKGUtPTIpPDApYnJlYWs7by5wdXNoKHI+PjZ8MTkyLDYzJnJ8MTI4KX1lbHNlIGlmKDY1NTM2PnIpe2lmKChlLT0zKTwwKWJyZWFrO28ucHVzaChyPj4xMnwyMjQscj4+NiY2M3wxMjgsNjMmcnwxMjgpfWVsc2V7aWYoISgxMTE0MTEyPnIpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29kZSBwb2ludFwiKTtpZigoZS09NCk8MClicmVhaztvLnB1c2gocj4+MTh8MjQwLHI+PjEyJjYzfDEyOCxyPj42JjYzfDEyOCw2MyZyfDEyOCl9fXJldHVybiBvfWZ1bmN0aW9uIEcodCl7Zm9yKHZhciBlPVtdLHI9MDtyPHQubGVuZ3RoO3IrKyllLnB1c2goMjU1JnQuY2hhckNvZGVBdChyKSk7cmV0dXJuIGV9ZnVuY3Rpb24gJCh0LGUpe2Zvcih2YXIgcixuLGksbz1bXSxzPTA7czx0Lmxlbmd0aCYmISgoZS09Mik8MCk7cysrKXI9dC5jaGFyQ29kZUF0KHMpLG49cj4+OCxpPXIlMjU2LG8ucHVzaChpKSxvLnB1c2gobik7cmV0dXJuIG99ZnVuY3Rpb24gSCh0KXtyZXR1cm4gSi50b0J5dGVBcnJheShqKHQpKX1mdW5jdGlvbiBLKHQsZSxyLG4pe2Zvcih2YXIgaT0wO24+aSYmIShpK3I+PWUubGVuZ3RofHxpPj10Lmxlbmd0aCk7aSsrKWVbaStyXT10W2ldO3JldHVybiBpfWZ1bmN0aW9uIFYodCl7cmV0dXJuIHQhPT10fXZhciBKPXQoXCJiYXNlNjQtanNcIiksWj10KFwiaWVlZTc1NFwiKSxRPXQoXCJpc2FycmF5XCIpO3IuQnVmZmVyPXMsci5TbG93QnVmZmVyPXksci5JTlNQRUNUX01BWF9CWVRFUz01MCxzLlRZUEVEX0FSUkFZX1NVUFBPUlQ9dm9pZCAwIT09ZS5UWVBFRF9BUlJBWV9TVVBQT1JUP2UuVFlQRURfQVJSQVlfU1VQUE9SVDpuKCksci5rTWF4TGVuZ3RoPWkoKSxzLnBvb2xTaXplPTgxOTIscy5fYXVnbWVudD1mdW5jdGlvbih0KXtyZXR1cm4gdC5fX3Byb3RvX189cy5wcm90b3R5cGUsdH0scy5mcm9tPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gYShudWxsLHQsZSxyKX0scy5UWVBFRF9BUlJBWV9TVVBQT1JUJiYocy5wcm90b3R5cGUuX19wcm90b19fPVVpbnQ4QXJyYXkucHJvdG90eXBlLHMuX19wcm90b19fPVVpbnQ4QXJyYXksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnNwZWNpZXMmJnNbU3ltYm9sLnNwZWNpZXNdPT09cyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHMsU3ltYm9sLnNwZWNpZXMse3ZhbHVlOm51bGwsY29uZmlndXJhYmxlOiEwfSkpLHMuYWxsb2M9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB1KG51bGwsdCxlLHIpfSxzLmFsbG9jVW5zYWZlPWZ1bmN0aW9uKHQpe3JldHVybiBoKG51bGwsdCl9LHMuYWxsb2NVbnNhZmVTbG93PWZ1bmN0aW9uKHQpe3JldHVybiBoKG51bGwsdCl9LHMuaXNCdWZmZXI9ZnVuY3Rpb24odCl7cmV0dXJuIShudWxsPT10fHwhdC5faXNCdWZmZXIpfSxzLmNvbXBhcmU9ZnVuY3Rpb24odCxlKXtpZighcy5pc0J1ZmZlcih0KXx8IXMuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnNcIik7aWYodD09PWUpcmV0dXJuIDA7Zm9yKHZhciByPXQubGVuZ3RoLG49ZS5sZW5ndGgsaT0wLG89TWF0aC5taW4ocixuKTtvPmk7KytpKWlmKHRbaV0hPT1lW2ldKXtyPXRbaV0sbj1lW2ldO2JyZWFrfXJldHVybiBuPnI/LTE6cj5uPzE6MH0scy5pc0VuY29kaW5nPWZ1bmN0aW9uKHQpe3N3aXRjaChTdHJpbmcodCkudG9Mb3dlckNhc2UoKSl7Y2FzZVwiaGV4XCI6Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6Y2FzZVwiYXNjaWlcIjpjYXNlXCJiaW5hcnlcIjpjYXNlXCJiYXNlNjRcIjpjYXNlXCJyYXdcIjpjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX0scy5jb25jYXQ9ZnVuY3Rpb24odCxlKXtpZighUSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTtpZigwPT09dC5sZW5ndGgpcmV0dXJuIHMuYWxsb2MoMCk7dmFyIHI7aWYodm9pZCAwPT09ZSlmb3IoZT0wLHI9MDtyPHQubGVuZ3RoO3IrKyllKz10W3JdLmxlbmd0aDt2YXIgbj1zLmFsbG9jVW5zYWZlKGUpLGk9MDtmb3Iocj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbz10W3JdO2lmKCFzLmlzQnVmZmVyKG8pKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpO28uY29weShuLGkpLGkrPW8ubGVuZ3RofXJldHVybiBufSxzLmJ5dGVMZW5ndGg9dixzLnByb3RvdHlwZS5faXNCdWZmZXI9ITAscy5wcm90b3R5cGUuc3dhcDE2PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5sZW5ndGg7aWYodCUyIT09MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzXCIpO2Zvcih2YXIgZT0wO3Q+ZTtlKz0yKW0odGhpcyxlLGUrMSk7cmV0dXJuIHRoaXN9LHMucHJvdG90eXBlLnN3YXAzMj1mdW5jdGlvbigpe3ZhciB0PXRoaXMubGVuZ3RoO2lmKHQlNCE9PTApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0c1wiKTtmb3IodmFyIGU9MDt0PmU7ZSs9NCltKHRoaXMsZSxlKzMpLG0odGhpcyxlKzEsZSsyKTtyZXR1cm4gdGhpc30scy5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXt2YXIgdD0wfHRoaXMubGVuZ3RoO3JldHVybiAwPT09dD9cIlwiOjA9PT1hcmd1bWVudHMubGVuZ3RoP0ModGhpcywwLHQpOncuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxzLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24odCl7aWYoIXMuaXNCdWZmZXIodCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXJcIik7cmV0dXJuIHRoaXM9PT10PyEwOjA9PT1zLmNvbXBhcmUodGhpcyx0KX0scy5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbigpe3ZhciB0PVwiXCIsZT1yLklOU1BFQ1RfTUFYX0JZVEVTO3JldHVybiB0aGlzLmxlbmd0aD4wJiYodD10aGlzLnRvU3RyaW5nKFwiaGV4XCIsMCxlKS5tYXRjaCgvLnsyfS9nKS5qb2luKFwiIFwiKSx0aGlzLmxlbmd0aD5lJiYodCs9XCIgLi4uIFwiKSksXCI8QnVmZmVyIFwiK3QrXCI+XCJ9LHMucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24odCxlLHIsbixpKXtpZighcy5pc0J1ZmZlcih0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtpZih2b2lkIDA9PT1lJiYoZT0wKSx2b2lkIDA9PT1yJiYocj10P3QubGVuZ3RoOjApLHZvaWQgMD09PW4mJihuPTApLHZvaWQgMD09PWkmJihpPXRoaXMubGVuZ3RoKSwwPmV8fHI+dC5sZW5ndGh8fDA+bnx8aT50aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByYW5nZSBpbmRleFwiKTtpZihuPj1pJiZlPj1yKXJldHVybiAwO2lmKG4+PWkpcmV0dXJuLTE7aWYoZT49cilyZXR1cm4gMTtpZihlPj4+PTAscj4+Pj0wLG4+Pj49MCxpPj4+PTAsdGhpcz09PXQpcmV0dXJuIDA7Zm9yKHZhciBvPWktbixhPXItZSxmPU1hdGgubWluKG8sYSksdT10aGlzLnNsaWNlKG4saSksaD10LnNsaWNlKGUsciksbD0wO2Y+bDsrK2wpaWYodVtsXSE9PWhbbF0pe289dVtsXSxhPWhbbF07YnJlYWt9cmV0dXJuIGE+bz8tMTpvPmE/MTowfSxzLnByb3RvdHlwZS5pbmRleE9mPWZ1bmN0aW9uKHQsZSxyKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZT8ocj1lLGU9MCk6ZT4yMTQ3NDgzNjQ3P2U9MjE0NzQ4MzY0NzotMjE0NzQ4MzY0OD5lJiYoZT0tMjE0NzQ4MzY0OCksZT4+PTAsMD09PXRoaXMubGVuZ3RoKXJldHVybi0xO2lmKGU+PXRoaXMubGVuZ3RoKXJldHVybi0xO2lmKDA+ZSYmKGU9TWF0aC5tYXgodGhpcy5sZW5ndGgrZSwwKSksXCJzdHJpbmdcIj09dHlwZW9mIHQmJih0PXMuZnJvbSh0LHIpKSxzLmlzQnVmZmVyKHQpKXJldHVybiAwPT09dC5sZW5ndGg/LTE6RSh0aGlzLHQsZSxyKTtpZihcIm51bWJlclwiPT10eXBlb2YgdClyZXR1cm4gcy5UWVBFRF9BUlJBWV9TVVBQT1JUJiZcImZ1bmN0aW9uXCI9PT1VaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mP1VpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLHQsZSk6RSh0aGlzLFt0XSxlLHIpO3Rocm93IG5ldyBUeXBlRXJyb3IoXCJ2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXJcIil9LHMucHJvdG90eXBlLmluY2x1ZGVzPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4tMSE9PXRoaXMuaW5kZXhPZih0LGUscil9LHMucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKHQsZSxyLG4pe2lmKHZvaWQgMD09PWUpbj1cInV0ZjhcIixyPXRoaXMubGVuZ3RoLGU9MDtlbHNlIGlmKHZvaWQgMD09PXImJlwic3RyaW5nXCI9PXR5cGVvZiBlKW49ZSxyPXRoaXMubGVuZ3RoLGU9MDtlbHNle2lmKCFpc0Zpbml0ZShlKSl0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZFwiKTtlPTB8ZSxpc0Zpbml0ZShyKT8ocj0wfHIsdm9pZCAwPT09biYmKG49XCJ1dGY4XCIpKToobj1yLHI9dm9pZCAwKX12YXIgaT10aGlzLmxlbmd0aC1lO2lmKCh2b2lkIDA9PT1yfHxyPmkpJiYocj1pKSx0Lmxlbmd0aD4wJiYoMD5yfHwwPmUpfHxlPnRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHNcIik7bnx8KG49XCJ1dGY4XCIpO2Zvcih2YXIgbz0hMTs7KXN3aXRjaChuKXtjYXNlXCJoZXhcIjpyZXR1cm4gYih0aGlzLHQsZSxyKTtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gUih0aGlzLHQsZSxyKTtjYXNlXCJhc2NpaVwiOnJldHVybiBfKHRoaXMsdCxlLHIpO2Nhc2VcImJpbmFyeVwiOnJldHVybiBBKHRoaXMsdCxlLHIpO2Nhc2VcImJhc2U2NFwiOnJldHVybiBQKHRoaXMsdCxlLHIpO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiBUKHRoaXMsdCxlLHIpO2RlZmF1bHQ6aWYobyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrbik7bj0oXCJcIituKS50b0xvd2VyQ2FzZSgpLG89ITB9fSxzLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpcIkJ1ZmZlclwiLGRhdGE6QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyfHx0aGlzLDApfX07dmFyIFc9NDA5NjtzLnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXMubGVuZ3RoO3Q9fn50LGU9dm9pZCAwPT09ZT9yOn5+ZSwwPnQ/KHQrPXIsMD50JiYodD0wKSk6dD5yJiYodD1yKSwwPmU/KGUrPXIsMD5lJiYoZT0wKSk6ZT5yJiYoZT1yKSx0PmUmJihlPXQpO3ZhciBuO2lmKHMuVFlQRURfQVJSQVlfU1VQUE9SVCluPXRoaXMuc3ViYXJyYXkodCxlKSxuLl9fcHJvdG9fXz1zLnByb3RvdHlwZTtlbHNle3ZhciBpPWUtdDtuPW5ldyBzKGksdm9pZCAwKTtmb3IodmFyIG89MDtpPm87bysrKW5bb109dGhpc1tvK3RdfXJldHVybiBufSxzLnByb3RvdHlwZS5yZWFkVUludExFPWZ1bmN0aW9uKHQsZSxyKXt0PTB8dCxlPTB8ZSxyfHxPKHQsZSx0aGlzLmxlbmd0aCk7Zm9yKHZhciBuPXRoaXNbdF0saT0xLG89MDsrK288ZSYmKGkqPTI1Nik7KW4rPXRoaXNbdCtvXSppO3JldHVybiBufSxzLnByb3RvdHlwZS5yZWFkVUludEJFPWZ1bmN0aW9uKHQsZSxyKXt0PTB8dCxlPTB8ZSxyfHxPKHQsZSx0aGlzLmxlbmd0aCk7Zm9yKHZhciBuPXRoaXNbdCstLWVdLGk9MTtlPjAmJihpKj0yNTYpOyluKz10aGlzW3QrLS1lXSppO3JldHVybiBufSxzLnByb3RvdHlwZS5yZWFkVUludDg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8Tyh0LDEsdGhpcy5sZW5ndGgpLHRoaXNbdF19LHMucHJvdG90eXBlLnJlYWRVSW50MTZMRT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHxPKHQsMix0aGlzLmxlbmd0aCksdGhpc1t0XXx0aGlzW3QrMV08PDh9LHMucHJvdG90eXBlLnJlYWRVSW50MTZCRT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHxPKHQsMix0aGlzLmxlbmd0aCksdGhpc1t0XTw8OHx0aGlzW3QrMV19LHMucHJvdG90eXBlLnJlYWRVSW50MzJMRT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHxPKHQsNCx0aGlzLmxlbmd0aCksKHRoaXNbdF18dGhpc1t0KzFdPDw4fHRoaXNbdCsyXTw8MTYpKzE2Nzc3MjE2KnRoaXNbdCszXX0scy5wcm90b3R5cGUucmVhZFVJbnQzMkJFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fE8odCw0LHRoaXMubGVuZ3RoKSwxNjc3NzIxNip0aGlzW3RdKyh0aGlzW3QrMV08PDE2fHRoaXNbdCsyXTw8OHx0aGlzW3QrM10pfSxzLnByb3RvdHlwZS5yZWFkSW50TEU9ZnVuY3Rpb24odCxlLHIpe3Q9MHx0LGU9MHxlLHJ8fE8odCxlLHRoaXMubGVuZ3RoKTtmb3IodmFyIG49dGhpc1t0XSxpPTEsbz0wOysrbzxlJiYoaSo9MjU2KTspbis9dGhpc1t0K29dKmk7cmV0dXJuIGkqPTEyOCxuPj1pJiYobi09TWF0aC5wb3coMiw4KmUpKSxufSxzLnByb3RvdHlwZS5yZWFkSW50QkU9ZnVuY3Rpb24odCxlLHIpe3Q9MHx0LGU9MHxlLHJ8fE8odCxlLHRoaXMubGVuZ3RoKTtmb3IodmFyIG49ZSxpPTEsbz10aGlzW3QrLS1uXTtuPjAmJihpKj0yNTYpOylvKz10aGlzW3QrLS1uXSppO3JldHVybiBpKj0xMjgsbz49aSYmKG8tPU1hdGgucG93KDIsOCplKSksb30scy5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8Tyh0LDEsdGhpcy5sZW5ndGgpLDEyOCZ0aGlzW3RdPy0xKigyNTUtdGhpc1t0XSsxKTp0aGlzW3RdfSxzLnByb3RvdHlwZS5yZWFkSW50MTZMRT1mdW5jdGlvbih0LGUpe2V8fE8odCwyLHRoaXMubGVuZ3RoKTt2YXIgcj10aGlzW3RdfHRoaXNbdCsxXTw8ODtyZXR1cm4gMzI3Njgmcj80Mjk0OTAxNzYwfHI6cn0scy5wcm90b3R5cGUucmVhZEludDE2QkU9ZnVuY3Rpb24odCxlKXtlfHxPKHQsMix0aGlzLmxlbmd0aCk7dmFyIHI9dGhpc1t0KzFdfHRoaXNbdF08PDg7cmV0dXJuIDMyNzY4JnI/NDI5NDkwMTc2MHxyOnJ9LHMucHJvdG90eXBlLnJlYWRJbnQzMkxFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fE8odCw0LHRoaXMubGVuZ3RoKSx0aGlzW3RdfHRoaXNbdCsxXTw8OHx0aGlzW3QrMl08PDE2fHRoaXNbdCszXTw8MjR9LHMucHJvdG90eXBlLnJlYWRJbnQzMkJFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fE8odCw0LHRoaXMubGVuZ3RoKSx0aGlzW3RdPDwyNHx0aGlzW3QrMV08PDE2fHRoaXNbdCsyXTw8OHx0aGlzW3QrM119LHMucHJvdG90eXBlLnJlYWRGbG9hdExFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fE8odCw0LHRoaXMubGVuZ3RoKSxaLnJlYWQodGhpcyx0LCEwLDIzLDQpfSxzLnByb3RvdHlwZS5yZWFkRmxvYXRCRT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHxPKHQsNCx0aGlzLmxlbmd0aCksWi5yZWFkKHRoaXMsdCwhMSwyMyw0KX0scy5wcm90b3R5cGUucmVhZERvdWJsZUxFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fE8odCw4LHRoaXMubGVuZ3RoKSxaLnJlYWQodGhpcyx0LCEwLDUyLDgpfSxzLnByb3RvdHlwZS5yZWFkRG91YmxlQkU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8Tyh0LDgsdGhpcy5sZW5ndGgpLFoucmVhZCh0aGlzLHQsITEsNTIsOCl9LHMucHJvdG90eXBlLndyaXRlVUludExFPWZ1bmN0aW9uKHQsZSxyLG4pe2lmKHQ9K3QsZT0wfGUscj0wfHIsIW4pe3ZhciBpPU1hdGgucG93KDIsOCpyKS0xO1kodGhpcyx0LGUscixpLDApfXZhciBvPTEscz0wO2Zvcih0aGlzW2VdPTI1NSZ0OysrczxyJiYobyo9MjU2KTspdGhpc1tlK3NdPXQvbyYyNTU7cmV0dXJuIGUrcn0scy5wcm90b3R5cGUud3JpdGVVSW50QkU9ZnVuY3Rpb24odCxlLHIsbil7aWYodD0rdCxlPTB8ZSxyPTB8ciwhbil7dmFyIGk9TWF0aC5wb3coMiw4KnIpLTE7WSh0aGlzLHQsZSxyLGksMCl9dmFyIG89ci0xLHM9MTtmb3IodGhpc1tlK29dPTI1NSZ0Oy0tbz49MCYmKHMqPTI1Nik7KXRoaXNbZStvXT10L3MmMjU1O3JldHVybiBlK3J9LHMucHJvdG90eXBlLndyaXRlVUludDg9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0PSt0LGU9MHxlLHJ8fFkodGhpcyx0LGUsMSwyNTUsMCkscy5UWVBFRF9BUlJBWV9TVVBQT1JUfHwodD1NYXRoLmZsb29yKHQpKSx0aGlzW2VdPTI1NSZ0LGUrMX0scy5wcm90b3R5cGUud3JpdGVVSW50MTZMRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIHQ9K3QsZT0wfGUscnx8WSh0aGlzLHQsZSwyLDY1NTM1LDApLHMuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1tlXT0yNTUmdCx0aGlzW2UrMV09dD4+PjgpOkwodGhpcyx0LGUsITApLGUrMn0scy5wcm90b3R5cGUud3JpdGVVSW50MTZCRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIHQ9K3QsZT0wfGUscnx8WSh0aGlzLHQsZSwyLDY1NTM1LDApLHMuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1tlXT10Pj4+OCx0aGlzW2UrMV09MjU1JnQpOkwodGhpcyx0LGUsITEpLGUrMn0scy5wcm90b3R5cGUud3JpdGVVSW50MzJMRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIHQ9K3QsZT0wfGUscnx8WSh0aGlzLHQsZSw0LDQyOTQ5NjcyOTUsMCkscy5UWVBFRF9BUlJBWV9TVVBQT1JUPyh0aGlzW2UrM109dD4+PjI0LHRoaXNbZSsyXT10Pj4+MTYsdGhpc1tlKzFdPXQ+Pj44LHRoaXNbZV09MjU1JnQpOkQodGhpcyx0LGUsITApLGUrNH0scy5wcm90b3R5cGUud3JpdGVVSW50MzJCRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIHQ9K3QsZT0wfGUscnx8WSh0aGlzLHQsZSw0LDQyOTQ5NjcyOTUsMCkscy5UWVBFRF9BUlJBWV9TVVBQT1JUPyh0aGlzW2VdPXQ+Pj4yNCx0aGlzW2UrMV09dD4+PjE2LHRoaXNbZSsyXT10Pj4+OCx0aGlzW2UrM109MjU1JnQpOkQodGhpcyx0LGUsITEpLGUrNH0scy5wcm90b3R5cGUud3JpdGVJbnRMRT1mdW5jdGlvbih0LGUscixuKXtpZih0PSt0LGU9MHxlLCFuKXt2YXIgaT1NYXRoLnBvdygyLDgqci0xKTtZKHRoaXMsdCxlLHIsaS0xLC1pKX12YXIgbz0wLHM9MSxhPTA7Zm9yKHRoaXNbZV09MjU1JnQ7KytvPHImJihzKj0yNTYpOykwPnQmJjA9PT1hJiYwIT09dGhpc1tlK28tMV0mJihhPTEpLHRoaXNbZStvXT0odC9zPj4wKS1hJjI1NTtyZXR1cm4gZStyfSxzLnByb3RvdHlwZS53cml0ZUludEJFPWZ1bmN0aW9uKHQsZSxyLG4pe2lmKHQ9K3QsZT0wfGUsIW4pe3ZhciBpPU1hdGgucG93KDIsOCpyLTEpO1kodGhpcyx0LGUscixpLTEsLWkpfXZhciBvPXItMSxzPTEsYT0wO2Zvcih0aGlzW2Urb109MjU1JnQ7LS1vPj0wJiYocyo9MjU2KTspMD50JiYwPT09YSYmMCE9PXRoaXNbZStvKzFdJiYoYT0xKSx0aGlzW2Urb109KHQvcz4+MCktYSYyNTU7cmV0dXJuIGUrcn0scy5wcm90b3R5cGUud3JpdGVJbnQ4PWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdD0rdCxlPTB8ZSxyfHxZKHRoaXMsdCxlLDEsMTI3LC0xMjgpLHMuVFlQRURfQVJSQVlfU1VQUE9SVHx8KHQ9TWF0aC5mbG9vcih0KSksMD50JiYodD0yNTUrdCsxKSx0aGlzW2VdPTI1NSZ0LGUrMX0scy5wcm90b3R5cGUud3JpdGVJbnQxNkxFPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdD0rdCxlPTB8ZSxyfHxZKHRoaXMsdCxlLDIsMzI3NjcsLTMyNzY4KSxzLlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbZV09MjU1JnQsdGhpc1tlKzFdPXQ+Pj44KTpMKHRoaXMsdCxlLCEwKSxlKzJ9LHMucHJvdG90eXBlLndyaXRlSW50MTZCRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIHQ9K3QsZT0wfGUscnx8WSh0aGlzLHQsZSwyLDMyNzY3LC0zMjc2OCkscy5UWVBFRF9BUlJBWV9TVVBQT1JUPyh0aGlzW2VdPXQ+Pj44LHRoaXNbZSsxXT0yNTUmdCk6TCh0aGlzLHQsZSwhMSksZSsyfSxzLnByb3RvdHlwZS53cml0ZUludDMyTEU9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0PSt0LGU9MHxlLHJ8fFkodGhpcyx0LGUsNCwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KSxzLlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbZV09MjU1JnQsdGhpc1tlKzFdPXQ+Pj44LHRoaXNbZSsyXT10Pj4+MTYsdGhpc1tlKzNdPXQ+Pj4yNCk6RCh0aGlzLHQsZSwhMCksZSs0fSxzLnByb3RvdHlwZS53cml0ZUludDMyQkU9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0PSt0LGU9MHxlLHJ8fFkodGhpcyx0LGUsNCwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KSwwPnQmJih0PTQyOTQ5NjcyOTUrdCsxKSxzLlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbZV09dD4+PjI0LHRoaXNbZSsxXT10Pj4+MTYsdGhpc1tlKzJdPXQ+Pj44LHRoaXNbZSszXT0yNTUmdCk6RCh0aGlzLHQsZSwhMSksZSs0fSxzLnByb3RvdHlwZS53cml0ZUZsb2F0TEU9ZnVuY3Rpb24odCxlLHIpe3JldHVybiBrKHRoaXMsdCxlLCEwLHIpfSxzLnByb3RvdHlwZS53cml0ZUZsb2F0QkU9ZnVuY3Rpb24odCxlLHIpe3JldHVybiBrKHRoaXMsdCxlLCExLHIpfSxzLnByb3RvdHlwZS53cml0ZURvdWJsZUxFPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gTih0aGlzLHQsZSwhMCxyKX0scy5wcm90b3R5cGUud3JpdGVEb3VibGVCRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIE4odGhpcyx0LGUsITEscil9LHMucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24odCxlLHIsbil7aWYocnx8KHI9MCksbnx8MD09PW58fChuPXRoaXMubGVuZ3RoKSxlPj10Lmxlbmd0aCYmKGU9dC5sZW5ndGgpLGV8fChlPTApLG4+MCYmcj5uJiYobj1yKSxuPT09cilyZXR1cm4gMDtpZigwPT09dC5sZW5ndGh8fDA9PT10aGlzLmxlbmd0aClyZXR1cm4gMDtpZigwPmUpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzXCIpO2lmKDA+cnx8cj49dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzXCIpO2lmKDA+bil0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInNvdXJjZUVuZCBvdXQgb2YgYm91bmRzXCIpO24+dGhpcy5sZW5ndGgmJihuPXRoaXMubGVuZ3RoKSx0Lmxlbmd0aC1lPG4tciYmKG49dC5sZW5ndGgtZStyKTt2YXIgaSxvPW4tcjtpZih0aGlzPT09dCYmZT5yJiZuPmUpZm9yKGk9by0xO2k+PTA7aS0tKXRbaStlXT10aGlzW2krcl07ZWxzZSBpZigxZTM+b3x8IXMuVFlQRURfQVJSQVlfU1VQUE9SVClmb3IoaT0wO28+aTtpKyspdFtpK2VdPXRoaXNbaStyXTtlbHNlIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKHQsdGhpcy5zdWJhcnJheShyLHIrbyksZSk7cmV0dXJuIG99LHMucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24odCxlLHIsbil7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlPyhuPWUsZT0wLHI9dGhpcy5sZW5ndGgpOlwic3RyaW5nXCI9PXR5cGVvZiByJiYobj1yLHI9dGhpcy5sZW5ndGgpLDE9PT10Lmxlbmd0aCl7dmFyIGk9dC5jaGFyQ29kZUF0KDApOzI1Nj5pJiYodD1pKX1pZih2b2lkIDAhPT1uJiZcInN0cmluZ1wiIT10eXBlb2Ygbil0aHJvdyBuZXcgVHlwZUVycm9yKFwiZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZ1wiKTtpZihcInN0cmluZ1wiPT10eXBlb2YgbiYmIXMuaXNFbmNvZGluZyhuKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrbil9ZWxzZVwibnVtYmVyXCI9PXR5cGVvZiB0JiYodD0yNTUmdCk7aWYoMD5lfHx0aGlzLmxlbmd0aDxlfHx0aGlzLmxlbmd0aDxyKXRocm93IG5ldyBSYW5nZUVycm9yKFwiT3V0IG9mIHJhbmdlIGluZGV4XCIpO2lmKGU+PXIpcmV0dXJuIHRoaXM7ZT4+Pj0wLHI9dm9pZCAwPT09cj90aGlzLmxlbmd0aDpyPj4+MCx0fHwodD0wKTt2YXIgbztpZihcIm51bWJlclwiPT10eXBlb2YgdClmb3Iobz1lO3I+bztvKyspdGhpc1tvXT10O2Vsc2V7dmFyIGE9cy5pc0J1ZmZlcih0KT90OnoobmV3IHModCxuKS50b1N0cmluZygpKSxmPWEubGVuZ3RoO2ZvcihvPTA7ci1lPm87bysrKXRoaXNbbytlXT1hW28lZl19cmV0dXJuIHRoaXN9O3ZhciB0dD0vW14rXFwvMC05QS1aYS16LV9dL2d9KS5jYWxsKHRoaXMsXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjpcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzp7fSl9LHtcImJhc2U2NC1qc1wiOjEsaWVlZTc1NDo0LGlzYXJyYXk6NX1dLDQ6W2Z1bmN0aW9uKHQsZSxyKXtyLnJlYWQ9ZnVuY3Rpb24odCxlLHIsbixpKXt2YXIgbyxzLGE9OCppLW4tMSxmPSgxPDxhKS0xLHU9Zj4+MSxoPS03LGw9cj9pLTE6MCxjPXI/LTE6MSxwPXRbZStsXTtmb3IobCs9YyxvPXAmKDE8PC1oKS0xLHA+Pj0taCxoKz1hO2g+MDtvPTI1NipvK3RbZStsXSxsKz1jLGgtPTgpO2ZvcihzPW8mKDE8PC1oKS0xLG8+Pj0taCxoKz1uO2g+MDtzPTI1NipzK3RbZStsXSxsKz1jLGgtPTgpO2lmKDA9PT1vKW89MS11O2Vsc2V7aWYobz09PWYpcmV0dXJuIHM/TmFOOihwPy0xOjEpKigxLzApO3MrPU1hdGgucG93KDIsbiksby09dX1yZXR1cm4ocD8tMToxKSpzKk1hdGgucG93KDIsby1uKX0sci53cml0ZT1mdW5jdGlvbih0LGUscixuLGksbyl7dmFyIHMsYSxmLHU9OCpvLWktMSxoPSgxPDx1KS0xLGw9aD4+MSxjPTIzPT09aT9NYXRoLnBvdygyLC0yNCktTWF0aC5wb3coMiwtNzcpOjAscD1uPzA6by0xLGQ9bj8xOi0xLGc9MD5lfHwwPT09ZSYmMD4xL2U/MTowO2ZvcihlPU1hdGguYWJzKGUpLGlzTmFOKGUpfHxlPT09MS8wPyhhPWlzTmFOKGUpPzE6MCxzPWgpOihzPU1hdGguZmxvb3IoTWF0aC5sb2coZSkvTWF0aC5MTjIpLGUqKGY9TWF0aC5wb3coMiwtcykpPDEmJihzLS0sZio9MiksZSs9cytsPj0xP2MvZjpjKk1hdGgucG93KDIsMS1sKSxlKmY+PTImJihzKyssZi89MikscytsPj1oPyhhPTAscz1oKTpzK2w+PTE/KGE9KGUqZi0xKSpNYXRoLnBvdygyLGkpLHMrPWwpOihhPWUqTWF0aC5wb3coMixsLTEpKk1hdGgucG93KDIsaSkscz0wKSk7aT49ODt0W3IrcF09MjU1JmEscCs9ZCxhLz0yNTYsaS09OCk7Zm9yKHM9czw8aXxhLHUrPWk7dT4wO3RbcitwXT0yNTUmcyxwKz1kLHMvPTI1Nix1LT04KTt0W3IrcC1kXXw9MTI4Kmd9fSx7fV0sNTpbZnVuY3Rpb24odCxlLHIpe3ZhciBuPXt9LnRvU3RyaW5nO2UuZXhwb3J0cz1BcnJheS5pc0FycmF5fHxmdW5jdGlvbih0KXtyZXR1cm5cIltvYmplY3QgQXJyYXldXCI9PW4uY2FsbCh0KX19LHt9XSw2OltmdW5jdGlvbih0LGUscil7KGZ1bmN0aW9uKHIsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9ZnVuY3Rpb24odCxlLHIsaSl7aWYoaT1pfHx7fSx0aGlzLmRpY3Rpb25hcnk9bnVsbCx0aGlzLnJ1bGVzPXt9LHRoaXMuZGljdGlvbmFyeVRhYmxlPXt9LHRoaXMuY29tcG91bmRSdWxlcz1bXSx0aGlzLmNvbXBvdW5kUnVsZUNvZGVzPXt9LHRoaXMucmVwbGFjZW1lbnRUYWJsZT1bXSx0aGlzLmZsYWdzPWkuZmxhZ3N8fHt9LHQpe2lmKHRoaXMuZGljdGlvbmFyeT10LFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJlwiY2hyb21lXCJpbiB3aW5kb3cmJlwiZXh0ZW5zaW9uXCJpbiB3aW5kb3cuY2hyb21lJiZcImdldFVSTFwiaW4gd2luZG93LmNocm9tZS5leHRlbnNpb24pZXx8KGU9dGhpcy5fcmVhZEZpbGUoY2hyb21lLmV4dGVuc2lvbi5nZXRVUkwoXCJsaWIvdHlwby9kaWN0aW9uYXJpZXMvXCIrdCtcIi9cIit0K1wiLmFmZlwiKSkpLHJ8fChyPXRoaXMuX3JlYWRGaWxlKGNocm9tZS5leHRlbnNpb24uZ2V0VVJMKFwibGliL3R5cG8vZGljdGlvbmFyaWVzL1wiK3QrXCIvXCIrdCtcIi5kaWNcIikpKTtlbHNle2lmKGkuZGljdGlvbmFyeVBhdGgpdmFyIG89aS5kaWN0aW9uYXJ5UGF0aDtlbHNlIGlmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBuKXZhciBvPW4rXCIvZGljdGlvbmFyaWVzXCI7ZWxzZSB2YXIgbz1cIi4vZGljdGlvbmFyaWVzXCI7ZXx8KGU9dGhpcy5fcmVhZEZpbGUobytcIi9cIit0K1wiL1wiK3QrXCIuYWZmXCIpKSxyfHwocj10aGlzLl9yZWFkRmlsZShvK1wiL1wiK3QrXCIvXCIrdCtcIi5kaWNcIikpfXRoaXMucnVsZXM9dGhpcy5fcGFyc2VBRkYoZSksdGhpcy5jb21wb3VuZFJ1bGVDb2Rlcz17fTtmb3IodmFyIHM9MCxhPXRoaXMuY29tcG91bmRSdWxlcy5sZW5ndGg7YT5zO3MrKylmb3IodmFyIGY9dGhpcy5jb21wb3VuZFJ1bGVzW3NdLHU9MCxoPWYubGVuZ3RoO2g+dTt1KyspdGhpcy5jb21wb3VuZFJ1bGVDb2Rlc1tmW3VdXT1bXTtcIk9OTFlJTkNPTVBPVU5EXCJpbiB0aGlzLmZsYWdzJiYodGhpcy5jb21wb3VuZFJ1bGVDb2Rlc1t0aGlzLmZsYWdzLk9OTFlJTkNPTVBPVU5EXT1bXSksdGhpcy5kaWN0aW9uYXJ5VGFibGU9dGhpcy5fcGFyc2VESUMocik7Zm9yKHZhciBzIGluIHRoaXMuY29tcG91bmRSdWxlQ29kZXMpMD09dGhpcy5jb21wb3VuZFJ1bGVDb2Rlc1tzXS5sZW5ndGgmJmRlbGV0ZSB0aGlzLmNvbXBvdW5kUnVsZUNvZGVzW3NdO2Zvcih2YXIgcz0wLGE9dGhpcy5jb21wb3VuZFJ1bGVzLmxlbmd0aDthPnM7cysrKXtmb3IodmFyIGw9dGhpcy5jb21wb3VuZFJ1bGVzW3NdLGM9XCJcIix1PTAsaD1sLmxlbmd0aDtoPnU7dSsrKXt2YXIgcD1sW3VdO2MrPXAgaW4gdGhpcy5jb21wb3VuZFJ1bGVDb2Rlcz9cIihcIit0aGlzLmNvbXBvdW5kUnVsZUNvZGVzW3BdLmpvaW4oXCJ8XCIpK1wiKVwiOnB9dGhpcy5jb21wb3VuZFJ1bGVzW3NdPW5ldyBSZWdFeHAoYyxcImlcIil9fXJldHVybiB0aGlzfTtpLnByb3RvdHlwZT17bG9hZDpmdW5jdGlvbih0KXtmb3IodmFyIGUgaW4gdCl0aGlzW2VdPXRbZV07cmV0dXJuIHRoaXN9LF9yZWFkRmlsZTpmdW5jdGlvbihlLG4pe2lmKG58fChuPVwidXRmOFwiKSxcInVuZGVmaW5lZFwiIT10eXBlb2YgWE1MSHR0cFJlcXVlc3Qpe3ZhciBpPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gaS5vcGVuKFwiR0VUXCIsZSwhMSksaS5vdmVycmlkZU1pbWVUeXBlJiZpLm92ZXJyaWRlTWltZVR5cGUoXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PVwiK24pLGkuc2VuZChudWxsKSxpLnJlc3BvbnNlVGV4dH1pZihcInVuZGVmaW5lZFwiIT10eXBlb2YgdCl7dmFyIG89dChcImZzXCIpO3RyeXtpZihvLmV4aXN0c1N5bmMoZSkpe3ZhciBzPW8uc3RhdFN5bmMoZSksYT1vLm9wZW5TeW5jKGUsXCJyXCIpLGY9bmV3IHIocy5zaXplKTtyZXR1cm4gby5yZWFkU3luYyhhLGYsMCxmLmxlbmd0aCxudWxsKSxmLnRvU3RyaW5nKG4sMCxmLmxlbmd0aCl9Y29uc29sZS5sb2coXCJQYXRoIFwiK2UrXCIgZG9lcyBub3QgZXhpc3QuXCIpfWNhdGNoKHUpe3JldHVybiBjb25zb2xlLmxvZyh1KSxcIlwifX19LF9wYXJzZUFGRjpmdW5jdGlvbih0KXt2YXIgZT17fTt0PXRoaXMuX3JlbW92ZUFmZml4Q29tbWVudHModCk7Zm9yKHZhciByPXQuc3BsaXQoXCJcXG5cIiksbj0wLGk9ci5sZW5ndGg7aT5uO24rKyl7dmFyIG89cltuXSxzPW8uc3BsaXQoL1xccysvKSxhPXNbMF07aWYoXCJQRlhcIj09YXx8XCJTRlhcIj09YSl7Zm9yKHZhciBmPXNbMV0sdT1zWzJdLGg9cGFyc2VJbnQoc1szXSwxMCksbD1bXSxjPW4rMSxwPW4rMStoO3A+YztjKyspe3ZhciBvPXJbY10sZD1vLnNwbGl0KC9cXHMrLyksZz1kWzJdLHk9ZFszXS5zcGxpdChcIi9cIiksdj15WzBdO1wiMFwiPT09diYmKHY9XCJcIik7dmFyIHc9dGhpcy5wYXJzZVJ1bGVDb2Rlcyh5WzFdKSxtPWRbNF0sRT17fTtFLmFkZD12LHcubGVuZ3RoPjAmJihFLmNvbnRpbnVhdGlvbkNsYXNzZXM9dyksXCIuXCIhPT1tJiYoXCJTRlhcIj09PWE/RS5tYXRjaD1uZXcgUmVnRXhwKG0rXCIkXCIpOkUubWF0Y2g9bmV3IFJlZ0V4cChcIl5cIittKSksXCIwXCIhPWcmJihcIlNGWFwiPT09YT9FLnJlbW92ZT1uZXcgUmVnRXhwKGcrXCIkXCIpOkUucmVtb3ZlPWcpLGwucHVzaChFKX1lW2ZdPXt0eXBlOmEsY29tYmluZWFibGU6XCJZXCI9PXUsZW50cmllczpsfSxuKz1ofWVsc2UgaWYoXCJDT01QT1VORFJVTEVcIj09PWEpe2Zvcih2YXIgaD1wYXJzZUludChzWzFdLDEwKSxjPW4rMSxwPW4rMStoO3A+YztjKyspe3ZhciBvPXJbY10sZD1vLnNwbGl0KC9cXHMrLyk7dGhpcy5jb21wb3VuZFJ1bGVzLnB1c2goZFsxXSl9bis9aH1lbHNlIGlmKFwiUkVQXCI9PT1hKXt2YXIgZD1vLnNwbGl0KC9cXHMrLyk7Mz09PWQubGVuZ3RoJiZ0aGlzLnJlcGxhY2VtZW50VGFibGUucHVzaChbZFsxXSxkWzJdXSl9ZWxzZSB0aGlzLmZsYWdzW2FdPXNbMV19cmV0dXJuIGV9LF9yZW1vdmVBZmZpeENvbW1lbnRzOmZ1bmN0aW9uKHQpe3JldHVybiB0PXQucmVwbGFjZSgvIy4qJC9nbSxcIlwiKSx0PXQucmVwbGFjZSgvXlxcc1xccyovbSxcIlwiKS5yZXBsYWNlKC9cXHNcXHMqJC9tLFwiXCIpLHQ9dC5yZXBsYWNlKC9cXG57Mix9L2csXCJcXG5cIiksdD10LnJlcGxhY2UoL15cXHNcXHMqLyxcIlwiKS5yZXBsYWNlKC9cXHNcXHMqJC8sXCJcIil9LF9wYXJzZURJQzpmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQsZSl7dCBpbiBuJiZcIm9iamVjdFwiPT10eXBlb2Ygblt0XXx8KG5bdF09W10pLG5bdF0ucHVzaChlKX10PXRoaXMuX3JlbW92ZURpY0NvbW1lbnRzKHQpO2Zvcih2YXIgcj10LnNwbGl0KFwiXFxuXCIpLG49e30saT0xLG89ci5sZW5ndGg7bz5pO2krKyl7dmFyIHM9cltpXSxhPXMuc3BsaXQoXCIvXCIsMiksZj1hWzBdO2lmKGEubGVuZ3RoPjEpe3ZhciB1PXRoaXMucGFyc2VSdWxlQ29kZXMoYVsxXSk7XCJORUVEQUZGSVhcImluIHRoaXMuZmxhZ3MmJi0xIT11LmluZGV4T2YodGhpcy5mbGFncy5ORUVEQUZGSVgpfHxlKGYsdSk7Zm9yKHZhciBoPTAsbD11Lmxlbmd0aDtsPmg7aCsrKXt2YXIgYz11W2hdLHA9dGhpcy5ydWxlc1tjXTtpZihwKWZvcih2YXIgZD10aGlzLl9hcHBseVJ1bGUoZixwKSxnPTAseT1kLmxlbmd0aDt5Pmc7ZysrKXt2YXIgdj1kW2ddO2lmKGUodixbXSkscC5jb21iaW5lYWJsZSlmb3IodmFyIHc9aCsxO2w+dzt3Kyspe3ZhciBtPXVbd10sRT10aGlzLnJ1bGVzW21dO2lmKEUmJkUuY29tYmluZWFibGUmJnAudHlwZSE9RS50eXBlKWZvcih2YXIgYj10aGlzLl9hcHBseVJ1bGUodixFKSxSPTAsXz1iLmxlbmd0aDtfPlI7UisrKXt2YXIgQT1iW1JdO2UoQSxbXSl9fX1jIGluIHRoaXMuY29tcG91bmRSdWxlQ29kZXMmJnRoaXMuY29tcG91bmRSdWxlQ29kZXNbY10ucHVzaChmKX19ZWxzZSBlKGYudHJpbSgpLFtdKX1yZXR1cm4gbn0sX3JlbW92ZURpY0NvbW1lbnRzOmZ1bmN0aW9uKHQpe3JldHVybiB0PXQucmVwbGFjZSgvXlxcdC4qJC9nbSxcIlwiKX0scGFyc2VSdWxlQ29kZXM6ZnVuY3Rpb24odCl7aWYoIXQpcmV0dXJuW107aWYoIShcIkZMQUdcImluIHRoaXMuZmxhZ3MpKXJldHVybiB0LnNwbGl0KFwiXCIpO2lmKFwibG9uZ1wiPT09dGhpcy5mbGFncy5GTEFHKXtmb3IodmFyIGU9W10scj0wLG49dC5sZW5ndGg7bj5yO3IrPTIpZS5wdXNoKHQuc3Vic3RyKHIsMikpO3JldHVybiBlfXJldHVyblwibnVtXCI9PT10aGlzLmZsYWdzLkZMQUc/dGV4dENvZGUuc3BsaXQoXCIsXCIpOnZvaWQgMH0sX2FwcGx5UnVsZTpmdW5jdGlvbih0LGUpe2Zvcih2YXIgcj1lLmVudHJpZXMsbj1bXSxpPTAsbz1yLmxlbmd0aDtvPmk7aSsrKXt2YXIgcz1yW2ldO2lmKCFzLm1hdGNofHx0Lm1hdGNoKHMubWF0Y2gpKXt2YXIgYT10O2lmKHMucmVtb3ZlJiYoYT1hLnJlcGxhY2Uocy5yZW1vdmUsXCJcIikpLFwiU0ZYXCI9PT1lLnR5cGU/YSs9cy5hZGQ6YT1zLmFkZCthLG4ucHVzaChhKSxcImNvbnRpbnVhdGlvbkNsYXNzZXNcImluIHMpZm9yKHZhciBmPTAsdT1zLmNvbnRpbnVhdGlvbkNsYXNzZXMubGVuZ3RoO3U+ZjtmKyspe3ZhciBoPXRoaXMucnVsZXNbcy5jb250aW51YXRpb25DbGFzc2VzW2ZdXTtoJiYobj1uLmNvbmNhdCh0aGlzLl9hcHBseVJ1bGUoYSxoKSkpfX19cmV0dXJuIG59LGNoZWNrOmZ1bmN0aW9uKHQpe3ZhciBlPXQucmVwbGFjZSgvXlxcc1xccyovLFwiXCIpLnJlcGxhY2UoL1xcc1xccyokLyxcIlwiKTtpZih0aGlzLmNoZWNrRXhhY3QoZSkpcmV0dXJuITA7aWYoZS50b1VwcGVyQ2FzZSgpPT09ZSl7dmFyIHI9ZVswXStlLnN1YnN0cmluZygxKS50b0xvd2VyQ2FzZSgpO2lmKHRoaXMuaGFzRmxhZyhyLFwiS0VFUENBU0VcIikpcmV0dXJuITE7aWYodGhpcy5jaGVja0V4YWN0KHIpKXJldHVybiEwfXZhciBuPWUudG9Mb3dlckNhc2UoKTtpZihuIT09ZSl7aWYodGhpcy5oYXNGbGFnKG4sXCJLRUVQQ0FTRVwiKSlyZXR1cm4hMTtpZih0aGlzLmNoZWNrRXhhY3QobikpcmV0dXJuITB9cmV0dXJuITF9LGNoZWNrRXhhY3Q6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5kaWN0aW9uYXJ5VGFibGVbdF07aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGUpe2lmKFwiQ09NUE9VTkRNSU5cImluIHRoaXMuZmxhZ3MmJnQubGVuZ3RoPj10aGlzLmZsYWdzLkNPTVBPVU5ETUlOKWZvcih2YXIgcj0wLG49dGhpcy5jb21wb3VuZFJ1bGVzLmxlbmd0aDtuPnI7cisrKWlmKHQubWF0Y2godGhpcy5jb21wb3VuZFJ1bGVzW3JdKSlyZXR1cm4hMDtyZXR1cm4hMX1pZihcIm9iamVjdFwiPT10eXBlb2YgZSl7Zm9yKHZhciByPTAsbj1lLmxlbmd0aDtuPnI7cisrKWlmKCF0aGlzLmhhc0ZsYWcodCxcIk9OTFlJTkNPTVBPVU5EXCIsZVtyXSkpcmV0dXJuITA7cmV0dXJuITF9fSxoYXNGbGFnOmZ1bmN0aW9uKHQsZSxyKXtpZihlIGluIHRoaXMuZmxhZ3Mpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiByKXZhciByPUFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sdGhpcy5kaWN0aW9uYXJ5VGFibGVbdF0pO2lmKHImJi0xIT09ci5pbmRleE9mKHRoaXMuZmxhZ3NbZV0pKXJldHVybiEwfXJldHVybiExfSxhbHBoYWJldDpcIlwiLHN1Z2dlc3Q6ZnVuY3Rpb24odCxlKXtmdW5jdGlvbiByKHQpe2Zvcih2YXIgZT1bXSxyPTAsbj10Lmxlbmd0aDtuPnI7cisrKXtmb3IodmFyIGk9dFtyXSxvPVtdLHM9MCxhPWkubGVuZ3RoKzE7YT5zO3MrKylvLnB1c2goW2kuc3Vic3RyaW5nKDAscyksaS5zdWJzdHJpbmcocyxpLmxlbmd0aCldKTtmb3IodmFyIGY9W10scz0wLGE9by5sZW5ndGg7YT5zO3MrKyl7dmFyIGg9b1tzXTtoWzFdJiZmLnB1c2goaFswXStoWzFdLnN1YnN0cmluZygxKSl9Zm9yKHZhciBsPVtdLHM9MCxhPW8ubGVuZ3RoO2E+cztzKyspe3ZhciBoPW9bc107aFsxXS5sZW5ndGg+MSYmbC5wdXNoKGhbMF0raFsxXVsxXStoWzFdWzBdK2hbMV0uc3Vic3RyaW5nKDIpKX1mb3IodmFyIGM9W10scz0wLGE9by5sZW5ndGg7YT5zO3MrKyl7dmFyIGg9b1tzXTtpZihoWzFdKWZvcih2YXIgcD0wLGQ9dS5hbHBoYWJldC5sZW5ndGg7ZD5wO3ArKyljLnB1c2goaFswXSt1LmFscGhhYmV0W3BdK2hbMV0uc3Vic3RyaW5nKDEpKX1mb3IodmFyIGc9W10scz0wLGE9by5sZW5ndGg7YT5zO3MrKyl7dmFyIGg9b1tzXTtpZihoWzFdKWZvcih2YXIgcD0wLGQ9dS5hbHBoYWJldC5sZW5ndGg7ZD5wO3ArKyljLnB1c2goaFswXSt1LmFscGhhYmV0W3BdK2hbMV0pfWU9ZS5jb25jYXQoZiksZT1lLmNvbmNhdChsKSxlPWUuY29uY2F0KGMpLGU9ZS5jb25jYXQoZyl9cmV0dXJuIGV9ZnVuY3Rpb24gbih0KXtmb3IodmFyIGU9W10scj0wO3I8dC5sZW5ndGg7cisrKXUuY2hlY2sodFtyXSkmJmUucHVzaCh0W3JdKTtyZXR1cm4gZX1mdW5jdGlvbiBpKHQpe2Z1bmN0aW9uIGkodCxlKXtyZXR1cm4gdFsxXTxlWzFdPy0xOjF9Zm9yKHZhciBvPXIoW3RdKSxzPXIobyksYT1uKG8pLmNvbmNhdChuKHMpKSxmPXt9LGg9MCxsPWEubGVuZ3RoO2w+aDtoKyspYVtoXWluIGY/ZlthW2hdXSs9MTpmW2FbaF1dPTE7dmFyIGM9W107Zm9yKHZhciBoIGluIGYpYy5wdXNoKFtoLGZbaF1dKTtjLnNvcnQoaSkucmV2ZXJzZSgpO2Zvcih2YXIgcD1bXSxoPTAsbD1NYXRoLm1pbihlLGMubGVuZ3RoKTtsPmg7aCsrKXUuaGFzRmxhZyhjW2hdWzBdLFwiTk9TVUdHRVNUXCIpfHxwLnB1c2goY1toXVswXSk7cmV0dXJuIHB9aWYoZXx8KGU9NSksdGhpcy5jaGVjayh0KSlyZXR1cm5bXTtmb3IodmFyIG89MCxzPXRoaXMucmVwbGFjZW1lbnRUYWJsZS5sZW5ndGg7cz5vO28rKyl7dmFyIGE9dGhpcy5yZXBsYWNlbWVudFRhYmxlW29dO2lmKC0xIT09dC5pbmRleE9mKGFbMF0pKXt2YXIgZj10LnJlcGxhY2UoYVswXSxhWzFdKTtpZih0aGlzLmNoZWNrKGYpKXJldHVybltmXX19dmFyIHU9dGhpcztyZXR1cm4gdS5hbHBoYWJldD1cImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIsaSh0KX19LFwidW5kZWZpbmVkXCIhPXR5cGVvZiBlJiYoZS5leHBvcnRzPWkpfSkuY2FsbCh0aGlzLHQoXCJidWZmZXJcIikuQnVmZmVyLFwiL25vZGVfbW9kdWxlcy90eXBvLWpzXCIpfSx7YnVmZmVyOjMsZnM6Mn1dLDc6W2Z1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBuKHQpe3JldHVybiB0PXR8fHt9LFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQuY29kZU1pcnJvckluc3RhbmNlfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiB0LmNvZGVNaXJyb3JJbnN0YW5jZS5kZWZpbmVNb2RlP3ZvaWQgY29uc29sZS5sb2coXCJDb2RlTWlycm9yIFNwZWxsIENoZWNrZXI6IFlvdSBtdXN0IHByb3ZpZGUgYW4gaW5zdGFuY2Ugb2YgQ29kZU1pcnJvciB2aWEgdGhlIG9wdGlvbiBgY29kZU1pcnJvckluc3RhbmNlYFwiKTooU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlc3x8KFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXM9ZnVuY3Rpb24oKXtyZXR1cm4tMSE9PVN0cmluZy5wcm90b3R5cGUuaW5kZXhPZi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KSx2b2lkIHQuY29kZU1pcnJvckluc3RhbmNlLmRlZmluZU1vZGUoXCJzcGVsbC1jaGVja2VyXCIsZnVuY3Rpb24oZSl7aWYoIW4uYWZmX2xvYWRpbmcpe24uYWZmX2xvYWRpbmc9ITA7dmFyIHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3Iub3BlbihcIkdFVFwiLFwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2NvZGVtaXJyb3Iuc3BlbGwtY2hlY2tlci9sYXRlc3QvZW5fVVMuYWZmXCIsITApLHIub25sb2FkPWZ1bmN0aW9uKCl7ND09PXIucmVhZHlTdGF0ZSYmMjAwPT09ci5zdGF0dXMmJihuLmFmZl9kYXRhPXIucmVzcG9uc2VUZXh0LG4ubnVtX2xvYWRlZCsrLDI9PW4ubnVtX2xvYWRlZCYmKG4udHlwbz1uZXcgaShcImVuX1VTXCIsbi5hZmZfZGF0YSxuLmRpY19kYXRhLHtwbGF0Zm9ybTpcImFueVwifSkpKX0sci5zZW5kKG51bGwpfWlmKCFuLmRpY19sb2FkaW5nKXtuLmRpY19sb2FkaW5nPSEwO3ZhciBvPW5ldyBYTUxIdHRwUmVxdWVzdDtvLm9wZW4oXCJHRVRcIixcImh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9jb2RlbWlycm9yLnNwZWxsLWNoZWNrZXIvbGF0ZXN0L2VuX1VTLmRpY1wiLCEwKSxvLm9ubG9hZD1mdW5jdGlvbigpezQ9PT1vLnJlYWR5U3RhdGUmJjIwMD09PW8uc3RhdHVzJiYobi5kaWNfZGF0YT1vLnJlc3BvbnNlVGV4dCxuLm51bV9sb2FkZWQrKywyPT1uLm51bV9sb2FkZWQmJihuLnR5cG89bmV3IGkoXCJlbl9VU1wiLG4uYWZmX2RhdGEsbi5kaWNfZGF0YSx7cGxhdGZvcm06XCJhbnlcIn0pKSl9LG8uc2VuZChudWxsKX12YXIgcz0nIVwiIyQlJigpKissLS4vOjs8PT4/QFtcXFxcXV5fYHt8fX4gJyxhPXt0b2tlbjpmdW5jdGlvbih0KXt2YXIgZT10LnBlZWsoKSxyPVwiXCI7aWYocy5pbmNsdWRlcyhlKSlyZXR1cm4gdC5uZXh0KCksbnVsbDtmb3IoO251bGwhPShlPXQucGVlaygpKSYmIXMuaW5jbHVkZXMoZSk7KXIrPWUsdC5uZXh0KCk7cmV0dXJuIG4udHlwbyYmIW4udHlwby5jaGVjayhyKT9cInNwZWxsLWVycm9yXCI6bnVsbH19LGY9dC5jb2RlTWlycm9ySW5zdGFuY2UuZ2V0TW9kZShlLGUuYmFja2Ryb3B8fFwidGV4dC9wbGFpblwiKTtyZXR1cm4gdC5jb2RlTWlycm9ySW5zdGFuY2Uub3ZlcmxheU1vZGUoZixhLCEwKX0pKX12YXIgaT10KFwidHlwby1qc1wiKTtuLm51bV9sb2FkZWQ9MCxuLmFmZl9sb2FkaW5nPSExLG4uZGljX2xvYWRpbmc9ITEsbi5hZmZfZGF0YT1cIlwiLG4uZGljX2RhdGE9XCJcIixuLnR5cG8sZS5leHBvcnRzPW59LHtcInR5cG8tanNcIjo2fV19LHt9LFs3XSkoNyl9KTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/spell-checker.min.js\n");

/***/ }),

/***/ "./lib/sweetalert.min.js":
/*!*******************************!*\
  !*** ./lib/sweetalert.min.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var require;var require;var __WEBPACK_AMD_DEFINE_RESULT__;!function(e,t,n){\"use strict\";!function o(e,t,n){function a(s,l){if(!t[s]){if(!e[s]){var i=\"function\"==typeof require&&require;if(!l&&i)return require(s,!0);if(r)return r(s,!0);var u=new Error(\"Cannot find module '\"+s+\"'\");throw u.code=\"MODULE_NOT_FOUND\",u}var c=t[s]={exports:{}};e[s][0].call(c.exports,function(t){var n=e[s][1][t];return a(n?n:t)},c,c.exports,o,e,t,n)}return t[s].exports}for(var r=\"function\"==typeof require&&require,s=0;s<n.length;s++)a(n[s]);return a}({1:[function(o,a,r){var s=function(e){return e&&e.__esModule?e:{\"default\":e}};Object.defineProperty(r,\"__esModule\",{value:!0});var l,i,u,c,d=o(\"./modules/handle-dom\"),f=o(\"./modules/utils\"),p=o(\"./modules/handle-swal-dom\"),m=o(\"./modules/handle-click\"),v=o(\"./modules/handle-key\"),y=s(v),h=o(\"./modules/default-params\"),b=s(h),g=o(\"./modules/set-params\"),w=s(g);r[\"default\"]=u=c=function(){function o(e){var t=a;return t[e]===n?b[\"default\"][e]:t[e]}var a=arguments[0];if(d.addClass(t.body,\"stop-scrolling\"),p.resetInput(),a===n)return f.logStr(\"SweetAlert expects at least 1 attribute!\"),!1;var r=f.extend({},b[\"default\"]);switch(typeof a){case\"string\":r.title=a,r.text=arguments[1]||\"\",r.type=arguments[2]||\"\";break;case\"object\":if(a.title===n)return f.logStr('Missing \"title\" argument!'),!1;r.title=a.title;for(var s in b[\"default\"])r[s]=o(s);r.confirmButtonText=r.showCancelButton?\"Confirm\":b[\"default\"].confirmButtonText,r.confirmButtonText=o(\"confirmButtonText\"),r.doneFunction=arguments[1]||null;break;default:return f.logStr('Unexpected type of argument! Expected \"string\" or \"object\", got '+typeof a),!1}w[\"default\"](r),p.fixVerticalPosition(),p.openModal(arguments[1]);for(var u=p.getModal(),v=u.querySelectorAll(\"button\"),h=[\"onclick\",\"onmouseover\",\"onmouseout\",\"onmousedown\",\"onmouseup\",\"onfocus\"],g=function(e){return m.handleButton(e,r,u)},C=0;C<v.length;C++)for(var S=0;S<h.length;S++){var x=h[S];v[C][x]=g}p.getOverlay().onclick=g,l=e.onkeydown;var k=function(e){return y[\"default\"](e,r,u)};e.onkeydown=k,e.onfocus=function(){setTimeout(function(){i!==n&&(i.focus(),i=n)},0)},c.enableButtons()},u.setDefaults=c.setDefaults=function(e){if(!e)throw new Error(\"userParams is required\");if(\"object\"!=typeof e)throw new Error(\"userParams has to be a object\");f.extend(b[\"default\"],e)},u.close=c.close=function(){var o=p.getModal();d.fadeOut(p.getOverlay(),5),d.fadeOut(o,5),d.removeClass(o,\"showSweetAlert\"),d.addClass(o,\"hideSweetAlert\"),d.removeClass(o,\"visible\");var a=o.querySelector(\".sa-icon.sa-success\");d.removeClass(a,\"animate\"),d.removeClass(a.querySelector(\".sa-tip\"),\"animateSuccessTip\"),d.removeClass(a.querySelector(\".sa-long\"),\"animateSuccessLong\");var r=o.querySelector(\".sa-icon.sa-error\");d.removeClass(r,\"animateErrorIcon\"),d.removeClass(r.querySelector(\".sa-x-mark\"),\"animateXMark\");var s=o.querySelector(\".sa-icon.sa-warning\");return d.removeClass(s,\"pulseWarning\"),d.removeClass(s.querySelector(\".sa-body\"),\"pulseWarningIns\"),d.removeClass(s.querySelector(\".sa-dot\"),\"pulseWarningIns\"),setTimeout(function(){var e=o.getAttribute(\"data-custom-class\");d.removeClass(o,e)},300),d.removeClass(t.body,\"stop-scrolling\"),e.onkeydown=l,e.previousActiveElement&&e.previousActiveElement.focus(),i=n,clearTimeout(o.timeout),!0},u.showInputError=c.showInputError=function(e){var t=p.getModal(),n=t.querySelector(\".sa-input-error\");d.addClass(n,\"show\");var o=t.querySelector(\".sa-error-container\");d.addClass(o,\"show\"),o.querySelector(\"p\").innerHTML=e,setTimeout(function(){u.enableButtons()},1),t.querySelector(\"input\").focus()},u.resetInputError=c.resetInputError=function(e){if(e&&13===e.keyCode)return!1;var t=p.getModal(),n=t.querySelector(\".sa-input-error\");d.removeClass(n,\"show\");var o=t.querySelector(\".sa-error-container\");d.removeClass(o,\"show\")},u.disableButtons=c.disableButtons=function(){var e=p.getModal(),t=e.querySelector(\"button.confirm\"),n=e.querySelector(\"button.cancel\");t.disabled=!0,n.disabled=!0},u.enableButtons=c.enableButtons=function(){var e=p.getModal(),t=e.querySelector(\"button.confirm\"),n=e.querySelector(\"button.cancel\");t.disabled=!1,n.disabled=!1},\"undefined\"!=typeof e?e.sweetAlert=e.swal=u:f.logStr(\"SweetAlert is a frontend module!\"),a.exports=r[\"default\"]},{\"./modules/default-params\":2,\"./modules/handle-click\":3,\"./modules/handle-dom\":4,\"./modules/handle-key\":5,\"./modules/handle-swal-dom\":6,\"./modules/set-params\":8,\"./modules/utils\":9}],2:[function(e,t,n){Object.defineProperty(n,\"__esModule\",{value:!0});var o={title:\"\",text:\"\",type:null,allowOutsideClick:!1,showConfirmButton:!0,showCancelButton:!1,closeOnConfirm:!0,closeOnCancel:!0,confirmButtonText:\"OK\",confirmButtonColor:\"#8CD4F5\",cancelButtonText:\"Cancel\",imageUrl:null,imageSize:null,timer:null,customClass:\"\",html:!1,animation:!0,allowEscapeKey:!0,inputType:\"text\",inputPlaceholder:\"\",inputValue:\"\",showLoaderOnConfirm:!1};n[\"default\"]=o,t.exports=n[\"default\"]},{}],3:[function(t,n,o){Object.defineProperty(o,\"__esModule\",{value:!0});var a=t(\"./utils\"),r=(t(\"./handle-swal-dom\"),t(\"./handle-dom\")),s=function(t,n,o){function s(e){m&&n.confirmButtonColor&&(p.style.backgroundColor=e)}var u,c,d,f=t||e.event,p=f.target||f.srcElement,m=-1!==p.className.indexOf(\"confirm\"),v=-1!==p.className.indexOf(\"sweet-overlay\"),y=r.hasClass(o,\"visible\"),h=n.doneFunction&&\"true\"===o.getAttribute(\"data-has-done-function\");switch(m&&n.confirmButtonColor&&(u=n.confirmButtonColor,c=a.colorLuminance(u,-.04),d=a.colorLuminance(u,-.14)),f.type){case\"mouseover\":s(c);break;case\"mouseout\":s(u);break;case\"mousedown\":s(d);break;case\"mouseup\":s(c);break;case\"focus\":var b=o.querySelector(\"button.confirm\"),g=o.querySelector(\"button.cancel\");m?g.style.boxShadow=\"none\":b.style.boxShadow=\"none\";break;case\"click\":var w=o===p,C=r.isDescendant(o,p);if(!w&&!C&&y&&!n.allowOutsideClick)break;m&&h&&y?l(o,n):h&&y||v?i(o,n):r.isDescendant(o,p)&&\"BUTTON\"===p.tagName&&sweetAlert.close()}},l=function(e,t){var n=!0;r.hasClass(e,\"show-input\")&&(n=e.querySelector(\"input\").value,n||(n=\"\")),t.doneFunction(n),t.closeOnConfirm&&sweetAlert.close(),t.showLoaderOnConfirm&&sweetAlert.disableButtons()},i=function(e,t){var n=String(t.doneFunction).replace(/\\s/g,\"\"),o=\"function(\"===n.substring(0,9)&&\")\"!==n.substring(9,10);o&&t.doneFunction(!1),t.closeOnCancel&&sweetAlert.close()};o[\"default\"]={handleButton:s,handleConfirm:l,handleCancel:i},n.exports=o[\"default\"]},{\"./handle-dom\":4,\"./handle-swal-dom\":6,\"./utils\":9}],4:[function(n,o,a){Object.defineProperty(a,\"__esModule\",{value:!0});var r=function(e,t){return new RegExp(\" \"+t+\" \").test(\" \"+e.className+\" \")},s=function(e,t){r(e,t)||(e.className+=\" \"+t)},l=function(e,t){var n=\" \"+e.className.replace(/[\\t\\r\\n]/g,\" \")+\" \";if(r(e,t)){for(;n.indexOf(\" \"+t+\" \")>=0;)n=n.replace(\" \"+t+\" \",\" \");e.className=n.replace(/^\\s+|\\s+$/g,\"\")}},i=function(e){var n=t.createElement(\"div\");return n.appendChild(t.createTextNode(e)),n.innerHTML},u=function(e){e.style.opacity=\"\",e.style.display=\"block\"},c=function(e){if(e&&!e.length)return u(e);for(var t=0;t<e.length;++t)u(e[t])},d=function(e){e.style.opacity=\"\",e.style.display=\"none\"},f=function(e){if(e&&!e.length)return d(e);for(var t=0;t<e.length;++t)d(e[t])},p=function(e,t){for(var n=t.parentNode;null!==n;){if(n===e)return!0;n=n.parentNode}return!1},m=function(e){e.style.left=\"-9999px\",e.style.display=\"block\";var t,n=e.clientHeight;return t=\"undefined\"!=typeof getComputedStyle?parseInt(getComputedStyle(e).getPropertyValue(\"padding-top\"),10):parseInt(e.currentStyle.padding),e.style.left=\"\",e.style.display=\"none\",\"-\"+parseInt((n+t)/2)+\"px\"},v=function(e,t){if(+e.style.opacity<1){t=t||16,e.style.opacity=0,e.style.display=\"block\";var n=+new Date,o=function(e){function t(){return e.apply(this,arguments)}return t.toString=function(){return e.toString()},t}(function(){e.style.opacity=+e.style.opacity+(new Date-n)/100,n=+new Date,+e.style.opacity<1&&setTimeout(o,t)});o()}e.style.display=\"block\"},y=function(e,t){t=t||16,e.style.opacity=1;var n=+new Date,o=function(e){function t(){return e.apply(this,arguments)}return t.toString=function(){return e.toString()},t}(function(){e.style.opacity=+e.style.opacity-(new Date-n)/100,n=+new Date,+e.style.opacity>0?setTimeout(o,t):e.style.display=\"none\"});o()},h=function(n){if(\"function\"==typeof MouseEvent){var o=new MouseEvent(\"click\",{view:e,bubbles:!1,cancelable:!0});n.dispatchEvent(o)}else if(t.createEvent){var a=t.createEvent(\"MouseEvents\");a.initEvent(\"click\",!1,!1),n.dispatchEvent(a)}else t.createEventObject?n.fireEvent(\"onclick\"):\"function\"==typeof n.onclick&&n.onclick()},b=function(t){\"function\"==typeof t.stopPropagation?(t.stopPropagation(),t.preventDefault()):e.event&&e.event.hasOwnProperty(\"cancelBubble\")&&(e.event.cancelBubble=!0)};a.hasClass=r,a.addClass=s,a.removeClass=l,a.escapeHtml=i,a._show=u,a.show=c,a._hide=d,a.hide=f,a.isDescendant=p,a.getTopMargin=m,a.fadeIn=v,a.fadeOut=y,a.fireClick=h,a.stopEventPropagation=b},{}],5:[function(t,o,a){Object.defineProperty(a,\"__esModule\",{value:!0});var r=t(\"./handle-dom\"),s=t(\"./handle-swal-dom\"),l=function(t,o,a){var l=t||e.event,i=l.keyCode||l.which,u=a.querySelector(\"button.confirm\"),c=a.querySelector(\"button.cancel\"),d=a.querySelectorAll(\"button[tabindex]\");if(-1!==[9,13,32,27].indexOf(i)){for(var f=l.target||l.srcElement,p=-1,m=0;m<d.length;m++)if(f===d[m]){p=m;break}9===i?(f=-1===p?u:p===d.length-1?d[0]:d[p+1],r.stopEventPropagation(l),f.focus(),o.confirmButtonColor&&s.setFocusStyle(f,o.confirmButtonColor)):13===i?(\"INPUT\"===f.tagName&&(f=u,u.focus()),f=-1===p?u:n):27===i&&o.allowEscapeKey===!0?(f=c,r.fireClick(f,l)):f=n}};a[\"default\"]=l,o.exports=a[\"default\"]},{\"./handle-dom\":4,\"./handle-swal-dom\":6}],6:[function(n,o,a){var r=function(e){return e&&e.__esModule?e:{\"default\":e}};Object.defineProperty(a,\"__esModule\",{value:!0});var s=n(\"./utils\"),l=n(\"./handle-dom\"),i=n(\"./default-params\"),u=r(i),c=n(\"./injected-html\"),d=r(c),f=\".sweet-alert\",p=\".sweet-overlay\",m=function(){var e=t.createElement(\"div\");for(e.innerHTML=d[\"default\"];e.firstChild;)t.body.appendChild(e.firstChild)},v=function(e){function t(){return e.apply(this,arguments)}return t.toString=function(){return e.toString()},t}(function(){var e=t.querySelector(f);return e||(m(),e=v()),e}),y=function(){var e=v();return e?e.querySelector(\"input\"):void 0},h=function(){return t.querySelector(p)},b=function(e,t){var n=s.hexToRgb(t);e.style.boxShadow=\"0 0 2px rgba(\"+n+\", 0.8), inset 0 0 0 1px rgba(0, 0, 0, 0.05)\"},g=function(n){var o=v();l.fadeIn(h(),10),l.show(o),l.addClass(o,\"showSweetAlert\"),l.removeClass(o,\"hideSweetAlert\"),e.previousActiveElement=t.activeElement;var a=o.querySelector(\"button.confirm\");a.focus(),setTimeout(function(){l.addClass(o,\"visible\")},500);var r=o.getAttribute(\"data-timer\");if(\"null\"!==r&&\"\"!==r){var s=n;o.timeout=setTimeout(function(){var e=(s||null)&&\"true\"===o.getAttribute(\"data-has-done-function\");e?s(null):sweetAlert.close()},r)}},w=function(){var e=v(),t=y();l.removeClass(e,\"show-input\"),t.value=u[\"default\"].inputValue,t.setAttribute(\"type\",u[\"default\"].inputType),t.setAttribute(\"placeholder\",u[\"default\"].inputPlaceholder),C()},C=function(e){if(e&&13===e.keyCode)return!1;var t=v(),n=t.querySelector(\".sa-input-error\");l.removeClass(n,\"show\");var o=t.querySelector(\".sa-error-container\");l.removeClass(o,\"show\")},S=function(){var e=v();e.style.marginTop=l.getTopMargin(v())};a.sweetAlertInitialize=m,a.getModal=v,a.getOverlay=h,a.getInput=y,a.setFocusStyle=b,a.openModal=g,a.resetInput=w,a.resetInputError=C,a.fixVerticalPosition=S},{\"./default-params\":2,\"./handle-dom\":4,\"./injected-html\":7,\"./utils\":9}],7:[function(e,t,n){Object.defineProperty(n,\"__esModule\",{value:!0});var o='<div class=\"sweet-overlay\" tabIndex=\"-1\"></div><div class=\"sweet-alert\"><div class=\"sa-icon sa-error\">\\n      <span class=\"sa-x-mark\">\\n        <span class=\"sa-line sa-left\"></span>\\n        <span class=\"sa-line sa-right\"></span>\\n      </span>\\n    </div><div class=\"sa-icon sa-warning\">\\n      <span class=\"sa-body\"></span>\\n      <span class=\"sa-dot\"></span>\\n    </div><div class=\"sa-icon sa-info\"></div><div class=\"sa-icon sa-success\">\\n      <span class=\"sa-line sa-tip\"></span>\\n      <span class=\"sa-line sa-long\"></span>\\n\\n      <div class=\"sa-placeholder\"></div>\\n      <div class=\"sa-fix\"></div>\\n    </div><div class=\"sa-icon sa-custom\"></div><h2>Title</h2>\\n    <p>Text</p>\\n    <fieldset>\\n      <input type=\"text\" tabIndex=\"3\" />\\n      <div class=\"sa-input-error\"></div>\\n    </fieldset><div class=\"sa-error-container\">\\n      <div class=\"icon\">!</div>\\n      <p>Not valid!</p>\\n    </div><div class=\"sa-button-container\">\\n      <button class=\"cancel\" tabIndex=\"2\">Cancel</button>\\n      <div class=\"sa-confirm-button-container\">\\n        <button class=\"confirm\" tabIndex=\"1\">OK</button><div class=\"la-ball-fall\">\\n          <div></div>\\n          <div></div>\\n          <div></div>\\n        </div>\\n      </div>\\n    </div></div>';n[\"default\"]=o,t.exports=n[\"default\"]},{}],8:[function(e,t,o){Object.defineProperty(o,\"__esModule\",{value:!0});var a=e(\"./utils\"),r=e(\"./handle-swal-dom\"),s=e(\"./handle-dom\"),l=[\"error\",\"warning\",\"info\",\"success\",\"input\",\"prompt\"],i=function(e){var t=r.getModal(),o=t.querySelector(\"h2\"),i=t.querySelector(\"p\"),u=t.querySelector(\"button.cancel\"),c=t.querySelector(\"button.confirm\");if(o.innerHTML=e.html?e.title:s.escapeHtml(e.title).split(\"\\n\").join(\"<br>\"),i.innerHTML=e.html?e.text:s.escapeHtml(e.text||\"\").split(\"\\n\").join(\"<br>\"),e.text&&s.show(i),e.customClass)s.addClass(t,e.customClass),t.setAttribute(\"data-custom-class\",e.customClass);else{var d=t.getAttribute(\"data-custom-class\");s.removeClass(t,d),t.setAttribute(\"data-custom-class\",\"\")}if(s.hide(t.querySelectorAll(\".sa-icon\")),e.type&&!a.isIE8()){var f=function(){for(var o=!1,a=0;a<l.length;a++)if(e.type===l[a]){o=!0;break}if(!o)return logStr(\"Unknown alert type: \"+e.type),{v:!1};var i=[\"success\",\"error\",\"warning\",\"info\"],u=n;-1!==i.indexOf(e.type)&&(u=t.querySelector(\".sa-icon.sa-\"+e.type),s.show(u));var c=r.getInput();switch(e.type){case\"success\":s.addClass(u,\"animate\"),s.addClass(u.querySelector(\".sa-tip\"),\"animateSuccessTip\"),s.addClass(u.querySelector(\".sa-long\"),\"animateSuccessLong\");break;case\"error\":s.addClass(u,\"animateErrorIcon\"),s.addClass(u.querySelector(\".sa-x-mark\"),\"animateXMark\");break;case\"warning\":s.addClass(u,\"pulseWarning\"),s.addClass(u.querySelector(\".sa-body\"),\"pulseWarningIns\"),s.addClass(u.querySelector(\".sa-dot\"),\"pulseWarningIns\");break;case\"input\":case\"prompt\":c.setAttribute(\"type\",e.inputType),c.value=e.inputValue,c.setAttribute(\"placeholder\",e.inputPlaceholder),s.addClass(t,\"show-input\"),setTimeout(function(){c.focus(),c.addEventListener(\"keyup\",swal.resetInputError)},400)}}();if(\"object\"==typeof f)return f.v}if(e.imageUrl){var p=t.querySelector(\".sa-icon.sa-custom\");p.style.backgroundImage=\"url(\"+e.imageUrl+\")\",s.show(p);var m=80,v=80;if(e.imageSize){var y=e.imageSize.toString().split(\"x\"),h=y[0],b=y[1];h&&b?(m=h,v=b):logStr(\"Parameter imageSize expects value with format WIDTHxHEIGHT, got \"+e.imageSize)}p.setAttribute(\"style\",p.getAttribute(\"style\")+\"width:\"+m+\"px; height:\"+v+\"px\")}t.setAttribute(\"data-has-cancel-button\",e.showCancelButton),e.showCancelButton?u.style.display=\"inline-block\":s.hide(u),t.setAttribute(\"data-has-confirm-button\",e.showConfirmButton),e.showConfirmButton?c.style.display=\"inline-block\":s.hide(c),e.cancelButtonText&&(u.innerHTML=s.escapeHtml(e.cancelButtonText)),e.confirmButtonText&&(c.innerHTML=s.escapeHtml(e.confirmButtonText)),e.confirmButtonColor&&(c.style.backgroundColor=e.confirmButtonColor,c.style.borderLeftColor=e.confirmLoadingButtonColor,c.style.borderRightColor=e.confirmLoadingButtonColor,r.setFocusStyle(c,e.confirmButtonColor)),t.setAttribute(\"data-allow-outside-click\",e.allowOutsideClick);var g=e.doneFunction?!0:!1;t.setAttribute(\"data-has-done-function\",g),e.animation?\"string\"==typeof e.animation?t.setAttribute(\"data-animation\",e.animation):t.setAttribute(\"data-animation\",\"pop\"):t.setAttribute(\"data-animation\",\"none\"),t.setAttribute(\"data-timer\",e.timer)};o[\"default\"]=i,t.exports=o[\"default\"]},{\"./handle-dom\":4,\"./handle-swal-dom\":6,\"./utils\":9}],9:[function(t,n,o){Object.defineProperty(o,\"__esModule\",{value:!0});var a=function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n]);return e},r=function(e){var t=/^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(e);return t?parseInt(t[1],16)+\", \"+parseInt(t[2],16)+\", \"+parseInt(t[3],16):null},s=function(){return e.attachEvent&&!e.addEventListener},l=function(t){e.console&&e.console.log(\"SweetAlert: \"+t)},i=function(e,t){e=String(e).replace(/[^0-9a-f]/gi,\"\"),e.length<6&&(e=e[0]+e[0]+e[1]+e[1]+e[2]+e[2]),t=t||0;var n,o,a=\"#\";for(o=0;3>o;o++)n=parseInt(e.substr(2*o,2),16),n=Math.round(Math.min(Math.max(0,n+n*t),255)).toString(16),a+=(\"00\"+n).substr(n.length);return a};o.extend=a,o.hexToRgb=r,o.isIE8=s,o.logStr=l,o.colorLuminance=i},{}]},{},[1]), true?!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return sweetAlert}).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):undefined}(window,document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvc3dlZXRhbGVydC5taW4uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvc3dlZXRhbGVydC5taW4uanM/ZTg2OSJdLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiOyFmdW5jdGlvbiBvKGUsdCxuKXtmdW5jdGlvbiBhKHMsbCl7aWYoIXRbc10pe2lmKCFlW3NdKXt2YXIgaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFsJiZpKXJldHVybiBpKHMsITApO2lmKHIpcmV0dXJuIHIocywhMCk7dmFyIHU9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitzK1wiJ1wiKTt0aHJvdyB1LmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsdX12YXIgYz10W3NdPXtleHBvcnRzOnt9fTtlW3NdWzBdLmNhbGwoYy5leHBvcnRzLGZ1bmN0aW9uKHQpe3ZhciBuPWVbc11bMV1bdF07cmV0dXJuIGEobj9uOnQpfSxjLGMuZXhwb3J0cyxvLGUsdCxuKX1yZXR1cm4gdFtzXS5leHBvcnRzfWZvcih2YXIgcj1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLHM9MDtzPG4ubGVuZ3RoO3MrKylhKG5bc10pO3JldHVybiBhfSh7MTpbZnVuY3Rpb24obyxhLHIpe3ZhciBzPWZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBsLGksdSxjLGQ9byhcIi4vbW9kdWxlcy9oYW5kbGUtZG9tXCIpLGY9byhcIi4vbW9kdWxlcy91dGlsc1wiKSxwPW8oXCIuL21vZHVsZXMvaGFuZGxlLXN3YWwtZG9tXCIpLG09byhcIi4vbW9kdWxlcy9oYW5kbGUtY2xpY2tcIiksdj1vKFwiLi9tb2R1bGVzL2hhbmRsZS1rZXlcIikseT1zKHYpLGg9byhcIi4vbW9kdWxlcy9kZWZhdWx0LXBhcmFtc1wiKSxiPXMoaCksZz1vKFwiLi9tb2R1bGVzL3NldC1wYXJhbXNcIiksdz1zKGcpO3JbXCJkZWZhdWx0XCJdPXU9Yz1mdW5jdGlvbigpe2Z1bmN0aW9uIG8oZSl7dmFyIHQ9YTtyZXR1cm4gdFtlXT09PW4/YltcImRlZmF1bHRcIl1bZV06dFtlXX12YXIgYT1hcmd1bWVudHNbMF07aWYoZC5hZGRDbGFzcyh0LmJvZHksXCJzdG9wLXNjcm9sbGluZ1wiKSxwLnJlc2V0SW5wdXQoKSxhPT09bilyZXR1cm4gZi5sb2dTdHIoXCJTd2VldEFsZXJ0IGV4cGVjdHMgYXQgbGVhc3QgMSBhdHRyaWJ1dGUhXCIpLCExO3ZhciByPWYuZXh0ZW5kKHt9LGJbXCJkZWZhdWx0XCJdKTtzd2l0Y2godHlwZW9mIGEpe2Nhc2VcInN0cmluZ1wiOnIudGl0bGU9YSxyLnRleHQ9YXJndW1lbnRzWzFdfHxcIlwiLHIudHlwZT1hcmd1bWVudHNbMl18fFwiXCI7YnJlYWs7Y2FzZVwib2JqZWN0XCI6aWYoYS50aXRsZT09PW4pcmV0dXJuIGYubG9nU3RyKCdNaXNzaW5nIFwidGl0bGVcIiBhcmd1bWVudCEnKSwhMTtyLnRpdGxlPWEudGl0bGU7Zm9yKHZhciBzIGluIGJbXCJkZWZhdWx0XCJdKXJbc109byhzKTtyLmNvbmZpcm1CdXR0b25UZXh0PXIuc2hvd0NhbmNlbEJ1dHRvbj9cIkNvbmZpcm1cIjpiW1wiZGVmYXVsdFwiXS5jb25maXJtQnV0dG9uVGV4dCxyLmNvbmZpcm1CdXR0b25UZXh0PW8oXCJjb25maXJtQnV0dG9uVGV4dFwiKSxyLmRvbmVGdW5jdGlvbj1hcmd1bWVudHNbMV18fG51bGw7YnJlYWs7ZGVmYXVsdDpyZXR1cm4gZi5sb2dTdHIoJ1VuZXhwZWN0ZWQgdHlwZSBvZiBhcmd1bWVudCEgRXhwZWN0ZWQgXCJzdHJpbmdcIiBvciBcIm9iamVjdFwiLCBnb3QgJyt0eXBlb2YgYSksITF9d1tcImRlZmF1bHRcIl0ocikscC5maXhWZXJ0aWNhbFBvc2l0aW9uKCkscC5vcGVuTW9kYWwoYXJndW1lbnRzWzFdKTtmb3IodmFyIHU9cC5nZXRNb2RhbCgpLHY9dS5xdWVyeVNlbGVjdG9yQWxsKFwiYnV0dG9uXCIpLGg9W1wib25jbGlja1wiLFwib25tb3VzZW92ZXJcIixcIm9ubW91c2VvdXRcIixcIm9ubW91c2Vkb3duXCIsXCJvbm1vdXNldXBcIixcIm9uZm9jdXNcIl0sZz1mdW5jdGlvbihlKXtyZXR1cm4gbS5oYW5kbGVCdXR0b24oZSxyLHUpfSxDPTA7Qzx2Lmxlbmd0aDtDKyspZm9yKHZhciBTPTA7UzxoLmxlbmd0aDtTKyspe3ZhciB4PWhbU107dltDXVt4XT1nfXAuZ2V0T3ZlcmxheSgpLm9uY2xpY2s9ZyxsPWUub25rZXlkb3duO3ZhciBrPWZ1bmN0aW9uKGUpe3JldHVybiB5W1wiZGVmYXVsdFwiXShlLHIsdSl9O2Uub25rZXlkb3duPWssZS5vbmZvY3VzPWZ1bmN0aW9uKCl7c2V0VGltZW91dChmdW5jdGlvbigpe2khPT1uJiYoaS5mb2N1cygpLGk9bil9LDApfSxjLmVuYWJsZUJ1dHRvbnMoKX0sdS5zZXREZWZhdWx0cz1jLnNldERlZmF1bHRzPWZ1bmN0aW9uKGUpe2lmKCFlKXRocm93IG5ldyBFcnJvcihcInVzZXJQYXJhbXMgaXMgcmVxdWlyZWRcIik7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKFwidXNlclBhcmFtcyBoYXMgdG8gYmUgYSBvYmplY3RcIik7Zi5leHRlbmQoYltcImRlZmF1bHRcIl0sZSl9LHUuY2xvc2U9Yy5jbG9zZT1mdW5jdGlvbigpe3ZhciBvPXAuZ2V0TW9kYWwoKTtkLmZhZGVPdXQocC5nZXRPdmVybGF5KCksNSksZC5mYWRlT3V0KG8sNSksZC5yZW1vdmVDbGFzcyhvLFwic2hvd1N3ZWV0QWxlcnRcIiksZC5hZGRDbGFzcyhvLFwiaGlkZVN3ZWV0QWxlcnRcIiksZC5yZW1vdmVDbGFzcyhvLFwidmlzaWJsZVwiKTt2YXIgYT1vLnF1ZXJ5U2VsZWN0b3IoXCIuc2EtaWNvbi5zYS1zdWNjZXNzXCIpO2QucmVtb3ZlQ2xhc3MoYSxcImFuaW1hdGVcIiksZC5yZW1vdmVDbGFzcyhhLnF1ZXJ5U2VsZWN0b3IoXCIuc2EtdGlwXCIpLFwiYW5pbWF0ZVN1Y2Nlc3NUaXBcIiksZC5yZW1vdmVDbGFzcyhhLnF1ZXJ5U2VsZWN0b3IoXCIuc2EtbG9uZ1wiKSxcImFuaW1hdGVTdWNjZXNzTG9uZ1wiKTt2YXIgcj1vLnF1ZXJ5U2VsZWN0b3IoXCIuc2EtaWNvbi5zYS1lcnJvclwiKTtkLnJlbW92ZUNsYXNzKHIsXCJhbmltYXRlRXJyb3JJY29uXCIpLGQucmVtb3ZlQ2xhc3Moci5xdWVyeVNlbGVjdG9yKFwiLnNhLXgtbWFya1wiKSxcImFuaW1hdGVYTWFya1wiKTt2YXIgcz1vLnF1ZXJ5U2VsZWN0b3IoXCIuc2EtaWNvbi5zYS13YXJuaW5nXCIpO3JldHVybiBkLnJlbW92ZUNsYXNzKHMsXCJwdWxzZVdhcm5pbmdcIiksZC5yZW1vdmVDbGFzcyhzLnF1ZXJ5U2VsZWN0b3IoXCIuc2EtYm9keVwiKSxcInB1bHNlV2FybmluZ0luc1wiKSxkLnJlbW92ZUNsYXNzKHMucXVlcnlTZWxlY3RvcihcIi5zYS1kb3RcIiksXCJwdWxzZVdhcm5pbmdJbnNcIiksc2V0VGltZW91dChmdW5jdGlvbigpe3ZhciBlPW8uZ2V0QXR0cmlidXRlKFwiZGF0YS1jdXN0b20tY2xhc3NcIik7ZC5yZW1vdmVDbGFzcyhvLGUpfSwzMDApLGQucmVtb3ZlQ2xhc3ModC5ib2R5LFwic3RvcC1zY3JvbGxpbmdcIiksZS5vbmtleWRvd249bCxlLnByZXZpb3VzQWN0aXZlRWxlbWVudCYmZS5wcmV2aW91c0FjdGl2ZUVsZW1lbnQuZm9jdXMoKSxpPW4sY2xlYXJUaW1lb3V0KG8udGltZW91dCksITB9LHUuc2hvd0lucHV0RXJyb3I9Yy5zaG93SW5wdXRFcnJvcj1mdW5jdGlvbihlKXt2YXIgdD1wLmdldE1vZGFsKCksbj10LnF1ZXJ5U2VsZWN0b3IoXCIuc2EtaW5wdXQtZXJyb3JcIik7ZC5hZGRDbGFzcyhuLFwic2hvd1wiKTt2YXIgbz10LnF1ZXJ5U2VsZWN0b3IoXCIuc2EtZXJyb3ItY29udGFpbmVyXCIpO2QuYWRkQ2xhc3MobyxcInNob3dcIiksby5xdWVyeVNlbGVjdG9yKFwicFwiKS5pbm5lckhUTUw9ZSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dS5lbmFibGVCdXR0b25zKCl9LDEpLHQucXVlcnlTZWxlY3RvcihcImlucHV0XCIpLmZvY3VzKCl9LHUucmVzZXRJbnB1dEVycm9yPWMucmVzZXRJbnB1dEVycm9yPWZ1bmN0aW9uKGUpe2lmKGUmJjEzPT09ZS5rZXlDb2RlKXJldHVybiExO3ZhciB0PXAuZ2V0TW9kYWwoKSxuPXQucXVlcnlTZWxlY3RvcihcIi5zYS1pbnB1dC1lcnJvclwiKTtkLnJlbW92ZUNsYXNzKG4sXCJzaG93XCIpO3ZhciBvPXQucXVlcnlTZWxlY3RvcihcIi5zYS1lcnJvci1jb250YWluZXJcIik7ZC5yZW1vdmVDbGFzcyhvLFwic2hvd1wiKX0sdS5kaXNhYmxlQnV0dG9ucz1jLmRpc2FibGVCdXR0b25zPWZ1bmN0aW9uKCl7dmFyIGU9cC5nZXRNb2RhbCgpLHQ9ZS5xdWVyeVNlbGVjdG9yKFwiYnV0dG9uLmNvbmZpcm1cIiksbj1lLnF1ZXJ5U2VsZWN0b3IoXCJidXR0b24uY2FuY2VsXCIpO3QuZGlzYWJsZWQ9ITAsbi5kaXNhYmxlZD0hMH0sdS5lbmFibGVCdXR0b25zPWMuZW5hYmxlQnV0dG9ucz1mdW5jdGlvbigpe3ZhciBlPXAuZ2V0TW9kYWwoKSx0PWUucXVlcnlTZWxlY3RvcihcImJ1dHRvbi5jb25maXJtXCIpLG49ZS5xdWVyeVNlbGVjdG9yKFwiYnV0dG9uLmNhbmNlbFwiKTt0LmRpc2FibGVkPSExLG4uZGlzYWJsZWQ9ITF9LFwidW5kZWZpbmVkXCIhPXR5cGVvZiBlP2Uuc3dlZXRBbGVydD1lLnN3YWw9dTpmLmxvZ1N0cihcIlN3ZWV0QWxlcnQgaXMgYSBmcm9udGVuZCBtb2R1bGUhXCIpLGEuZXhwb3J0cz1yW1wiZGVmYXVsdFwiXX0se1wiLi9tb2R1bGVzL2RlZmF1bHQtcGFyYW1zXCI6MixcIi4vbW9kdWxlcy9oYW5kbGUtY2xpY2tcIjozLFwiLi9tb2R1bGVzL2hhbmRsZS1kb21cIjo0LFwiLi9tb2R1bGVzL2hhbmRsZS1rZXlcIjo1LFwiLi9tb2R1bGVzL2hhbmRsZS1zd2FsLWRvbVwiOjYsXCIuL21vZHVsZXMvc2V0LXBhcmFtc1wiOjgsXCIuL21vZHVsZXMvdXRpbHNcIjo5fV0sMjpbZnVuY3Rpb24oZSx0LG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvPXt0aXRsZTpcIlwiLHRleHQ6XCJcIix0eXBlOm51bGwsYWxsb3dPdXRzaWRlQ2xpY2s6ITEsc2hvd0NvbmZpcm1CdXR0b246ITAsc2hvd0NhbmNlbEJ1dHRvbjohMSxjbG9zZU9uQ29uZmlybTohMCxjbG9zZU9uQ2FuY2VsOiEwLGNvbmZpcm1CdXR0b25UZXh0OlwiT0tcIixjb25maXJtQnV0dG9uQ29sb3I6XCIjOENENEY1XCIsY2FuY2VsQnV0dG9uVGV4dDpcIkNhbmNlbFwiLGltYWdlVXJsOm51bGwsaW1hZ2VTaXplOm51bGwsdGltZXI6bnVsbCxjdXN0b21DbGFzczpcIlwiLGh0bWw6ITEsYW5pbWF0aW9uOiEwLGFsbG93RXNjYXBlS2V5OiEwLGlucHV0VHlwZTpcInRleHRcIixpbnB1dFBsYWNlaG9sZGVyOlwiXCIsaW5wdXRWYWx1ZTpcIlwiLHNob3dMb2FkZXJPbkNvbmZpcm06ITF9O25bXCJkZWZhdWx0XCJdPW8sdC5leHBvcnRzPW5bXCJkZWZhdWx0XCJdfSx7fV0sMzpbZnVuY3Rpb24odCxuLG8pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShvLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBhPXQoXCIuL3V0aWxzXCIpLHI9KHQoXCIuL2hhbmRsZS1zd2FsLWRvbVwiKSx0KFwiLi9oYW5kbGUtZG9tXCIpKSxzPWZ1bmN0aW9uKHQsbixvKXtmdW5jdGlvbiBzKGUpe20mJm4uY29uZmlybUJ1dHRvbkNvbG9yJiYocC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9ZSl9dmFyIHUsYyxkLGY9dHx8ZS5ldmVudCxwPWYudGFyZ2V0fHxmLnNyY0VsZW1lbnQsbT0tMSE9PXAuY2xhc3NOYW1lLmluZGV4T2YoXCJjb25maXJtXCIpLHY9LTEhPT1wLmNsYXNzTmFtZS5pbmRleE9mKFwic3dlZXQtb3ZlcmxheVwiKSx5PXIuaGFzQ2xhc3MobyxcInZpc2libGVcIiksaD1uLmRvbmVGdW5jdGlvbiYmXCJ0cnVlXCI9PT1vLmdldEF0dHJpYnV0ZShcImRhdGEtaGFzLWRvbmUtZnVuY3Rpb25cIik7c3dpdGNoKG0mJm4uY29uZmlybUJ1dHRvbkNvbG9yJiYodT1uLmNvbmZpcm1CdXR0b25Db2xvcixjPWEuY29sb3JMdW1pbmFuY2UodSwtLjA0KSxkPWEuY29sb3JMdW1pbmFuY2UodSwtLjE0KSksZi50eXBlKXtjYXNlXCJtb3VzZW92ZXJcIjpzKGMpO2JyZWFrO2Nhc2VcIm1vdXNlb3V0XCI6cyh1KTticmVhaztjYXNlXCJtb3VzZWRvd25cIjpzKGQpO2JyZWFrO2Nhc2VcIm1vdXNldXBcIjpzKGMpO2JyZWFrO2Nhc2VcImZvY3VzXCI6dmFyIGI9by5xdWVyeVNlbGVjdG9yKFwiYnV0dG9uLmNvbmZpcm1cIiksZz1vLnF1ZXJ5U2VsZWN0b3IoXCJidXR0b24uY2FuY2VsXCIpO20/Zy5zdHlsZS5ib3hTaGFkb3c9XCJub25lXCI6Yi5zdHlsZS5ib3hTaGFkb3c9XCJub25lXCI7YnJlYWs7Y2FzZVwiY2xpY2tcIjp2YXIgdz1vPT09cCxDPXIuaXNEZXNjZW5kYW50KG8scCk7aWYoIXcmJiFDJiZ5JiYhbi5hbGxvd091dHNpZGVDbGljaylicmVhazttJiZoJiZ5P2wobyxuKTpoJiZ5fHx2P2kobyxuKTpyLmlzRGVzY2VuZGFudChvLHApJiZcIkJVVFRPTlwiPT09cC50YWdOYW1lJiZzd2VldEFsZXJ0LmNsb3NlKCl9fSxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49ITA7ci5oYXNDbGFzcyhlLFwic2hvdy1pbnB1dFwiKSYmKG49ZS5xdWVyeVNlbGVjdG9yKFwiaW5wdXRcIikudmFsdWUsbnx8KG49XCJcIikpLHQuZG9uZUZ1bmN0aW9uKG4pLHQuY2xvc2VPbkNvbmZpcm0mJnN3ZWV0QWxlcnQuY2xvc2UoKSx0LnNob3dMb2FkZXJPbkNvbmZpcm0mJnN3ZWV0QWxlcnQuZGlzYWJsZUJ1dHRvbnMoKX0saT1mdW5jdGlvbihlLHQpe3ZhciBuPVN0cmluZyh0LmRvbmVGdW5jdGlvbikucmVwbGFjZSgvXFxzL2csXCJcIiksbz1cImZ1bmN0aW9uKFwiPT09bi5zdWJzdHJpbmcoMCw5KSYmXCIpXCIhPT1uLnN1YnN0cmluZyg5LDEwKTtvJiZ0LmRvbmVGdW5jdGlvbighMSksdC5jbG9zZU9uQ2FuY2VsJiZzd2VldEFsZXJ0LmNsb3NlKCl9O29bXCJkZWZhdWx0XCJdPXtoYW5kbGVCdXR0b246cyxoYW5kbGVDb25maXJtOmwsaGFuZGxlQ2FuY2VsOml9LG4uZXhwb3J0cz1vW1wiZGVmYXVsdFwiXX0se1wiLi9oYW5kbGUtZG9tXCI6NCxcIi4vaGFuZGxlLXN3YWwtZG9tXCI6NixcIi4vdXRpbHNcIjo5fV0sNDpbZnVuY3Rpb24obixvLGEpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyBSZWdFeHAoXCIgXCIrdCtcIiBcIikudGVzdChcIiBcIitlLmNsYXNzTmFtZStcIiBcIil9LHM9ZnVuY3Rpb24oZSx0KXtyKGUsdCl8fChlLmNsYXNzTmFtZSs9XCIgXCIrdCl9LGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1cIiBcIitlLmNsYXNzTmFtZS5yZXBsYWNlKC9bXFx0XFxyXFxuXS9nLFwiIFwiKStcIiBcIjtpZihyKGUsdCkpe2Zvcig7bi5pbmRleE9mKFwiIFwiK3QrXCIgXCIpPj0wOyluPW4ucmVwbGFjZShcIiBcIit0K1wiIFwiLFwiIFwiKTtlLmNsYXNzTmFtZT1uLnJlcGxhY2UoL15cXHMrfFxccyskL2csXCJcIil9fSxpPWZ1bmN0aW9uKGUpe3ZhciBuPXQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtyZXR1cm4gbi5hcHBlbmRDaGlsZCh0LmNyZWF0ZVRleHROb2RlKGUpKSxuLmlubmVySFRNTH0sdT1mdW5jdGlvbihlKXtlLnN0eWxlLm9wYWNpdHk9XCJcIixlLnN0eWxlLmRpc3BsYXk9XCJibG9ja1wifSxjPWZ1bmN0aW9uKGUpe2lmKGUmJiFlLmxlbmd0aClyZXR1cm4gdShlKTtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoOysrdCl1KGVbdF0pfSxkPWZ1bmN0aW9uKGUpe2Uuc3R5bGUub3BhY2l0eT1cIlwiLGUuc3R5bGUuZGlzcGxheT1cIm5vbmVcIn0sZj1mdW5jdGlvbihlKXtpZihlJiYhZS5sZW5ndGgpcmV0dXJuIGQoZSk7Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDsrK3QpZChlW3RdKX0scD1mdW5jdGlvbihlLHQpe2Zvcih2YXIgbj10LnBhcmVudE5vZGU7bnVsbCE9PW47KXtpZihuPT09ZSlyZXR1cm4hMDtuPW4ucGFyZW50Tm9kZX1yZXR1cm4hMX0sbT1mdW5jdGlvbihlKXtlLnN0eWxlLmxlZnQ9XCItOTk5OXB4XCIsZS5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIjt2YXIgdCxuPWUuY2xpZW50SGVpZ2h0O3JldHVybiB0PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBnZXRDb21wdXRlZFN0eWxlP3BhcnNlSW50KGdldENvbXB1dGVkU3R5bGUoZSkuZ2V0UHJvcGVydHlWYWx1ZShcInBhZGRpbmctdG9wXCIpLDEwKTpwYXJzZUludChlLmN1cnJlbnRTdHlsZS5wYWRkaW5nKSxlLnN0eWxlLmxlZnQ9XCJcIixlLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsXCItXCIrcGFyc2VJbnQoKG4rdCkvMikrXCJweFwifSx2PWZ1bmN0aW9uKGUsdCl7aWYoK2Uuc3R5bGUub3BhY2l0eTwxKXt0PXR8fDE2LGUuc3R5bGUub3BhY2l0eT0wLGUuc3R5bGUuZGlzcGxheT1cImJsb2NrXCI7dmFyIG49K25ldyBEYXRlLG89ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gdC50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBlLnRvU3RyaW5nKCl9LHR9KGZ1bmN0aW9uKCl7ZS5zdHlsZS5vcGFjaXR5PStlLnN0eWxlLm9wYWNpdHkrKG5ldyBEYXRlLW4pLzEwMCxuPStuZXcgRGF0ZSwrZS5zdHlsZS5vcGFjaXR5PDEmJnNldFRpbWVvdXQobyx0KX0pO28oKX1lLnN0eWxlLmRpc3BsYXk9XCJibG9ja1wifSx5PWZ1bmN0aW9uKGUsdCl7dD10fHwxNixlLnN0eWxlLm9wYWNpdHk9MTt2YXIgbj0rbmV3IERhdGUsbz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiB0LnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIGUudG9TdHJpbmcoKX0sdH0oZnVuY3Rpb24oKXtlLnN0eWxlLm9wYWNpdHk9K2Uuc3R5bGUub3BhY2l0eS0obmV3IERhdGUtbikvMTAwLG49K25ldyBEYXRlLCtlLnN0eWxlLm9wYWNpdHk+MD9zZXRUaW1lb3V0KG8sdCk6ZS5zdHlsZS5kaXNwbGF5PVwibm9uZVwifSk7bygpfSxoPWZ1bmN0aW9uKG4pe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIE1vdXNlRXZlbnQpe3ZhciBvPW5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIix7dmlldzplLGJ1YmJsZXM6ITEsY2FuY2VsYWJsZTohMH0pO24uZGlzcGF0Y2hFdmVudChvKX1lbHNlIGlmKHQuY3JlYXRlRXZlbnQpe3ZhciBhPXQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKTthLmluaXRFdmVudChcImNsaWNrXCIsITEsITEpLG4uZGlzcGF0Y2hFdmVudChhKX1lbHNlIHQuY3JlYXRlRXZlbnRPYmplY3Q/bi5maXJlRXZlbnQoXCJvbmNsaWNrXCIpOlwiZnVuY3Rpb25cIj09dHlwZW9mIG4ub25jbGljayYmbi5vbmNsaWNrKCl9LGI9ZnVuY3Rpb24odCl7XCJmdW5jdGlvblwiPT10eXBlb2YgdC5zdG9wUHJvcGFnYXRpb24/KHQuc3RvcFByb3BhZ2F0aW9uKCksdC5wcmV2ZW50RGVmYXVsdCgpKTplLmV2ZW50JiZlLmV2ZW50Lmhhc093blByb3BlcnR5KFwiY2FuY2VsQnViYmxlXCIpJiYoZS5ldmVudC5jYW5jZWxCdWJibGU9ITApfTthLmhhc0NsYXNzPXIsYS5hZGRDbGFzcz1zLGEucmVtb3ZlQ2xhc3M9bCxhLmVzY2FwZUh0bWw9aSxhLl9zaG93PXUsYS5zaG93PWMsYS5faGlkZT1kLGEuaGlkZT1mLGEuaXNEZXNjZW5kYW50PXAsYS5nZXRUb3BNYXJnaW49bSxhLmZhZGVJbj12LGEuZmFkZU91dD15LGEuZmlyZUNsaWNrPWgsYS5zdG9wRXZlbnRQcm9wYWdhdGlvbj1ifSx7fV0sNTpbZnVuY3Rpb24odCxvLGEpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPXQoXCIuL2hhbmRsZS1kb21cIikscz10KFwiLi9oYW5kbGUtc3dhbC1kb21cIiksbD1mdW5jdGlvbih0LG8sYSl7dmFyIGw9dHx8ZS5ldmVudCxpPWwua2V5Q29kZXx8bC53aGljaCx1PWEucXVlcnlTZWxlY3RvcihcImJ1dHRvbi5jb25maXJtXCIpLGM9YS5xdWVyeVNlbGVjdG9yKFwiYnV0dG9uLmNhbmNlbFwiKSxkPWEucXVlcnlTZWxlY3RvckFsbChcImJ1dHRvblt0YWJpbmRleF1cIik7aWYoLTEhPT1bOSwxMywzMiwyN10uaW5kZXhPZihpKSl7Zm9yKHZhciBmPWwudGFyZ2V0fHxsLnNyY0VsZW1lbnQscD0tMSxtPTA7bTxkLmxlbmd0aDttKyspaWYoZj09PWRbbV0pe3A9bTticmVha305PT09aT8oZj0tMT09PXA/dTpwPT09ZC5sZW5ndGgtMT9kWzBdOmRbcCsxXSxyLnN0b3BFdmVudFByb3BhZ2F0aW9uKGwpLGYuZm9jdXMoKSxvLmNvbmZpcm1CdXR0b25Db2xvciYmcy5zZXRGb2N1c1N0eWxlKGYsby5jb25maXJtQnV0dG9uQ29sb3IpKToxMz09PWk/KFwiSU5QVVRcIj09PWYudGFnTmFtZSYmKGY9dSx1LmZvY3VzKCkpLGY9LTE9PT1wP3U6bik6Mjc9PT1pJiZvLmFsbG93RXNjYXBlS2V5PT09ITA/KGY9YyxyLmZpcmVDbGljayhmLGwpKTpmPW59fTthW1wiZGVmYXVsdFwiXT1sLG8uZXhwb3J0cz1hW1wiZGVmYXVsdFwiXX0se1wiLi9oYW5kbGUtZG9tXCI6NCxcIi4vaGFuZGxlLXN3YWwtZG9tXCI6Nn1dLDY6W2Z1bmN0aW9uKG4sbyxhKXt2YXIgcj1mdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1uKFwiLi91dGlsc1wiKSxsPW4oXCIuL2hhbmRsZS1kb21cIiksaT1uKFwiLi9kZWZhdWx0LXBhcmFtc1wiKSx1PXIoaSksYz1uKFwiLi9pbmplY3RlZC1odG1sXCIpLGQ9cihjKSxmPVwiLnN3ZWV0LWFsZXJ0XCIscD1cIi5zd2VldC1vdmVybGF5XCIsbT1mdW5jdGlvbigpe3ZhciBlPXQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtmb3IoZS5pbm5lckhUTUw9ZFtcImRlZmF1bHRcIl07ZS5maXJzdENoaWxkOyl0LmJvZHkuYXBwZW5kQ2hpbGQoZS5maXJzdENoaWxkKX0sdj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiB0LnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIGUudG9TdHJpbmcoKX0sdH0oZnVuY3Rpb24oKXt2YXIgZT10LnF1ZXJ5U2VsZWN0b3IoZik7cmV0dXJuIGV8fChtKCksZT12KCkpLGV9KSx5PWZ1bmN0aW9uKCl7dmFyIGU9digpO3JldHVybiBlP2UucXVlcnlTZWxlY3RvcihcImlucHV0XCIpOnZvaWQgMH0saD1mdW5jdGlvbigpe3JldHVybiB0LnF1ZXJ5U2VsZWN0b3IocCl9LGI9ZnVuY3Rpb24oZSx0KXt2YXIgbj1zLmhleFRvUmdiKHQpO2Uuc3R5bGUuYm94U2hhZG93PVwiMCAwIDJweCByZ2JhKFwiK24rXCIsIDAuOCksIGluc2V0IDAgMCAwIDFweCByZ2JhKDAsIDAsIDAsIDAuMDUpXCJ9LGc9ZnVuY3Rpb24obil7dmFyIG89digpO2wuZmFkZUluKGgoKSwxMCksbC5zaG93KG8pLGwuYWRkQ2xhc3MobyxcInNob3dTd2VldEFsZXJ0XCIpLGwucmVtb3ZlQ2xhc3MobyxcImhpZGVTd2VldEFsZXJ0XCIpLGUucHJldmlvdXNBY3RpdmVFbGVtZW50PXQuYWN0aXZlRWxlbWVudDt2YXIgYT1vLnF1ZXJ5U2VsZWN0b3IoXCJidXR0b24uY29uZmlybVwiKTthLmZvY3VzKCksc2V0VGltZW91dChmdW5jdGlvbigpe2wuYWRkQ2xhc3MobyxcInZpc2libGVcIil9LDUwMCk7dmFyIHI9by5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRpbWVyXCIpO2lmKFwibnVsbFwiIT09ciYmXCJcIiE9PXIpe3ZhciBzPW47by50aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXt2YXIgZT0oc3x8bnVsbCkmJlwidHJ1ZVwiPT09by5nZXRBdHRyaWJ1dGUoXCJkYXRhLWhhcy1kb25lLWZ1bmN0aW9uXCIpO2U/cyhudWxsKTpzd2VldEFsZXJ0LmNsb3NlKCl9LHIpfX0sdz1mdW5jdGlvbigpe3ZhciBlPXYoKSx0PXkoKTtsLnJlbW92ZUNsYXNzKGUsXCJzaG93LWlucHV0XCIpLHQudmFsdWU9dVtcImRlZmF1bHRcIl0uaW5wdXRWYWx1ZSx0LnNldEF0dHJpYnV0ZShcInR5cGVcIix1W1wiZGVmYXVsdFwiXS5pbnB1dFR5cGUpLHQuc2V0QXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIix1W1wiZGVmYXVsdFwiXS5pbnB1dFBsYWNlaG9sZGVyKSxDKCl9LEM9ZnVuY3Rpb24oZSl7aWYoZSYmMTM9PT1lLmtleUNvZGUpcmV0dXJuITE7dmFyIHQ9digpLG49dC5xdWVyeVNlbGVjdG9yKFwiLnNhLWlucHV0LWVycm9yXCIpO2wucmVtb3ZlQ2xhc3MobixcInNob3dcIik7dmFyIG89dC5xdWVyeVNlbGVjdG9yKFwiLnNhLWVycm9yLWNvbnRhaW5lclwiKTtsLnJlbW92ZUNsYXNzKG8sXCJzaG93XCIpfSxTPWZ1bmN0aW9uKCl7dmFyIGU9digpO2Uuc3R5bGUubWFyZ2luVG9wPWwuZ2V0VG9wTWFyZ2luKHYoKSl9O2Euc3dlZXRBbGVydEluaXRpYWxpemU9bSxhLmdldE1vZGFsPXYsYS5nZXRPdmVybGF5PWgsYS5nZXRJbnB1dD15LGEuc2V0Rm9jdXNTdHlsZT1iLGEub3Blbk1vZGFsPWcsYS5yZXNldElucHV0PXcsYS5yZXNldElucHV0RXJyb3I9QyxhLmZpeFZlcnRpY2FsUG9zaXRpb249U30se1wiLi9kZWZhdWx0LXBhcmFtc1wiOjIsXCIuL2hhbmRsZS1kb21cIjo0LFwiLi9pbmplY3RlZC1odG1sXCI6NyxcIi4vdXRpbHNcIjo5fV0sNzpbZnVuY3Rpb24oZSx0LG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvPSc8ZGl2IGNsYXNzPVwic3dlZXQtb3ZlcmxheVwiIHRhYkluZGV4PVwiLTFcIj48L2Rpdj48ZGl2IGNsYXNzPVwic3dlZXQtYWxlcnRcIj48ZGl2IGNsYXNzPVwic2EtaWNvbiBzYS1lcnJvclwiPlxcbiAgICAgIDxzcGFuIGNsYXNzPVwic2EteC1tYXJrXCI+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cInNhLWxpbmUgc2EtbGVmdFwiPjwvc3Bhbj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVwic2EtbGluZSBzYS1yaWdodFwiPjwvc3Bhbj5cXG4gICAgICA8L3NwYW4+XFxuICAgIDwvZGl2PjxkaXYgY2xhc3M9XCJzYS1pY29uIHNhLXdhcm5pbmdcIj5cXG4gICAgICA8c3BhbiBjbGFzcz1cInNhLWJvZHlcIj48L3NwYW4+XFxuICAgICAgPHNwYW4gY2xhc3M9XCJzYS1kb3RcIj48L3NwYW4+XFxuICAgIDwvZGl2PjxkaXYgY2xhc3M9XCJzYS1pY29uIHNhLWluZm9cIj48L2Rpdj48ZGl2IGNsYXNzPVwic2EtaWNvbiBzYS1zdWNjZXNzXCI+XFxuICAgICAgPHNwYW4gY2xhc3M9XCJzYS1saW5lIHNhLXRpcFwiPjwvc3Bhbj5cXG4gICAgICA8c3BhbiBjbGFzcz1cInNhLWxpbmUgc2EtbG9uZ1wiPjwvc3Bhbj5cXG5cXG4gICAgICA8ZGl2IGNsYXNzPVwic2EtcGxhY2Vob2xkZXJcIj48L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVwic2EtZml4XCI+PC9kaXY+XFxuICAgIDwvZGl2PjxkaXYgY2xhc3M9XCJzYS1pY29uIHNhLWN1c3RvbVwiPjwvZGl2PjxoMj5UaXRsZTwvaDI+XFxuICAgIDxwPlRleHQ8L3A+XFxuICAgIDxmaWVsZHNldD5cXG4gICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiB0YWJJbmRleD1cIjNcIiAvPlxcbiAgICAgIDxkaXYgY2xhc3M9XCJzYS1pbnB1dC1lcnJvclwiPjwvZGl2PlxcbiAgICA8L2ZpZWxkc2V0PjxkaXYgY2xhc3M9XCJzYS1lcnJvci1jb250YWluZXJcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVwiaWNvblwiPiE8L2Rpdj5cXG4gICAgICA8cD5Ob3QgdmFsaWQhPC9wPlxcbiAgICA8L2Rpdj48ZGl2IGNsYXNzPVwic2EtYnV0dG9uLWNvbnRhaW5lclwiPlxcbiAgICAgIDxidXR0b24gY2xhc3M9XCJjYW5jZWxcIiB0YWJJbmRleD1cIjJcIj5DYW5jZWw8L2J1dHRvbj5cXG4gICAgICA8ZGl2IGNsYXNzPVwic2EtY29uZmlybS1idXR0b24tY29udGFpbmVyXCI+XFxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiY29uZmlybVwiIHRhYkluZGV4PVwiMVwiPk9LPC9idXR0b24+PGRpdiBjbGFzcz1cImxhLWJhbGwtZmFsbFwiPlxcbiAgICAgICAgICA8ZGl2PjwvZGl2PlxcbiAgICAgICAgICA8ZGl2PjwvZGl2PlxcbiAgICAgICAgICA8ZGl2PjwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PjwvZGl2Pic7bltcImRlZmF1bHRcIl09byx0LmV4cG9ydHM9bltcImRlZmF1bHRcIl19LHt9XSw4OltmdW5jdGlvbihlLHQsbyl7T2JqZWN0LmRlZmluZVByb3BlcnR5KG8sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGE9ZShcIi4vdXRpbHNcIikscj1lKFwiLi9oYW5kbGUtc3dhbC1kb21cIikscz1lKFwiLi9oYW5kbGUtZG9tXCIpLGw9W1wiZXJyb3JcIixcIndhcm5pbmdcIixcImluZm9cIixcInN1Y2Nlc3NcIixcImlucHV0XCIsXCJwcm9tcHRcIl0saT1mdW5jdGlvbihlKXt2YXIgdD1yLmdldE1vZGFsKCksbz10LnF1ZXJ5U2VsZWN0b3IoXCJoMlwiKSxpPXQucXVlcnlTZWxlY3RvcihcInBcIiksdT10LnF1ZXJ5U2VsZWN0b3IoXCJidXR0b24uY2FuY2VsXCIpLGM9dC5xdWVyeVNlbGVjdG9yKFwiYnV0dG9uLmNvbmZpcm1cIik7aWYoby5pbm5lckhUTUw9ZS5odG1sP2UudGl0bGU6cy5lc2NhcGVIdG1sKGUudGl0bGUpLnNwbGl0KFwiXFxuXCIpLmpvaW4oXCI8YnI+XCIpLGkuaW5uZXJIVE1MPWUuaHRtbD9lLnRleHQ6cy5lc2NhcGVIdG1sKGUudGV4dHx8XCJcIikuc3BsaXQoXCJcXG5cIikuam9pbihcIjxicj5cIiksZS50ZXh0JiZzLnNob3coaSksZS5jdXN0b21DbGFzcylzLmFkZENsYXNzKHQsZS5jdXN0b21DbGFzcyksdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWN1c3RvbS1jbGFzc1wiLGUuY3VzdG9tQ2xhc3MpO2Vsc2V7dmFyIGQ9dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWN1c3RvbS1jbGFzc1wiKTtzLnJlbW92ZUNsYXNzKHQsZCksdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWN1c3RvbS1jbGFzc1wiLFwiXCIpfWlmKHMuaGlkZSh0LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuc2EtaWNvblwiKSksZS50eXBlJiYhYS5pc0lFOCgpKXt2YXIgZj1mdW5jdGlvbigpe2Zvcih2YXIgbz0hMSxhPTA7YTxsLmxlbmd0aDthKyspaWYoZS50eXBlPT09bFthXSl7bz0hMDticmVha31pZighbylyZXR1cm4gbG9nU3RyKFwiVW5rbm93biBhbGVydCB0eXBlOiBcIitlLnR5cGUpLHt2OiExfTt2YXIgaT1bXCJzdWNjZXNzXCIsXCJlcnJvclwiLFwid2FybmluZ1wiLFwiaW5mb1wiXSx1PW47LTEhPT1pLmluZGV4T2YoZS50eXBlKSYmKHU9dC5xdWVyeVNlbGVjdG9yKFwiLnNhLWljb24uc2EtXCIrZS50eXBlKSxzLnNob3codSkpO3ZhciBjPXIuZ2V0SW5wdXQoKTtzd2l0Y2goZS50eXBlKXtjYXNlXCJzdWNjZXNzXCI6cy5hZGRDbGFzcyh1LFwiYW5pbWF0ZVwiKSxzLmFkZENsYXNzKHUucXVlcnlTZWxlY3RvcihcIi5zYS10aXBcIiksXCJhbmltYXRlU3VjY2Vzc1RpcFwiKSxzLmFkZENsYXNzKHUucXVlcnlTZWxlY3RvcihcIi5zYS1sb25nXCIpLFwiYW5pbWF0ZVN1Y2Nlc3NMb25nXCIpO2JyZWFrO2Nhc2VcImVycm9yXCI6cy5hZGRDbGFzcyh1LFwiYW5pbWF0ZUVycm9ySWNvblwiKSxzLmFkZENsYXNzKHUucXVlcnlTZWxlY3RvcihcIi5zYS14LW1hcmtcIiksXCJhbmltYXRlWE1hcmtcIik7YnJlYWs7Y2FzZVwid2FybmluZ1wiOnMuYWRkQ2xhc3ModSxcInB1bHNlV2FybmluZ1wiKSxzLmFkZENsYXNzKHUucXVlcnlTZWxlY3RvcihcIi5zYS1ib2R5XCIpLFwicHVsc2VXYXJuaW5nSW5zXCIpLHMuYWRkQ2xhc3ModS5xdWVyeVNlbGVjdG9yKFwiLnNhLWRvdFwiKSxcInB1bHNlV2FybmluZ0luc1wiKTticmVhaztjYXNlXCJpbnB1dFwiOmNhc2VcInByb21wdFwiOmMuc2V0QXR0cmlidXRlKFwidHlwZVwiLGUuaW5wdXRUeXBlKSxjLnZhbHVlPWUuaW5wdXRWYWx1ZSxjLnNldEF0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIsZS5pbnB1dFBsYWNlaG9sZGVyKSxzLmFkZENsYXNzKHQsXCJzaG93LWlucHV0XCIpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtjLmZvY3VzKCksYy5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIixzd2FsLnJlc2V0SW5wdXRFcnJvcil9LDQwMCl9fSgpO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBmKXJldHVybiBmLnZ9aWYoZS5pbWFnZVVybCl7dmFyIHA9dC5xdWVyeVNlbGVjdG9yKFwiLnNhLWljb24uc2EtY3VzdG9tXCIpO3Auc3R5bGUuYmFja2dyb3VuZEltYWdlPVwidXJsKFwiK2UuaW1hZ2VVcmwrXCIpXCIscy5zaG93KHApO3ZhciBtPTgwLHY9ODA7aWYoZS5pbWFnZVNpemUpe3ZhciB5PWUuaW1hZ2VTaXplLnRvU3RyaW5nKCkuc3BsaXQoXCJ4XCIpLGg9eVswXSxiPXlbMV07aCYmYj8obT1oLHY9Yik6bG9nU3RyKFwiUGFyYW1ldGVyIGltYWdlU2l6ZSBleHBlY3RzIHZhbHVlIHdpdGggZm9ybWF0IFdJRFRIeEhFSUdIVCwgZ290IFwiK2UuaW1hZ2VTaXplKX1wLnNldEF0dHJpYnV0ZShcInN0eWxlXCIscC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKStcIndpZHRoOlwiK20rXCJweDsgaGVpZ2h0OlwiK3YrXCJweFwiKX10LnNldEF0dHJpYnV0ZShcImRhdGEtaGFzLWNhbmNlbC1idXR0b25cIixlLnNob3dDYW5jZWxCdXR0b24pLGUuc2hvd0NhbmNlbEJ1dHRvbj91LnN0eWxlLmRpc3BsYXk9XCJpbmxpbmUtYmxvY2tcIjpzLmhpZGUodSksdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWhhcy1jb25maXJtLWJ1dHRvblwiLGUuc2hvd0NvbmZpcm1CdXR0b24pLGUuc2hvd0NvbmZpcm1CdXR0b24/Yy5zdHlsZS5kaXNwbGF5PVwiaW5saW5lLWJsb2NrXCI6cy5oaWRlKGMpLGUuY2FuY2VsQnV0dG9uVGV4dCYmKHUuaW5uZXJIVE1MPXMuZXNjYXBlSHRtbChlLmNhbmNlbEJ1dHRvblRleHQpKSxlLmNvbmZpcm1CdXR0b25UZXh0JiYoYy5pbm5lckhUTUw9cy5lc2NhcGVIdG1sKGUuY29uZmlybUJ1dHRvblRleHQpKSxlLmNvbmZpcm1CdXR0b25Db2xvciYmKGMuc3R5bGUuYmFja2dyb3VuZENvbG9yPWUuY29uZmlybUJ1dHRvbkNvbG9yLGMuc3R5bGUuYm9yZGVyTGVmdENvbG9yPWUuY29uZmlybUxvYWRpbmdCdXR0b25Db2xvcixjLnN0eWxlLmJvcmRlclJpZ2h0Q29sb3I9ZS5jb25maXJtTG9hZGluZ0J1dHRvbkNvbG9yLHIuc2V0Rm9jdXNTdHlsZShjLGUuY29uZmlybUJ1dHRvbkNvbG9yKSksdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWFsbG93LW91dHNpZGUtY2xpY2tcIixlLmFsbG93T3V0c2lkZUNsaWNrKTt2YXIgZz1lLmRvbmVGdW5jdGlvbj8hMDohMTt0LnNldEF0dHJpYnV0ZShcImRhdGEtaGFzLWRvbmUtZnVuY3Rpb25cIixnKSxlLmFuaW1hdGlvbj9cInN0cmluZ1wiPT10eXBlb2YgZS5hbmltYXRpb24/dC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWFuaW1hdGlvblwiLGUuYW5pbWF0aW9uKTp0LnNldEF0dHJpYnV0ZShcImRhdGEtYW5pbWF0aW9uXCIsXCJwb3BcIik6dC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWFuaW1hdGlvblwiLFwibm9uZVwiKSx0LnNldEF0dHJpYnV0ZShcImRhdGEtdGltZXJcIixlLnRpbWVyKX07b1tcImRlZmF1bHRcIl09aSx0LmV4cG9ydHM9b1tcImRlZmF1bHRcIl19LHtcIi4vaGFuZGxlLWRvbVwiOjQsXCIuL2hhbmRsZS1zd2FsLWRvbVwiOjYsXCIuL3V0aWxzXCI6OX1dLDk6W2Z1bmN0aW9uKHQsbixvKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgYT1mdW5jdGlvbihlLHQpe2Zvcih2YXIgbiBpbiB0KXQuaGFzT3duUHJvcGVydHkobikmJihlW25dPXRbbl0pO3JldHVybiBlfSxyPWZ1bmN0aW9uKGUpe3ZhciB0PS9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2kuZXhlYyhlKTtyZXR1cm4gdD9wYXJzZUludCh0WzFdLDE2KStcIiwgXCIrcGFyc2VJbnQodFsyXSwxNikrXCIsIFwiK3BhcnNlSW50KHRbM10sMTYpOm51bGx9LHM9ZnVuY3Rpb24oKXtyZXR1cm4gZS5hdHRhY2hFdmVudCYmIWUuYWRkRXZlbnRMaXN0ZW5lcn0sbD1mdW5jdGlvbih0KXtlLmNvbnNvbGUmJmUuY29uc29sZS5sb2coXCJTd2VldEFsZXJ0OiBcIit0KX0saT1mdW5jdGlvbihlLHQpe2U9U3RyaW5nKGUpLnJlcGxhY2UoL1teMC05YS1mXS9naSxcIlwiKSxlLmxlbmd0aDw2JiYoZT1lWzBdK2VbMF0rZVsxXStlWzFdK2VbMl0rZVsyXSksdD10fHwwO3ZhciBuLG8sYT1cIiNcIjtmb3Iobz0wOzM+bztvKyspbj1wYXJzZUludChlLnN1YnN0cigyKm8sMiksMTYpLG49TWF0aC5yb3VuZChNYXRoLm1pbihNYXRoLm1heCgwLG4rbip0KSwyNTUpKS50b1N0cmluZygxNiksYSs9KFwiMDBcIituKS5zdWJzdHIobi5sZW5ndGgpO3JldHVybiBhfTtvLmV4dGVuZD1hLG8uaGV4VG9SZ2I9cixvLmlzSUU4PXMsby5sb2dTdHI9bCxvLmNvbG9yTHVtaW5hbmNlPWl9LHt9XX0se30sWzFdKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKGZ1bmN0aW9uKCl7cmV0dXJuIHN3ZWV0QWxlcnR9KTpcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cyYmKG1vZHVsZS5leHBvcnRzPXN3ZWV0QWxlcnQpfSh3aW5kb3csZG9jdW1lbnQpOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/sweetalert.min.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib */ \"./src/lib.js\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_markdown_it__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/markdown-it */ \"./lib/markdown-it.js\");\n/* harmony import */ var _lib_markdown_it__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lib_markdown_it__WEBPACK_IMPORTED_MODULE_1__);\n\n\nvar URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\nnavigator.saveBlob = navigator.saveBlob || navigator.msSaveBlob || navigator.mozSaveBlob || navigator.webkitSaveBlob;\nwindow.saveAs = window.saveAs || window.webkitSaveAs || window.mozSaveAs || window.msSaveAs;\nvar languageOverrides = {\n  js: 'javascript',\n  html: 'xml'\n};\nvar md = _lib__WEBPACK_IMPORTED_MODULE_0__[\"markdownit\"]({\n  html: true,\n  highlight: function highlight(code, lang) {\n    if (languageOverrides[lang]) lang = languageOverrides[lang];\n\n    if (lang && hljs.getLanguage(lang)) {\n      try {\n        return hljs.highlight(lang, code).value;\n      } catch (e) {\n        console.log(e);\n      }\n    }\n\n    return '';\n  }\n}).use(_lib__WEBPACK_IMPORTED_MODULE_0__[\"markdownitFootnote\"]);\n\nvar update = function update(e) {\n  setOutput(e.getValue());\n  var headerEle = document.querySelectorAll('h1');\n  var title;\n\n  if (headerEle.length > 0 && headerEle[0].textContent.length > 0) {\n    title = headerEle[0].textContent;\n  } else {\n    title = '  EXE';\n  }\n\n  var oldTitle = document.title;\n\n  if (oldTitle != title) {\n    oldTitle = document.title = title;\n  }\n};\n\nvar editor = _lib__WEBPACK_IMPORTED_MODULE_0__[\"CodeMirror\"].fromTextArea(document.getElementById('code'), {\n  mode: \"spell-checker\",\n  backdrop: \"gfm\",\n  lineNumbers: false,\n  matchBrackets: true,\n  lineWrapping: true,\n  theme: 'base16-light',\n  extraKeys: {\n    \"Enter\": \"newlineAndIndentContinueMarkdownList\"\n  }\n});\neditor.on('change', update);\n\nvar setOutput = function setOutput(val) {\n  val = val.replace(/<equation>((.*?\\n)*?.*?)<\\/equation>/ig, function (a, b) {\n    return '<img src=\"http://latex.codecogs.com/png.latex?' + encodeURIComponent(b) + '\" />';\n  });\n  var out = document.getElementById('out');\n  var old = out.cloneNode(true);\n  out.innerHTML = md.render(val); //emojify.run(out);\n\n  console.log(out.innerHTML);\n};\n\nvar processQueryParams = function processQueryParams() {\n  var params = window.location.search.split('?')[1];\n\n  if (window.location.hash) {\n    document.getElementById('readbutton').click(); // Show reading view\n  }\n\n  if (params) {\n    var obj = {};\n    params.split('&').forEach(function (ele) {\n      obj[ele.split('=')[0]] = ele.split(\"=\")[1];\n    });\n\n    if (obj.reading === 'false') {\n      document.getElementById('readbutton').click(); // Hide reading view\n    }\n\n    if (obj.dark === 'true') {\n      document.getElementById('nightbutton').click(); // Show night view\n    }\n  }\n};\n\nvar openFile = function openFile() {};\n/**\r\n * \r\n */\n\n\nvar run = function run() {\n  processQueryParams();\n\n  if (window.location.hash) {\n    var hash = window.location.hash.replace(/^#/, '');\n\n    if (hash.slice(0, 5) == 'view:') {\n      setOutput();\n    } else {\n      var val = decodeURIComponent(escape(_lib__WEBPACK_IMPORTED_MODULE_0__[\"RawDeflate\"].inflate(atob(hash))));\n      editor.setValue(val);\n    }\n  } else if (localStorage.getItem('content')) {\n    editor.setValue(localStorage.getItem('content'));\n  }\n\n  editor.focus();\n  document.getElementById('fileInput').addEventListener('change', openFile, false);\n};\n\nwindow.addEventListener(\"beforeunload\", function (e) {\n  if (!editor.getValue() || editor.getValue() == localStorage.getItem('content')) {\n    return;\n  }\n\n  var confirmationMessage = 'It looks like you have been editing something. ' + 'If you leave before saving, your changes will be lost.';\n  (e || window.event).returnValue = confirmationMessage; //Gecko + IE\n\n  return confirmationMessage; //Gecko + Webkit, Safari, Chrome etc.\n});\nrun();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBsaWIgZnJvbSAnLi9saWInO1xyXG5pbXBvcnQgeyBoYXMgfSBmcm9tICcuLi9saWIvbWFya2Rvd24taXQnO1xyXG5cclxuY29uc3QgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdy5tb3pVUkwgfHwgd2luZG93Lm1zVVJMO1xyXG5uYXZpZ2F0b3Iuc2F2ZUJsb2IgPSBuYXZpZ2F0b3Iuc2F2ZUJsb2IgfHwgbmF2aWdhdG9yLm1zU2F2ZUJsb2IgfHwgbmF2aWdhdG9yLm1velNhdmVCbG9iIHx8IG5hdmlnYXRvci53ZWJraXRTYXZlQmxvYjtcclxud2luZG93LnNhdmVBcyA9IHdpbmRvdy5zYXZlQXMgfHwgd2luZG93LndlYmtpdFNhdmVBcyB8fCB3aW5kb3cubW96U2F2ZUFzIHx8IHdpbmRvdy5tc1NhdmVBcztcclxuXHJcbmNvbnN0IGxhbmd1YWdlT3ZlcnJpZGVzID0ge1xyXG4gICAganM6ICdqYXZhc2NyaXB0JyxcclxuICAgIGh0bWw6ICd4bWwnXHJcbn07XHJcblxyXG5jb25zdCBtZCA9IGxpYi5tYXJrZG93bml0KHtcclxuICAgIGh0bWw6IHRydWUsXHJcbiAgICBoaWdobGlnaHQ6IGZ1bmN0aW9uKGNvZGUsIGxhbmcpIHtcclxuICAgICAgICBpZiAobGFuZ3VhZ2VPdmVycmlkZXNbbGFuZ10pIGxhbmcgPSBsYW5ndWFnZU92ZXJyaWRlc1tsYW5nXTtcclxuICAgICAgICBpZiAobGFuZyAmJiBobGpzLmdldExhbmd1YWdlKGxhbmcpKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaGxqcy5oaWdobGlnaHQobGFuZywgY29kZSkudmFsdWU7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgY29uc29sZS5sb2coZSk7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG59KVxyXG4udXNlKGxpYi5tYXJrZG93bml0Rm9vdG5vdGUpO1xyXG5cclxuY29uc3QgdXBkYXRlID0gKGUpID0+IHtcclxuICAgIHNldE91dHB1dChlLmdldFZhbHVlKCkpO1xyXG5cclxuICAgIFxyXG4gICAgbGV0IGhlYWRlckVsZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2gxJyk7XHJcbiAgICBsZXQgdGl0bGU7XHJcbiAgICBpZihoZWFkZXJFbGUubGVuZ3RoID4gMCAmJiBoZWFkZXJFbGVbMF0udGV4dENvbnRlbnQubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgdGl0bGUgPSBoZWFkZXJFbGVbMF0udGV4dENvbnRlbnQ7XHJcbiAgICB9ZWxzZSB7XHJcbiAgICAgICAgdGl0bGUgPSAn66eI7YGs64uk7Jq0IOyXkOuUlO2EsCBFWEUnO1xyXG4gICAgfVxyXG4gICAgbGV0IG9sZFRpdGxlID0gZG9jdW1lbnQudGl0bGU7XHJcbiAgICBpZihvbGRUaXRsZSAhPSB0aXRsZSl7XHJcbiAgICAgICAgb2xkVGl0bGUgPSAgZG9jdW1lbnQudGl0bGUgPSB0aXRsZTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmNvbnN0IGVkaXRvciA9IGxpYi5Db2RlTWlycm9yLmZyb21UZXh0QXJlYShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29kZScpLCB7XHJcbiAgICBtb2RlOiBcInNwZWxsLWNoZWNrZXJcIixcclxuICAgIGJhY2tkcm9wOiBcImdmbVwiLFxyXG4gICAgbGluZU51bWJlcnM6IGZhbHNlLFxyXG4gICAgbWF0Y2hCcmFja2V0czogdHJ1ZSxcclxuICAgIGxpbmVXcmFwcGluZzogdHJ1ZSxcclxuICAgIHRoZW1lOiAnYmFzZTE2LWxpZ2h0JyxcclxuICAgIGV4dHJhS2V5czoge1xyXG4gICAgICAgIFwiRW50ZXJcIjogXCJuZXdsaW5lQW5kSW5kZW50Q29udGludWVNYXJrZG93bkxpc3RcIlxyXG4gICAgfVxyXG59KTtcclxuZWRpdG9yLm9uKCdjaGFuZ2UnLCB1cGRhdGUpO1xyXG5cclxuY29uc3Qgc2V0T3V0cHV0ID0gKHZhbCkgPT4ge1xyXG4gICAgdmFsID0gdmFsLnJlcGxhY2UoLzxlcXVhdGlvbj4oKC4qP1xcbikqPy4qPyk8XFwvZXF1YXRpb24+L2lnLCBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuICc8aW1nIHNyYz1cImh0dHA6Ly9sYXRleC5jb2RlY29ncy5jb20vcG5nLmxhdGV4PycgKyBlbmNvZGVVUklDb21wb25lbnQoYikgKyAnXCIgLz4nO1xyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IG91dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvdXQnKTtcclxuICAgIGxldCBvbGQgPSBvdXQuY2xvbmVOb2RlKHRydWUpO1xyXG4gICAgb3V0LmlubmVySFRNTCA9IG1kLnJlbmRlcih2YWwpO1xyXG4gICAgLy9lbW9qaWZ5LnJ1bihvdXQpO1xyXG4gICAgY29uc29sZS5sb2cob3V0LmlubmVySFRNTCk7XHJcblxyXG59O1xyXG5cclxuXHJcblxyXG5jb25zdCBwcm9jZXNzUXVlcnlQYXJhbXMgPSAoKSA9PiB7XHJcbiAgICBsZXQgcGFyYW1zID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC5zcGxpdCgnPycpWzFdO1xyXG4gICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5oYXNoKSB7XHJcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JlYWRidXR0b24nKS5jbGljaygpOyAvLyBTaG93IHJlYWRpbmcgdmlld1xyXG4gICAgfVxyXG4gICAgaWYgKHBhcmFtcyl7XHJcbiAgICAgICAgY29uc3Qgb2JqID0ge307XHJcbiAgICAgICAgcGFyYW1zLnNwbGl0KCcmJykuZm9yRWFjaCgoZWxlKSA9PiB7XHJcbiAgICAgICAgICAgIG9ialtlbGUuc3BsaXQoJz0nKVswXV0gPSBlbGUuc3BsaXQoXCI9XCIpWzFdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmKG9iai5yZWFkaW5nID09PSAnZmFsc2UnKXtcclxuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JlYWRidXR0b24nKS5jbGljaygpOyAvLyBIaWRlIHJlYWRpbmcgdmlld1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihvYmouZGFyayA9PT0gJ3RydWUnKXtcclxuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25pZ2h0YnV0dG9uJykuY2xpY2soKTsgLy8gU2hvdyBuaWdodCB2aWV3XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5jb25zdCBvcGVuRmlsZSA9ICgpID0+IHt9O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBcclxuICovXHJcbmNvbnN0IHJ1biA9ICgpID0+IHtcclxuICAgIHByb2Nlc3NRdWVyeVBhcmFtcygpO1xyXG4gICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5oYXNoKSB7XHJcbiAgICAgICAgbGV0IGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaC5yZXBsYWNlKC9eIy8sICcnKTtcclxuICAgICAgICBpZiAoaGFzaC5zbGljZSgwLCA1KSA9PSAndmlldzonKSB7XHJcbiAgICAgICAgICAgIHNldE91dHB1dCgpXHJcbiAgICAgICAgfSBlbHNle1xyXG4gICAgICAgICAgICBjb25zdCB2YWwgPSAgZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShsaWIuUmF3RGVmbGF0ZS5pbmZsYXRlKGF0b2IoaGFzaCkpKSk7XHJcbiAgICAgICAgICAgIGVkaXRvci5zZXRWYWx1ZSggdmFsKTtcclxuICAgICAgICB9XHJcbiAgICB9ZWxzZSBpZihsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnY29udGVudCcpKXtcclxuICAgICAgICBlZGl0b3Iuc2V0VmFsdWUobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2NvbnRlbnQnKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZWRpdG9yLmZvY3VzKCk7XHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmlsZUlucHV0JykuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb3BlbkZpbGUsIGZhbHNlKTtcclxufTtcclxuXHJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIChlKSA9PiB7XHJcblxyXG4gICAgaWYgKCFlZGl0b3IuZ2V0VmFsdWUoKSB8fCBlZGl0b3IuZ2V0VmFsdWUoKSA9PSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnY29udGVudCcpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBjb25maXJtYXRpb25NZXNzYWdlID0gJ0l0IGxvb2tzIGxpa2UgeW91IGhhdmUgYmVlbiBlZGl0aW5nIHNvbWV0aGluZy4gJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnSWYgeW91IGxlYXZlIGJlZm9yZSBzYXZpbmcsIHlvdXIgY2hhbmdlcyB3aWxsIGJlIGxvc3QuJztcclxuICAgIChlIHx8IHdpbmRvdy5ldmVudCkucmV0dXJuVmFsdWUgPSBjb25maXJtYXRpb25NZXNzYWdlOyAvL0dlY2tvICsgSUVcclxuICAgIHJldHVybiBjb25maXJtYXRpb25NZXNzYWdlOyAvL0dlY2tvICsgV2Via2l0LCBTYWZhcmksIENocm9tZSBldGMuXHJcbn0pO1xyXG5cclxuXHJcbnJ1bigpO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFWQTtBQUNBO0FBYUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFQQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBR0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/lib.js":
/*!********************!*\
  !*** ./src/lib.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ../lib/markdown-it */ \"./lib/markdown-it.js\");\nmodule.exports = __webpack_require__(/*! ../lib/markdown-it-footnote */ \"./lib/markdown-it-footnote.js\");\nmodule.exports = __webpack_require__(/*! ../lib/highlight.pack */ \"./lib/highlight.pack.js\");\nmodule.exports = __webpack_require__(/*! ../codemirror/lib/codemirror */ \"./codemirror/lib/codemirror.js\");\nmodule.exports = __webpack_require__(/*! ../codemirror/overlay */ \"./codemirror/overlay.js\"); //module.exports = require('../codemirror/xml/xml');\n//module.exports = require('../codemirror/markdown/markdown');\n//module.exports = require('../codemirror/gfm/gfm');\n//module.exports = require('../codemirror/javascript/javascript');\n//module.exports = require( '../codemirror/css/css');\n//module.exports = require( '../codemirror/htmlmixed/htmlmixed');\n//module.exports = require( '../codemirror/lib/util/continuelist');\n\nmodule.exports = __webpack_require__(/*! ../lib/spell-checker.min */ \"./lib/spell-checker.min.js\");\nmodule.exports = __webpack_require__(/*! ../lib/rawinflate */ \"./lib/rawinflate.js\");\nmodule.exports = __webpack_require__(/*! ../lib/rawdeflate */ \"./lib/rawdeflate.js\");\nmodule.exports = __webpack_require__(/*! ../lib/sweetalert.min */ \"./lib/sweetalert.min.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGliLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi5qcz8zNGU5Il0sInNvdXJjZXNDb250ZW50IjpbIlxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9saWIvbWFya2Rvd24taXQnKTtcclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9saWIvbWFya2Rvd24taXQtZm9vdG5vdGUnKTtcclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9saWIvaGlnaGxpZ2h0LnBhY2snKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY29kZW1pcnJvci9saWIvY29kZW1pcnJvcicpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2NvZGVtaXJyb3Ivb3ZlcmxheScpO1xyXG4vL21vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY29kZW1pcnJvci94bWwveG1sJyk7XHJcbi8vbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9jb2RlbWlycm9yL21hcmtkb3duL21hcmtkb3duJyk7XHJcbi8vbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9jb2RlbWlycm9yL2dmbS9nZm0nKTtcclxuLy9tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2NvZGVtaXJyb3IvamF2YXNjcmlwdC9qYXZhc2NyaXB0Jyk7XHJcbi8vbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCAnLi4vY29kZW1pcnJvci9jc3MvY3NzJyk7XHJcbi8vbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCAnLi4vY29kZW1pcnJvci9odG1sbWl4ZWQvaHRtbG1peGVkJyk7XHJcbi8vbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCAnLi4vY29kZW1pcnJvci9saWIvdXRpbC9jb250aW51ZWxpc3QnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbGliL3NwZWxsLWNoZWNrZXIubWluJyk7XHJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbGliL3Jhd2luZmxhdGUnKTtcclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9saWIvcmF3ZGVmbGF0ZScpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2xpYi9zd2VldGFsZXJ0Lm1pbicpO1xyXG5cclxuIl0sIm1hcHBpbmdzIjoiQUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/lib.js\n");

/***/ })

/******/ });